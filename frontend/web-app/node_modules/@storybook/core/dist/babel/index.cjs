"use strict";
var rTe = Object.create;
var My = Object.defineProperty;
var nTe = Object.getOwnPropertyDescriptor;
var aTe = Object.getOwnPropertyNames;
var oTe = Object.getPrototypeOf, lTe = Object.prototype.hasOwnProperty;
var n = (t, e) => My(t, "name", { value: e, configurable: !0 });
var g = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), uTe = (t, e) => {
  for (var s in e)
    My(t, s, { get: e[s], enumerable: !0 });
}, A7 = (t, e, s, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let r of aTe(e))
      !lTe.call(t, r) && r !== s && My(t, r, { get: () => e[r], enumerable: !(i = nTe(e, r)) || i.enumerable });
  return t;
};
var Jo = (t, e, s) => (s = t != null ? rTe(oTe(t)) : {}, A7(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? My(s, "default", { value: t, enumerable: !0 }) : s,
  t
)), cTe = (t) => A7(My({}, "__esModule", { value: !0 }), t);

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var wb = g((AC) => {
  "use strict";
  Object.defineProperty(AC, "__esModule", {
    value: !0
  });
  AC.default = pTe;
  function pTe(t, e) {
    let s = Object.keys(e);
    for (let i of s)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  n(pTe, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Fy = g((vC) => {
  "use strict";
  Object.defineProperty(vC, "__esModule", {
    value: !0
  });
  vC.default = hTe;
  var v7 = /* @__PURE__ */ new Set();
  function hTe(t, e, s = "") {
    if (v7.has(t)) return;
    v7.add(t);
    let {
      internal: i,
      trace: r
    } = fTe(1, 2);
    i || console.warn(`${s}\`${t}\` has been deprecated, please migrate to \`${e}\`
${r}`);
  }
  n(hTe, "deprecationWarning");
  function fTe(t, e) {
    let {
      stackTraceLimit: s,
      prepareStackTrace: i
    } = Error, r;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      r = l;
    }, new Error().stack, Error.stackTraceLimit = s, Error.prepareStackTrace = i, !r) return {
      internal: !1,
      trace: ""
    };
    let a = r.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(fTe, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var tr = g((I) => {
  "use strict";
  Object.defineProperty(I, "__esModule", {
    value: !0
  });
  I.isAccessor = NPe;
  I.isAnyTypeAnnotation = X0e;
  I.isArgumentPlaceholder = Axe;
  I.isArrayExpression = dTe;
  I.isArrayPattern = h0e;
  I.isArrayTypeAnnotation = z0e;
  I.isArrowFunctionExpression = f0e;
  I.isAssignmentExpression = mTe;
  I.isAssignmentPattern = p0e;
  I.isAwaitExpression = M0e;
  I.isBigIntLiteral = j0e;
  I.isBinary = QSe;
  I.isBinaryExpression = yTe;
  I.isBindExpression = vxe;
  I.isBlock = tPe;
  I.isBlockParent = ePe;
  I.isBlockStatement = xTe;
  I.isBooleanLiteral = UTe;
  I.isBooleanLiteralTypeAnnotation = Q0e;
  I.isBooleanTypeAnnotation = G0e;
  I.isBreakStatement = STe;
  I.isCallExpression = PTe;
  I.isCatchClause = ETe;
  I.isClass = CPe;
  I.isClassAccessorProperty = V0e;
  I.isClassBody = d0e;
  I.isClassDeclaration = y0e;
  I.isClassExpression = m0e;
  I.isClassImplements = ebe;
  I.isClassMethod = I0e;
  I.isClassPrivateMethod = $0e;
  I.isClassPrivateProperty = W0e;
  I.isClassProperty = K0e;
  I.isCompletionStatement = rPe;
  I.isConditional = nPe;
  I.isConditionalExpression = ATe;
  I.isContinueStatement = vTe;
  I.isDebuggerStatement = CTe;
  I.isDecimalLiteral = Dxe;
  I.isDeclaration = dPe;
  I.isDeclareClass = tbe;
  I.isDeclareExportAllDeclaration = cbe;
  I.isDeclareExportDeclaration = ube;
  I.isDeclareFunction = sbe;
  I.isDeclareInterface = ibe;
  I.isDeclareModule = rbe;
  I.isDeclareModuleExports = nbe;
  I.isDeclareOpaqueType = obe;
  I.isDeclareTypeAlias = abe;
  I.isDeclareVariable = lbe;
  I.isDeclaredPredicate = pbe;
  I.isDecorator = Cxe;
  I.isDirective = TTe;
  I.isDirectiveLiteral = bTe;
  I.isDoExpression = wxe;
  I.isDoWhileStatement = wTe;
  I.isEmptyStatement = ITe;
  I.isEmptyTypeAnnotation = Pbe;
  I.isEnumBody = MPe;
  I.isEnumBooleanBody = zbe;
  I.isEnumBooleanMember = exe;
  I.isEnumDeclaration = Xbe;
  I.isEnumDefaultedMember = ixe;
  I.isEnumMember = FPe;
  I.isEnumNumberBody = Gbe;
  I.isEnumNumberMember = txe;
  I.isEnumStringBody = Qbe;
  I.isEnumStringMember = sxe;
  I.isEnumSymbolBody = Zbe;
  I.isExistsTypeAnnotation = hbe;
  I.isExportAllDeclaration = g0e;
  I.isExportDeclaration = wPe;
  I.isExportDefaultDeclaration = T0e;
  I.isExportDefaultSpecifier = Ixe;
  I.isExportNamedDeclaration = b0e;
  I.isExportNamespaceSpecifier = R0e;
  I.isExportSpecifier = x0e;
  I.isExpression = GSe;
  I.isExpressionStatement = NTe;
  I.isExpressionWrapper = lPe;
  I.isFile = kTe;
  I.isFlow = DPe;
  I.isFlowBaseAnnotation = _Pe;
  I.isFlowDeclaration = LPe;
  I.isFlowPredicate = BPe;
  I.isFlowType = OPe;
  I.isFor = uPe;
  I.isForInStatement = DTe;
  I.isForOfStatement = S0e;
  I.isForStatement = OTe;
  I.isForXStatement = cPe;
  I.isFunction = pPe;
  I.isFunctionDeclaration = _Te;
  I.isFunctionExpression = LTe;
  I.isFunctionParent = hPe;
  I.isFunctionTypeAnnotation = fbe;
  I.isFunctionTypeParam = dbe;
  I.isGenericTypeAnnotation = mbe;
  I.isIdentifier = BTe;
  I.isIfStatement = MTe;
  I.isImmutable = bPe;
  I.isImport = F0e;
  I.isImportAttribute = Y0e;
  I.isImportDeclaration = P0e;
  I.isImportDefaultSpecifier = E0e;
  I.isImportExpression = C0e;
  I.isImportNamespaceSpecifier = A0e;
  I.isImportOrExportDeclaration = C7;
  I.isImportSpecifier = v0e;
  I.isIndexedAccessType = rxe;
  I.isInferredPredicate = ybe;
  I.isInterfaceDeclaration = Tbe;
  I.isInterfaceExtends = gbe;
  I.isInterfaceTypeAnnotation = bbe;
  I.isInterpreterDirective = gTe;
  I.isIntersectionTypeAnnotation = xbe;
  I.isJSX = jPe;
  I.isJSXAttribute = axe;
  I.isJSXClosingElement = oxe;
  I.isJSXClosingFragment = xxe;
  I.isJSXElement = lxe;
  I.isJSXEmptyExpression = uxe;
  I.isJSXExpressionContainer = cxe;
  I.isJSXFragment = Txe;
  I.isJSXIdentifier = hxe;
  I.isJSXMemberExpression = fxe;
  I.isJSXNamespacedName = dxe;
  I.isJSXOpeningElement = mxe;
  I.isJSXOpeningFragment = bxe;
  I.isJSXSpreadAttribute = yxe;
  I.isJSXSpreadChild = pxe;
  I.isJSXText = gxe;
  I.isLVal = yPe;
  I.isLabeledStatement = FTe;
  I.isLiteral = TPe;
  I.isLogicalExpression = VTe;
  I.isLoop = aPe;
  I.isMemberExpression = WTe;
  I.isMetaProperty = w0e;
  I.isMethod = SPe;
  I.isMiscellaneous = RPe;
  I.isMixedTypeAnnotation = Sbe;
  I.isModuleDeclaration = YPe;
  I.isModuleExpression = Oxe;
  I.isModuleSpecifier = IPe;
  I.isNewExpression = $Te;
  I.isNoop = Sxe;
  I.isNullLiteral = qTe;
  I.isNullLiteralTypeAnnotation = Z0e;
  I.isNullableTypeAnnotation = Ebe;
  I.isNumberLiteral = WPe;
  I.isNumberLiteralTypeAnnotation = Abe;
  I.isNumberTypeAnnotation = vbe;
  I.isNumericLiteral = RTe;
  I.isObjectExpression = JTe;
  I.isObjectMember = PPe;
  I.isObjectMethod = YTe;
  I.isObjectPattern = N0e;
  I.isObjectProperty = XTe;
  I.isObjectTypeAnnotation = Cbe;
  I.isObjectTypeCallProperty = Ibe;
  I.isObjectTypeIndexer = Nbe;
  I.isObjectTypeInternalSlot = wbe;
  I.isObjectTypeProperty = kbe;
  I.isObjectTypeSpreadProperty = Dbe;
  I.isOpaqueType = Obe;
  I.isOptionalCallExpression = U0e;
  I.isOptionalIndexedAccessType = nxe;
  I.isOptionalMemberExpression = q0e;
  I.isParenthesizedExpression = ZTe;
  I.isPattern = vPe;
  I.isPatternLike = mPe;
  I.isPipelineBareFunction = Bxe;
  I.isPipelinePrimaryTopicReference = Mxe;
  I.isPipelineTopicExpression = Lxe;
  I.isPlaceholder = Pxe;
  I.isPrivate = kPe;
  I.isPrivateName = H0e;
  I.isProgram = HTe;
  I.isProperty = EPe;
  I.isPureish = fPe;
  I.isQualifiedTypeIdentifier = _be;
  I.isRecordExpression = Nxe;
  I.isRegExpLiteral = KTe;
  I.isRegexLiteral = $Pe;
  I.isRestElement = zTe;
  I.isRestProperty = HPe;
  I.isReturnStatement = GTe;
  I.isScopable = ZSe;
  I.isSequenceExpression = QTe;
  I.isSpreadElement = k0e;
  I.isSpreadProperty = JPe;
  I.isStandardized = zSe;
  I.isStatement = sPe;
  I.isStaticBlock = J0e;
  I.isStringLiteral = jTe;
  I.isStringLiteralTypeAnnotation = Lbe;
  I.isStringTypeAnnotation = Bbe;
  I.isSuper = D0e;
  I.isSwitchCase = e0e;
  I.isSwitchStatement = t0e;
  I.isSymbolTypeAnnotation = Mbe;
  I.isTSAnyKeyword = Hxe;
  I.isTSArrayType = hSe;
  I.isTSAsExpression = OSe;
  I.isTSBaseType = VPe;
  I.isTSBigIntKeyword = Yxe;
  I.isTSBooleanKeyword = Jxe;
  I.isTSCallSignatureDeclaration = Uxe;
  I.isTSConditionalType = bSe;
  I.isTSConstructSignatureDeclaration = Kxe;
  I.isTSConstructorType = oSe;
  I.isTSDeclareFunction = jxe;
  I.isTSDeclareMethod = Rxe;
  I.isTSEntityName = gPe;
  I.isTSEnumBody = BSe;
  I.isTSEnumDeclaration = MSe;
  I.isTSEnumMember = FSe;
  I.isTSExportAssignment = WSe;
  I.isTSExpressionWithTypeArguments = wSe;
  I.isTSExternalModuleReference = KSe;
  I.isTSFunctionType = aSe;
  I.isTSImportEqualsDeclaration = USe;
  I.isTSImportType = qSe;
  I.isTSIndexSignature = $xe;
  I.isTSIndexedAccessType = ESe;
  I.isTSInferType = xSe;
  I.isTSInstantiationExpression = DSe;
  I.isTSInterfaceBody = NSe;
  I.isTSInterfaceDeclaration = ISe;
  I.isTSIntersectionType = TSe;
  I.isTSIntrinsicKeyword = Xxe;
  I.isTSLiteralType = CSe;
  I.isTSMappedType = ASe;
  I.isTSMethodSignature = Wxe;
  I.isTSModuleBlock = RSe;
  I.isTSModuleDeclaration = jSe;
  I.isTSNamedTupleMember = ySe;
  I.isTSNamespaceExportDeclaration = $Se;
  I.isTSNeverKeyword = zxe;
  I.isTSNonNullExpression = VSe;
  I.isTSNullKeyword = Gxe;
  I.isTSNumberKeyword = Qxe;
  I.isTSObjectKeyword = Zxe;
  I.isTSOptionalType = dSe;
  I.isTSParameterProperty = Fxe;
  I.isTSParenthesizedType = SSe;
  I.isTSPropertySignature = Vxe;
  I.isTSQualifiedName = qxe;
  I.isTSRestType = mSe;
  I.isTSSatisfiesExpression = _Se;
  I.isTSStringKeyword = eSe;
  I.isTSSymbolKeyword = tSe;
  I.isTSTemplateLiteralType = vSe;
  I.isTSThisType = nSe;
  I.isTSTupleType = fSe;
  I.isTSType = KPe;
  I.isTSTypeAliasDeclaration = kSe;
  I.isTSTypeAnnotation = HSe;
  I.isTSTypeAssertion = LSe;
  I.isTSTypeElement = UPe;
  I.isTSTypeLiteral = pSe;
  I.isTSTypeOperator = PSe;
  I.isTSTypeParameter = XSe;
  I.isTSTypeParameterDeclaration = YSe;
  I.isTSTypeParameterInstantiation = JSe;
  I.isTSTypePredicate = uSe;
  I.isTSTypeQuery = cSe;
  I.isTSTypeReference = lSe;
  I.isTSUndefinedKeyword = sSe;
  I.isTSUnionType = gSe;
  I.isTSUnknownKeyword = iSe;
  I.isTSVoidKeyword = rSe;
  I.isTaggedTemplateExpression = O0e;
  I.isTemplateElement = _0e;
  I.isTemplateLiteral = L0e;
  I.isTerminatorless = iPe;
  I.isThisExpression = s0e;
  I.isThisTypeAnnotation = Fbe;
  I.isThrowStatement = i0e;
  I.isTopicReference = _xe;
  I.isTryStatement = r0e;
  I.isTupleExpression = kxe;
  I.isTupleTypeAnnotation = jbe;
  I.isTypeAlias = qbe;
  I.isTypeAnnotation = Ube;
  I.isTypeCastExpression = Kbe;
  I.isTypeParameter = Vbe;
  I.isTypeParameterDeclaration = Wbe;
  I.isTypeParameterInstantiation = $be;
  I.isTypeScript = qPe;
  I.isTypeofTypeAnnotation = Rbe;
  I.isUnaryExpression = n0e;
  I.isUnaryLike = APe;
  I.isUnionTypeAnnotation = Hbe;
  I.isUpdateExpression = a0e;
  I.isUserWhitespacable = xPe;
  I.isV8IntrinsicIdentifier = Exe;
  I.isVariableDeclaration = o0e;
  I.isVariableDeclarator = l0e;
  I.isVariance = Jbe;
  I.isVoidTypeAnnotation = Ybe;
  I.isWhile = oPe;
  I.isWhileStatement = u0e;
  I.isWithStatement = c0e;
  I.isYieldExpression = B0e;
  var B = wb(), jy = Fy();
  function dTe(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(dTe, "isArrayExpression");
  function mTe(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(mTe, "isAssignmentExpression");
  function yTe(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(yTe, "isBinaryExpression");
  function gTe(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(gTe, "isInterpreterDirective");
  function TTe(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(TTe, "isDirective");
  function bTe(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(bTe, "isDirectiveLiteral");
  function xTe(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(xTe, "isBlockStatement");
  function STe(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(STe, "isBreakStatement");
  function PTe(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(PTe, "isCallExpression");
  function ETe(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ETe, "isCatchClause");
  function ATe(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ATe, "isConditionalExpression");
  function vTe(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(vTe, "isContinueStatement");
  function CTe(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(CTe, "isDebuggerStatement");
  function wTe(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(wTe, "isDoWhileStatement");
  function ITe(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ITe, "isEmptyStatement");
  function NTe(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(NTe, "isExpressionStatement");
  function kTe(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(kTe, "isFile");
  function DTe(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(DTe, "isForInStatement");
  function OTe(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(OTe, "isForStatement");
  function _Te(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(_Te, "isFunctionDeclaration");
  function LTe(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(LTe, "isFunctionExpression");
  function BTe(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(BTe, "isIdentifier");
  function MTe(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(MTe, "isIfStatement");
  function FTe(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(FTe, "isLabeledStatement");
  function jTe(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(jTe, "isStringLiteral");
  function RTe(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(RTe, "isNumericLiteral");
  function qTe(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(qTe, "isNullLiteral");
  function UTe(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(UTe, "isBooleanLiteral");
  function KTe(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(KTe, "isRegExpLiteral");
  function VTe(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(VTe, "isLogicalExpression");
  function WTe(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(WTe, "isMemberExpression");
  function $Te(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($Te, "isNewExpression");
  function HTe(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(HTe, "isProgram");
  function JTe(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(JTe, "isObjectExpression");
  function YTe(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(YTe, "isObjectMethod");
  function XTe(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(XTe, "isObjectProperty");
  function zTe(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(zTe, "isRestElement");
  function GTe(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(GTe, "isReturnStatement");
  function QTe(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(QTe, "isSequenceExpression");
  function ZTe(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ZTe, "isParenthesizedExpression");
  function e0e(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(e0e, "isSwitchCase");
  function t0e(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(t0e, "isSwitchStatement");
  function s0e(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(s0e, "isThisExpression");
  function i0e(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(i0e, "isThrowStatement");
  function r0e(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(r0e, "isTryStatement");
  function n0e(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(n0e, "isUnaryExpression");
  function a0e(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(a0e, "isUpdateExpression");
  function o0e(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(o0e, "isVariableDeclaration");
  function l0e(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(l0e, "isVariableDeclarator");
  function u0e(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(u0e, "isWhileStatement");
  function c0e(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(c0e, "isWithStatement");
  function p0e(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(p0e, "isAssignmentPattern");
  function h0e(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(h0e, "isArrayPattern");
  function f0e(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(f0e, "isArrowFunctionExpression");
  function d0e(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(d0e, "isClassBody");
  function m0e(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(m0e, "isClassExpression");
  function y0e(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(y0e, "isClassDeclaration");
  function g0e(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(g0e, "isExportAllDeclaration");
  function T0e(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(T0e, "isExportDefaultDeclaration");
  function b0e(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(b0e, "isExportNamedDeclaration");
  function x0e(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(x0e, "isExportSpecifier");
  function S0e(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(S0e, "isForOfStatement");
  function P0e(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(P0e, "isImportDeclaration");
  function E0e(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(E0e, "isImportDefaultSpecifier");
  function A0e(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(A0e, "isImportNamespaceSpecifier");
  function v0e(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(v0e, "isImportSpecifier");
  function C0e(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(C0e, "isImportExpression");
  function w0e(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(w0e, "isMetaProperty");
  function I0e(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(I0e, "isClassMethod");
  function N0e(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(N0e, "isObjectPattern");
  function k0e(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(k0e, "isSpreadElement");
  function D0e(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(D0e, "isSuper");
  function O0e(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(O0e, "isTaggedTemplateExpression");
  function _0e(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(_0e, "isTemplateElement");
  function L0e(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(L0e, "isTemplateLiteral");
  function B0e(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(B0e, "isYieldExpression");
  function M0e(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(M0e, "isAwaitExpression");
  function F0e(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(F0e, "isImport");
  function j0e(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(j0e, "isBigIntLiteral");
  function R0e(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(R0e, "isExportNamespaceSpecifier");
  function q0e(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(q0e, "isOptionalMemberExpression");
  function U0e(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(U0e, "isOptionalCallExpression");
  function K0e(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(K0e, "isClassProperty");
  function V0e(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(V0e, "isClassAccessorProperty");
  function W0e(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(W0e, "isClassPrivateProperty");
  function $0e(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($0e, "isClassPrivateMethod");
  function H0e(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(H0e, "isPrivateName");
  function J0e(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(J0e, "isStaticBlock");
  function Y0e(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Y0e, "isImportAttribute");
  function X0e(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(X0e, "isAnyTypeAnnotation");
  function z0e(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(z0e, "isArrayTypeAnnotation");
  function G0e(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(G0e, "isBooleanTypeAnnotation");
  function Q0e(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Q0e, "isBooleanLiteralTypeAnnotation");
  function Z0e(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Z0e, "isNullLiteralTypeAnnotation");
  function ebe(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ebe, "isClassImplements");
  function tbe(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(tbe, "isDeclareClass");
  function sbe(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(sbe, "isDeclareFunction");
  function ibe(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ibe, "isDeclareInterface");
  function rbe(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(rbe, "isDeclareModule");
  function nbe(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(nbe, "isDeclareModuleExports");
  function abe(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(abe, "isDeclareTypeAlias");
  function obe(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(obe, "isDeclareOpaqueType");
  function lbe(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(lbe, "isDeclareVariable");
  function ube(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ube, "isDeclareExportDeclaration");
  function cbe(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(cbe, "isDeclareExportAllDeclaration");
  function pbe(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(pbe, "isDeclaredPredicate");
  function hbe(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(hbe, "isExistsTypeAnnotation");
  function fbe(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(fbe, "isFunctionTypeAnnotation");
  function dbe(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(dbe, "isFunctionTypeParam");
  function mbe(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(mbe, "isGenericTypeAnnotation");
  function ybe(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ybe, "isInferredPredicate");
  function gbe(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(gbe, "isInterfaceExtends");
  function Tbe(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Tbe, "isInterfaceDeclaration");
  function bbe(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(bbe, "isInterfaceTypeAnnotation");
  function xbe(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(xbe, "isIntersectionTypeAnnotation");
  function Sbe(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Sbe, "isMixedTypeAnnotation");
  function Pbe(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Pbe, "isEmptyTypeAnnotation");
  function Ebe(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Ebe, "isNullableTypeAnnotation");
  function Abe(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Abe, "isNumberLiteralTypeAnnotation");
  function vbe(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(vbe, "isNumberTypeAnnotation");
  function Cbe(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Cbe, "isObjectTypeAnnotation");
  function wbe(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(wbe, "isObjectTypeInternalSlot");
  function Ibe(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Ibe, "isObjectTypeCallProperty");
  function Nbe(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Nbe, "isObjectTypeIndexer");
  function kbe(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(kbe, "isObjectTypeProperty");
  function Dbe(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Dbe, "isObjectTypeSpreadProperty");
  function Obe(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Obe, "isOpaqueType");
  function _be(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(_be, "isQualifiedTypeIdentifier");
  function Lbe(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Lbe, "isStringLiteralTypeAnnotation");
  function Bbe(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Bbe, "isStringTypeAnnotation");
  function Mbe(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Mbe, "isSymbolTypeAnnotation");
  function Fbe(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Fbe, "isThisTypeAnnotation");
  function jbe(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(jbe, "isTupleTypeAnnotation");
  function Rbe(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Rbe, "isTypeofTypeAnnotation");
  function qbe(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(qbe, "isTypeAlias");
  function Ube(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Ube, "isTypeAnnotation");
  function Kbe(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Kbe, "isTypeCastExpression");
  function Vbe(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Vbe, "isTypeParameter");
  function Wbe(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Wbe, "isTypeParameterDeclaration");
  function $be(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($be, "isTypeParameterInstantiation");
  function Hbe(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Hbe, "isUnionTypeAnnotation");
  function Jbe(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Jbe, "isVariance");
  function Ybe(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Ybe, "isVoidTypeAnnotation");
  function Xbe(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Xbe, "isEnumDeclaration");
  function zbe(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(zbe, "isEnumBooleanBody");
  function Gbe(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Gbe, "isEnumNumberBody");
  function Qbe(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Qbe, "isEnumStringBody");
  function Zbe(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Zbe, "isEnumSymbolBody");
  function exe(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(exe, "isEnumBooleanMember");
  function txe(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(txe, "isEnumNumberMember");
  function sxe(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(sxe, "isEnumStringMember");
  function ixe(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ixe, "isEnumDefaultedMember");
  function rxe(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(rxe, "isIndexedAccessType");
  function nxe(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(nxe, "isOptionalIndexedAccessType");
  function axe(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(axe, "isJSXAttribute");
  function oxe(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(oxe, "isJSXClosingElement");
  function lxe(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(lxe, "isJSXElement");
  function uxe(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(uxe, "isJSXEmptyExpression");
  function cxe(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(cxe, "isJSXExpressionContainer");
  function pxe(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(pxe, "isJSXSpreadChild");
  function hxe(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(hxe, "isJSXIdentifier");
  function fxe(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(fxe, "isJSXMemberExpression");
  function dxe(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(dxe, "isJSXNamespacedName");
  function mxe(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(mxe, "isJSXOpeningElement");
  function yxe(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(yxe, "isJSXSpreadAttribute");
  function gxe(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(gxe, "isJSXText");
  function Txe(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Txe, "isJSXFragment");
  function bxe(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(bxe, "isJSXOpeningFragment");
  function xxe(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(xxe, "isJSXClosingFragment");
  function Sxe(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Sxe, "isNoop");
  function Pxe(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Pxe, "isPlaceholder");
  function Exe(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Exe, "isV8IntrinsicIdentifier");
  function Axe(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Axe, "isArgumentPlaceholder");
  function vxe(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(vxe, "isBindExpression");
  function Cxe(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Cxe, "isDecorator");
  function wxe(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(wxe, "isDoExpression");
  function Ixe(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Ixe, "isExportDefaultSpecifier");
  function Nxe(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Nxe, "isRecordExpression");
  function kxe(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(kxe, "isTupleExpression");
  function Dxe(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Dxe, "isDecimalLiteral");
  function Oxe(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Oxe, "isModuleExpression");
  function _xe(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(_xe, "isTopicReference");
  function Lxe(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Lxe, "isPipelineTopicExpression");
  function Bxe(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Bxe, "isPipelineBareFunction");
  function Mxe(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Mxe, "isPipelinePrimaryTopicReference");
  function Fxe(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Fxe, "isTSParameterProperty");
  function jxe(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(jxe, "isTSDeclareFunction");
  function Rxe(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Rxe, "isTSDeclareMethod");
  function qxe(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(qxe, "isTSQualifiedName");
  function Uxe(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Uxe, "isTSCallSignatureDeclaration");
  function Kxe(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Kxe, "isTSConstructSignatureDeclaration");
  function Vxe(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Vxe, "isTSPropertySignature");
  function Wxe(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Wxe, "isTSMethodSignature");
  function $xe(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($xe, "isTSIndexSignature");
  function Hxe(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Hxe, "isTSAnyKeyword");
  function Jxe(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Jxe, "isTSBooleanKeyword");
  function Yxe(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Yxe, "isTSBigIntKeyword");
  function Xxe(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Xxe, "isTSIntrinsicKeyword");
  function zxe(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(zxe, "isTSNeverKeyword");
  function Gxe(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Gxe, "isTSNullKeyword");
  function Qxe(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Qxe, "isTSNumberKeyword");
  function Zxe(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(Zxe, "isTSObjectKeyword");
  function eSe(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(eSe, "isTSStringKeyword");
  function tSe(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(tSe, "isTSSymbolKeyword");
  function sSe(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(sSe, "isTSUndefinedKeyword");
  function iSe(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(iSe, "isTSUnknownKeyword");
  function rSe(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(rSe, "isTSVoidKeyword");
  function nSe(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(nSe, "isTSThisType");
  function aSe(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(aSe, "isTSFunctionType");
  function oSe(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(oSe, "isTSConstructorType");
  function lSe(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(lSe, "isTSTypeReference");
  function uSe(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(uSe, "isTSTypePredicate");
  function cSe(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(cSe, "isTSTypeQuery");
  function pSe(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(pSe, "isTSTypeLiteral");
  function hSe(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(hSe, "isTSArrayType");
  function fSe(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(fSe, "isTSTupleType");
  function dSe(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(dSe, "isTSOptionalType");
  function mSe(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(mSe, "isTSRestType");
  function ySe(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ySe, "isTSNamedTupleMember");
  function gSe(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(gSe, "isTSUnionType");
  function TSe(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(TSe, "isTSIntersectionType");
  function bSe(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(bSe, "isTSConditionalType");
  function xSe(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(xSe, "isTSInferType");
  function SSe(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(SSe, "isTSParenthesizedType");
  function PSe(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(PSe, "isTSTypeOperator");
  function ESe(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ESe, "isTSIndexedAccessType");
  function ASe(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ASe, "isTSMappedType");
  function vSe(t, e) {
    return !t || t.type !== "TSTemplateLiteralType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(vSe, "isTSTemplateLiteralType");
  function CSe(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(CSe, "isTSLiteralType");
  function wSe(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(wSe, "isTSExpressionWithTypeArguments");
  function ISe(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(ISe, "isTSInterfaceDeclaration");
  function NSe(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(NSe, "isTSInterfaceBody");
  function kSe(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(kSe, "isTSTypeAliasDeclaration");
  function DSe(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(DSe, "isTSInstantiationExpression");
  function OSe(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(OSe, "isTSAsExpression");
  function _Se(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(_Se, "isTSSatisfiesExpression");
  function LSe(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(LSe, "isTSTypeAssertion");
  function BSe(t, e) {
    return !t || t.type !== "TSEnumBody" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(BSe, "isTSEnumBody");
  function MSe(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(MSe, "isTSEnumDeclaration");
  function FSe(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(FSe, "isTSEnumMember");
  function jSe(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(jSe, "isTSModuleDeclaration");
  function RSe(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(RSe, "isTSModuleBlock");
  function qSe(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(qSe, "isTSImportType");
  function USe(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(USe, "isTSImportEqualsDeclaration");
  function KSe(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(KSe, "isTSExternalModuleReference");
  function VSe(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(VSe, "isTSNonNullExpression");
  function WSe(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(WSe, "isTSExportAssignment");
  function $Se(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($Se, "isTSNamespaceExportDeclaration");
  function HSe(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(HSe, "isTSTypeAnnotation");
  function JSe(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(JSe, "isTSTypeParameterInstantiation");
  function YSe(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(YSe, "isTSTypeParameterDeclaration");
  function XSe(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(XSe, "isTSTypeParameter");
  function zSe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(zSe, "isStandardized");
  function GSe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(GSe, "isExpression");
  function QSe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(QSe, "isBinary");
  function ZSe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(ZSe, "isScopable");
  function ePe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(ePe, "isBlockParent");
  function tPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(tPe, "isBlock");
  function sPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(sPe, "isStatement");
  function iPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(iPe, "isTerminatorless");
  function rPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(rPe, "isCompletionStatement");
  function nPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(nPe, "isConditional");
  function aPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(aPe, "isLoop");
  function oPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(oPe, "isWhile");
  function lPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(lPe, "isExpressionWrapper");
  function uPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(uPe, "isFor");
  function cPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(cPe, "isForXStatement");
  function pPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(pPe, "isFunction");
  function hPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(hPe, "isFunctionParent");
  function fPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(fPe, "isPureish");
  function dPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(dPe, "isDeclaration");
  function mPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(mPe, "isPatternLike");
  function yPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(yPe, "isLVal");
  function gPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(gPe, "isTSEntityName");
  function TPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(TPe, "isLiteral");
  function bPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(bPe, "isImmutable");
  function xPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(xPe, "isUserWhitespacable");
  function SPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(SPe, "isMethod");
  function PPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(PPe, "isObjectMember");
  function EPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(EPe, "isProperty");
  function APe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(APe, "isUnaryLike");
  function vPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(vPe, "isPattern");
  function CPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(CPe, "isClass");
  function C7(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(C7, "isImportOrExportDeclaration");
  function wPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(wPe, "isExportDeclaration");
  function IPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(IPe, "isModuleSpecifier");
  function NPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(NPe, "isAccessor");
  function kPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(kPe, "isPrivate");
  function DPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(DPe, "isFlow");
  function OPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(OPe, "isFlowType");
  function _Pe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(_Pe, "isFlowBaseAnnotation");
  function LPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(LPe, "isFlowDeclaration");
  function BPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(BPe, "isFlowPredicate");
  function MPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(MPe, "isEnumBody");
  function FPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(FPe, "isEnumMember");
  function jPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(jPe, "isJSX");
  function RPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(RPe, "isMiscellaneous");
  function qPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(qPe, "isTypeScript");
  function UPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(UPe, "isTSTypeElement");
  function KPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(KPe, "isTSType");
  function VPe(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, B.default)(t, e);
  }
  n(VPe, "isTSBaseType");
  function WPe(t, e) {
    return (0, jy.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(WPe, "isNumberLiteral");
  function $Pe(t, e) {
    return (0, jy.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, B.default)(t, e);
  }
  n($Pe, "isRegexLiteral");
  function HPe(t, e) {
    return (0, jy.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(HPe, "isRestProperty");
  function JPe(t, e) {
    return (0, jy.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, B.default)(t, e);
  }
  n(JPe, "isSpreadProperty");
  function YPe(t, e) {
    return (0, jy.default)("isModuleDeclaration", "isImportOrExportDeclaration"), C7(t, e);
  }
  n(YPe, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var wC = g((CC) => {
  "use strict";
  Object.defineProperty(CC, "__esModule", {
    value: !0
  });
  CC.default = XPe;
  var Ry = tr();
  function XPe(t, e, s) {
    if (!(0, Ry.isMemberExpression)(t)) return !1;
    let i = Array.isArray(e) ? e : e.split("."), r = [], a;
    for (a = t; (0, Ry.isMemberExpression)(a); a = a.object)
      r.push(a.property);
    if (r.push(a), r.length < i.length || !s && r.length > i.length) return !1;
    for (let o = 0, l = r.length - 1; o < i.length; o++, l--) {
      let u = r[l], c;
      if ((0, Ry.isIdentifier)(u))
        c = u.name;
      else if ((0, Ry.isStringLiteral)(u))
        c = u.value;
      else if ((0, Ry.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (i[o] !== c) return !1;
    }
    return !0;
  }
  n(XPe, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var NC = g((IC) => {
  "use strict";
  Object.defineProperty(IC, "__esModule", {
    value: !0
  });
  IC.default = GPe;
  var zPe = wC();
  function GPe(t, e) {
    let s = t.split(".");
    return (i) => (0, zPe.default)(i, s, e);
  }
  n(GPe, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var w7 = g((Ib) => {
  "use strict";
  Object.defineProperty(Ib, "__esModule", {
    value: !0
  });
  Ib.default = void 0;
  var QPe = NC(), ZPe = (0, QPe.default)("React.Component"), a4s = Ib.default = ZPe;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var I7 = g((kC) => {
  "use strict";
  Object.defineProperty(kC, "__esModule", {
    value: !0
  });
  kC.default = eEe;
  function eEe(t) {
    return !!t && /^[a-z]/.test(t);
  }
  n(eEe, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Nb = g((DC) => {
  "use strict";
  Object.defineProperty(DC, "__esModule", {
    value: !0
  });
  DC.default = tEe;
  var N7 = Pa();
  function tEe(t, e) {
    if (t === e) return !0;
    if (t == null || N7.ALIAS_KEYS[e]) return !1;
    let s = N7.FLIPPED_ALIAS_KEYS[e];
    return !!(s != null && s.includes(t));
  }
  n(tEe, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var _C = g((OC) => {
  "use strict";
  Object.defineProperty(OC, "__esModule", {
    value: !0
  });
  OC.default = iEe;
  var sEe = Pa();
  function iEe(t, e) {
    if (t === e) return !0;
    let s = sEe.PLACEHOLDERS_ALIAS[t];
    return !!(s != null && s.includes(e));
  }
  n(iEe, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var Gf = g((LC) => {
  "use strict";
  Object.defineProperty(LC, "__esModule", {
    value: !0
  });
  LC.default = lEe;
  var rEe = wb(), nEe = Nb(), aEe = _C(), oEe = Pa();
  function lEe(t, e, s) {
    return e ? (0, nEe.default)(e.type, t) ? s === void 0 ? !0 : (0, rEe.default)(e, s) : !s && e.type === "Placeholder" && t in oEe.FLIPPED_ALIAS_KEYS ?
    (0, aEe.default)(e.expectedNode, t) : !1 : !1;
  }
  n(lEe, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var L7 = g((qy) => {
  "use strict";
  Object.defineProperty(qy, "__esModule", {
    value: !0
  });
  qy.isIdentifierChar = _7;
  qy.isIdentifierName = hEe;
  qy.isIdentifierStart = O7;
  var MC = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  k7 = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", uEe = new RegExp("[" + MC + "]"), cEe = new RegExp("[" + MC + k7 + "]");
  MC = k7 = null;
  var D7 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], pEe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function BC(t, e) {
    let s = 65536;
    for (let i = 0, r = e.length; i < r; i += 2) {
      if (s += e[i], s > t) return !1;
      if (s += e[i + 1], s >= t) return !0;
    }
    return !1;
  }
  n(BC, "isInAstralSet");
  function O7(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && uEe.test(String.fromCharCode(t)) :
    BC(t, D7);
  }
  n(O7, "isIdentifierStart");
  function _7(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && cEe.test(
    String.fromCharCode(t)) : BC(t, D7) || BC(t, pEe);
  }
  n(_7, "isIdentifierChar");
  function hEe(t) {
    let e = !0;
    for (let s = 0; s < t.length; s++) {
      let i = t.charCodeAt(s);
      if ((i & 64512) === 55296 && s + 1 < t.length) {
        let r = t.charCodeAt(++s);
        (r & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (r & 1023));
      }
      if (e) {
        if (e = !1, !O7(i))
          return !1;
      } else if (!_7(i))
        return !1;
    }
    return !e;
  }
  n(hEe, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var j7 = g((zp) => {
  "use strict";
  Object.defineProperty(zp, "__esModule", {
    value: !0
  });
  zp.isKeyword = gEe;
  zp.isReservedWord = B7;
  zp.isStrictBindOnlyReservedWord = F7;
  zp.isStrictBindReservedWord = yEe;
  zp.isStrictReservedWord = M7;
  var FC = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, fEe = new Set(FC.keyword), dEe = new Set(FC.strict), mEe = new Set(FC.strictBind);
  function B7(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(B7, "isReservedWord");
  function M7(t, e) {
    return B7(t, e) || dEe.has(t);
  }
  n(M7, "isStrictReservedWord");
  function F7(t) {
    return mEe.has(t);
  }
  n(F7, "isStrictBindOnlyReservedWord");
  function yEe(t, e) {
    return M7(t, e) || F7(t);
  }
  n(yEe, "isStrictBindReservedWord");
  function gEe(t) {
    return fEe.has(t);
  }
  n(gEe, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Ea = g((Yo) => {
  "use strict";
  Object.defineProperty(Yo, "__esModule", {
    value: !0
  });
  Object.defineProperty(Yo, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jC.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Yo, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jC.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Yo, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jC.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Yo, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uy.isKeyword;
    }, "get")
  });
  Object.defineProperty(Yo, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uy.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Yo, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uy.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Yo, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uy.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Yo, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uy.isStrictReservedWord;
    }, "get")
  });
  var jC = L7(), Uy = j7();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var Qf = g((qC) => {
  "use strict";
  Object.defineProperty(qC, "__esModule", {
    value: !0
  });
  qC.default = TEe;
  var RC = Ea();
  function TEe(t, e = !0) {
    return typeof t != "string" || e && ((0, RC.isKeyword)(t) || (0, RC.isStrictReservedWord)(t, !0)) ? !1 : (0, RC.isIdentifierName)(t);
  }
  n(TEe, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var Db = g((Ky) => {
  "use strict";
  Object.defineProperty(Ky, "__esModule", {
    value: !0
  });
  Ky.readCodePoint = U7;
  Ky.readInt = q7;
  Ky.readStringContents = xEe;
  var bEe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), R7 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, kb = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function xEe(t, e, s, i, r, a) {
    let o = s, l = i, u = r, c = "", p = null, h = s, {
      length: f
    } = e;
    for (; ; ) {
      if (s >= f) {
        a.unterminated(o, l, u), c += e.slice(h, s);
        break;
      }
      let d = e.charCodeAt(s);
      if (SEe(t, d, e, s)) {
        c += e.slice(h, s);
        break;
      }
      if (d === 92) {
        c += e.slice(h, s);
        let y = PEe(e, s, i, r, t === "template", a);
        y.ch === null && !p ? p = {
          pos: s,
          lineStart: i,
          curLine: r
        } : c += y.ch, {
          pos: s,
          lineStart: i,
          curLine: r
        } = y, h = s;
      } else d === 8232 || d === 8233 ? (++s, ++r, i = s) : d === 10 || d === 13 ? t === "template" ? (c += e.slice(h, s) + `
`, ++s, d === 13 && e.charCodeAt(s) === 10 && ++s, ++r, h = i = s) : a.unterminated(o, l, u) : ++s;
    }
    return {
      pos: s,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: r,
      containsInvalid: !!p
    };
  }
  n(xEe, "readStringContents");
  function SEe(t, e, s, i) {
    return t === "template" ? e === 96 || e === 36 && s.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(SEe, "isStringEnd");
  function PEe(t, e, s, i, r, a) {
    let o = !r;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: s,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = UC(t, e, s, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = U7(t, e, s, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        s = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (r)
          return l(null);
        a.strictNumericEscape(e - 1, s, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, h = /^[0-7]+/.exec(t.slice(c, e + 2))[0], f = parseInt(h, 8);
          f > 255 && (h = h.slice(0, -1), f = parseInt(h, 8)), e += h.length - 1;
          let d = t.charCodeAt(e);
          if (h !== "0" || d === 56 || d === 57) {
            if (r)
              return l(null);
            a.strictNumericEscape(c, s, i);
          }
          return l(String.fromCharCode(f));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(PEe, "readEscapedChar");
  function UC(t, e, s, i, r, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = q7(t, e, s, i, 16, r, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, s, i) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(UC, "readHexChar");
  function q7(t, e, s, i, r, a, o, l, u, c) {
    let p = e, h = r === 16 ? R7.hex : R7.decBinOct, f = r === 16 ? kb.hex : r === 10 ? kb.dec : r === 8 ? kb.oct : kb.bin, d = !1, y = 0;
    for (let m = 0, T = a ?? 1 / 0; m < T; ++m) {
      let b = t.charCodeAt(e), E;
      if (b === 95 && l !== "bail") {
        let w = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !f(K) || h.has(w) || h.has(K)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, s, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, s, i);
        }
        ++e;
        continue;
      }
      if (b >= 97 ? E = b - 97 + 10 : b >= 65 ? E = b - 65 + 10 : bEe(b) ? E = b - 48 : E = 1 / 0, E >= r) {
        if (E <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (E <= 9 && u.invalidDigit(e, s, i, r))
          E = 0;
        else if (o)
          E = 0, d = !0;
        else
          break;
      }
      ++e, y = y * r + E;
    }
    return e === p || a != null && e - p !== a || d ? {
      n: null,
      pos: e
    } : {
      n: y,
      pos: e
    };
  }
  n(q7, "readInt");
  function U7(t, e, s, i, r, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = UC(t, e, s, i, t.indexOf("}", e) - e, !0, r, a), ++e, l !== null && l > 1114111)
        if (r)
          a.invalidCodePoint(e, s, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = UC(t, e, s, i, 4, !1, r, a));
    return {
      code: l,
      pos: e
    };
  }
  n(U7, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Zf = g((es) => {
  "use strict";
  Object.defineProperty(es, "__esModule", {
    value: !0
  });
  es.UPDATE_OPERATORS = es.UNARY_OPERATORS = es.STRING_UNARY_OPERATORS = es.STATEMENT_OR_BLOCK_KEYS = es.NUMBER_UNARY_OPERATORS = es.NUMBER_BINARY_OPERATORS =
  es.LOGICAL_OPERATORS = es.INHERIT_KEYS = es.FOR_INIT_KEYS = es.FLATTENABLE_KEYS = es.EQUALITY_BINARY_OPERATORS = es.COMPARISON_BINARY_OPERATORS =
  es.COMMENT_KEYS = es.BOOLEAN_UNARY_OPERATORS = es.BOOLEAN_NUMBER_BINARY_OPERATORS = es.BOOLEAN_BINARY_OPERATORS = es.BINARY_OPERATORS = es.
  ASSIGNMENT_OPERATORS = void 0;
  var C4s = es.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], w4s = es.FLATTENABLE_KEYS = ["body", "expressions"], I4s = es.
  FOR_INIT_KEYS = ["left", "init"], N4s = es.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], EEe = es.LOGICAL_OPERATORS =
  ["||", "&&", "??"], k4s = es.UPDATE_OPERATORS = ["++", "--"], AEe = es.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], vEe = es.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], CEe = es.COMPARISON_BINARY_OPERATORS = [...vEe, "in", "instanceof"], wEe = es.BOOLEAN_BINARY_OPERATORS =
  [...CEe, ...AEe], K7 = es.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], D4s = es.BINARY_OPERATORS =
  ["+", ...K7, ...wEe, "|>"], O4s = es.ASSIGNMENT_OPERATORS = ["=", "+=", ...K7.map((t) => t + "="), ...EEe.map((t) => t + "=")], IEe = es.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], NEe = es.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], kEe = es.STRING_UNARY_OPERATORS = ["typeof"], _4s = es.UNARY_OPERATORS =
  ["void", "throw", ...IEe, ...NEe, ...kEe], L4s = es.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  es.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), es.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var Xo = g((Cs) => {
  "use strict";
  Object.defineProperty(Cs, "__esModule", {
    value: !0
  });
  Cs.allExpandedTypes = Cs.VISITOR_KEYS = Cs.NODE_PARENT_VALIDATIONS = Cs.NODE_FIELDS = Cs.FLIPPED_ALIAS_KEYS = Cs.DEPRECATED_KEYS = Cs.BUILDER_KEYS =
  Cs.ALIAS_KEYS = void 0;
  Cs.arrayOf = W7;
  Cs.arrayOfType = $7;
  Cs.assertEach = H7;
  Cs.assertNodeOrValueType = VEe;
  Cs.assertNodeType = _b;
  Cs.assertOneOf = UEe;
  Cs.assertOptionalChainStart = $Ee;
  Cs.assertShape = WEe;
  Cs.assertValueType = $C;
  Cs.chain = J7;
  Cs.default = Y7;
  Cs.defineAliasedType = YEe;
  Cs.validate = WC;
  Cs.validateArrayOfType = qEe;
  Cs.validateOptional = jEe;
  Cs.validateOptionalType = REe;
  Cs.validateType = FEe;
  var V7 = Gf(), Vy = Lb(), DEe = Cs.VISITOR_KEYS = {}, OEe = Cs.ALIAS_KEYS = {}, KC = Cs.FLIPPED_ALIAS_KEYS = {}, _Ee = Cs.NODE_FIELDS = {},
  LEe = Cs.BUILDER_KEYS = {}, BEe = Cs.DEPRECATED_KEYS = {}, MEe = Cs.NODE_PARENT_VALIDATIONS = {};
  function Ob(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  n(Ob, "getType");
  function WC(t) {
    return {
      validate: t
    };
  }
  n(WC, "validate");
  function FEe(...t) {
    return WC(_b(...t));
  }
  n(FEe, "validateType");
  function jEe(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  n(jEe, "validateOptional");
  function REe(...t) {
    return {
      validate: _b(...t),
      optional: !0
    };
  }
  n(REe, "validateOptionalType");
  function W7(t) {
    return J7($C("array"), H7(t));
  }
  n(W7, "arrayOf");
  function $7(...t) {
    return W7(_b(...t));
  }
  n($7, "arrayOfType");
  function qEe(...t) {
    return WC($7(...t));
  }
  n(qEe, "validateArrayOfType");
  function H7(t) {
    let e = process.env.BABEL_TYPES_8_BREAKING ? Vy.validateChild : () => {
    };
    function s(i, r, a) {
      if (!Array.isArray(a)) return;
      let o = 0, l = {
        toString() {
          return `${r}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let u = a[o];
        t(i, l, u), e(i, l, u);
      }
    }
    return n(s, "validator"), s.each = t, s;
  }
  n(H7, "assertEach");
  function UEe(...t) {
    function e(s, i, r) {
      if (!t.includes(r))
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(r)}`);
    }
    return n(e, "validate"), e.oneOf = t, e;
  }
  n(UEe, "assertOneOf");
  var KEe = Cs.allExpandedTypes = [];
  function _b(...t) {
    let e = /* @__PURE__ */ new Set();
    KEe.push({
      types: t,
      set: e
    });
    function s(i, r, a) {
      let o = a?.type;
      if (o != null) {
        if (e.has(o)) {
          (0, Vy.validateChild)(i, r, a);
          return;
        }
        if (o === "Placeholder") {
          for (let l of t)
            if ((0, V7.default)(l, a)) {
              (0, Vy.validateChild)(i, r, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${r} of ${i.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(o)}`);
    }
    return n(s, "validate"), s.oneOfNodeTypes = t, s;
  }
  n(_b, "assertNodeType");
  function VEe(...t) {
    function e(s, i, r) {
      let a = Ob(r);
      for (let o of t)
        if (a === o || (0, V7.default)(o, r)) {
          (0, Vy.validateChild)(s, i, r);
          return;
        }
      throw new TypeError(`Property ${i} of ${s.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(r?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  n(VEe, "assertNodeOrValueType");
  function $C(t) {
    function e(s, i, r) {
      if (Ob(r) !== t)
        throw new TypeError(`Property ${i} expected type of ${t} but got ${Ob(r)}`);
    }
    return n(e, "validate"), e.type = t, e;
  }
  n($C, "assertValueType");
  function WEe(t) {
    let e = Object.keys(t);
    function s(i, r, a) {
      let o = [];
      for (let l of e)
        try {
          (0, Vy.validateField)(i, l, a[l], t[l]);
        } catch (u) {
          if (u instanceof TypeError) {
            o.push(u.message);
            continue;
          }
          throw u;
        }
      if (o.length)
        throw new TypeError(`Property ${r} of ${i.type} expected to have the following:
${o.join(`
`)}`);
    }
    return n(s, "validate"), s.shapeOf = t, s;
  }
  n(WEe, "assertShape");
  function $Ee() {
    function t(e) {
      var s;
      let i = e;
      for (; e; ) {
        let {
          type: r
        } = i;
        if (r === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (r === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(s = i) == null ? void 0 : s.type}`);
    }
    return n(t, "validate"), t;
  }
  n($Ee, "assertOptionalChainStart");
  function J7(...t) {
    function e(...s) {
      for (let i of t)
        i(...s);
    }
    if (n(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  n(J7, "chain");
  var HEe = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), JEe = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), VC = {};
  function YEe(...t) {
    return (e, s = {}) => {
      let i = s.aliases;
      if (!i) {
        var r;
        s.inherits && (i = (r = VC[s.inherits].aliases) == null ? void 0 : r.slice()), i ?? (i = []), s.aliases = i;
      }
      let a = t.filter((o) => !i.includes(o));
      i.unshift(...a), Y7(e, s);
    };
  }
  n(YEe, "defineAliasedType");
  function Y7(t, e = {}) {
    let s = e.inherits && VC[e.inherits] || {}, i = e.fields;
    if (!i && (i = {}, s.fields)) {
      let l = Object.getOwnPropertyNames(s.fields);
      for (let u of l) {
        let c = s.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let r = e.visitor || s.visitor || [], a = e.aliases || s.aliases || [], o = e.builder || s.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (!HEe.has(l))
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (BEe[e.deprecatedAlias] = t);
    for (let l of r.concat(o))
      i[l] = i[l] || {};
    for (let l of Object.keys(i)) {
      let u = i[l];
      u.default !== void 0 && !o.includes(l) && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default != null &&
      (u.validate = $C(Ob(u.default)));
      for (let c of Object.keys(u))
        if (!JEe.has(c))
          throw new Error(`Unknown field key "${c}" on ${t}.${l}`);
    }
    DEe[t] = e.visitor = r, LEe[t] = e.builder = o, _Ee[t] = e.fields = i, OEe[t] = e.aliases = a, a.forEach((l) => {
      KC[l] = KC[l] || [], KC[l].push(t);
    }), e.validate && (MEe[t] = e.validate), VC[t] = e;
  }
  n(Y7, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var $y = g((tn) => {
  "use strict";
  Object.defineProperty(tn, "__esModule", {
    value: !0
  });
  tn.patternLikeCommon = tn.importAttributes = tn.functionTypeAnnotationCommon = tn.functionDeclarationCommon = tn.functionCommon = tn.classMethodOrPropertyCommon =
  tn.classMethodOrDeclareMethodCommon = void 0;
  var fn = Gf(), XEe = Qf(), X7 = Ea(), zEe = Db(), Wy = Zf(), U = Xo(), Me = (0, U.defineAliasedType)("Standardized");
  Me("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, U.arrayOf)((0, U.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  Me("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let t = (0, U.assertOneOf)(...Wy.ASSIGNMENT_OPERATORS), e = (0, U.assertOneOf)("=");
          return function(s, i, r) {
            ((0, fn.default)("Pattern", s.left) ? e : t)(s, i, r);
          };
        }(), {
          type: "string"
        }) : (0, U.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, U.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  Me("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, U.assertOneOf)(...Wy.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, U.assertNodeType)("Expression"), e = (0, U.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, r, a) {
            (i.operator === "in" ? e : t)(i, r, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  Me("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, U.assertValueType)("string")
      }
    }
  });
  Me("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, U.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  Me("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, U.assertValueType)("string")
      }
    }
  });
  Me("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, U.arrayOfType)("Directive"),
        default: []
      },
      body: (0, U.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  Me("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, U.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  Me("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, U.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, U.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, U.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      optional: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, U.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Me("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, U.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  Me("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, U.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, U.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, U.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  Me("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, U.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  Me("DebuggerStatement", {
    aliases: ["Statement"]
  });
  Me("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, U.assertNodeType)("Expression")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  Me("EmptyStatement", {
    aliases: ["Statement"]
  });
  Me("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, U.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  Me("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, U.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertEach)((0, U.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, U.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  Me("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, U.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  Me("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, U.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  var ed = /* @__PURE__ */ n(() => ({
    params: (0, U.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  tn.functionCommon = ed;
  var Gp = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, U.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, U.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  tn.functionTypeAnnotationCommon = Gp;
  var z7 = /* @__PURE__ */ n(() => Object.assign({}, ed(), {
    declare: {
      validate: (0, U.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, U.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  tn.functionDeclarationCommon = z7;
  Me("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, z7(), Gp(), {
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, U.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, U.assertNodeType)("Identifier");
      return function(e, s, i) {
        (0, fn.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  Me("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, ed(), Gp(), {
      id: {
        validate: (0, U.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, U.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var td = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, U.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, U.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, U.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  tn.patternLikeCommon = td;
  Me("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, td(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("string"), Object.assign(function(t, e, s) {
          if (!(0, XEe.default)(s, !1))
            throw new TypeError(`"${s}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, U.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e, s) {
      let i = /\.(\w+)$/.exec(e.toString());
      if (!i) return;
      let [, r] = i, a = {
        computed: !1
      };
      if (r === "property") {
        if ((0, fn.default)("MemberExpression", t, a) || (0, fn.default)("OptionalMemberExpression", t, a)) return;
      } else if (r === "key") {
        if ((0, fn.default)("Property", t, a) || (0, fn.default)("Method", t, a)) return;
      } else if (r === "exported") {
        if ((0, fn.default)("ExportSpecifier", t)) return;
      } else if (r === "imported") {
        if ((0, fn.default)("ImportSpecifier", t, {
          imported: s
        })) return;
      } else if (r === "meta" && (0, fn.default)("MetaProperty", t, {
        meta: s
      }))
        return;
      if (((0, X7.isKeyword)(s.name) || (0, X7.isReservedWord)(s.name, !1)) && s.name !== "this")
        throw new TypeError(`"${s.name}" is not a valid identifier`);
    } : void 0
  });
  Me("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, U.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, U.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  Me("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, U.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  Me("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, U.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Me("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, U.chain)((0, U.assertValueType)("number"), Object.assign(function(t, e, s) {
          if (1 / s < 0 || !Number.isFinite(s)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${s}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Me("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Me("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, U.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Me("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, U.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("string"), Object.assign(function(t, e, s) {
          let i = /[^gimsuy]/.exec(s);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, U.assertValueType)("string"),
        default: ""
      }
    }
  });
  Me("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, U.assertOneOf)(...Wy.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, U.assertNodeType)("Expression")
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, U.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, U.assertNodeType)("Identifier", "PrivateName"), e = (0, U.assertNodeType)("Expression"), s = /* @__PURE__ */ n(function(i, r, a) {
            (i.computed ? e : t)(i, r, a);
          }, "validator");
          return s.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], s;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Me("NewExpression", {
    inherits: "CallExpression"
  });
  Me("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, U.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, U.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, U.arrayOfType)("Directive"),
        default: []
      },
      body: (0, U.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  Me("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, U.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  Me("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, ed(), Gp(), {
      kind: Object.assign({
        validate: (0, U.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, U.assertNodeType)("Expres\
sion"), s = /* @__PURE__ */ n(function(i, r, a) {
            (i.computed ? e : t)(i, r, a);
          }, "validator");
          return s.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], s;
        }()
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  Me("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, U.
          assertNodeType)("Expression");
          return Object.assign(function(i, r, a) {
            (i.computed ? e : t)(i, r, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, U.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("boolean"), Object.assign(function(t, e, s) {
          if (s) {
            if (t.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, fn.default)("Identifier", t.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, U.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, U.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, U.assertNodeType)("Expression");
      return function(s, i, r) {
        ((0, fn.default)("ObjectPattern", s) ? t : e)(r, "value", r.value);
      };
    }() : void 0
  });
  Me("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, td(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, U.assertNodeType)("LVal")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(t, e) {
      let s = /(\w+)\[(\d+)\]/.exec(e.toString());
      if (!s) throw new Error("Internal Babel error: malformed key.");
      let [, i, r] = s;
      if (t[i].length > +r + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    } : void 0
  });
  Me("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Me("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, U.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  Me("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, U.validateArrayOfType)("Statement")
    }
  });
  Me("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, U.assertNodeType)("Expression")
      },
      cases: (0, U.validateArrayOfType)("SwitchCase")
    }
  });
  Me("ThisExpression", {
    aliases: ["Expression"]
  });
  Me("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (!t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, U.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, U.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, U.assertNodeType)("BlockStatement")
      }
    }
  });
  Me("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, U.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, U.assertOneOf)(...Wy.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  Me("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertNodeType)("Identifier", "MemberExpression") : (0, U.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, U.assertOneOf)(...Wy.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  Me("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, U.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, U.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let t = (0, U.assertNodeType)("Identifier");
      return function(e, s, i) {
        if ((0, fn.default)("ForXStatement", e, {
          left: i
        })) {
          if (i.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
        } else
          i.declarations.forEach((r) => {
            r.init || t(r, "id", r.id);
          });
      };
    })() : void 0
  });
  Me("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, U.assertNodeType)(
        "LVal")
      },
      definite: {
        optional: !0,
        validate: (0, U.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, U.assertNodeType)("Expression")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  Me("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, U.assertNodeType)("Expression")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      }
    }
  });
  Me("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, td(), {
      left: {
        validate: (0, U.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  Me("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, td(), {
      elements: {
        validate: (0, U.chain)((0, U.assertValueType)("array"), (0, U.assertEach)((0, U.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  Me("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, ed(), Gp(), {
      expression: {
        validate: (0, U.assertValueType)("boolean")
      },
      body: {
        validate: (0, U.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, U.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  Me("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, U.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  Me("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, U.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, U.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, U.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, U.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, U.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, U.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  Me("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, U.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, U.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, U.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, U.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, U.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, U.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, U.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let t = (0, U.assertNodeType)("Identifier");
      return function(e, s, i) {
        (0, fn.default)("ExportDefaultDeclaration", e) || t(i, "id", i.id);
      };
    }() : void 0
  });
  var HC = tn.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, U.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, U.arrayOfType)("ImportAttribute")
    }
  };
  Me("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, U.assertNodeType)("StringLiteral")
      },
      exportKind: (0, U.validateOptional)((0, U.assertOneOf)("type", "value"))
    }, HC)
  });
  Me("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, U.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, U.validateOptional)((0, U.assertOneOf)("value"))
    }
  });
  Me("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "as\
sertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertNodeType)("Declaration"), Object.assign(function(t, e, s) {
          if (s && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (s && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, U.assertNodeType)("Declaration")
      }
    }, HC, {
      specifiers: {
        default: [],
        validate: (0, U.arrayOf)(function() {
          let t = (0, U.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, U.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(s, i, r) {
            (s.source ? t : e)(s, i, r);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : t;
        }())
      },
      source: {
        validate: (0, U.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, U.validateOptional)((0, U.assertOneOf)("type", "value"))
    })
  });
  Me("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, U.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, U.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, U.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  Me("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, U.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, U.assertNodeType)("VariableDeclaration"), e = (0, U.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(s, i, r) {
            (0, fn.default)("VariableDeclaration", r) ? t(s, i, r) : e(s, i, r);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, U.assertNodeType)("Expression")
      },
      body: {
        validate: (0, U.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  Me("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, HC, {
      module: {
        optional: !0,
        validate: (0, U.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, U.assertOneOf)("source", "defer")
      },
      specifiers: (0, U.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, U.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, U.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  Me("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, U.assertNodeType)("Identifier")
      }
    }
  });
  Me("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, U.assertNodeType)("Identifier")
      }
    }
  });
  Me("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, U.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, U.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, U.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  Me("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, U.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, U.assertNodeType)("Expression")
      },
      options: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Me("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertNodeType)("Identifier"), Object.assign(function(t, e, s) {
          let i;
          switch (s.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, fn.default)("Identifier", t.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, U.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, U.assertNodeType)("Identifier")
      }
    }
  });
  var Bb = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, U.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, U.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, U.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, U.chain)(function() {
        let t = (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, U.assertNodeType)("Expressi\
on");
        return function(s, i, r) {
          (s.computed ? e : t)(s, i, r);
        };
      }(), (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  tn.classMethodOrPropertyCommon = Bb;
  var JC = /* @__PURE__ */ n(() => Object.assign({}, ed(), Bb(), {
    params: (0, U.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
    kind: {
      validate: (0, U.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, U.chain)((0, U.assertValueType)("string"), (0, U.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, U.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  tn.classMethodOrDeclareMethodCommon = JC;
  Me("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, JC(), Gp(), {
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      }
    })
  });
  Me("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, td(), {
      properties: (0, U.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  Me("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("Super", {
    aliases: ["Expression"]
  });
  Me("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, U.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, U.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, U.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  Me("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, U.chain)((0, U.assertShape)({
          raw: {
            validate: (0, U.assertValueType)("string")
          },
          cooked: {
            validate: (0, U.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(e) {
          let s = e.value.raw, i = !1, r = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, zEe.readStringContents)("template", s, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: r,
            invalidEscapeSequence: r,
            numericSeparatorInEscapeSequence: r,
            unexpectedNumericSeparator: r,
            invalidDigit: r,
            invalidCodePoint: r
          });
          if (!i) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  Me("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, U.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, U.chain)((0, U.assertValueType)("array"), (0, U.assertEach)((0, U.assertNodeType)("Expression", "TSType")), function(t, e, s) {
          if (t.quasis.length !== s.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${s.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  Me("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("boolean"), Object.assign(function(t, e, s) {
          if (s && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, U.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, U.assertNodeType)("Expression")
      }
    }
  });
  Me("Import", {
    aliases: ["Expression"]
  });
  Me("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, U.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  Me("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, U.assertNodeType)("Identifier")
      }
    }
  });
  Me("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, U.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, U.assertNodeType)("Identifier"), e = (0, U.assertNodeType)("Expression");
          return Object.assign(function(i, r, a) {
            (i.computed ? e : t)(i, r, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("boolean"), (0, U.assertOptionalChainStart)()) : (0, U.
        assertValueType)("boolean")
      }
    }
  });
  Me("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, U.assertNodeType)("Expression")
      },
      arguments: (0, U.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, U.chain)((0, U.assertValueType)("boolean"), (0, U.assertOptionalChainStart)()) : (0, U.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, U.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, U.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  Me("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, Bb(), {
      value: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, U.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, U.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  Me("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, Bb(), {
      key: {
        validate: (0, U.chain)(function() {
          let t = (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, U.assertNodeType)(
          "Expression");
          return function(s, i, r) {
            (s.computed ? e : t)(s, i, r);
          };
        }(), (0, U.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, U.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, U.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  Me("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, U.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, U.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, U.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, U.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, U.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, U.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, U.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  Me("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, JC(), Gp(), {
      kind: {
        validate: (0, U.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, U.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, U.assertNodeType)("BlockStatement")
      }
    })
  });
  Me("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, U.assertNodeType)("Identifier")
      }
    }
  });
  Me("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, U.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  Me("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, U.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, U.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var Q7 = g(() => {
  "use strict";
  var G7 = $y(), le = Xo(), ft = (0, le.defineAliasedType)("Flow"), YC = /* @__PURE__ */ n((t) => {
    let e = t === "DeclareClass";
    ft(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, le.validateType)("Identifier"),
        typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, le.validateOptional)((0, le.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, le.validateOptional)((0, le.arrayOfType)("InterfaceExtends")),
        implements: (0, le.validateOptional)((0, le.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, le.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  ft("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, le.validateType)("FlowType")
    }
  });
  ft("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  YC("DeclareClass");
  ft("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      predicate: (0, le.validateOptionalType)("DeclaredPredicate")
    }
  });
  YC("DeclareInterface");
  ft("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier", "StringLiteral"),
      body: (0, le.validateType)("BlockStatement"),
      kind: (0, le.validateOptional)((0, le.assertOneOf)("CommonJS", "ES"))
    }
  });
  ft("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, le.validateType)("TypeAnnotation")
    }
  });
  ft("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, le.validateType)("FlowType")
    }
  });
  ft("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, le.validateOptionalType)("FlowType"),
      impltype: (0, le.validateOptionalType)("FlowType")
    }
  });
  ft("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier")
    }
  });
  ft("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, le.validateOptionalType)("Flow"),
      specifiers: (0, le.validateOptional)((0, le.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, le.validateOptionalType)("StringLiteral"),
      default: (0, le.validateOptional)((0, le.assertValueType)("boolean"))
    }, G7.importAttributes)
  });
  ft("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, le.validateType)("StringLiteral"),
      exportKind: (0, le.validateOptional)((0, le.assertOneOf)("type", "value"))
    }, G7.importAttributes)
  });
  ft("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, le.validateType)("Flow")
    }
  });
  ft("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  ft("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, le.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, le.validateOptionalType)("FunctionTypeParam"),
      this: (0, le.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, le.validateType)("FlowType")
    }
  });
  ft("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, le.validateOptionalType)("Identifier"),
      typeAnnotation: (0, le.validateType)("FlowType"),
      optional: (0, le.validateOptional)((0, le.assertValueType)("boolean"))
    }
  });
  ft("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, le.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  ft("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  ft("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, le.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  YC("InterfaceDeclaration");
  ft("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, le.validateOptional)((0, le.arrayOfType)("InterfaceExtends")),
      body: (0, le.validateType)("ObjectTypeAnnotation")
    }
  });
  ft("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, le.validate)((0, le.arrayOfType)("FlowType"))
    }
  });
  ft("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, le.validateType)("FlowType")
    }
  });
  ft("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, le.validate)((0, le.assertValueType)("number"))
    }
  });
  ft("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, le.validate)((0, le.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, le.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, le.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, le.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, le.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, le.validateOptional)((0, le.assertValueType)("boolean"))
    }
  });
  ft("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      value: (0, le.validateType)("FlowType"),
      optional: (0, le.validate)((0, le.assertValueType)("boolean")),
      static: (0, le.validate)((0, le.assertValueType)("boolean")),
      method: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, le.validateType)("FlowType"),
      static: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, le.validateOptionalType)("Identifier"),
      key: (0, le.validateType)("FlowType"),
      value: (0, le.validateType)("FlowType"),
      static: (0, le.validate)((0, le.assertValueType)("boolean")),
      variance: (0, le.validateOptionalType)("Variance")
    }
  });
  ft("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, le.validateType)("Identifier", "StringLiteral"),
      value: (0, le.validateType)("FlowType"),
      kind: (0, le.validate)((0, le.assertOneOf)("init", "get", "set")),
      static: (0, le.validate)((0, le.assertValueType)("boolean")),
      proto: (0, le.validate)((0, le.assertValueType)("boolean")),
      optional: (0, le.validate)((0, le.assertValueType)("boolean")),
      variance: (0, le.validateOptionalType)("Variance"),
      method: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, le.validateType)("FlowType")
    }
  });
  ft("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, le.validateOptionalType)("FlowType"),
      impltype: (0, le.validateType)("FlowType")
    }
  });
  ft("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      qualification: (0, le.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  ft("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, le.validate)((0, le.assertValueType)("string"))
    }
  });
  ft("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, le.validate)((0, le.arrayOfType)("FlowType"))
    }
  });
  ft("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, le.validateType)("FlowType")
    }
  });
  ft("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      typeParameters: (0, le.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, le.validateType)("FlowType")
    }
  });
  ft("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, le.validateType)("FlowType")
    }
  });
  ft("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, le.validateType)("Expression"),
      typeAnnotation: (0, le.validateType)("TypeAnnotation")
    }
  });
  ft("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, le.validate)((0, le.assertValueType)("string")),
      bound: (0, le.validateOptionalType)("TypeAnnotation"),
      default: (0, le.validateOptionalType)("FlowType"),
      variance: (0, le.validateOptionalType)("Variance")
    }
  });
  ft("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, le.validate)((0, le.arrayOfType)("TypeParameter"))
    }
  });
  ft("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, le.validate)((0, le.arrayOfType)("FlowType"))
    }
  });
  ft("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, le.validate)((0, le.arrayOfType)("FlowType"))
    }
  });
  ft("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, le.validate)((0, le.assertOneOf)("minus", "plus"))
    }
  });
  ft("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ft("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      body: (0, le.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  ft("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, le.validate)((0, le.assertValueType)("boolean")),
      members: (0, le.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, le.validate)((0, le.assertValueType)("boolean")),
      members: (0, le.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, le.validate)((0, le.assertValueType)("boolean")),
      members: (0, le.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, le.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
  ft("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      init: (0, le.validateType)("BooleanLiteral")
    }
  });
  ft("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      init: (0, le.validateType)("NumericLiteral")
    }
  });
  ft("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, le.validateType)("Identifier"),
      init: (0, le.validateType)("StringLiteral")
    }
  });
  ft("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, le.validateType)("Identifier")
    }
  });
  ft("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, le.validateType)("FlowType"),
      indexType: (0, le.validateType)("FlowType")
    }
  });
  ft("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, le.validateType)("FlowType"),
      indexType: (0, le.validateType)("FlowType"),
      optional: (0, le.validate)((0, le.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var Z7 = g(() => {
  "use strict";
  var qi = Xo(), dn = (0, qi.defineAliasedType)("JSX");
  dn("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, qi.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, qi.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  dn("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, qi.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  dn("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, qi.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, qi.assertNodeType)("JSXClosingElement")
      },
      children: (0, qi.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, qi.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  dn("JSXEmptyExpression", {});
  dn("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, qi.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  dn("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, qi.assertNodeType)("Expression")
      }
    }
  });
  dn("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, qi.assertValueType)("string")
      }
    }
  });
  dn("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, qi.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, qi.assertNodeType)("JSXIdentifier")
      }
    }
  });
  dn("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, qi.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, qi.assertNodeType)("JSXIdentifier")
      }
    }
  });
  dn("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, qi.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, qi.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, qi.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, qi.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  dn("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, qi.assertNodeType)("Expression")
      }
    }
  });
  dn("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, qi.assertValueType)("string")
      }
    }
  });
  dn("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, qi.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, qi.assertNodeType)("JSXClosingFragment")
      },
      children: (0, qi.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  dn("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  dn("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var GC = g((Sc) => {
  "use strict";
  Object.defineProperty(Sc, "__esModule", {
    value: !0
  });
  Sc.PLACEHOLDERS_FLIPPED_ALIAS = Sc.PLACEHOLDERS_ALIAS = Sc.PLACEHOLDERS = void 0;
  var GEe = Xo(), QEe = Sc.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], zC = Sc.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of QEe) {
    let e = GEe.ALIAS_KEYS[t];
    e != null && e.length && (zC[t] = e);
  }
  var XC = Sc.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(zC).forEach((t) => {
    zC[t].forEach((e) => {
      hasOwnProperty.call(XC, e) || (XC[e] = []), XC[e].push(t);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var eq = g(() => {
  "use strict";
  var Mb = Xo(), ZEe = GC(), e1e = $y(), QC = (0, Mb.defineAliasedType)("Miscellaneous");
  QC("Noop", {
    visitor: []
  });
  QC("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, Mb.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Mb.assertOneOf)(...ZEe.PLACEHOLDERS)
      }
    }, (0, e1e.patternLikeCommon)())
  });
  QC("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Mb.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var tq = g(() => {
  "use strict";
  var Di = Xo();
  (0, Di.default)("ArgumentPlaceholder", {});
  (0, Di.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, Di.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, Di.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, Di.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Di.assertNodeType)("Expression")
      }
    }
  });
  (0, Di.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, Di.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, Di.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, Di.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, Di.assertNodeType)("Identifier")
      }
    }
  });
  (0, Di.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, Di.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, Di.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, Di.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, Di.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Di.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, Di.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, Di.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, Di.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, Di.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Di.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Di.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, Di.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Di.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var uq = g(() => {
  "use strict";
  var Te = Xo(), sq = $y(), t1e = Gf(), Dt = (0, Te.defineAliasedType)("TypeScript"), Zn = (0, Te.assertValueType)("boolean"), iq = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, Te.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, Te.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  Dt("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, Te.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, Te.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, Te.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, Te.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, Te.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  Dt("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, sq.functionDeclarationCommon)(), iq())
  });
  Dt("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, sq.classMethodOrDeclareMethodCommon)(), iq())
  });
  Dt("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, Te.validateType)("TSEntityName"),
      right: (0, Te.validateType)("Identifier")
    }
  });
  var Fb = /* @__PURE__ */ n(() => ({
    typeParameters: (0, Te.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, Te.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, Te.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), rq = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Fb()
  };
  Dt("TSCallSignatureDeclaration", rq);
  Dt("TSConstructSignatureDeclaration", rq);
  var nq = /* @__PURE__ */ n(() => ({
    key: (0, Te.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, Te.validateOptional)(Zn)
  }), "namedTypeElementCommon");
  Dt("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, nq(), {
      readonly: (0, Te.validateOptional)(Zn),
      typeAnnotation: (0, Te.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, Te.assertOneOf)("get", "set")
      }
    })
  });
  Dt("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Fb(), nq(), {
      kind: {
        validate: (0, Te.assertOneOf)("method", "get", "set")
      }
    })
  });
  Dt("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, Te.validateOptional)(Zn),
      static: (0, Te.validateOptional)(Zn),
      parameters: (0, Te.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, Te.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var s1e = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of s1e)
    Dt(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  Dt("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var aq = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  Dt("TSFunctionType", Object.assign({}, aq, {
    fields: Fb()
  }));
  Dt("TSConstructorType", Object.assign({}, aq, {
    fields: Object.assign({}, Fb(), {
      abstract: (0, Te.validateOptional)(Zn)
    })
  }));
  Dt("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, Te.validateType)("TSEntityName"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Dt("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, Te.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, Te.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, Te.validateOptional)(Zn)
    }
  });
  Dt("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, Te.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Dt("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, Te.validateArrayOfType)("TSTypeElement")
    }
  });
  Dt("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, Te.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  Dt("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, Te.validateType)("Identifier"),
      optional: {
        validate: Zn,
        default: !1
      },
      elementType: (0, Te.validateType)("TSType")
    }
  });
  var oq = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, Te.validateArrayOfType)("TSType")
    }
  };
  Dt("TSUnionType", oq);
  Dt("TSIntersectionType", oq);
  Dt("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, Te.validateType)("TSType"),
      extendsType: (0, Te.validateType)("TSType"),
      trueType: (0, Te.validateType)("TSType"),
      falseType: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, Te.validateType)("TSTypeParameter")
    }
  });
  Dt("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, Te.validate)((0, Te.assertValueType)("string")),
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, Te.validateType)("TSType"),
      indexType: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, Te.validateType)("TSTypeParameter")
    }, {
      readonly: (0, Te.validateOptional)((0, Te.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, Te.validateOptional)((0, Te.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, Te.validateOptionalType)("TSType"),
      nameType: (0, Te.validateOptionalType)("TSType")
    })
  });
  Dt("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, Te.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, Te.chain)((0, Te.assertValueType)("array"), (0, Te.assertEach)((0, Te.assertNodeType)("TSType")), function(t, e, s) {
          if (t.quasis.length !== s.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of types.
Expected ${s.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  Dt("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, Te.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, Te.assertOneOf)("-"), s = (0, Te.assertNodeType)("Numer\
icLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function i(r, a, o) {
            (0, t1e.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : s(r, a, o);
          }
          return n(i, "validator"), i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], i;
        }()
      }
    }
  });
  Dt("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, Te.validateType)("TSEntityName"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Dt("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, Te.validateOptional)(Zn),
      id: (0, Te.validateType)("Identifier"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, Te.validateOptional)((0, Te.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, Te.validateType)("TSInterfaceBody")
    }
  });
  Dt("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, Te.validateArrayOfType)("TSTypeElement")
    }
  });
  Dt("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, Te.validateOptional)(Zn),
      id: (0, Te.validateType)("Identifier"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  });
  Dt("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, Te.validateType)("Expression"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var lq = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, Te.validateType)("Expression"),
      typeAnnotation: (0, Te.validateType)("TSType")
    }
  };
  Dt("TSAsExpression", lq);
  Dt("TSSatisfiesExpression", lq);
  Dt("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, Te.validateType)("TSType"),
      expression: (0, Te.validateType)("Expression")
    }
  });
  Dt("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, Te.validateArrayOfType)("TSEnumMember")
    }
  });
  Dt("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, Te.validateOptional)(Zn),
      const: (0, Te.validateOptional)(Zn),
      id: (0, Te.validateType)("Identifier"),
      members: (0, Te.validateArrayOfType)("TSEnumMember"),
      initializer: (0, Te.validateOptionalType)("Expression"),
      body: (0, Te.validateOptionalType)("TSEnumBody")
    }
  });
  Dt("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, Te.validateType)("Identifier", "StringLiteral"),
      initializer: (0, Te.validateOptionalType)("Expression")
    }
  });
  Dt("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, Te.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, Te.validateOptional)(Zn)
    }, {
      global: (0, Te.validateOptional)(Zn)
    }, {
      id: (0, Te.validateType)("Identifier", "StringLiteral"),
      body: (0, Te.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  Dt("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, Te.validateArrayOfType)("Statement")
    }
  });
  Dt("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, Te.validateType)("StringLiteral"),
      qualifier: (0, Te.validateOptionalType)("TSEntityName"),
      typeParameters: (0, Te.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, Te.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Dt("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, Te.validate)(Zn)
    }, {
      id: (0, Te.validateType)("Identifier"),
      moduleReference: (0, Te.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, Te.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  Dt("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, Te.validateType)("StringLiteral")
    }
  });
  Dt("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, Te.validateType)("Expression")
    }
  });
  Dt("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, Te.validateType)("Expression")
    }
  });
  Dt("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, Te.validateType)("Identifier")
    }
  });
  Dt("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, Te.assertNodeType)("TSType")
      }
    }
  });
  Dt("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, Te.validateArrayOfType)("TSType")
    }
  });
  Dt("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, Te.validateArrayOfType)("TSTypeParameter")
    }
  });
  Dt("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, Te.assertValueType)("string")
      },
      in: {
        validate: (0, Te.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, Te.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, Te.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, Te.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, Te.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var cq = g((jb) => {
  "use strict";
  Object.defineProperty(jb, "__esModule", {
    value: !0
  });
  jb.DEPRECATED_ALIASES = void 0;
  var Z4s = jb.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Pa = g((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  Object.defineProperty(mn, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(mn, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(mn, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ZC.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(mn, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(mn, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(mn, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(mn, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(mn, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ew.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(mn, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ew.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(mn, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ew.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  mn.TYPES = void 0;
  Object.defineProperty(mn, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ea.VISITOR_KEYS;
    }, "get")
  });
  $y();
  Q7();
  Z7();
  eq();
  tq();
  uq();
  var ea = Xo(), ew = GC(), ZC = cq();
  Object.keys(ZC.DEPRECATED_ALIASES).forEach((t) => {
    ea.FLIPPED_ALIAS_KEYS[t] = ea.FLIPPED_ALIAS_KEYS[ZC.DEPRECATED_ALIASES[t]];
  });
  for (let {
    types: t,
    set: e
  } of ea.allExpandedTypes)
    for (let s of t) {
      let i = ea.FLIPPED_ALIAS_KEYS[s];
      i ? i.forEach(e.add, e) : e.add(s);
    }
  var tjs = mn.TYPES = [].concat(Object.keys(ea.VISITOR_KEYS), Object.keys(ea.FLIPPED_ALIAS_KEYS), Object.keys(ea.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Lb = g((sd) => {
  "use strict";
  Object.defineProperty(sd, "__esModule", {
    value: !0
  });
  sd.default = i1e;
  sd.validateChild = hq;
  sd.validateField = pq;
  sd.validateInternal = r1e;
  var Hy = Pa();
  function i1e(t, e, s) {
    if (!t) return;
    let i = Hy.NODE_FIELDS[t.type];
    if (!i) return;
    let r = i[e];
    pq(t, e, s, r), hq(t, e, s);
  }
  n(i1e, "validate");
  function r1e(t, e, s, i, r) {
    if (t != null && t.validate && !(t.optional && i == null) && (t.validate(e, s, i), r)) {
      var a;
      let o = i.type;
      if (o == null) return;
      (a = Hy.NODE_PARENT_VALIDATIONS[o]) == null || a.call(Hy.NODE_PARENT_VALIDATIONS, e, s, i);
    }
  }
  n(r1e, "validateInternal");
  function pq(t, e, s, i) {
    i != null && i.validate && (i.optional && s == null || i.validate(t, e, s));
  }
  n(pq, "validateField");
  function hq(t, e, s) {
    var i;
    let r = s?.type;
    r != null && ((i = Hy.NODE_PARENT_VALIDATIONS[r]) == null || i.call(Hy.NODE_PARENT_VALIDATIONS, t, e, s));
  }
  n(hq, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var tw = g((A) => {
  "use strict";
  Object.defineProperty(A, "__esModule", {
    value: !0
  });
  A.anyTypeAnnotation = jAe;
  A.argumentPlaceholder = fCe;
  A.arrayExpression = o1e;
  A.arrayPattern = sAe;
  A.arrayTypeAnnotation = RAe;
  A.arrowFunctionExpression = iAe;
  A.assignmentExpression = l1e;
  A.assignmentPattern = tAe;
  A.awaitExpression = vAe;
  A.bigIntLiteral = wAe;
  A.binaryExpression = u1e;
  A.bindExpression = dCe;
  A.blockStatement = f1e;
  A.booleanLiteral = _1e;
  A.booleanLiteralTypeAnnotation = UAe;
  A.booleanTypeAnnotation = qAe;
  A.breakStatement = d1e;
  A.callExpression = m1e;
  A.catchClause = y1e;
  A.classAccessorProperty = OAe;
  A.classBody = rAe;
  A.classDeclaration = aAe;
  A.classExpression = nAe;
  A.classImplements = VAe;
  A.classMethod = TAe;
  A.classPrivateMethod = LAe;
  A.classPrivateProperty = _Ae;
  A.classProperty = DAe;
  A.conditionalExpression = g1e;
  A.continueStatement = T1e;
  A.debuggerStatement = b1e;
  A.decimalLiteral = xCe;
  A.declareClass = WAe;
  A.declareExportAllDeclaration = ZAe;
  A.declareExportDeclaration = QAe;
  A.declareFunction = $Ae;
  A.declareInterface = HAe;
  A.declareModule = JAe;
  A.declareModuleExports = YAe;
  A.declareOpaqueType = zAe;
  A.declareTypeAlias = XAe;
  A.declareVariable = GAe;
  A.declaredPredicate = eve;
  A.decorator = mCe;
  A.directive = p1e;
  A.directiveLiteral = h1e;
  A.doExpression = yCe;
  A.doWhileStatement = x1e;
  A.emptyStatement = S1e;
  A.emptyTypeAnnotation = pve;
  A.enumBooleanBody = Rve;
  A.enumBooleanMember = Vve;
  A.enumDeclaration = jve;
  A.enumDefaultedMember = Hve;
  A.enumNumberBody = qve;
  A.enumNumberMember = Wve;
  A.enumStringBody = Uve;
  A.enumStringMember = $ve;
  A.enumSymbolBody = Kve;
  A.existsTypeAnnotation = tve;
  A.exportAllDeclaration = oAe;
  A.exportDefaultDeclaration = lAe;
  A.exportDefaultSpecifier = gCe;
  A.exportNamedDeclaration = uAe;
  A.exportNamespaceSpecifier = IAe;
  A.exportSpecifier = cAe;
  A.expressionStatement = P1e;
  A.file = E1e;
  A.forInStatement = A1e;
  A.forOfStatement = pAe;
  A.forStatement = v1e;
  A.functionDeclaration = C1e;
  A.functionExpression = w1e;
  A.functionTypeAnnotation = sve;
  A.functionTypeParam = ive;
  A.genericTypeAnnotation = rve;
  A.identifier = I1e;
  A.ifStatement = N1e;
  A.import = CAe;
  A.importAttribute = FAe;
  A.importDeclaration = hAe;
  A.importDefaultSpecifier = fAe;
  A.importExpression = yAe;
  A.importNamespaceSpecifier = dAe;
  A.importSpecifier = mAe;
  A.indexedAccessType = Jve;
  A.inferredPredicate = nve;
  A.interfaceDeclaration = ove;
  A.interfaceExtends = ave;
  A.interfaceTypeAnnotation = lve;
  A.interpreterDirective = c1e;
  A.intersectionTypeAnnotation = uve;
  A.jSXAttribute = A.jsxAttribute = Xve;
  A.jSXClosingElement = A.jsxClosingElement = zve;
  A.jSXClosingFragment = A.jsxClosingFragment = uCe;
  A.jSXElement = A.jsxElement = Gve;
  A.jSXEmptyExpression = A.jsxEmptyExpression = Qve;
  A.jSXExpressionContainer = A.jsxExpressionContainer = Zve;
  A.jSXFragment = A.jsxFragment = oCe;
  A.jSXIdentifier = A.jsxIdentifier = tCe;
  A.jSXMemberExpression = A.jsxMemberExpression = sCe;
  A.jSXNamespacedName = A.jsxNamespacedName = iCe;
  A.jSXOpeningElement = A.jsxOpeningElement = rCe;
  A.jSXOpeningFragment = A.jsxOpeningFragment = lCe;
  A.jSXSpreadAttribute = A.jsxSpreadAttribute = nCe;
  A.jSXSpreadChild = A.jsxSpreadChild = eCe;
  A.jSXText = A.jsxText = aCe;
  A.labeledStatement = k1e;
  A.logicalExpression = L1e;
  A.memberExpression = B1e;
  A.metaProperty = gAe;
  A.mixedTypeAnnotation = cve;
  A.moduleExpression = SCe;
  A.newExpression = M1e;
  A.noop = cCe;
  A.nullLiteral = O1e;
  A.nullLiteralTypeAnnotation = KAe;
  A.nullableTypeAnnotation = hve;
  A.numberLiteral = Rwe;
  A.numberLiteralTypeAnnotation = fve;
  A.numberTypeAnnotation = dve;
  A.numericLiteral = fq;
  A.objectExpression = j1e;
  A.objectMethod = R1e;
  A.objectPattern = bAe;
  A.objectProperty = q1e;
  A.objectTypeAnnotation = mve;
  A.objectTypeCallProperty = gve;
  A.objectTypeIndexer = Tve;
  A.objectTypeInternalSlot = yve;
  A.objectTypeProperty = bve;
  A.objectTypeSpreadProperty = xve;
  A.opaqueType = Sve;
  A.optionalCallExpression = kAe;
  A.optionalIndexedAccessType = Yve;
  A.optionalMemberExpression = NAe;
  A.parenthesizedExpression = V1e;
  A.pipelineBareFunction = ACe;
  A.pipelinePrimaryTopicReference = vCe;
  A.pipelineTopicExpression = ECe;
  A.placeholder = pCe;
  A.privateName = BAe;
  A.program = F1e;
  A.qualifiedTypeIdentifier = Pve;
  A.recordExpression = TCe;
  A.regExpLiteral = dq;
  A.regexLiteral = qwe;
  A.restElement = mq;
  A.restProperty = Uwe;
  A.returnStatement = U1e;
  A.sequenceExpression = K1e;
  A.spreadElement = yq;
  A.spreadProperty = Kwe;
  A.staticBlock = MAe;
  A.stringLiteral = D1e;
  A.stringLiteralTypeAnnotation = Eve;
  A.stringTypeAnnotation = Ave;
  A.super = xAe;
  A.switchCase = W1e;
  A.switchStatement = $1e;
  A.symbolTypeAnnotation = vve;
  A.taggedTemplateExpression = SAe;
  A.templateElement = PAe;
  A.templateLiteral = EAe;
  A.thisExpression = H1e;
  A.thisTypeAnnotation = Cve;
  A.throwStatement = J1e;
  A.topicReference = PCe;
  A.tryStatement = Y1e;
  A.tSAnyKeyword = A.tsAnyKeyword = BCe;
  A.tSArrayType = A.tsArrayType = twe;
  A.tSAsExpression = A.tsAsExpression = Swe;
  A.tSBigIntKeyword = A.tsBigIntKeyword = FCe;
  A.tSBooleanKeyword = A.tsBooleanKeyword = MCe;
  A.tSCallSignatureDeclaration = A.tsCallSignatureDeclaration = kCe;
  A.tSConditionalType = A.tsConditionalType = lwe;
  A.tSConstructSignatureDeclaration = A.tsConstructSignatureDeclaration = DCe;
  A.tSConstructorType = A.tsConstructorType = zCe;
  A.tSDeclareFunction = A.tsDeclareFunction = wCe;
  A.tSDeclareMethod = A.tsDeclareMethod = ICe;
  A.tSEnumBody = A.tsEnumBody = Awe;
  A.tSEnumDeclaration = A.tsEnumDeclaration = vwe;
  A.tSEnumMember = A.tsEnumMember = Cwe;
  A.tSExportAssignment = A.tsExportAssignment = _we;
  A.tSExpressionWithTypeArguments = A.tsExpressionWithTypeArguments = ywe;
  A.tSExternalModuleReference = A.tsExternalModuleReference = Dwe;
  A.tSFunctionType = A.tsFunctionType = XCe;
  A.tSImportEqualsDeclaration = A.tsImportEqualsDeclaration = kwe;
  A.tSImportType = A.tsImportType = Nwe;
  A.tSIndexSignature = A.tsIndexSignature = LCe;
  A.tSIndexedAccessType = A.tsIndexedAccessType = hwe;
  A.tSInferType = A.tsInferType = uwe;
  A.tSInstantiationExpression = A.tsInstantiationExpression = xwe;
  A.tSInterfaceBody = A.tsInterfaceBody = Twe;
  A.tSInterfaceDeclaration = A.tsInterfaceDeclaration = gwe;
  A.tSIntersectionType = A.tsIntersectionType = owe;
  A.tSIntrinsicKeyword = A.tsIntrinsicKeyword = jCe;
  A.tSLiteralType = A.tsLiteralType = mwe;
  A.tSMappedType = A.tsMappedType = fwe;
  A.tSMethodSignature = A.tsMethodSignature = _Ce;
  A.tSModuleBlock = A.tsModuleBlock = Iwe;
  A.tSModuleDeclaration = A.tsModuleDeclaration = wwe;
  A.tSNamedTupleMember = A.tsNamedTupleMember = nwe;
  A.tSNamespaceExportDeclaration = A.tsNamespaceExportDeclaration = Lwe;
  A.tSNeverKeyword = A.tsNeverKeyword = RCe;
  A.tSNonNullExpression = A.tsNonNullExpression = Owe;
  A.tSNullKeyword = A.tsNullKeyword = qCe;
  A.tSNumberKeyword = A.tsNumberKeyword = UCe;
  A.tSObjectKeyword = A.tsObjectKeyword = KCe;
  A.tSOptionalType = A.tsOptionalType = iwe;
  A.tSParameterProperty = A.tsParameterProperty = CCe;
  A.tSParenthesizedType = A.tsParenthesizedType = cwe;
  A.tSPropertySignature = A.tsPropertySignature = OCe;
  A.tSQualifiedName = A.tsQualifiedName = NCe;
  A.tSRestType = A.tsRestType = rwe;
  A.tSSatisfiesExpression = A.tsSatisfiesExpression = Pwe;
  A.tSStringKeyword = A.tsStringKeyword = VCe;
  A.tSSymbolKeyword = A.tsSymbolKeyword = WCe;
  A.tSTemplateLiteralType = A.tsTemplateLiteralType = dwe;
  A.tSThisType = A.tsThisType = YCe;
  A.tSTupleType = A.tsTupleType = swe;
  A.tSTypeAliasDeclaration = A.tsTypeAliasDeclaration = bwe;
  A.tSTypeAnnotation = A.tsTypeAnnotation = Bwe;
  A.tSTypeAssertion = A.tsTypeAssertion = Ewe;
  A.tSTypeLiteral = A.tsTypeLiteral = ewe;
  A.tSTypeOperator = A.tsTypeOperator = pwe;
  A.tSTypeParameter = A.tsTypeParameter = jwe;
  A.tSTypeParameterDeclaration = A.tsTypeParameterDeclaration = Fwe;
  A.tSTypeParameterInstantiation = A.tsTypeParameterInstantiation = Mwe;
  A.tSTypePredicate = A.tsTypePredicate = QCe;
  A.tSTypeQuery = A.tsTypeQuery = ZCe;
  A.tSTypeReference = A.tsTypeReference = GCe;
  A.tSUndefinedKeyword = A.tsUndefinedKeyword = $Ce;
  A.tSUnionType = A.tsUnionType = awe;
  A.tSUnknownKeyword = A.tsUnknownKeyword = HCe;
  A.tSVoidKeyword = A.tsVoidKeyword = JCe;
  A.tupleExpression = bCe;
  A.tupleTypeAnnotation = wve;
  A.typeAlias = Nve;
  A.typeAnnotation = kve;
  A.typeCastExpression = Dve;
  A.typeParameter = Ove;
  A.typeParameterDeclaration = _ve;
  A.typeParameterInstantiation = Lve;
  A.typeofTypeAnnotation = Ive;
  A.unaryExpression = X1e;
  A.unionTypeAnnotation = Bve;
  A.updateExpression = z1e;
  A.v8IntrinsicIdentifier = hCe;
  A.variableDeclaration = G1e;
  A.variableDeclarator = Q1e;
  A.variance = Mve;
  A.voidTypeAnnotation = Fve;
  A.whileStatement = Z1e;
  A.withStatement = eAe;
  A.yieldExpression = AAe;
  var n1e = Lb(), Rb = Fy(), a1e = Xo(), {
    validateInternal: x
  } = n1e, {
    NODE_FIELDS: ie
  } = a1e;
  function o1e(t = []) {
    let e = {
      type: "ArrayExpression",
      elements: t
    }, s = ie.ArrayExpression;
    return x(s.elements, e, "elements", t, 1), e;
  }
  n(o1e, "arrayExpression");
  function l1e(t, e, s) {
    let i = {
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: s
    }, r = ie.AssignmentExpression;
    return x(r.operator, i, "operator", t), x(r.left, i, "left", e, 1), x(r.right, i, "right", s, 1), i;
  }
  n(l1e, "assignmentExpression");
  function u1e(t, e, s) {
    let i = {
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: s
    }, r = ie.BinaryExpression;
    return x(r.operator, i, "operator", t), x(r.left, i, "left", e, 1), x(r.right, i, "right", s, 1), i;
  }
  n(u1e, "binaryExpression");
  function c1e(t) {
    let e = {
      type: "InterpreterDirective",
      value: t
    }, s = ie.InterpreterDirective;
    return x(s.value, e, "value", t), e;
  }
  n(c1e, "interpreterDirective");
  function p1e(t) {
    let e = {
      type: "Directive",
      value: t
    }, s = ie.Directive;
    return x(s.value, e, "value", t, 1), e;
  }
  n(p1e, "directive");
  function h1e(t) {
    let e = {
      type: "DirectiveLiteral",
      value: t
    }, s = ie.DirectiveLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(h1e, "directiveLiteral");
  function f1e(t, e = []) {
    let s = {
      type: "BlockStatement",
      body: t,
      directives: e
    }, i = ie.BlockStatement;
    return x(i.body, s, "body", t, 1), x(i.directives, s, "directives", e, 1), s;
  }
  n(f1e, "blockStatement");
  function d1e(t = null) {
    let e = {
      type: "BreakStatement",
      label: t
    }, s = ie.BreakStatement;
    return x(s.label, e, "label", t, 1), e;
  }
  n(d1e, "breakStatement");
  function m1e(t, e) {
    let s = {
      type: "CallExpression",
      callee: t,
      arguments: e
    }, i = ie.CallExpression;
    return x(i.callee, s, "callee", t, 1), x(i.arguments, s, "arguments", e, 1), s;
  }
  n(m1e, "callExpression");
  function y1e(t = null, e) {
    let s = {
      type: "CatchClause",
      param: t,
      body: e
    }, i = ie.CatchClause;
    return x(i.param, s, "param", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(y1e, "catchClause");
  function g1e(t, e, s) {
    let i = {
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: s
    }, r = ie.ConditionalExpression;
    return x(r.test, i, "test", t, 1), x(r.consequent, i, "consequent", e, 1), x(r.alternate, i, "alternate", s, 1), i;
  }
  n(g1e, "conditionalExpression");
  function T1e(t = null) {
    let e = {
      type: "ContinueStatement",
      label: t
    }, s = ie.ContinueStatement;
    return x(s.label, e, "label", t, 1), e;
  }
  n(T1e, "continueStatement");
  function b1e() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(b1e, "debuggerStatement");
  function x1e(t, e) {
    let s = {
      type: "DoWhileStatement",
      test: t,
      body: e
    }, i = ie.DoWhileStatement;
    return x(i.test, s, "test", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(x1e, "doWhileStatement");
  function S1e() {
    return {
      type: "EmptyStatement"
    };
  }
  n(S1e, "emptyStatement");
  function P1e(t) {
    let e = {
      type: "ExpressionStatement",
      expression: t
    }, s = ie.ExpressionStatement;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(P1e, "expressionStatement");
  function E1e(t, e = null, s = null) {
    let i = {
      type: "File",
      program: t,
      comments: e,
      tokens: s
    }, r = ie.File;
    return x(r.program, i, "program", t, 1), x(r.comments, i, "comments", e, 1), x(r.tokens, i, "tokens", s), i;
  }
  n(E1e, "file");
  function A1e(t, e, s) {
    let i = {
      type: "ForInStatement",
      left: t,
      right: e,
      body: s
    }, r = ie.ForInStatement;
    return x(r.left, i, "left", t, 1), x(r.right, i, "right", e, 1), x(r.body, i, "body", s, 1), i;
  }
  n(A1e, "forInStatement");
  function v1e(t = null, e = null, s = null, i) {
    let r = {
      type: "ForStatement",
      init: t,
      test: e,
      update: s,
      body: i
    }, a = ie.ForStatement;
    return x(a.init, r, "init", t, 1), x(a.test, r, "test", e, 1), x(a.update, r, "update", s, 1), x(a.body, r, "body", i, 1), r;
  }
  n(v1e, "forStatement");
  function C1e(t = null, e, s, i = !1, r = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: s,
      generator: i,
      async: r
    }, o = ie.FunctionDeclaration;
    return x(o.id, a, "id", t, 1), x(o.params, a, "params", e, 1), x(o.body, a, "body", s, 1), x(o.generator, a, "generator", i), x(o.async,
    a, "async", r), a;
  }
  n(C1e, "functionDeclaration");
  function w1e(t = null, e, s, i = !1, r = !1) {
    let a = {
      type: "FunctionExpression",
      id: t,
      params: e,
      body: s,
      generator: i,
      async: r
    }, o = ie.FunctionExpression;
    return x(o.id, a, "id", t, 1), x(o.params, a, "params", e, 1), x(o.body, a, "body", s, 1), x(o.generator, a, "generator", i), x(o.async,
    a, "async", r), a;
  }
  n(w1e, "functionExpression");
  function I1e(t) {
    let e = {
      type: "Identifier",
      name: t
    }, s = ie.Identifier;
    return x(s.name, e, "name", t), e;
  }
  n(I1e, "identifier");
  function N1e(t, e, s = null) {
    let i = {
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: s
    }, r = ie.IfStatement;
    return x(r.test, i, "test", t, 1), x(r.consequent, i, "consequent", e, 1), x(r.alternate, i, "alternate", s, 1), i;
  }
  n(N1e, "ifStatement");
  function k1e(t, e) {
    let s = {
      type: "LabeledStatement",
      label: t,
      body: e
    }, i = ie.LabeledStatement;
    return x(i.label, s, "label", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(k1e, "labeledStatement");
  function D1e(t) {
    let e = {
      type: "StringLiteral",
      value: t
    }, s = ie.StringLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(D1e, "stringLiteral");
  function fq(t) {
    let e = {
      type: "NumericLiteral",
      value: t
    }, s = ie.NumericLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(fq, "numericLiteral");
  function O1e() {
    return {
      type: "NullLiteral"
    };
  }
  n(O1e, "nullLiteral");
  function _1e(t) {
    let e = {
      type: "BooleanLiteral",
      value: t
    }, s = ie.BooleanLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(_1e, "booleanLiteral");
  function dq(t, e = "") {
    let s = {
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    }, i = ie.RegExpLiteral;
    return x(i.pattern, s, "pattern", t), x(i.flags, s, "flags", e), s;
  }
  n(dq, "regExpLiteral");
  function L1e(t, e, s) {
    let i = {
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: s
    }, r = ie.LogicalExpression;
    return x(r.operator, i, "operator", t), x(r.left, i, "left", e, 1), x(r.right, i, "right", s, 1), i;
  }
  n(L1e, "logicalExpression");
  function B1e(t, e, s = !1, i = null) {
    let r = {
      type: "MemberExpression",
      object: t,
      property: e,
      computed: s,
      optional: i
    }, a = ie.MemberExpression;
    return x(a.object, r, "object", t, 1), x(a.property, r, "property", e, 1), x(a.computed, r, "computed", s), x(a.optional, r, "optional",
    i), r;
  }
  n(B1e, "memberExpression");
  function M1e(t, e) {
    let s = {
      type: "NewExpression",
      callee: t,
      arguments: e
    }, i = ie.NewExpression;
    return x(i.callee, s, "callee", t, 1), x(i.arguments, s, "arguments", e, 1), s;
  }
  n(M1e, "newExpression");
  function F1e(t, e = [], s = "script", i = null) {
    let r = {
      type: "Program",
      body: t,
      directives: e,
      sourceType: s,
      interpreter: i
    }, a = ie.Program;
    return x(a.body, r, "body", t, 1), x(a.directives, r, "directives", e, 1), x(a.sourceType, r, "sourceType", s), x(a.interpreter, r, "int\
erpreter", i, 1), r;
  }
  n(F1e, "program");
  function j1e(t) {
    let e = {
      type: "ObjectExpression",
      properties: t
    }, s = ie.ObjectExpression;
    return x(s.properties, e, "properties", t, 1), e;
  }
  n(j1e, "objectExpression");
  function R1e(t = "method", e, s, i, r = !1, a = !1, o = !1) {
    let l = {
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: s,
      body: i,
      computed: r,
      generator: a,
      async: o
    }, u = ie.ObjectMethod;
    return x(u.kind, l, "kind", t), x(u.key, l, "key", e, 1), x(u.params, l, "params", s, 1), x(u.body, l, "body", i, 1), x(u.computed, l, "\
computed", r), x(u.generator, l, "generator", a), x(u.async, l, "async", o), l;
  }
  n(R1e, "objectMethod");
  function q1e(t, e, s = !1, i = !1, r = null) {
    let a = {
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: s,
      shorthand: i,
      decorators: r
    }, o = ie.ObjectProperty;
    return x(o.key, a, "key", t, 1), x(o.value, a, "value", e, 1), x(o.computed, a, "computed", s), x(o.shorthand, a, "shorthand", i), x(o.decorators,
    a, "decorators", r, 1), a;
  }
  n(q1e, "objectProperty");
  function mq(t) {
    let e = {
      type: "RestElement",
      argument: t
    }, s = ie.RestElement;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(mq, "restElement");
  function U1e(t = null) {
    let e = {
      type: "ReturnStatement",
      argument: t
    }, s = ie.ReturnStatement;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(U1e, "returnStatement");
  function K1e(t) {
    let e = {
      type: "SequenceExpression",
      expressions: t
    }, s = ie.SequenceExpression;
    return x(s.expressions, e, "expressions", t, 1), e;
  }
  n(K1e, "sequenceExpression");
  function V1e(t) {
    let e = {
      type: "ParenthesizedExpression",
      expression: t
    }, s = ie.ParenthesizedExpression;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(V1e, "parenthesizedExpression");
  function W1e(t = null, e) {
    let s = {
      type: "SwitchCase",
      test: t,
      consequent: e
    }, i = ie.SwitchCase;
    return x(i.test, s, "test", t, 1), x(i.consequent, s, "consequent", e, 1), s;
  }
  n(W1e, "switchCase");
  function $1e(t, e) {
    let s = {
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    }, i = ie.SwitchStatement;
    return x(i.discriminant, s, "discriminant", t, 1), x(i.cases, s, "cases", e, 1), s;
  }
  n($1e, "switchStatement");
  function H1e() {
    return {
      type: "ThisExpression"
    };
  }
  n(H1e, "thisExpression");
  function J1e(t) {
    let e = {
      type: "ThrowStatement",
      argument: t
    }, s = ie.ThrowStatement;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(J1e, "throwStatement");
  function Y1e(t, e = null, s = null) {
    let i = {
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: s
    }, r = ie.TryStatement;
    return x(r.block, i, "block", t, 1), x(r.handler, i, "handler", e, 1), x(r.finalizer, i, "finalizer", s, 1), i;
  }
  n(Y1e, "tryStatement");
  function X1e(t, e, s = !0) {
    let i = {
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: s
    }, r = ie.UnaryExpression;
    return x(r.operator, i, "operator", t), x(r.argument, i, "argument", e, 1), x(r.prefix, i, "prefix", s), i;
  }
  n(X1e, "unaryExpression");
  function z1e(t, e, s = !1) {
    let i = {
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: s
    }, r = ie.UpdateExpression;
    return x(r.operator, i, "operator", t), x(r.argument, i, "argument", e, 1), x(r.prefix, i, "prefix", s), i;
  }
  n(z1e, "updateExpression");
  function G1e(t, e) {
    let s = {
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    }, i = ie.VariableDeclaration;
    return x(i.kind, s, "kind", t), x(i.declarations, s, "declarations", e, 1), s;
  }
  n(G1e, "variableDeclaration");
  function Q1e(t, e = null) {
    let s = {
      type: "VariableDeclarator",
      id: t,
      init: e
    }, i = ie.VariableDeclarator;
    return x(i.id, s, "id", t, 1), x(i.init, s, "init", e, 1), s;
  }
  n(Q1e, "variableDeclarator");
  function Z1e(t, e) {
    let s = {
      type: "WhileStatement",
      test: t,
      body: e
    }, i = ie.WhileStatement;
    return x(i.test, s, "test", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(Z1e, "whileStatement");
  function eAe(t, e) {
    let s = {
      type: "WithStatement",
      object: t,
      body: e
    }, i = ie.WithStatement;
    return x(i.object, s, "object", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(eAe, "withStatement");
  function tAe(t, e) {
    let s = {
      type: "AssignmentPattern",
      left: t,
      right: e
    }, i = ie.AssignmentPattern;
    return x(i.left, s, "left", t, 1), x(i.right, s, "right", e, 1), s;
  }
  n(tAe, "assignmentPattern");
  function sAe(t) {
    let e = {
      type: "ArrayPattern",
      elements: t
    }, s = ie.ArrayPattern;
    return x(s.elements, e, "elements", t, 1), e;
  }
  n(sAe, "arrayPattern");
  function iAe(t, e, s = !1) {
    let i = {
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: s,
      expression: null
    }, r = ie.ArrowFunctionExpression;
    return x(r.params, i, "params", t, 1), x(r.body, i, "body", e, 1), x(r.async, i, "async", s), i;
  }
  n(iAe, "arrowFunctionExpression");
  function rAe(t) {
    let e = {
      type: "ClassBody",
      body: t
    }, s = ie.ClassBody;
    return x(s.body, e, "body", t, 1), e;
  }
  n(rAe, "classBody");
  function nAe(t = null, e = null, s, i = null) {
    let r = {
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: s,
      decorators: i
    }, a = ie.ClassExpression;
    return x(a.id, r, "id", t, 1), x(a.superClass, r, "superClass", e, 1), x(a.body, r, "body", s, 1), x(a.decorators, r, "decorators", i, 1),
    r;
  }
  n(nAe, "classExpression");
  function aAe(t = null, e = null, s, i = null) {
    let r = {
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: s,
      decorators: i
    }, a = ie.ClassDeclaration;
    return x(a.id, r, "id", t, 1), x(a.superClass, r, "superClass", e, 1), x(a.body, r, "body", s, 1), x(a.decorators, r, "decorators", i, 1),
    r;
  }
  n(aAe, "classDeclaration");
  function oAe(t) {
    let e = {
      type: "ExportAllDeclaration",
      source: t
    }, s = ie.ExportAllDeclaration;
    return x(s.source, e, "source", t, 1), e;
  }
  n(oAe, "exportAllDeclaration");
  function lAe(t) {
    let e = {
      type: "ExportDefaultDeclaration",
      declaration: t
    }, s = ie.ExportDefaultDeclaration;
    return x(s.declaration, e, "declaration", t, 1), e;
  }
  n(lAe, "exportDefaultDeclaration");
  function uAe(t = null, e = [], s = null) {
    let i = {
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: s
    }, r = ie.ExportNamedDeclaration;
    return x(r.declaration, i, "declaration", t, 1), x(r.specifiers, i, "specifiers", e, 1), x(r.source, i, "source", s, 1), i;
  }
  n(uAe, "exportNamedDeclaration");
  function cAe(t, e) {
    let s = {
      type: "ExportSpecifier",
      local: t,
      exported: e
    }, i = ie.ExportSpecifier;
    return x(i.local, s, "local", t, 1), x(i.exported, s, "exported", e, 1), s;
  }
  n(cAe, "exportSpecifier");
  function pAe(t, e, s, i = !1) {
    let r = {
      type: "ForOfStatement",
      left: t,
      right: e,
      body: s,
      await: i
    }, a = ie.ForOfStatement;
    return x(a.left, r, "left", t, 1), x(a.right, r, "right", e, 1), x(a.body, r, "body", s, 1), x(a.await, r, "await", i), r;
  }
  n(pAe, "forOfStatement");
  function hAe(t, e) {
    let s = {
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    }, i = ie.ImportDeclaration;
    return x(i.specifiers, s, "specifiers", t, 1), x(i.source, s, "source", e, 1), s;
  }
  n(hAe, "importDeclaration");
  function fAe(t) {
    let e = {
      type: "ImportDefaultSpecifier",
      local: t
    }, s = ie.ImportDefaultSpecifier;
    return x(s.local, e, "local", t, 1), e;
  }
  n(fAe, "importDefaultSpecifier");
  function dAe(t) {
    let e = {
      type: "ImportNamespaceSpecifier",
      local: t
    }, s = ie.ImportNamespaceSpecifier;
    return x(s.local, e, "local", t, 1), e;
  }
  n(dAe, "importNamespaceSpecifier");
  function mAe(t, e) {
    let s = {
      type: "ImportSpecifier",
      local: t,
      imported: e
    }, i = ie.ImportSpecifier;
    return x(i.local, s, "local", t, 1), x(i.imported, s, "imported", e, 1), s;
  }
  n(mAe, "importSpecifier");
  function yAe(t, e = null) {
    let s = {
      type: "ImportExpression",
      source: t,
      options: e
    }, i = ie.ImportExpression;
    return x(i.source, s, "source", t, 1), x(i.options, s, "options", e, 1), s;
  }
  n(yAe, "importExpression");
  function gAe(t, e) {
    let s = {
      type: "MetaProperty",
      meta: t,
      property: e
    }, i = ie.MetaProperty;
    return x(i.meta, s, "meta", t, 1), x(i.property, s, "property", e, 1), s;
  }
  n(gAe, "metaProperty");
  function TAe(t = "method", e, s, i, r = !1, a = !1, o = !1, l = !1) {
    let u = {
      type: "ClassMethod",
      kind: t,
      key: e,
      params: s,
      body: i,
      computed: r,
      static: a,
      generator: o,
      async: l
    }, c = ie.ClassMethod;
    return x(c.kind, u, "kind", t), x(c.key, u, "key", e, 1), x(c.params, u, "params", s, 1), x(c.body, u, "body", i, 1), x(c.computed, u, "\
computed", r), x(c.static, u, "static", a), x(c.generator, u, "generator", o), x(c.async, u, "async", l), u;
  }
  n(TAe, "classMethod");
  function bAe(t) {
    let e = {
      type: "ObjectPattern",
      properties: t
    }, s = ie.ObjectPattern;
    return x(s.properties, e, "properties", t, 1), e;
  }
  n(bAe, "objectPattern");
  function yq(t) {
    let e = {
      type: "SpreadElement",
      argument: t
    }, s = ie.SpreadElement;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(yq, "spreadElement");
  function xAe() {
    return {
      type: "Super"
    };
  }
  n(xAe, "_super");
  function SAe(t, e) {
    let s = {
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    }, i = ie.TaggedTemplateExpression;
    return x(i.tag, s, "tag", t, 1), x(i.quasi, s, "quasi", e, 1), s;
  }
  n(SAe, "taggedTemplateExpression");
  function PAe(t, e = !1) {
    let s = {
      type: "TemplateElement",
      value: t,
      tail: e
    }, i = ie.TemplateElement;
    return x(i.value, s, "value", t), x(i.tail, s, "tail", e), s;
  }
  n(PAe, "templateElement");
  function EAe(t, e) {
    let s = {
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    }, i = ie.TemplateLiteral;
    return x(i.quasis, s, "quasis", t, 1), x(i.expressions, s, "expressions", e, 1), s;
  }
  n(EAe, "templateLiteral");
  function AAe(t = null, e = !1) {
    let s = {
      type: "YieldExpression",
      argument: t,
      delegate: e
    }, i = ie.YieldExpression;
    return x(i.argument, s, "argument", t, 1), x(i.delegate, s, "delegate", e), s;
  }
  n(AAe, "yieldExpression");
  function vAe(t) {
    let e = {
      type: "AwaitExpression",
      argument: t
    }, s = ie.AwaitExpression;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(vAe, "awaitExpression");
  function CAe() {
    return {
      type: "Import"
    };
  }
  n(CAe, "_import");
  function wAe(t) {
    let e = {
      type: "BigIntLiteral",
      value: t
    }, s = ie.BigIntLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(wAe, "bigIntLiteral");
  function IAe(t) {
    let e = {
      type: "ExportNamespaceSpecifier",
      exported: t
    }, s = ie.ExportNamespaceSpecifier;
    return x(s.exported, e, "exported", t, 1), e;
  }
  n(IAe, "exportNamespaceSpecifier");
  function NAe(t, e, s = !1, i) {
    let r = {
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: s,
      optional: i
    }, a = ie.OptionalMemberExpression;
    return x(a.object, r, "object", t, 1), x(a.property, r, "property", e, 1), x(a.computed, r, "computed", s), x(a.optional, r, "optional",
    i), r;
  }
  n(NAe, "optionalMemberExpression");
  function kAe(t, e, s) {
    let i = {
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: s
    }, r = ie.OptionalCallExpression;
    return x(r.callee, i, "callee", t, 1), x(r.arguments, i, "arguments", e, 1), x(r.optional, i, "optional", s), i;
  }
  n(kAe, "optionalCallExpression");
  function DAe(t, e = null, s = null, i = null, r = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: s,
      decorators: i,
      computed: r,
      static: a
    }, l = ie.ClassProperty;
    return x(l.key, o, "key", t, 1), x(l.value, o, "value", e, 1), x(l.typeAnnotation, o, "typeAnnotation", s, 1), x(l.decorators, o, "decor\
ators", i, 1), x(l.computed, o, "computed", r), x(l.static, o, "static", a), o;
  }
  n(DAe, "classProperty");
  function OAe(t, e = null, s = null, i = null, r = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: s,
      decorators: i,
      computed: r,
      static: a
    }, l = ie.ClassAccessorProperty;
    return x(l.key, o, "key", t, 1), x(l.value, o, "value", e, 1), x(l.typeAnnotation, o, "typeAnnotation", s, 1), x(l.decorators, o, "decor\
ators", i, 1), x(l.computed, o, "computed", r), x(l.static, o, "static", a), o;
  }
  n(OAe, "classAccessorProperty");
  function _Ae(t, e = null, s = null, i = !1) {
    let r = {
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: s,
      static: i
    }, a = ie.ClassPrivateProperty;
    return x(a.key, r, "key", t, 1), x(a.value, r, "value", e, 1), x(a.decorators, r, "decorators", s, 1), x(a.static, r, "static", i), r;
  }
  n(_Ae, "classPrivateProperty");
  function LAe(t = "method", e, s, i, r = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: s,
      body: i,
      static: r
    }, o = ie.ClassPrivateMethod;
    return x(o.kind, a, "kind", t), x(o.key, a, "key", e, 1), x(o.params, a, "params", s, 1), x(o.body, a, "body", i, 1), x(o.static, a, "st\
atic", r), a;
  }
  n(LAe, "classPrivateMethod");
  function BAe(t) {
    let e = {
      type: "PrivateName",
      id: t
    }, s = ie.PrivateName;
    return x(s.id, e, "id", t, 1), e;
  }
  n(BAe, "privateName");
  function MAe(t) {
    let e = {
      type: "StaticBlock",
      body: t
    }, s = ie.StaticBlock;
    return x(s.body, e, "body", t, 1), e;
  }
  n(MAe, "staticBlock");
  function FAe(t, e) {
    let s = {
      type: "ImportAttribute",
      key: t,
      value: e
    }, i = ie.ImportAttribute;
    return x(i.key, s, "key", t, 1), x(i.value, s, "value", e, 1), s;
  }
  n(FAe, "importAttribute");
  function jAe() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(jAe, "anyTypeAnnotation");
  function RAe(t) {
    let e = {
      type: "ArrayTypeAnnotation",
      elementType: t
    }, s = ie.ArrayTypeAnnotation;
    return x(s.elementType, e, "elementType", t, 1), e;
  }
  n(RAe, "arrayTypeAnnotation");
  function qAe() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(qAe, "booleanTypeAnnotation");
  function UAe(t) {
    let e = {
      type: "BooleanLiteralTypeAnnotation",
      value: t
    }, s = ie.BooleanLiteralTypeAnnotation;
    return x(s.value, e, "value", t), e;
  }
  n(UAe, "booleanLiteralTypeAnnotation");
  function KAe() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(KAe, "nullLiteralTypeAnnotation");
  function VAe(t, e = null) {
    let s = {
      type: "ClassImplements",
      id: t,
      typeParameters: e
    }, i = ie.ClassImplements;
    return x(i.id, s, "id", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(VAe, "classImplements");
  function WAe(t, e = null, s = null, i) {
    let r = {
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: s,
      body: i
    }, a = ie.DeclareClass;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.extends, r, "extends", s, 1), x(a.body, r, "body", i,
    1), r;
  }
  n(WAe, "declareClass");
  function $Ae(t) {
    let e = {
      type: "DeclareFunction",
      id: t
    }, s = ie.DeclareFunction;
    return x(s.id, e, "id", t, 1), e;
  }
  n($Ae, "declareFunction");
  function HAe(t, e = null, s = null, i) {
    let r = {
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: s,
      body: i
    }, a = ie.DeclareInterface;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.extends, r, "extends", s, 1), x(a.body, r, "body", i,
    1), r;
  }
  n(HAe, "declareInterface");
  function JAe(t, e, s = null) {
    let i = {
      type: "DeclareModule",
      id: t,
      body: e,
      kind: s
    }, r = ie.DeclareModule;
    return x(r.id, i, "id", t, 1), x(r.body, i, "body", e, 1), x(r.kind, i, "kind", s), i;
  }
  n(JAe, "declareModule");
  function YAe(t) {
    let e = {
      type: "DeclareModuleExports",
      typeAnnotation: t
    }, s = ie.DeclareModuleExports;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(YAe, "declareModuleExports");
  function XAe(t, e = null, s) {
    let i = {
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: s
    }, r = ie.DeclareTypeAlias;
    return x(r.id, i, "id", t, 1), x(r.typeParameters, i, "typeParameters", e, 1), x(r.right, i, "right", s, 1), i;
  }
  n(XAe, "declareTypeAlias");
  function zAe(t, e = null, s = null) {
    let i = {
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: s
    }, r = ie.DeclareOpaqueType;
    return x(r.id, i, "id", t, 1), x(r.typeParameters, i, "typeParameters", e, 1), x(r.supertype, i, "supertype", s, 1), i;
  }
  n(zAe, "declareOpaqueType");
  function GAe(t) {
    let e = {
      type: "DeclareVariable",
      id: t
    }, s = ie.DeclareVariable;
    return x(s.id, e, "id", t, 1), e;
  }
  n(GAe, "declareVariable");
  function QAe(t = null, e = null, s = null, i = null) {
    let r = {
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: s,
      attributes: i
    }, a = ie.DeclareExportDeclaration;
    return x(a.declaration, r, "declaration", t, 1), x(a.specifiers, r, "specifiers", e, 1), x(a.source, r, "source", s, 1), x(a.attributes,
    r, "attributes", i, 1), r;
  }
  n(QAe, "declareExportDeclaration");
  function ZAe(t, e = null) {
    let s = {
      type: "DeclareExportAllDeclaration",
      source: t,
      attributes: e
    }, i = ie.DeclareExportAllDeclaration;
    return x(i.source, s, "source", t, 1), x(i.attributes, s, "attributes", e, 1), s;
  }
  n(ZAe, "declareExportAllDeclaration");
  function eve(t) {
    let e = {
      type: "DeclaredPredicate",
      value: t
    }, s = ie.DeclaredPredicate;
    return x(s.value, e, "value", t, 1), e;
  }
  n(eve, "declaredPredicate");
  function tve() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(tve, "existsTypeAnnotation");
  function sve(t = null, e, s = null, i) {
    let r = {
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: s,
      returnType: i
    }, a = ie.FunctionTypeAnnotation;
    return x(a.typeParameters, r, "typeParameters", t, 1), x(a.params, r, "params", e, 1), x(a.rest, r, "rest", s, 1), x(a.returnType, r, "r\
eturnType", i, 1), r;
  }
  n(sve, "functionTypeAnnotation");
  function ive(t = null, e) {
    let s = {
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    }, i = ie.FunctionTypeParam;
    return x(i.name, s, "name", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(ive, "functionTypeParam");
  function rve(t, e = null) {
    let s = {
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    }, i = ie.GenericTypeAnnotation;
    return x(i.id, s, "id", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(rve, "genericTypeAnnotation");
  function nve() {
    return {
      type: "InferredPredicate"
    };
  }
  n(nve, "inferredPredicate");
  function ave(t, e = null) {
    let s = {
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    }, i = ie.InterfaceExtends;
    return x(i.id, s, "id", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(ave, "interfaceExtends");
  function ove(t, e = null, s = null, i) {
    let r = {
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: s,
      body: i
    }, a = ie.InterfaceDeclaration;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.extends, r, "extends", s, 1), x(a.body, r, "body", i,
    1), r;
  }
  n(ove, "interfaceDeclaration");
  function lve(t = null, e) {
    let s = {
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    }, i = ie.InterfaceTypeAnnotation;
    return x(i.extends, s, "extends", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(lve, "interfaceTypeAnnotation");
  function uve(t) {
    let e = {
      type: "IntersectionTypeAnnotation",
      types: t
    }, s = ie.IntersectionTypeAnnotation;
    return x(s.types, e, "types", t, 1), e;
  }
  n(uve, "intersectionTypeAnnotation");
  function cve() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(cve, "mixedTypeAnnotation");
  function pve() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(pve, "emptyTypeAnnotation");
  function hve(t) {
    let e = {
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    }, s = ie.NullableTypeAnnotation;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(hve, "nullableTypeAnnotation");
  function fve(t) {
    let e = {
      type: "NumberLiteralTypeAnnotation",
      value: t
    }, s = ie.NumberLiteralTypeAnnotation;
    return x(s.value, e, "value", t), e;
  }
  n(fve, "numberLiteralTypeAnnotation");
  function dve() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(dve, "numberTypeAnnotation");
  function mve(t, e = [], s = [], i = [], r = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: s,
      internalSlots: i,
      exact: r
    }, o = ie.ObjectTypeAnnotation;
    return x(o.properties, a, "properties", t, 1), x(o.indexers, a, "indexers", e, 1), x(o.callProperties, a, "callProperties", s, 1), x(o.internalSlots,
    a, "internalSlots", i, 1), x(o.exact, a, "exact", r), a;
  }
  n(mve, "objectTypeAnnotation");
  function yve(t, e, s, i, r) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: s,
      static: i,
      method: r
    }, o = ie.ObjectTypeInternalSlot;
    return x(o.id, a, "id", t, 1), x(o.value, a, "value", e, 1), x(o.optional, a, "optional", s), x(o.static, a, "static", i), x(o.method, a,
    "method", r), a;
  }
  n(yve, "objectTypeInternalSlot");
  function gve(t) {
    let e = {
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    }, s = ie.ObjectTypeCallProperty;
    return x(s.value, e, "value", t, 1), e;
  }
  n(gve, "objectTypeCallProperty");
  function Tve(t = null, e, s, i = null) {
    let r = {
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: s,
      variance: i,
      static: null
    }, a = ie.ObjectTypeIndexer;
    return x(a.id, r, "id", t, 1), x(a.key, r, "key", e, 1), x(a.value, r, "value", s, 1), x(a.variance, r, "variance", i, 1), r;
  }
  n(Tve, "objectTypeIndexer");
  function bve(t, e, s = null) {
    let i = {
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: s,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, r = ie.ObjectTypeProperty;
    return x(r.key, i, "key", t, 1), x(r.value, i, "value", e, 1), x(r.variance, i, "variance", s, 1), i;
  }
  n(bve, "objectTypeProperty");
  function xve(t) {
    let e = {
      type: "ObjectTypeSpreadProperty",
      argument: t
    }, s = ie.ObjectTypeSpreadProperty;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(xve, "objectTypeSpreadProperty");
  function Sve(t, e = null, s = null, i) {
    let r = {
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: s,
      impltype: i
    }, a = ie.OpaqueType;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.supertype, r, "supertype", s, 1), x(a.impltype, r, "i\
mpltype", i, 1), r;
  }
  n(Sve, "opaqueType");
  function Pve(t, e) {
    let s = {
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    }, i = ie.QualifiedTypeIdentifier;
    return x(i.id, s, "id", t, 1), x(i.qualification, s, "qualification", e, 1), s;
  }
  n(Pve, "qualifiedTypeIdentifier");
  function Eve(t) {
    let e = {
      type: "StringLiteralTypeAnnotation",
      value: t
    }, s = ie.StringLiteralTypeAnnotation;
    return x(s.value, e, "value", t), e;
  }
  n(Eve, "stringLiteralTypeAnnotation");
  function Ave() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(Ave, "stringTypeAnnotation");
  function vve() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(vve, "symbolTypeAnnotation");
  function Cve() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(Cve, "thisTypeAnnotation");
  function wve(t) {
    let e = {
      type: "TupleTypeAnnotation",
      types: t
    }, s = ie.TupleTypeAnnotation;
    return x(s.types, e, "types", t, 1), e;
  }
  n(wve, "tupleTypeAnnotation");
  function Ive(t) {
    let e = {
      type: "TypeofTypeAnnotation",
      argument: t
    }, s = ie.TypeofTypeAnnotation;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(Ive, "typeofTypeAnnotation");
  function Nve(t, e = null, s) {
    let i = {
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: s
    }, r = ie.TypeAlias;
    return x(r.id, i, "id", t, 1), x(r.typeParameters, i, "typeParameters", e, 1), x(r.right, i, "right", s, 1), i;
  }
  n(Nve, "typeAlias");
  function kve(t) {
    let e = {
      type: "TypeAnnotation",
      typeAnnotation: t
    }, s = ie.TypeAnnotation;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(kve, "typeAnnotation");
  function Dve(t, e) {
    let s = {
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    }, i = ie.TypeCastExpression;
    return x(i.expression, s, "expression", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(Dve, "typeCastExpression");
  function Ove(t = null, e = null, s = null) {
    let i = {
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: s,
      name: null
    }, r = ie.TypeParameter;
    return x(r.bound, i, "bound", t, 1), x(r.default, i, "default", e, 1), x(r.variance, i, "variance", s, 1), i;
  }
  n(Ove, "typeParameter");
  function _ve(t) {
    let e = {
      type: "TypeParameterDeclaration",
      params: t
    }, s = ie.TypeParameterDeclaration;
    return x(s.params, e, "params", t, 1), e;
  }
  n(_ve, "typeParameterDeclaration");
  function Lve(t) {
    let e = {
      type: "TypeParameterInstantiation",
      params: t
    }, s = ie.TypeParameterInstantiation;
    return x(s.params, e, "params", t, 1), e;
  }
  n(Lve, "typeParameterInstantiation");
  function Bve(t) {
    let e = {
      type: "UnionTypeAnnotation",
      types: t
    }, s = ie.UnionTypeAnnotation;
    return x(s.types, e, "types", t, 1), e;
  }
  n(Bve, "unionTypeAnnotation");
  function Mve(t) {
    let e = {
      type: "Variance",
      kind: t
    }, s = ie.Variance;
    return x(s.kind, e, "kind", t), e;
  }
  n(Mve, "variance");
  function Fve() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(Fve, "voidTypeAnnotation");
  function jve(t, e) {
    let s = {
      type: "EnumDeclaration",
      id: t,
      body: e
    }, i = ie.EnumDeclaration;
    return x(i.id, s, "id", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(jve, "enumDeclaration");
  function Rve(t) {
    let e = {
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, s = ie.EnumBooleanBody;
    return x(s.members, e, "members", t, 1), e;
  }
  n(Rve, "enumBooleanBody");
  function qve(t) {
    let e = {
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, s = ie.EnumNumberBody;
    return x(s.members, e, "members", t, 1), e;
  }
  n(qve, "enumNumberBody");
  function Uve(t) {
    let e = {
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    }, s = ie.EnumStringBody;
    return x(s.members, e, "members", t, 1), e;
  }
  n(Uve, "enumStringBody");
  function Kve(t) {
    let e = {
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    }, s = ie.EnumSymbolBody;
    return x(s.members, e, "members", t, 1), e;
  }
  n(Kve, "enumSymbolBody");
  function Vve(t) {
    let e = {
      type: "EnumBooleanMember",
      id: t,
      init: null
    }, s = ie.EnumBooleanMember;
    return x(s.id, e, "id", t, 1), e;
  }
  n(Vve, "enumBooleanMember");
  function Wve(t, e) {
    let s = {
      type: "EnumNumberMember",
      id: t,
      init: e
    }, i = ie.EnumNumberMember;
    return x(i.id, s, "id", t, 1), x(i.init, s, "init", e, 1), s;
  }
  n(Wve, "enumNumberMember");
  function $ve(t, e) {
    let s = {
      type: "EnumStringMember",
      id: t,
      init: e
    }, i = ie.EnumStringMember;
    return x(i.id, s, "id", t, 1), x(i.init, s, "init", e, 1), s;
  }
  n($ve, "enumStringMember");
  function Hve(t) {
    let e = {
      type: "EnumDefaultedMember",
      id: t
    }, s = ie.EnumDefaultedMember;
    return x(s.id, e, "id", t, 1), e;
  }
  n(Hve, "enumDefaultedMember");
  function Jve(t, e) {
    let s = {
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    }, i = ie.IndexedAccessType;
    return x(i.objectType, s, "objectType", t, 1), x(i.indexType, s, "indexType", e, 1), s;
  }
  n(Jve, "indexedAccessType");
  function Yve(t, e) {
    let s = {
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    }, i = ie.OptionalIndexedAccessType;
    return x(i.objectType, s, "objectType", t, 1), x(i.indexType, s, "indexType", e, 1), s;
  }
  n(Yve, "optionalIndexedAccessType");
  function Xve(t, e = null) {
    let s = {
      type: "JSXAttribute",
      name: t,
      value: e
    }, i = ie.JSXAttribute;
    return x(i.name, s, "name", t, 1), x(i.value, s, "value", e, 1), s;
  }
  n(Xve, "jsxAttribute");
  function zve(t) {
    let e = {
      type: "JSXClosingElement",
      name: t
    }, s = ie.JSXClosingElement;
    return x(s.name, e, "name", t, 1), e;
  }
  n(zve, "jsxClosingElement");
  function Gve(t, e = null, s, i = null) {
    let r = {
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: s,
      selfClosing: i
    }, a = ie.JSXElement;
    return x(a.openingElement, r, "openingElement", t, 1), x(a.closingElement, r, "closingElement", e, 1), x(a.children, r, "children", s, 1),
    x(a.selfClosing, r, "selfClosing", i), r;
  }
  n(Gve, "jsxElement");
  function Qve() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(Qve, "jsxEmptyExpression");
  function Zve(t) {
    let e = {
      type: "JSXExpressionContainer",
      expression: t
    }, s = ie.JSXExpressionContainer;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(Zve, "jsxExpressionContainer");
  function eCe(t) {
    let e = {
      type: "JSXSpreadChild",
      expression: t
    }, s = ie.JSXSpreadChild;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(eCe, "jsxSpreadChild");
  function tCe(t) {
    let e = {
      type: "JSXIdentifier",
      name: t
    }, s = ie.JSXIdentifier;
    return x(s.name, e, "name", t), e;
  }
  n(tCe, "jsxIdentifier");
  function sCe(t, e) {
    let s = {
      type: "JSXMemberExpression",
      object: t,
      property: e
    }, i = ie.JSXMemberExpression;
    return x(i.object, s, "object", t, 1), x(i.property, s, "property", e, 1), s;
  }
  n(sCe, "jsxMemberExpression");
  function iCe(t, e) {
    let s = {
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    }, i = ie.JSXNamespacedName;
    return x(i.namespace, s, "namespace", t, 1), x(i.name, s, "name", e, 1), s;
  }
  n(iCe, "jsxNamespacedName");
  function rCe(t, e, s = !1) {
    let i = {
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: s
    }, r = ie.JSXOpeningElement;
    return x(r.name, i, "name", t, 1), x(r.attributes, i, "attributes", e, 1), x(r.selfClosing, i, "selfClosing", s), i;
  }
  n(rCe, "jsxOpeningElement");
  function nCe(t) {
    let e = {
      type: "JSXSpreadAttribute",
      argument: t
    }, s = ie.JSXSpreadAttribute;
    return x(s.argument, e, "argument", t, 1), e;
  }
  n(nCe, "jsxSpreadAttribute");
  function aCe(t) {
    let e = {
      type: "JSXText",
      value: t
    }, s = ie.JSXText;
    return x(s.value, e, "value", t), e;
  }
  n(aCe, "jsxText");
  function oCe(t, e, s) {
    let i = {
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: s
    }, r = ie.JSXFragment;
    return x(r.openingFragment, i, "openingFragment", t, 1), x(r.closingFragment, i, "closingFragment", e, 1), x(r.children, i, "children", s,
    1), i;
  }
  n(oCe, "jsxFragment");
  function lCe() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n(lCe, "jsxOpeningFragment");
  function uCe() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(uCe, "jsxClosingFragment");
  function cCe() {
    return {
      type: "Noop"
    };
  }
  n(cCe, "noop");
  function pCe(t, e) {
    let s = {
      type: "Placeholder",
      expectedNode: t,
      name: e
    }, i = ie.Placeholder;
    return x(i.expectedNode, s, "expectedNode", t), x(i.name, s, "name", e, 1), s;
  }
  n(pCe, "placeholder");
  function hCe(t) {
    let e = {
      type: "V8IntrinsicIdentifier",
      name: t
    }, s = ie.V8IntrinsicIdentifier;
    return x(s.name, e, "name", t), e;
  }
  n(hCe, "v8IntrinsicIdentifier");
  function fCe() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(fCe, "argumentPlaceholder");
  function dCe(t, e) {
    let s = {
      type: "BindExpression",
      object: t,
      callee: e
    }, i = ie.BindExpression;
    return x(i.object, s, "object", t, 1), x(i.callee, s, "callee", e, 1), s;
  }
  n(dCe, "bindExpression");
  function mCe(t) {
    let e = {
      type: "Decorator",
      expression: t
    }, s = ie.Decorator;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(mCe, "decorator");
  function yCe(t, e = !1) {
    let s = {
      type: "DoExpression",
      body: t,
      async: e
    }, i = ie.DoExpression;
    return x(i.body, s, "body", t, 1), x(i.async, s, "async", e), s;
  }
  n(yCe, "doExpression");
  function gCe(t) {
    let e = {
      type: "ExportDefaultSpecifier",
      exported: t
    }, s = ie.ExportDefaultSpecifier;
    return x(s.exported, e, "exported", t, 1), e;
  }
  n(gCe, "exportDefaultSpecifier");
  function TCe(t) {
    let e = {
      type: "RecordExpression",
      properties: t
    }, s = ie.RecordExpression;
    return x(s.properties, e, "properties", t, 1), e;
  }
  n(TCe, "recordExpression");
  function bCe(t = []) {
    let e = {
      type: "TupleExpression",
      elements: t
    }, s = ie.TupleExpression;
    return x(s.elements, e, "elements", t, 1), e;
  }
  n(bCe, "tupleExpression");
  function xCe(t) {
    let e = {
      type: "DecimalLiteral",
      value: t
    }, s = ie.DecimalLiteral;
    return x(s.value, e, "value", t), e;
  }
  n(xCe, "decimalLiteral");
  function SCe(t) {
    let e = {
      type: "ModuleExpression",
      body: t
    }, s = ie.ModuleExpression;
    return x(s.body, e, "body", t, 1), e;
  }
  n(SCe, "moduleExpression");
  function PCe() {
    return {
      type: "TopicReference"
    };
  }
  n(PCe, "topicReference");
  function ECe(t) {
    let e = {
      type: "PipelineTopicExpression",
      expression: t
    }, s = ie.PipelineTopicExpression;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(ECe, "pipelineTopicExpression");
  function ACe(t) {
    let e = {
      type: "PipelineBareFunction",
      callee: t
    }, s = ie.PipelineBareFunction;
    return x(s.callee, e, "callee", t, 1), e;
  }
  n(ACe, "pipelineBareFunction");
  function vCe() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(vCe, "pipelinePrimaryTopicReference");
  function CCe(t) {
    let e = {
      type: "TSParameterProperty",
      parameter: t
    }, s = ie.TSParameterProperty;
    return x(s.parameter, e, "parameter", t, 1), e;
  }
  n(CCe, "tsParameterProperty");
  function wCe(t = null, e = null, s, i = null) {
    let r = {
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: s,
      returnType: i
    }, a = ie.TSDeclareFunction;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.params, r, "params", s, 1), x(a.returnType, r, "retur\
nType", i, 1), r;
  }
  n(wCe, "tsDeclareFunction");
  function ICe(t = null, e, s = null, i, r = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: s,
      params: i,
      returnType: r
    }, o = ie.TSDeclareMethod;
    return x(o.decorators, a, "decorators", t, 1), x(o.key, a, "key", e, 1), x(o.typeParameters, a, "typeParameters", s, 1), x(o.params, a, "\
params", i, 1), x(o.returnType, a, "returnType", r, 1), a;
  }
  n(ICe, "tsDeclareMethod");
  function NCe(t, e) {
    let s = {
      type: "TSQualifiedName",
      left: t,
      right: e
    }, i = ie.TSQualifiedName;
    return x(i.left, s, "left", t, 1), x(i.right, s, "right", e, 1), s;
  }
  n(NCe, "tsQualifiedName");
  function kCe(t = null, e, s = null) {
    let i = {
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: s
    }, r = ie.TSCallSignatureDeclaration;
    return x(r.typeParameters, i, "typeParameters", t, 1), x(r.parameters, i, "parameters", e, 1), x(r.typeAnnotation, i, "typeAnnotation", s,
    1), i;
  }
  n(kCe, "tsCallSignatureDeclaration");
  function DCe(t = null, e, s = null) {
    let i = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: s
    }, r = ie.TSConstructSignatureDeclaration;
    return x(r.typeParameters, i, "typeParameters", t, 1), x(r.parameters, i, "parameters", e, 1), x(r.typeAnnotation, i, "typeAnnotation", s,
    1), i;
  }
  n(DCe, "tsConstructSignatureDeclaration");
  function OCe(t, e = null) {
    let s = {
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e
    }, i = ie.TSPropertySignature;
    return x(i.key, s, "key", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(OCe, "tsPropertySignature");
  function _Ce(t, e = null, s, i = null) {
    let r = {
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: s,
      typeAnnotation: i,
      kind: null
    }, a = ie.TSMethodSignature;
    return x(a.key, r, "key", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.parameters, r, "parameters", s, 1), x(a.typeAnnotation,
    r, "typeAnnotation", i, 1), r;
  }
  n(_Ce, "tsMethodSignature");
  function LCe(t, e = null) {
    let s = {
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    }, i = ie.TSIndexSignature;
    return x(i.parameters, s, "parameters", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(LCe, "tsIndexSignature");
  function BCe() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(BCe, "tsAnyKeyword");
  function MCe() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(MCe, "tsBooleanKeyword");
  function FCe() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(FCe, "tsBigIntKeyword");
  function jCe() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(jCe, "tsIntrinsicKeyword");
  function RCe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(RCe, "tsNeverKeyword");
  function qCe() {
    return {
      type: "TSNullKeyword"
    };
  }
  n(qCe, "tsNullKeyword");
  function UCe() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(UCe, "tsNumberKeyword");
  function KCe() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n(KCe, "tsObjectKeyword");
  function VCe() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(VCe, "tsStringKeyword");
  function WCe() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(WCe, "tsSymbolKeyword");
  function $Ce() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n($Ce, "tsUndefinedKeyword");
  function HCe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(HCe, "tsUnknownKeyword");
  function JCe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(JCe, "tsVoidKeyword");
  function YCe() {
    return {
      type: "TSThisType"
    };
  }
  n(YCe, "tsThisType");
  function XCe(t = null, e, s = null) {
    let i = {
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: s
    }, r = ie.TSFunctionType;
    return x(r.typeParameters, i, "typeParameters", t, 1), x(r.parameters, i, "parameters", e, 1), x(r.typeAnnotation, i, "typeAnnotation", s,
    1), i;
  }
  n(XCe, "tsFunctionType");
  function zCe(t = null, e, s = null) {
    let i = {
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: s
    }, r = ie.TSConstructorType;
    return x(r.typeParameters, i, "typeParameters", t, 1), x(r.parameters, i, "parameters", e, 1), x(r.typeAnnotation, i, "typeAnnotation", s,
    1), i;
  }
  n(zCe, "tsConstructorType");
  function GCe(t, e = null) {
    let s = {
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    }, i = ie.TSTypeReference;
    return x(i.typeName, s, "typeName", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(GCe, "tsTypeReference");
  function QCe(t, e = null, s = null) {
    let i = {
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: s
    }, r = ie.TSTypePredicate;
    return x(r.parameterName, i, "parameterName", t, 1), x(r.typeAnnotation, i, "typeAnnotation", e, 1), x(r.asserts, i, "asserts", s), i;
  }
  n(QCe, "tsTypePredicate");
  function ZCe(t, e = null) {
    let s = {
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    }, i = ie.TSTypeQuery;
    return x(i.exprName, s, "exprName", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(ZCe, "tsTypeQuery");
  function ewe(t) {
    let e = {
      type: "TSTypeLiteral",
      members: t
    }, s = ie.TSTypeLiteral;
    return x(s.members, e, "members", t, 1), e;
  }
  n(ewe, "tsTypeLiteral");
  function twe(t) {
    let e = {
      type: "TSArrayType",
      elementType: t
    }, s = ie.TSArrayType;
    return x(s.elementType, e, "elementType", t, 1), e;
  }
  n(twe, "tsArrayType");
  function swe(t) {
    let e = {
      type: "TSTupleType",
      elementTypes: t
    }, s = ie.TSTupleType;
    return x(s.elementTypes, e, "elementTypes", t, 1), e;
  }
  n(swe, "tsTupleType");
  function iwe(t) {
    let e = {
      type: "TSOptionalType",
      typeAnnotation: t
    }, s = ie.TSOptionalType;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(iwe, "tsOptionalType");
  function rwe(t) {
    let e = {
      type: "TSRestType",
      typeAnnotation: t
    }, s = ie.TSRestType;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(rwe, "tsRestType");
  function nwe(t, e, s = !1) {
    let i = {
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: s
    }, r = ie.TSNamedTupleMember;
    return x(r.label, i, "label", t, 1), x(r.elementType, i, "elementType", e, 1), x(r.optional, i, "optional", s), i;
  }
  n(nwe, "tsNamedTupleMember");
  function awe(t) {
    let e = {
      type: "TSUnionType",
      types: t
    }, s = ie.TSUnionType;
    return x(s.types, e, "types", t, 1), e;
  }
  n(awe, "tsUnionType");
  function owe(t) {
    let e = {
      type: "TSIntersectionType",
      types: t
    }, s = ie.TSIntersectionType;
    return x(s.types, e, "types", t, 1), e;
  }
  n(owe, "tsIntersectionType");
  function lwe(t, e, s, i) {
    let r = {
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: s,
      falseType: i
    }, a = ie.TSConditionalType;
    return x(a.checkType, r, "checkType", t, 1), x(a.extendsType, r, "extendsType", e, 1), x(a.trueType, r, "trueType", s, 1), x(a.falseType,
    r, "falseType", i, 1), r;
  }
  n(lwe, "tsConditionalType");
  function uwe(t) {
    let e = {
      type: "TSInferType",
      typeParameter: t
    }, s = ie.TSInferType;
    return x(s.typeParameter, e, "typeParameter", t, 1), e;
  }
  n(uwe, "tsInferType");
  function cwe(t) {
    let e = {
      type: "TSParenthesizedType",
      typeAnnotation: t
    }, s = ie.TSParenthesizedType;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(cwe, "tsParenthesizedType");
  function pwe(t) {
    let e = {
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    }, s = ie.TSTypeOperator;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(pwe, "tsTypeOperator");
  function hwe(t, e) {
    let s = {
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    }, i = ie.TSIndexedAccessType;
    return x(i.objectType, s, "objectType", t, 1), x(i.indexType, s, "indexType", e, 1), s;
  }
  n(hwe, "tsIndexedAccessType");
  function fwe(t, e = null, s = null) {
    let i = {
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: s
    }, r = ie.TSMappedType;
    return x(r.typeParameter, i, "typeParameter", t, 1), x(r.typeAnnotation, i, "typeAnnotation", e, 1), x(r.nameType, i, "nameType", s, 1),
    i;
  }
  n(fwe, "tsMappedType");
  function dwe(t, e) {
    let s = {
      type: "TSTemplateLiteralType",
      quasis: t,
      types: e
    }, i = ie.TSTemplateLiteralType;
    return x(i.quasis, s, "quasis", t, 1), x(i.types, s, "types", e, 1), s;
  }
  n(dwe, "tsTemplateLiteralType");
  function mwe(t) {
    let e = {
      type: "TSLiteralType",
      literal: t
    }, s = ie.TSLiteralType;
    return x(s.literal, e, "literal", t, 1), e;
  }
  n(mwe, "tsLiteralType");
  function ywe(t, e = null) {
    let s = {
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    }, i = ie.TSExpressionWithTypeArguments;
    return x(i.expression, s, "expression", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(ywe, "tsExpressionWithTypeArguments");
  function gwe(t, e = null, s = null, i) {
    let r = {
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: s,
      body: i
    }, a = ie.TSInterfaceDeclaration;
    return x(a.id, r, "id", t, 1), x(a.typeParameters, r, "typeParameters", e, 1), x(a.extends, r, "extends", s, 1), x(a.body, r, "body", i,
    1), r;
  }
  n(gwe, "tsInterfaceDeclaration");
  function Twe(t) {
    let e = {
      type: "TSInterfaceBody",
      body: t
    }, s = ie.TSInterfaceBody;
    return x(s.body, e, "body", t, 1), e;
  }
  n(Twe, "tsInterfaceBody");
  function bwe(t, e = null, s) {
    let i = {
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: s
    }, r = ie.TSTypeAliasDeclaration;
    return x(r.id, i, "id", t, 1), x(r.typeParameters, i, "typeParameters", e, 1), x(r.typeAnnotation, i, "typeAnnotation", s, 1), i;
  }
  n(bwe, "tsTypeAliasDeclaration");
  function xwe(t, e = null) {
    let s = {
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    }, i = ie.TSInstantiationExpression;
    return x(i.expression, s, "expression", t, 1), x(i.typeParameters, s, "typeParameters", e, 1), s;
  }
  n(xwe, "tsInstantiationExpression");
  function Swe(t, e) {
    let s = {
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    }, i = ie.TSAsExpression;
    return x(i.expression, s, "expression", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(Swe, "tsAsExpression");
  function Pwe(t, e) {
    let s = {
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    }, i = ie.TSSatisfiesExpression;
    return x(i.expression, s, "expression", t, 1), x(i.typeAnnotation, s, "typeAnnotation", e, 1), s;
  }
  n(Pwe, "tsSatisfiesExpression");
  function Ewe(t, e) {
    let s = {
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    }, i = ie.TSTypeAssertion;
    return x(i.typeAnnotation, s, "typeAnnotation", t, 1), x(i.expression, s, "expression", e, 1), s;
  }
  n(Ewe, "tsTypeAssertion");
  function Awe(t) {
    let e = {
      type: "TSEnumBody",
      members: t
    }, s = ie.TSEnumBody;
    return x(s.members, e, "members", t, 1), e;
  }
  n(Awe, "tsEnumBody");
  function vwe(t, e) {
    let s = {
      type: "TSEnumDeclaration",
      id: t,
      members: e
    }, i = ie.TSEnumDeclaration;
    return x(i.id, s, "id", t, 1), x(i.members, s, "members", e, 1), s;
  }
  n(vwe, "tsEnumDeclaration");
  function Cwe(t, e = null) {
    let s = {
      type: "TSEnumMember",
      id: t,
      initializer: e
    }, i = ie.TSEnumMember;
    return x(i.id, s, "id", t, 1), x(i.initializer, s, "initializer", e, 1), s;
  }
  n(Cwe, "tsEnumMember");
  function wwe(t, e) {
    let s = {
      type: "TSModuleDeclaration",
      id: t,
      body: e,
      kind: null
    }, i = ie.TSModuleDeclaration;
    return x(i.id, s, "id", t, 1), x(i.body, s, "body", e, 1), s;
  }
  n(wwe, "tsModuleDeclaration");
  function Iwe(t) {
    let e = {
      type: "TSModuleBlock",
      body: t
    }, s = ie.TSModuleBlock;
    return x(s.body, e, "body", t, 1), e;
  }
  n(Iwe, "tsModuleBlock");
  function Nwe(t, e = null, s = null) {
    let i = {
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: s
    }, r = ie.TSImportType;
    return x(r.argument, i, "argument", t, 1), x(r.qualifier, i, "qualifier", e, 1), x(r.typeParameters, i, "typeParameters", s, 1), i;
  }
  n(Nwe, "tsImportType");
  function kwe(t, e) {
    let s = {
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    }, i = ie.TSImportEqualsDeclaration;
    return x(i.id, s, "id", t, 1), x(i.moduleReference, s, "moduleReference", e, 1), s;
  }
  n(kwe, "tsImportEqualsDeclaration");
  function Dwe(t) {
    let e = {
      type: "TSExternalModuleReference",
      expression: t
    }, s = ie.TSExternalModuleReference;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(Dwe, "tsExternalModuleReference");
  function Owe(t) {
    let e = {
      type: "TSNonNullExpression",
      expression: t
    }, s = ie.TSNonNullExpression;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(Owe, "tsNonNullExpression");
  function _we(t) {
    let e = {
      type: "TSExportAssignment",
      expression: t
    }, s = ie.TSExportAssignment;
    return x(s.expression, e, "expression", t, 1), e;
  }
  n(_we, "tsExportAssignment");
  function Lwe(t) {
    let e = {
      type: "TSNamespaceExportDeclaration",
      id: t
    }, s = ie.TSNamespaceExportDeclaration;
    return x(s.id, e, "id", t, 1), e;
  }
  n(Lwe, "tsNamespaceExportDeclaration");
  function Bwe(t) {
    let e = {
      type: "TSTypeAnnotation",
      typeAnnotation: t
    }, s = ie.TSTypeAnnotation;
    return x(s.typeAnnotation, e, "typeAnnotation", t, 1), e;
  }
  n(Bwe, "tsTypeAnnotation");
  function Mwe(t) {
    let e = {
      type: "TSTypeParameterInstantiation",
      params: t
    }, s = ie.TSTypeParameterInstantiation;
    return x(s.params, e, "params", t, 1), e;
  }
  n(Mwe, "tsTypeParameterInstantiation");
  function Fwe(t) {
    let e = {
      type: "TSTypeParameterDeclaration",
      params: t
    }, s = ie.TSTypeParameterDeclaration;
    return x(s.params, e, "params", t, 1), e;
  }
  n(Fwe, "tsTypeParameterDeclaration");
  function jwe(t = null, e = null, s) {
    let i = {
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: s
    }, r = ie.TSTypeParameter;
    return x(r.constraint, i, "constraint", t, 1), x(r.default, i, "default", e, 1), x(r.name, i, "name", s), i;
  }
  n(jwe, "tsTypeParameter");
  function Rwe(t) {
    return (0, Rb.default)("NumberLiteral", "NumericLiteral", "The node type "), fq(t);
  }
  n(Rwe, "NumberLiteral");
  function qwe(t, e = "") {
    return (0, Rb.default)("RegexLiteral", "RegExpLiteral", "The node type "), dq(t, e);
  }
  n(qwe, "RegexLiteral");
  function Uwe(t) {
    return (0, Rb.default)("RestProperty", "RestElement", "The node type "), mq(t);
  }
  n(Uwe, "RestProperty");
  function Kwe(t) {
    return (0, Rb.default)("SpreadProperty", "SpreadElement", "The node type "), yq(t);
  }
  n(Kwe, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var gq = g(($) => {
  "use strict";
  Object.defineProperty($, "__esModule", {
    value: !0
  });
  Object.defineProperty($, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty($, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.arrayExpression;
    }, "get")
  });
  Object.defineProperty($, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.arrayPattern;
    }, "get")
  });
  Object.defineProperty($, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty($, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.assignmentExpression;
    }, "get")
  });
  Object.defineProperty($, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.assignmentPattern;
    }, "get")
  });
  Object.defineProperty($, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.awaitExpression;
    }, "get")
  });
  Object.defineProperty($, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty($, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.binaryExpression;
    }, "get")
  });
  Object.defineProperty($, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.bindExpression;
    }, "get")
  });
  Object.defineProperty($, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.blockStatement;
    }, "get")
  });
  Object.defineProperty($, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.booleanLiteral;
    }, "get")
  });
  Object.defineProperty($, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.breakStatement;
    }, "get")
  });
  Object.defineProperty($, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.callExpression;
    }, "get")
  });
  Object.defineProperty($, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.catchClause;
    }, "get")
  });
  Object.defineProperty($, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty($, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classBody;
    }, "get")
  });
  Object.defineProperty($, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classDeclaration;
    }, "get")
  });
  Object.defineProperty($, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classExpression;
    }, "get")
  });
  Object.defineProperty($, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classImplements;
    }, "get")
  });
  Object.defineProperty($, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classMethod;
    }, "get")
  });
  Object.defineProperty($, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty($, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty($, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.classProperty;
    }, "get")
  });
  Object.defineProperty($, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.conditionalExpression;
    }, "get")
  });
  Object.defineProperty($, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.continueStatement;
    }, "get")
  });
  Object.defineProperty($, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.debuggerStatement;
    }, "get")
  });
  Object.defineProperty($, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.decimalLiteral;
    }, "get")
  });
  Object.defineProperty($, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareClass;
    }, "get")
  });
  Object.defineProperty($, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty($, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty($, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareFunction;
    }, "get")
  });
  Object.defineProperty($, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareInterface;
    }, "get")
  });
  Object.defineProperty($, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareModule;
    }, "get")
  });
  Object.defineProperty($, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareModuleExports;
    }, "get")
  });
  Object.defineProperty($, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty($, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty($, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declareVariable;
    }, "get")
  });
  Object.defineProperty($, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.declaredPredicate;
    }, "get")
  });
  Object.defineProperty($, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.decorator;
    }, "get")
  });
  Object.defineProperty($, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.directive;
    }, "get")
  });
  Object.defineProperty($, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.directiveLiteral;
    }, "get")
  });
  Object.defineProperty($, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.doExpression;
    }, "get")
  });
  Object.defineProperty($, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.doWhileStatement;
    }, "get")
  });
  Object.defineProperty($, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.emptyStatement;
    }, "get")
  });
  Object.defineProperty($, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty($, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty($, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumDeclaration;
    }, "get")
  });
  Object.defineProperty($, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty($, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumNumberBody;
    }, "get")
  });
  Object.defineProperty($, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumNumberMember;
    }, "get")
  });
  Object.defineProperty($, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumStringBody;
    }, "get")
  });
  Object.defineProperty($, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumStringMember;
    }, "get")
  });
  Object.defineProperty($, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty($, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty($, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty($, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty($, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty($, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty($, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.exportSpecifier;
    }, "get")
  });
  Object.defineProperty($, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.expressionStatement;
    }, "get")
  });
  Object.defineProperty($, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.file;
    }, "get")
  });
  Object.defineProperty($, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.forInStatement;
    }, "get")
  });
  Object.defineProperty($, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.forOfStatement;
    }, "get")
  });
  Object.defineProperty($, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.forStatement;
    }, "get")
  });
  Object.defineProperty($, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.functionDeclaration;
    }, "get")
  });
  Object.defineProperty($, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.functionExpression;
    }, "get")
  });
  Object.defineProperty($, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.functionTypeParam;
    }, "get")
  });
  Object.defineProperty($, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.identifier;
    }, "get")
  });
  Object.defineProperty($, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.ifStatement;
    }, "get")
  });
  Object.defineProperty($, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.import;
    }, "get")
  });
  Object.defineProperty($, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importAttribute;
    }, "get")
  });
  Object.defineProperty($, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importDeclaration;
    }, "get")
  });
  Object.defineProperty($, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty($, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importExpression;
    }, "get")
  });
  Object.defineProperty($, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty($, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.importSpecifier;
    }, "get")
  });
  Object.defineProperty($, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.indexedAccessType;
    }, "get")
  });
  Object.defineProperty($, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.inferredPredicate;
    }, "get")
  });
  Object.defineProperty($, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty($, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.interfaceExtends;
    }, "get")
  });
  Object.defineProperty($, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.interpreterDirective;
    }, "get")
  });
  Object.defineProperty($, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxAttribute;
    }, "get")
  });
  Object.defineProperty($, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty($, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty($, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxElement;
    }, "get")
  });
  Object.defineProperty($, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty($, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty($, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxFragment;
    }, "get")
  });
  Object.defineProperty($, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty($, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty($, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty($, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty($, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty($, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty($, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty($, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.jsxText;
    }, "get")
  });
  Object.defineProperty($, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.labeledStatement;
    }, "get")
  });
  Object.defineProperty($, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.logicalExpression;
    }, "get")
  });
  Object.defineProperty($, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.memberExpression;
    }, "get")
  });
  Object.defineProperty($, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.metaProperty;
    }, "get")
  });
  Object.defineProperty($, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.moduleExpression;
    }, "get")
  });
  Object.defineProperty($, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.newExpression;
    }, "get")
  });
  Object.defineProperty($, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.noop;
    }, "get")
  });
  Object.defineProperty($, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.nullLiteral;
    }, "get")
  });
  Object.defineProperty($, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.numberLiteral;
    }, "get")
  });
  Object.defineProperty($, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.numericLiteral;
    }, "get")
  });
  Object.defineProperty($, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectExpression;
    }, "get")
  });
  Object.defineProperty($, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectMethod;
    }, "get")
  });
  Object.defineProperty($, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectPattern;
    }, "get")
  });
  Object.defineProperty($, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectProperty;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty($, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty($, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.opaqueType;
    }, "get")
  });
  Object.defineProperty($, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty($, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty($, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty($, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty($, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty($, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty($, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty($, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.placeholder;
    }, "get")
  });
  Object.defineProperty($, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.privateName;
    }, "get")
  });
  Object.defineProperty($, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.program;
    }, "get")
  });
  Object.defineProperty($, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty($, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.recordExpression;
    }, "get")
  });
  Object.defineProperty($, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.regExpLiteral;
    }, "get")
  });
  Object.defineProperty($, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.regexLiteral;
    }, "get")
  });
  Object.defineProperty($, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.restElement;
    }, "get")
  });
  Object.defineProperty($, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.restProperty;
    }, "get")
  });
  Object.defineProperty($, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.returnStatement;
    }, "get")
  });
  Object.defineProperty($, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.sequenceExpression;
    }, "get")
  });
  Object.defineProperty($, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.spreadElement;
    }, "get")
  });
  Object.defineProperty($, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.spreadProperty;
    }, "get")
  });
  Object.defineProperty($, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.staticBlock;
    }, "get")
  });
  Object.defineProperty($, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.stringLiteral;
    }, "get")
  });
  Object.defineProperty($, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.super;
    }, "get")
  });
  Object.defineProperty($, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.switchCase;
    }, "get")
  });
  Object.defineProperty($, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.switchStatement;
    }, "get")
  });
  Object.defineProperty($, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsArrayType;
    }, "get")
  });
  Object.defineProperty($, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsAsExpression;
    }, "get")
  });
  Object.defineProperty($, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsConditionalType;
    }, "get")
  });
  Object.defineProperty($, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsConstructorType;
    }, "get")
  });
  Object.defineProperty($, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty($, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty($, "TSEnumBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsEnumBody;
    }, "get")
  });
  Object.defineProperty($, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsEnumMember;
    }, "get")
  });
  Object.defineProperty($, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty($, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty($, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty($, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsFunctionType;
    }, "get")
  });
  Object.defineProperty($, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsImportType;
    }, "get")
  });
  Object.defineProperty($, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty($, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty($, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsInferType;
    }, "get")
  });
  Object.defineProperty($, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty($, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty($, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty($, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsLiteralType;
    }, "get")
  });
  Object.defineProperty($, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsMappedType;
    }, "get")
  });
  Object.defineProperty($, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty($, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty($, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty($, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty($, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsOptionalType;
    }, "get")
  });
  Object.defineProperty($, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty($, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty($, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty($, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty($, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsRestType;
    }, "get")
  });
  Object.defineProperty($, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty($, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSTemplateLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTemplateLiteralType;
    }, "get")
  });
  Object.defineProperty($, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsThisType;
    }, "get")
  });
  Object.defineProperty($, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTupleType;
    }, "get")
  });
  Object.defineProperty($, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty($, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty($, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty($, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty($, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty($, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty($, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty($, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsTypeReference;
    }, "get")
  });
  Object.defineProperty($, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsUnionType;
    }, "get")
  });
  Object.defineProperty($, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty($, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty($, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty($, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.templateElement;
    }, "get")
  });
  Object.defineProperty($, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.templateLiteral;
    }, "get")
  });
  Object.defineProperty($, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.thisExpression;
    }, "get")
  });
  Object.defineProperty($, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.throwStatement;
    }, "get")
  });
  Object.defineProperty($, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.topicReference;
    }, "get")
  });
  Object.defineProperty($, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tryStatement;
    }, "get")
  });
  Object.defineProperty($, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tupleExpression;
    }, "get")
  });
  Object.defineProperty($, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeAlias;
    }, "get")
  });
  Object.defineProperty($, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeCastExpression;
    }, "get")
  });
  Object.defineProperty($, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeParameter;
    }, "get")
  });
  Object.defineProperty($, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty($, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty($, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.unaryExpression;
    }, "get")
  });
  Object.defineProperty($, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.updateExpression;
    }, "get")
  });
  Object.defineProperty($, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty($, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.variableDeclaration;
    }, "get")
  });
  Object.defineProperty($, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.variableDeclarator;
    }, "get")
  });
  Object.defineProperty($, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.variance;
    }, "get")
  });
  Object.defineProperty($, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty($, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.whileStatement;
    }, "get")
  });
  Object.defineProperty($, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.withStatement;
    }, "get")
  });
  Object.defineProperty($, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y.yieldExpression;
    }, "get")
  });
  var Y = tw();
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var ta = g((Pc) => {
  "use strict";
  Object.defineProperty(Pc, "__esModule", {
    value: !0
  });
  var sw = tw();
  Object.keys(sw).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Pc && Pc[t] === sw[t] || Object.defineProperty(Pc, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return sw[t];
      }, "get")
    });
  });
  var iw = gq();
  Object.keys(iw).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Pc && Pc[t] === iw[t] || Object.defineProperty(Pc, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return iw[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Tq = g((rw) => {
  "use strict";
  Object.defineProperty(rw, "__esModule", {
    value: !0
  });
  rw.default = $we;
  var Vwe = ta(), Wwe = fe();
  function $we(t, e) {
    let s = t.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < s.length; a++)
      /[^ \t]/.exec(s[a]) && (i = a);
    let r = "";
    for (let a = 0; a < s.length; a++) {
      let o = s[a], l = a === 0, u = a === s.length - 1, c = a === i, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^ +/, "")), u || (p = p.replace(/ +$/, "")), p && (c || (p += " "), r += p);
    }
    r && e.push((0, Wwe.inherits)((0, Vwe.stringLiteral)(r), t));
  }
  n($we, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var bq = g((aw) => {
  "use strict";
  Object.defineProperty(aw, "__esModule", {
    value: !0
  });
  aw.default = Jwe;
  var nw = tr(), Hwe = Tq();
  function Jwe(t) {
    let e = [];
    for (let s = 0; s < t.children.length; s++) {
      let i = t.children[s];
      if ((0, nw.isJSXText)(i)) {
        (0, Hwe.default)(i, e);
        continue;
      }
      (0, nw.isJSXExpressionContainer)(i) && (i = i.expression), !(0, nw.isJSXEmptyExpression)(i) && e.push(i);
    }
    return e;
  }
  n(Jwe, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var lw = g((ow) => {
  "use strict";
  Object.defineProperty(ow, "__esModule", {
    value: !0
  });
  ow.default = Xwe;
  var Ywe = Pa();
  function Xwe(t) {
    return !!(t && Ywe.VISITOR_KEYS[t.type]);
  }
  n(Xwe, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var xq = g((uw) => {
  "use strict";
  Object.defineProperty(uw, "__esModule", {
    value: !0
  });
  uw.default = Gwe;
  var zwe = lw();
  function Gwe(t) {
    if (!(0, zwe.default)(t)) {
      var e;
      let s = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${s}"`);
    }
  }
  n(Gwe, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var Sq = g((N) => {
  "use strict";
  Object.defineProperty(N, "__esModule", {
    value: !0
  });
  N.assertAccessor = m2e;
  N.assertAnyTypeAnnotation = LNe;
  N.assertArgumentPlaceholder = uDe;
  N.assertArrayExpression = Zwe;
  N.assertArrayPattern = GIe;
  N.assertArrayTypeAnnotation = BNe;
  N.assertArrowFunctionExpression = QIe;
  N.assertAssignmentExpression = eIe;
  N.assertAssignmentPattern = zIe;
  N.assertAwaitExpression = SNe;
  N.assertBigIntLiteral = ENe;
  N.assertBinary = FOe;
  N.assertBinaryExpression = tIe;
  N.assertBindExpression = cDe;
  N.assertBlock = qOe;
  N.assertBlockParent = ROe;
  N.assertBlockStatement = nIe;
  N.assertBooleanLiteral = CIe;
  N.assertBooleanLiteralTypeAnnotation = FNe;
  N.assertBooleanTypeAnnotation = MNe;
  N.assertBreakStatement = aIe;
  N.assertCallExpression = oIe;
  N.assertCatchClause = lIe;
  N.assertClass = p2e;
  N.assertClassAccessorProperty = INe;
  N.assertClassBody = ZIe;
  N.assertClassDeclaration = tNe;
  N.assertClassExpression = eNe;
  N.assertClassImplements = RNe;
  N.assertClassMethod = fNe;
  N.assertClassPrivateMethod = kNe;
  N.assertClassPrivateProperty = NNe;
  N.assertClassProperty = wNe;
  N.assertCompletionStatement = VOe;
  N.assertConditional = WOe;
  N.assertConditionalExpression = uIe;
  N.assertContinueStatement = cIe;
  N.assertDebuggerStatement = pIe;
  N.assertDecimalLiteral = yDe;
  N.assertDeclaration = ZOe;
  N.assertDeclareClass = qNe;
  N.assertDeclareExportAllDeclaration = XNe;
  N.assertDeclareExportDeclaration = YNe;
  N.assertDeclareFunction = UNe;
  N.assertDeclareInterface = KNe;
  N.assertDeclareModule = VNe;
  N.assertDeclareModuleExports = WNe;
  N.assertDeclareOpaqueType = HNe;
  N.assertDeclareTypeAlias = $Ne;
  N.assertDeclareVariable = JNe;
  N.assertDeclaredPredicate = zNe;
  N.assertDecorator = pDe;
  N.assertDirective = iIe;
  N.assertDirectiveLiteral = rIe;
  N.assertDoExpression = hDe;
  N.assertDoWhileStatement = hIe;
  N.assertEmptyStatement = fIe;
  N.assertEmptyTypeAnnotation = oke;
  N.assertEnumBody = P2e;
  N.assertEnumBooleanBody = Bke;
  N.assertEnumBooleanMember = Rke;
  N.assertEnumDeclaration = Lke;
  N.assertEnumDefaultedMember = Kke;
  N.assertEnumMember = E2e;
  N.assertEnumNumberBody = Mke;
  N.assertEnumNumberMember = qke;
  N.assertEnumStringBody = Fke;
  N.assertEnumStringMember = Uke;
  N.assertEnumSymbolBody = jke;
  N.assertExistsTypeAnnotation = GNe;
  N.assertExportAllDeclaration = sNe;
  N.assertExportDeclaration = f2e;
  N.assertExportDefaultDeclaration = iNe;
  N.assertExportDefaultSpecifier = fDe;
  N.assertExportNamedDeclaration = rNe;
  N.assertExportNamespaceSpecifier = ANe;
  N.assertExportSpecifier = nNe;
  N.assertExpression = MOe;
  N.assertExpressionStatement = dIe;
  N.assertExpressionWrapper = JOe;
  N.assertFile = mIe;
  N.assertFlow = g2e;
  N.assertFlowBaseAnnotation = b2e;
  N.assertFlowDeclaration = x2e;
  N.assertFlowPredicate = S2e;
  N.assertFlowType = T2e;
  N.assertFor = YOe;
  N.assertForInStatement = yIe;
  N.assertForOfStatement = aNe;
  N.assertForStatement = gIe;
  N.assertForXStatement = XOe;
  N.assertFunction = zOe;
  N.assertFunctionDeclaration = TIe;
  N.assertFunctionExpression = bIe;
  N.assertFunctionParent = GOe;
  N.assertFunctionTypeAnnotation = QNe;
  N.assertFunctionTypeParam = ZNe;
  N.assertGenericTypeAnnotation = eke;
  N.assertIdentifier = xIe;
  N.assertIfStatement = SIe;
  N.assertImmutable = r2e;
  N.assertImport = PNe;
  N.assertImportAttribute = _Ne;
  N.assertImportDeclaration = oNe;
  N.assertImportDefaultSpecifier = lNe;
  N.assertImportExpression = pNe;
  N.assertImportNamespaceSpecifier = uNe;
  N.assertImportOrExportDeclaration = h2e;
  N.assertImportSpecifier = cNe;
  N.assertIndexedAccessType = Vke;
  N.assertInferredPredicate = tke;
  N.assertInterfaceDeclaration = ike;
  N.assertInterfaceExtends = ske;
  N.assertInterfaceTypeAnnotation = rke;
  N.assertInterpreterDirective = sIe;
  N.assertIntersectionTypeAnnotation = nke;
  N.assertJSX = A2e;
  N.assertJSXAttribute = $ke;
  N.assertJSXClosingElement = Hke;
  N.assertJSXClosingFragment = nDe;
  N.assertJSXElement = Jke;
  N.assertJSXEmptyExpression = Yke;
  N.assertJSXExpressionContainer = Xke;
  N.assertJSXFragment = iDe;
  N.assertJSXIdentifier = Gke;
  N.assertJSXMemberExpression = Qke;
  N.assertJSXNamespacedName = Zke;
  N.assertJSXOpeningElement = eDe;
  N.assertJSXOpeningFragment = rDe;
  N.assertJSXSpreadAttribute = tDe;
  N.assertJSXSpreadChild = zke;
  N.assertJSXText = sDe;
  N.assertLVal = t2e;
  N.assertLabeledStatement = PIe;
  N.assertLiteral = i2e;
  N.assertLogicalExpression = IIe;
  N.assertLoop = $Oe;
  N.assertMemberExpression = NIe;
  N.assertMetaProperty = hNe;
  N.assertMethod = a2e;
  N.assertMiscellaneous = v2e;
  N.assertMixedTypeAnnotation = ake;
  N.assertModuleDeclaration = L2e;
  N.assertModuleExpression = gDe;
  N.assertModuleSpecifier = d2e;
  N.assertNewExpression = kIe;
  N.assertNoop = aDe;
  N.assertNullLiteral = vIe;
  N.assertNullLiteralTypeAnnotation = jNe;
  N.assertNullableTypeAnnotation = lke;
  N.assertNumberLiteral = k2e;
  N.assertNumberLiteralTypeAnnotation = uke;
  N.assertNumberTypeAnnotation = cke;
  N.assertNumericLiteral = AIe;
  N.assertObjectExpression = OIe;
  N.assertObjectMember = o2e;
  N.assertObjectMethod = _Ie;
  N.assertObjectPattern = dNe;
  N.assertObjectProperty = LIe;
  N.assertObjectTypeAnnotation = pke;
  N.assertObjectTypeCallProperty = fke;
  N.assertObjectTypeIndexer = dke;
  N.assertObjectTypeInternalSlot = hke;
  N.assertObjectTypeProperty = mke;
  N.assertObjectTypeSpreadProperty = yke;
  N.assertOpaqueType = gke;
  N.assertOptionalCallExpression = CNe;
  N.assertOptionalIndexedAccessType = Wke;
  N.assertOptionalMemberExpression = vNe;
  N.assertParenthesizedExpression = jIe;
  N.assertPattern = c2e;
  N.assertPatternLike = e2e;
  N.assertPipelineBareFunction = xDe;
  N.assertPipelinePrimaryTopicReference = SDe;
  N.assertPipelineTopicExpression = bDe;
  N.assertPlaceholder = oDe;
  N.assertPrivate = y2e;
  N.assertPrivateName = DNe;
  N.assertProgram = DIe;
  N.assertProperty = l2e;
  N.assertPureish = QOe;
  N.assertQualifiedTypeIdentifier = Tke;
  N.assertRecordExpression = dDe;
  N.assertRegExpLiteral = wIe;
  N.assertRegexLiteral = D2e;
  N.assertRestElement = BIe;
  N.assertRestProperty = O2e;
  N.assertReturnStatement = MIe;
  N.assertScopable = jOe;
  N.assertSequenceExpression = FIe;
  N.assertSpreadElement = mNe;
  N.assertSpreadProperty = _2e;
  N.assertStandardized = BOe;
  N.assertStatement = UOe;
  N.assertStaticBlock = ONe;
  N.assertStringLiteral = EIe;
  N.assertStringLiteralTypeAnnotation = bke;
  N.assertStringTypeAnnotation = xke;
  N.assertSuper = yNe;
  N.assertSwitchCase = RIe;
  N.assertSwitchStatement = qIe;
  N.assertSymbolTypeAnnotation = Ske;
  N.assertTSAnyKeyword = DDe;
  N.assertTSArrayType = GDe;
  N.assertTSAsExpression = gOe;
  N.assertTSBaseType = N2e;
  N.assertTSBigIntKeyword = _De;
  N.assertTSBooleanKeyword = ODe;
  N.assertTSCallSignatureDeclaration = CDe;
  N.assertTSConditionalType = rOe;
  N.assertTSConstructSignatureDeclaration = wDe;
  N.assertTSConstructorType = HDe;
  N.assertTSDeclareFunction = EDe;
  N.assertTSDeclareMethod = ADe;
  N.assertTSEntityName = s2e;
  N.assertTSEnumBody = xOe;
  N.assertTSEnumDeclaration = SOe;
  N.assertTSEnumMember = POe;
  N.assertTSExportAssignment = NOe;
  N.assertTSExpressionWithTypeArguments = hOe;
  N.assertTSExternalModuleReference = wOe;
  N.assertTSFunctionType = $De;
  N.assertTSImportEqualsDeclaration = COe;
  N.assertTSImportType = vOe;
  N.assertTSIndexSignature = kDe;
  N.assertTSIndexedAccessType = lOe;
  N.assertTSInferType = nOe;
  N.assertTSInstantiationExpression = yOe;
  N.assertTSInterfaceBody = dOe;
  N.assertTSInterfaceDeclaration = fOe;
  N.assertTSIntersectionType = iOe;
  N.assertTSIntrinsicKeyword = LDe;
  N.assertTSLiteralType = pOe;
  N.assertTSMappedType = uOe;
  N.assertTSMethodSignature = NDe;
  N.assertTSModuleBlock = AOe;
  N.assertTSModuleDeclaration = EOe;
  N.assertTSNamedTupleMember = tOe;
  N.assertTSNamespaceExportDeclaration = kOe;
  N.assertTSNeverKeyword = BDe;
  N.assertTSNonNullExpression = IOe;
  N.assertTSNullKeyword = MDe;
  N.assertTSNumberKeyword = FDe;
  N.assertTSObjectKeyword = jDe;
  N.assertTSOptionalType = ZDe;
  N.assertTSParameterProperty = PDe;
  N.assertTSParenthesizedType = aOe;
  N.assertTSPropertySignature = IDe;
  N.assertTSQualifiedName = vDe;
  N.assertTSRestType = eOe;
  N.assertTSSatisfiesExpression = TOe;
  N.assertTSStringKeyword = RDe;
  N.assertTSSymbolKeyword = qDe;
  N.assertTSTemplateLiteralType = cOe;
  N.assertTSThisType = WDe;
  N.assertTSTupleType = QDe;
  N.assertTSType = I2e;
  N.assertTSTypeAliasDeclaration = mOe;
  N.assertTSTypeAnnotation = DOe;
  N.assertTSTypeAssertion = bOe;
  N.assertTSTypeElement = w2e;
  N.assertTSTypeLiteral = zDe;
  N.assertTSTypeOperator = oOe;
  N.assertTSTypeParameter = LOe;
  N.assertTSTypeParameterDeclaration = _Oe;
  N.assertTSTypeParameterInstantiation = OOe;
  N.assertTSTypePredicate = YDe;
  N.assertTSTypeQuery = XDe;
  N.assertTSTypeReference = JDe;
  N.assertTSUndefinedKeyword = UDe;
  N.assertTSUnionType = sOe;
  N.assertTSUnknownKeyword = KDe;
  N.assertTSVoidKeyword = VDe;
  N.assertTaggedTemplateExpression = gNe;
  N.assertTemplateElement = TNe;
  N.assertTemplateLiteral = bNe;
  N.assertTerminatorless = KOe;
  N.assertThisExpression = UIe;
  N.assertThisTypeAnnotation = Pke;
  N.assertThrowStatement = KIe;
  N.assertTopicReference = TDe;
  N.assertTryStatement = VIe;
  N.assertTupleExpression = mDe;
  N.assertTupleTypeAnnotation = Eke;
  N.assertTypeAlias = vke;
  N.assertTypeAnnotation = Cke;
  N.assertTypeCastExpression = wke;
  N.assertTypeParameter = Ike;
  N.assertTypeParameterDeclaration = Nke;
  N.assertTypeParameterInstantiation = kke;
  N.assertTypeScript = C2e;
  N.assertTypeofTypeAnnotation = Ake;
  N.assertUnaryExpression = WIe;
  N.assertUnaryLike = u2e;
  N.assertUnionTypeAnnotation = Dke;
  N.assertUpdateExpression = $Ie;
  N.assertUserWhitespacable = n2e;
  N.assertV8IntrinsicIdentifier = lDe;
  N.assertVariableDeclaration = HIe;
  N.assertVariableDeclarator = JIe;
  N.assertVariance = Oke;
  N.assertVoidTypeAnnotation = _ke;
  N.assertWhile = HOe;
  N.assertWhileStatement = YIe;
  N.assertWithStatement = XIe;
  N.assertYieldExpression = xNe;
  var Qwe = Gf(), Jy = Fy();
  function L(t, e, s) {
    if (!(0, Qwe.default)(t, e, s))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(s)}, but instead got "${e.type}".`);
  }
  n(L, "assert");
  function Zwe(t, e) {
    L("ArrayExpression", t, e);
  }
  n(Zwe, "assertArrayExpression");
  function eIe(t, e) {
    L("AssignmentExpression", t, e);
  }
  n(eIe, "assertAssignmentExpression");
  function tIe(t, e) {
    L("BinaryExpression", t, e);
  }
  n(tIe, "assertBinaryExpression");
  function sIe(t, e) {
    L("InterpreterDirective", t, e);
  }
  n(sIe, "assertInterpreterDirective");
  function iIe(t, e) {
    L("Directive", t, e);
  }
  n(iIe, "assertDirective");
  function rIe(t, e) {
    L("DirectiveLiteral", t, e);
  }
  n(rIe, "assertDirectiveLiteral");
  function nIe(t, e) {
    L("BlockStatement", t, e);
  }
  n(nIe, "assertBlockStatement");
  function aIe(t, e) {
    L("BreakStatement", t, e);
  }
  n(aIe, "assertBreakStatement");
  function oIe(t, e) {
    L("CallExpression", t, e);
  }
  n(oIe, "assertCallExpression");
  function lIe(t, e) {
    L("CatchClause", t, e);
  }
  n(lIe, "assertCatchClause");
  function uIe(t, e) {
    L("ConditionalExpression", t, e);
  }
  n(uIe, "assertConditionalExpression");
  function cIe(t, e) {
    L("ContinueStatement", t, e);
  }
  n(cIe, "assertContinueStatement");
  function pIe(t, e) {
    L("DebuggerStatement", t, e);
  }
  n(pIe, "assertDebuggerStatement");
  function hIe(t, e) {
    L("DoWhileStatement", t, e);
  }
  n(hIe, "assertDoWhileStatement");
  function fIe(t, e) {
    L("EmptyStatement", t, e);
  }
  n(fIe, "assertEmptyStatement");
  function dIe(t, e) {
    L("ExpressionStatement", t, e);
  }
  n(dIe, "assertExpressionStatement");
  function mIe(t, e) {
    L("File", t, e);
  }
  n(mIe, "assertFile");
  function yIe(t, e) {
    L("ForInStatement", t, e);
  }
  n(yIe, "assertForInStatement");
  function gIe(t, e) {
    L("ForStatement", t, e);
  }
  n(gIe, "assertForStatement");
  function TIe(t, e) {
    L("FunctionDeclaration", t, e);
  }
  n(TIe, "assertFunctionDeclaration");
  function bIe(t, e) {
    L("FunctionExpression", t, e);
  }
  n(bIe, "assertFunctionExpression");
  function xIe(t, e) {
    L("Identifier", t, e);
  }
  n(xIe, "assertIdentifier");
  function SIe(t, e) {
    L("IfStatement", t, e);
  }
  n(SIe, "assertIfStatement");
  function PIe(t, e) {
    L("LabeledStatement", t, e);
  }
  n(PIe, "assertLabeledStatement");
  function EIe(t, e) {
    L("StringLiteral", t, e);
  }
  n(EIe, "assertStringLiteral");
  function AIe(t, e) {
    L("NumericLiteral", t, e);
  }
  n(AIe, "assertNumericLiteral");
  function vIe(t, e) {
    L("NullLiteral", t, e);
  }
  n(vIe, "assertNullLiteral");
  function CIe(t, e) {
    L("BooleanLiteral", t, e);
  }
  n(CIe, "assertBooleanLiteral");
  function wIe(t, e) {
    L("RegExpLiteral", t, e);
  }
  n(wIe, "assertRegExpLiteral");
  function IIe(t, e) {
    L("LogicalExpression", t, e);
  }
  n(IIe, "assertLogicalExpression");
  function NIe(t, e) {
    L("MemberExpression", t, e);
  }
  n(NIe, "assertMemberExpression");
  function kIe(t, e) {
    L("NewExpression", t, e);
  }
  n(kIe, "assertNewExpression");
  function DIe(t, e) {
    L("Program", t, e);
  }
  n(DIe, "assertProgram");
  function OIe(t, e) {
    L("ObjectExpression", t, e);
  }
  n(OIe, "assertObjectExpression");
  function _Ie(t, e) {
    L("ObjectMethod", t, e);
  }
  n(_Ie, "assertObjectMethod");
  function LIe(t, e) {
    L("ObjectProperty", t, e);
  }
  n(LIe, "assertObjectProperty");
  function BIe(t, e) {
    L("RestElement", t, e);
  }
  n(BIe, "assertRestElement");
  function MIe(t, e) {
    L("ReturnStatement", t, e);
  }
  n(MIe, "assertReturnStatement");
  function FIe(t, e) {
    L("SequenceExpression", t, e);
  }
  n(FIe, "assertSequenceExpression");
  function jIe(t, e) {
    L("ParenthesizedExpression", t, e);
  }
  n(jIe, "assertParenthesizedExpression");
  function RIe(t, e) {
    L("SwitchCase", t, e);
  }
  n(RIe, "assertSwitchCase");
  function qIe(t, e) {
    L("SwitchStatement", t, e);
  }
  n(qIe, "assertSwitchStatement");
  function UIe(t, e) {
    L("ThisExpression", t, e);
  }
  n(UIe, "assertThisExpression");
  function KIe(t, e) {
    L("ThrowStatement", t, e);
  }
  n(KIe, "assertThrowStatement");
  function VIe(t, e) {
    L("TryStatement", t, e);
  }
  n(VIe, "assertTryStatement");
  function WIe(t, e) {
    L("UnaryExpression", t, e);
  }
  n(WIe, "assertUnaryExpression");
  function $Ie(t, e) {
    L("UpdateExpression", t, e);
  }
  n($Ie, "assertUpdateExpression");
  function HIe(t, e) {
    L("VariableDeclaration", t, e);
  }
  n(HIe, "assertVariableDeclaration");
  function JIe(t, e) {
    L("VariableDeclarator", t, e);
  }
  n(JIe, "assertVariableDeclarator");
  function YIe(t, e) {
    L("WhileStatement", t, e);
  }
  n(YIe, "assertWhileStatement");
  function XIe(t, e) {
    L("WithStatement", t, e);
  }
  n(XIe, "assertWithStatement");
  function zIe(t, e) {
    L("AssignmentPattern", t, e);
  }
  n(zIe, "assertAssignmentPattern");
  function GIe(t, e) {
    L("ArrayPattern", t, e);
  }
  n(GIe, "assertArrayPattern");
  function QIe(t, e) {
    L("ArrowFunctionExpression", t, e);
  }
  n(QIe, "assertArrowFunctionExpression");
  function ZIe(t, e) {
    L("ClassBody", t, e);
  }
  n(ZIe, "assertClassBody");
  function eNe(t, e) {
    L("ClassExpression", t, e);
  }
  n(eNe, "assertClassExpression");
  function tNe(t, e) {
    L("ClassDeclaration", t, e);
  }
  n(tNe, "assertClassDeclaration");
  function sNe(t, e) {
    L("ExportAllDeclaration", t, e);
  }
  n(sNe, "assertExportAllDeclaration");
  function iNe(t, e) {
    L("ExportDefaultDeclaration", t, e);
  }
  n(iNe, "assertExportDefaultDeclaration");
  function rNe(t, e) {
    L("ExportNamedDeclaration", t, e);
  }
  n(rNe, "assertExportNamedDeclaration");
  function nNe(t, e) {
    L("ExportSpecifier", t, e);
  }
  n(nNe, "assertExportSpecifier");
  function aNe(t, e) {
    L("ForOfStatement", t, e);
  }
  n(aNe, "assertForOfStatement");
  function oNe(t, e) {
    L("ImportDeclaration", t, e);
  }
  n(oNe, "assertImportDeclaration");
  function lNe(t, e) {
    L("ImportDefaultSpecifier", t, e);
  }
  n(lNe, "assertImportDefaultSpecifier");
  function uNe(t, e) {
    L("ImportNamespaceSpecifier", t, e);
  }
  n(uNe, "assertImportNamespaceSpecifier");
  function cNe(t, e) {
    L("ImportSpecifier", t, e);
  }
  n(cNe, "assertImportSpecifier");
  function pNe(t, e) {
    L("ImportExpression", t, e);
  }
  n(pNe, "assertImportExpression");
  function hNe(t, e) {
    L("MetaProperty", t, e);
  }
  n(hNe, "assertMetaProperty");
  function fNe(t, e) {
    L("ClassMethod", t, e);
  }
  n(fNe, "assertClassMethod");
  function dNe(t, e) {
    L("ObjectPattern", t, e);
  }
  n(dNe, "assertObjectPattern");
  function mNe(t, e) {
    L("SpreadElement", t, e);
  }
  n(mNe, "assertSpreadElement");
  function yNe(t, e) {
    L("Super", t, e);
  }
  n(yNe, "assertSuper");
  function gNe(t, e) {
    L("TaggedTemplateExpression", t, e);
  }
  n(gNe, "assertTaggedTemplateExpression");
  function TNe(t, e) {
    L("TemplateElement", t, e);
  }
  n(TNe, "assertTemplateElement");
  function bNe(t, e) {
    L("TemplateLiteral", t, e);
  }
  n(bNe, "assertTemplateLiteral");
  function xNe(t, e) {
    L("YieldExpression", t, e);
  }
  n(xNe, "assertYieldExpression");
  function SNe(t, e) {
    L("AwaitExpression", t, e);
  }
  n(SNe, "assertAwaitExpression");
  function PNe(t, e) {
    L("Import", t, e);
  }
  n(PNe, "assertImport");
  function ENe(t, e) {
    L("BigIntLiteral", t, e);
  }
  n(ENe, "assertBigIntLiteral");
  function ANe(t, e) {
    L("ExportNamespaceSpecifier", t, e);
  }
  n(ANe, "assertExportNamespaceSpecifier");
  function vNe(t, e) {
    L("OptionalMemberExpression", t, e);
  }
  n(vNe, "assertOptionalMemberExpression");
  function CNe(t, e) {
    L("OptionalCallExpression", t, e);
  }
  n(CNe, "assertOptionalCallExpression");
  function wNe(t, e) {
    L("ClassProperty", t, e);
  }
  n(wNe, "assertClassProperty");
  function INe(t, e) {
    L("ClassAccessorProperty", t, e);
  }
  n(INe, "assertClassAccessorProperty");
  function NNe(t, e) {
    L("ClassPrivateProperty", t, e);
  }
  n(NNe, "assertClassPrivateProperty");
  function kNe(t, e) {
    L("ClassPrivateMethod", t, e);
  }
  n(kNe, "assertClassPrivateMethod");
  function DNe(t, e) {
    L("PrivateName", t, e);
  }
  n(DNe, "assertPrivateName");
  function ONe(t, e) {
    L("StaticBlock", t, e);
  }
  n(ONe, "assertStaticBlock");
  function _Ne(t, e) {
    L("ImportAttribute", t, e);
  }
  n(_Ne, "assertImportAttribute");
  function LNe(t, e) {
    L("AnyTypeAnnotation", t, e);
  }
  n(LNe, "assertAnyTypeAnnotation");
  function BNe(t, e) {
    L("ArrayTypeAnnotation", t, e);
  }
  n(BNe, "assertArrayTypeAnnotation");
  function MNe(t, e) {
    L("BooleanTypeAnnotation", t, e);
  }
  n(MNe, "assertBooleanTypeAnnotation");
  function FNe(t, e) {
    L("BooleanLiteralTypeAnnotation", t, e);
  }
  n(FNe, "assertBooleanLiteralTypeAnnotation");
  function jNe(t, e) {
    L("NullLiteralTypeAnnotation", t, e);
  }
  n(jNe, "assertNullLiteralTypeAnnotation");
  function RNe(t, e) {
    L("ClassImplements", t, e);
  }
  n(RNe, "assertClassImplements");
  function qNe(t, e) {
    L("DeclareClass", t, e);
  }
  n(qNe, "assertDeclareClass");
  function UNe(t, e) {
    L("DeclareFunction", t, e);
  }
  n(UNe, "assertDeclareFunction");
  function KNe(t, e) {
    L("DeclareInterface", t, e);
  }
  n(KNe, "assertDeclareInterface");
  function VNe(t, e) {
    L("DeclareModule", t, e);
  }
  n(VNe, "assertDeclareModule");
  function WNe(t, e) {
    L("DeclareModuleExports", t, e);
  }
  n(WNe, "assertDeclareModuleExports");
  function $Ne(t, e) {
    L("DeclareTypeAlias", t, e);
  }
  n($Ne, "assertDeclareTypeAlias");
  function HNe(t, e) {
    L("DeclareOpaqueType", t, e);
  }
  n(HNe, "assertDeclareOpaqueType");
  function JNe(t, e) {
    L("DeclareVariable", t, e);
  }
  n(JNe, "assertDeclareVariable");
  function YNe(t, e) {
    L("DeclareExportDeclaration", t, e);
  }
  n(YNe, "assertDeclareExportDeclaration");
  function XNe(t, e) {
    L("DeclareExportAllDeclaration", t, e);
  }
  n(XNe, "assertDeclareExportAllDeclaration");
  function zNe(t, e) {
    L("DeclaredPredicate", t, e);
  }
  n(zNe, "assertDeclaredPredicate");
  function GNe(t, e) {
    L("ExistsTypeAnnotation", t, e);
  }
  n(GNe, "assertExistsTypeAnnotation");
  function QNe(t, e) {
    L("FunctionTypeAnnotation", t, e);
  }
  n(QNe, "assertFunctionTypeAnnotation");
  function ZNe(t, e) {
    L("FunctionTypeParam", t, e);
  }
  n(ZNe, "assertFunctionTypeParam");
  function eke(t, e) {
    L("GenericTypeAnnotation", t, e);
  }
  n(eke, "assertGenericTypeAnnotation");
  function tke(t, e) {
    L("InferredPredicate", t, e);
  }
  n(tke, "assertInferredPredicate");
  function ske(t, e) {
    L("InterfaceExtends", t, e);
  }
  n(ske, "assertInterfaceExtends");
  function ike(t, e) {
    L("InterfaceDeclaration", t, e);
  }
  n(ike, "assertInterfaceDeclaration");
  function rke(t, e) {
    L("InterfaceTypeAnnotation", t, e);
  }
  n(rke, "assertInterfaceTypeAnnotation");
  function nke(t, e) {
    L("IntersectionTypeAnnotation", t, e);
  }
  n(nke, "assertIntersectionTypeAnnotation");
  function ake(t, e) {
    L("MixedTypeAnnotation", t, e);
  }
  n(ake, "assertMixedTypeAnnotation");
  function oke(t, e) {
    L("EmptyTypeAnnotation", t, e);
  }
  n(oke, "assertEmptyTypeAnnotation");
  function lke(t, e) {
    L("NullableTypeAnnotation", t, e);
  }
  n(lke, "assertNullableTypeAnnotation");
  function uke(t, e) {
    L("NumberLiteralTypeAnnotation", t, e);
  }
  n(uke, "assertNumberLiteralTypeAnnotation");
  function cke(t, e) {
    L("NumberTypeAnnotation", t, e);
  }
  n(cke, "assertNumberTypeAnnotation");
  function pke(t, e) {
    L("ObjectTypeAnnotation", t, e);
  }
  n(pke, "assertObjectTypeAnnotation");
  function hke(t, e) {
    L("ObjectTypeInternalSlot", t, e);
  }
  n(hke, "assertObjectTypeInternalSlot");
  function fke(t, e) {
    L("ObjectTypeCallProperty", t, e);
  }
  n(fke, "assertObjectTypeCallProperty");
  function dke(t, e) {
    L("ObjectTypeIndexer", t, e);
  }
  n(dke, "assertObjectTypeIndexer");
  function mke(t, e) {
    L("ObjectTypeProperty", t, e);
  }
  n(mke, "assertObjectTypeProperty");
  function yke(t, e) {
    L("ObjectTypeSpreadProperty", t, e);
  }
  n(yke, "assertObjectTypeSpreadProperty");
  function gke(t, e) {
    L("OpaqueType", t, e);
  }
  n(gke, "assertOpaqueType");
  function Tke(t, e) {
    L("QualifiedTypeIdentifier", t, e);
  }
  n(Tke, "assertQualifiedTypeIdentifier");
  function bke(t, e) {
    L("StringLiteralTypeAnnotation", t, e);
  }
  n(bke, "assertStringLiteralTypeAnnotation");
  function xke(t, e) {
    L("StringTypeAnnotation", t, e);
  }
  n(xke, "assertStringTypeAnnotation");
  function Ske(t, e) {
    L("SymbolTypeAnnotation", t, e);
  }
  n(Ske, "assertSymbolTypeAnnotation");
  function Pke(t, e) {
    L("ThisTypeAnnotation", t, e);
  }
  n(Pke, "assertThisTypeAnnotation");
  function Eke(t, e) {
    L("TupleTypeAnnotation", t, e);
  }
  n(Eke, "assertTupleTypeAnnotation");
  function Ake(t, e) {
    L("TypeofTypeAnnotation", t, e);
  }
  n(Ake, "assertTypeofTypeAnnotation");
  function vke(t, e) {
    L("TypeAlias", t, e);
  }
  n(vke, "assertTypeAlias");
  function Cke(t, e) {
    L("TypeAnnotation", t, e);
  }
  n(Cke, "assertTypeAnnotation");
  function wke(t, e) {
    L("TypeCastExpression", t, e);
  }
  n(wke, "assertTypeCastExpression");
  function Ike(t, e) {
    L("TypeParameter", t, e);
  }
  n(Ike, "assertTypeParameter");
  function Nke(t, e) {
    L("TypeParameterDeclaration", t, e);
  }
  n(Nke, "assertTypeParameterDeclaration");
  function kke(t, e) {
    L("TypeParameterInstantiation", t, e);
  }
  n(kke, "assertTypeParameterInstantiation");
  function Dke(t, e) {
    L("UnionTypeAnnotation", t, e);
  }
  n(Dke, "assertUnionTypeAnnotation");
  function Oke(t, e) {
    L("Variance", t, e);
  }
  n(Oke, "assertVariance");
  function _ke(t, e) {
    L("VoidTypeAnnotation", t, e);
  }
  n(_ke, "assertVoidTypeAnnotation");
  function Lke(t, e) {
    L("EnumDeclaration", t, e);
  }
  n(Lke, "assertEnumDeclaration");
  function Bke(t, e) {
    L("EnumBooleanBody", t, e);
  }
  n(Bke, "assertEnumBooleanBody");
  function Mke(t, e) {
    L("EnumNumberBody", t, e);
  }
  n(Mke, "assertEnumNumberBody");
  function Fke(t, e) {
    L("EnumStringBody", t, e);
  }
  n(Fke, "assertEnumStringBody");
  function jke(t, e) {
    L("EnumSymbolBody", t, e);
  }
  n(jke, "assertEnumSymbolBody");
  function Rke(t, e) {
    L("EnumBooleanMember", t, e);
  }
  n(Rke, "assertEnumBooleanMember");
  function qke(t, e) {
    L("EnumNumberMember", t, e);
  }
  n(qke, "assertEnumNumberMember");
  function Uke(t, e) {
    L("EnumStringMember", t, e);
  }
  n(Uke, "assertEnumStringMember");
  function Kke(t, e) {
    L("EnumDefaultedMember", t, e);
  }
  n(Kke, "assertEnumDefaultedMember");
  function Vke(t, e) {
    L("IndexedAccessType", t, e);
  }
  n(Vke, "assertIndexedAccessType");
  function Wke(t, e) {
    L("OptionalIndexedAccessType", t, e);
  }
  n(Wke, "assertOptionalIndexedAccessType");
  function $ke(t, e) {
    L("JSXAttribute", t, e);
  }
  n($ke, "assertJSXAttribute");
  function Hke(t, e) {
    L("JSXClosingElement", t, e);
  }
  n(Hke, "assertJSXClosingElement");
  function Jke(t, e) {
    L("JSXElement", t, e);
  }
  n(Jke, "assertJSXElement");
  function Yke(t, e) {
    L("JSXEmptyExpression", t, e);
  }
  n(Yke, "assertJSXEmptyExpression");
  function Xke(t, e) {
    L("JSXExpressionContainer", t, e);
  }
  n(Xke, "assertJSXExpressionContainer");
  function zke(t, e) {
    L("JSXSpreadChild", t, e);
  }
  n(zke, "assertJSXSpreadChild");
  function Gke(t, e) {
    L("JSXIdentifier", t, e);
  }
  n(Gke, "assertJSXIdentifier");
  function Qke(t, e) {
    L("JSXMemberExpression", t, e);
  }
  n(Qke, "assertJSXMemberExpression");
  function Zke(t, e) {
    L("JSXNamespacedName", t, e);
  }
  n(Zke, "assertJSXNamespacedName");
  function eDe(t, e) {
    L("JSXOpeningElement", t, e);
  }
  n(eDe, "assertJSXOpeningElement");
  function tDe(t, e) {
    L("JSXSpreadAttribute", t, e);
  }
  n(tDe, "assertJSXSpreadAttribute");
  function sDe(t, e) {
    L("JSXText", t, e);
  }
  n(sDe, "assertJSXText");
  function iDe(t, e) {
    L("JSXFragment", t, e);
  }
  n(iDe, "assertJSXFragment");
  function rDe(t, e) {
    L("JSXOpeningFragment", t, e);
  }
  n(rDe, "assertJSXOpeningFragment");
  function nDe(t, e) {
    L("JSXClosingFragment", t, e);
  }
  n(nDe, "assertJSXClosingFragment");
  function aDe(t, e) {
    L("Noop", t, e);
  }
  n(aDe, "assertNoop");
  function oDe(t, e) {
    L("Placeholder", t, e);
  }
  n(oDe, "assertPlaceholder");
  function lDe(t, e) {
    L("V8IntrinsicIdentifier", t, e);
  }
  n(lDe, "assertV8IntrinsicIdentifier");
  function uDe(t, e) {
    L("ArgumentPlaceholder", t, e);
  }
  n(uDe, "assertArgumentPlaceholder");
  function cDe(t, e) {
    L("BindExpression", t, e);
  }
  n(cDe, "assertBindExpression");
  function pDe(t, e) {
    L("Decorator", t, e);
  }
  n(pDe, "assertDecorator");
  function hDe(t, e) {
    L("DoExpression", t, e);
  }
  n(hDe, "assertDoExpression");
  function fDe(t, e) {
    L("ExportDefaultSpecifier", t, e);
  }
  n(fDe, "assertExportDefaultSpecifier");
  function dDe(t, e) {
    L("RecordExpression", t, e);
  }
  n(dDe, "assertRecordExpression");
  function mDe(t, e) {
    L("TupleExpression", t, e);
  }
  n(mDe, "assertTupleExpression");
  function yDe(t, e) {
    L("DecimalLiteral", t, e);
  }
  n(yDe, "assertDecimalLiteral");
  function gDe(t, e) {
    L("ModuleExpression", t, e);
  }
  n(gDe, "assertModuleExpression");
  function TDe(t, e) {
    L("TopicReference", t, e);
  }
  n(TDe, "assertTopicReference");
  function bDe(t, e) {
    L("PipelineTopicExpression", t, e);
  }
  n(bDe, "assertPipelineTopicExpression");
  function xDe(t, e) {
    L("PipelineBareFunction", t, e);
  }
  n(xDe, "assertPipelineBareFunction");
  function SDe(t, e) {
    L("PipelinePrimaryTopicReference", t, e);
  }
  n(SDe, "assertPipelinePrimaryTopicReference");
  function PDe(t, e) {
    L("TSParameterProperty", t, e);
  }
  n(PDe, "assertTSParameterProperty");
  function EDe(t, e) {
    L("TSDeclareFunction", t, e);
  }
  n(EDe, "assertTSDeclareFunction");
  function ADe(t, e) {
    L("TSDeclareMethod", t, e);
  }
  n(ADe, "assertTSDeclareMethod");
  function vDe(t, e) {
    L("TSQualifiedName", t, e);
  }
  n(vDe, "assertTSQualifiedName");
  function CDe(t, e) {
    L("TSCallSignatureDeclaration", t, e);
  }
  n(CDe, "assertTSCallSignatureDeclaration");
  function wDe(t, e) {
    L("TSConstructSignatureDeclaration", t, e);
  }
  n(wDe, "assertTSConstructSignatureDeclaration");
  function IDe(t, e) {
    L("TSPropertySignature", t, e);
  }
  n(IDe, "assertTSPropertySignature");
  function NDe(t, e) {
    L("TSMethodSignature", t, e);
  }
  n(NDe, "assertTSMethodSignature");
  function kDe(t, e) {
    L("TSIndexSignature", t, e);
  }
  n(kDe, "assertTSIndexSignature");
  function DDe(t, e) {
    L("TSAnyKeyword", t, e);
  }
  n(DDe, "assertTSAnyKeyword");
  function ODe(t, e) {
    L("TSBooleanKeyword", t, e);
  }
  n(ODe, "assertTSBooleanKeyword");
  function _De(t, e) {
    L("TSBigIntKeyword", t, e);
  }
  n(_De, "assertTSBigIntKeyword");
  function LDe(t, e) {
    L("TSIntrinsicKeyword", t, e);
  }
  n(LDe, "assertTSIntrinsicKeyword");
  function BDe(t, e) {
    L("TSNeverKeyword", t, e);
  }
  n(BDe, "assertTSNeverKeyword");
  function MDe(t, e) {
    L("TSNullKeyword", t, e);
  }
  n(MDe, "assertTSNullKeyword");
  function FDe(t, e) {
    L("TSNumberKeyword", t, e);
  }
  n(FDe, "assertTSNumberKeyword");
  function jDe(t, e) {
    L("TSObjectKeyword", t, e);
  }
  n(jDe, "assertTSObjectKeyword");
  function RDe(t, e) {
    L("TSStringKeyword", t, e);
  }
  n(RDe, "assertTSStringKeyword");
  function qDe(t, e) {
    L("TSSymbolKeyword", t, e);
  }
  n(qDe, "assertTSSymbolKeyword");
  function UDe(t, e) {
    L("TSUndefinedKeyword", t, e);
  }
  n(UDe, "assertTSUndefinedKeyword");
  function KDe(t, e) {
    L("TSUnknownKeyword", t, e);
  }
  n(KDe, "assertTSUnknownKeyword");
  function VDe(t, e) {
    L("TSVoidKeyword", t, e);
  }
  n(VDe, "assertTSVoidKeyword");
  function WDe(t, e) {
    L("TSThisType", t, e);
  }
  n(WDe, "assertTSThisType");
  function $De(t, e) {
    L("TSFunctionType", t, e);
  }
  n($De, "assertTSFunctionType");
  function HDe(t, e) {
    L("TSConstructorType", t, e);
  }
  n(HDe, "assertTSConstructorType");
  function JDe(t, e) {
    L("TSTypeReference", t, e);
  }
  n(JDe, "assertTSTypeReference");
  function YDe(t, e) {
    L("TSTypePredicate", t, e);
  }
  n(YDe, "assertTSTypePredicate");
  function XDe(t, e) {
    L("TSTypeQuery", t, e);
  }
  n(XDe, "assertTSTypeQuery");
  function zDe(t, e) {
    L("TSTypeLiteral", t, e);
  }
  n(zDe, "assertTSTypeLiteral");
  function GDe(t, e) {
    L("TSArrayType", t, e);
  }
  n(GDe, "assertTSArrayType");
  function QDe(t, e) {
    L("TSTupleType", t, e);
  }
  n(QDe, "assertTSTupleType");
  function ZDe(t, e) {
    L("TSOptionalType", t, e);
  }
  n(ZDe, "assertTSOptionalType");
  function eOe(t, e) {
    L("TSRestType", t, e);
  }
  n(eOe, "assertTSRestType");
  function tOe(t, e) {
    L("TSNamedTupleMember", t, e);
  }
  n(tOe, "assertTSNamedTupleMember");
  function sOe(t, e) {
    L("TSUnionType", t, e);
  }
  n(sOe, "assertTSUnionType");
  function iOe(t, e) {
    L("TSIntersectionType", t, e);
  }
  n(iOe, "assertTSIntersectionType");
  function rOe(t, e) {
    L("TSConditionalType", t, e);
  }
  n(rOe, "assertTSConditionalType");
  function nOe(t, e) {
    L("TSInferType", t, e);
  }
  n(nOe, "assertTSInferType");
  function aOe(t, e) {
    L("TSParenthesizedType", t, e);
  }
  n(aOe, "assertTSParenthesizedType");
  function oOe(t, e) {
    L("TSTypeOperator", t, e);
  }
  n(oOe, "assertTSTypeOperator");
  function lOe(t, e) {
    L("TSIndexedAccessType", t, e);
  }
  n(lOe, "assertTSIndexedAccessType");
  function uOe(t, e) {
    L("TSMappedType", t, e);
  }
  n(uOe, "assertTSMappedType");
  function cOe(t, e) {
    L("TSTemplateLiteralType", t, e);
  }
  n(cOe, "assertTSTemplateLiteralType");
  function pOe(t, e) {
    L("TSLiteralType", t, e);
  }
  n(pOe, "assertTSLiteralType");
  function hOe(t, e) {
    L("TSExpressionWithTypeArguments", t, e);
  }
  n(hOe, "assertTSExpressionWithTypeArguments");
  function fOe(t, e) {
    L("TSInterfaceDeclaration", t, e);
  }
  n(fOe, "assertTSInterfaceDeclaration");
  function dOe(t, e) {
    L("TSInterfaceBody", t, e);
  }
  n(dOe, "assertTSInterfaceBody");
  function mOe(t, e) {
    L("TSTypeAliasDeclaration", t, e);
  }
  n(mOe, "assertTSTypeAliasDeclaration");
  function yOe(t, e) {
    L("TSInstantiationExpression", t, e);
  }
  n(yOe, "assertTSInstantiationExpression");
  function gOe(t, e) {
    L("TSAsExpression", t, e);
  }
  n(gOe, "assertTSAsExpression");
  function TOe(t, e) {
    L("TSSatisfiesExpression", t, e);
  }
  n(TOe, "assertTSSatisfiesExpression");
  function bOe(t, e) {
    L("TSTypeAssertion", t, e);
  }
  n(bOe, "assertTSTypeAssertion");
  function xOe(t, e) {
    L("TSEnumBody", t, e);
  }
  n(xOe, "assertTSEnumBody");
  function SOe(t, e) {
    L("TSEnumDeclaration", t, e);
  }
  n(SOe, "assertTSEnumDeclaration");
  function POe(t, e) {
    L("TSEnumMember", t, e);
  }
  n(POe, "assertTSEnumMember");
  function EOe(t, e) {
    L("TSModuleDeclaration", t, e);
  }
  n(EOe, "assertTSModuleDeclaration");
  function AOe(t, e) {
    L("TSModuleBlock", t, e);
  }
  n(AOe, "assertTSModuleBlock");
  function vOe(t, e) {
    L("TSImportType", t, e);
  }
  n(vOe, "assertTSImportType");
  function COe(t, e) {
    L("TSImportEqualsDeclaration", t, e);
  }
  n(COe, "assertTSImportEqualsDeclaration");
  function wOe(t, e) {
    L("TSExternalModuleReference", t, e);
  }
  n(wOe, "assertTSExternalModuleReference");
  function IOe(t, e) {
    L("TSNonNullExpression", t, e);
  }
  n(IOe, "assertTSNonNullExpression");
  function NOe(t, e) {
    L("TSExportAssignment", t, e);
  }
  n(NOe, "assertTSExportAssignment");
  function kOe(t, e) {
    L("TSNamespaceExportDeclaration", t, e);
  }
  n(kOe, "assertTSNamespaceExportDeclaration");
  function DOe(t, e) {
    L("TSTypeAnnotation", t, e);
  }
  n(DOe, "assertTSTypeAnnotation");
  function OOe(t, e) {
    L("TSTypeParameterInstantiation", t, e);
  }
  n(OOe, "assertTSTypeParameterInstantiation");
  function _Oe(t, e) {
    L("TSTypeParameterDeclaration", t, e);
  }
  n(_Oe, "assertTSTypeParameterDeclaration");
  function LOe(t, e) {
    L("TSTypeParameter", t, e);
  }
  n(LOe, "assertTSTypeParameter");
  function BOe(t, e) {
    L("Standardized", t, e);
  }
  n(BOe, "assertStandardized");
  function MOe(t, e) {
    L("Expression", t, e);
  }
  n(MOe, "assertExpression");
  function FOe(t, e) {
    L("Binary", t, e);
  }
  n(FOe, "assertBinary");
  function jOe(t, e) {
    L("Scopable", t, e);
  }
  n(jOe, "assertScopable");
  function ROe(t, e) {
    L("BlockParent", t, e);
  }
  n(ROe, "assertBlockParent");
  function qOe(t, e) {
    L("Block", t, e);
  }
  n(qOe, "assertBlock");
  function UOe(t, e) {
    L("Statement", t, e);
  }
  n(UOe, "assertStatement");
  function KOe(t, e) {
    L("Terminatorless", t, e);
  }
  n(KOe, "assertTerminatorless");
  function VOe(t, e) {
    L("CompletionStatement", t, e);
  }
  n(VOe, "assertCompletionStatement");
  function WOe(t, e) {
    L("Conditional", t, e);
  }
  n(WOe, "assertConditional");
  function $Oe(t, e) {
    L("Loop", t, e);
  }
  n($Oe, "assertLoop");
  function HOe(t, e) {
    L("While", t, e);
  }
  n(HOe, "assertWhile");
  function JOe(t, e) {
    L("ExpressionWrapper", t, e);
  }
  n(JOe, "assertExpressionWrapper");
  function YOe(t, e) {
    L("For", t, e);
  }
  n(YOe, "assertFor");
  function XOe(t, e) {
    L("ForXStatement", t, e);
  }
  n(XOe, "assertForXStatement");
  function zOe(t, e) {
    L("Function", t, e);
  }
  n(zOe, "assertFunction");
  function GOe(t, e) {
    L("FunctionParent", t, e);
  }
  n(GOe, "assertFunctionParent");
  function QOe(t, e) {
    L("Pureish", t, e);
  }
  n(QOe, "assertPureish");
  function ZOe(t, e) {
    L("Declaration", t, e);
  }
  n(ZOe, "assertDeclaration");
  function e2e(t, e) {
    L("PatternLike", t, e);
  }
  n(e2e, "assertPatternLike");
  function t2e(t, e) {
    L("LVal", t, e);
  }
  n(t2e, "assertLVal");
  function s2e(t, e) {
    L("TSEntityName", t, e);
  }
  n(s2e, "assertTSEntityName");
  function i2e(t, e) {
    L("Literal", t, e);
  }
  n(i2e, "assertLiteral");
  function r2e(t, e) {
    L("Immutable", t, e);
  }
  n(r2e, "assertImmutable");
  function n2e(t, e) {
    L("UserWhitespacable", t, e);
  }
  n(n2e, "assertUserWhitespacable");
  function a2e(t, e) {
    L("Method", t, e);
  }
  n(a2e, "assertMethod");
  function o2e(t, e) {
    L("ObjectMember", t, e);
  }
  n(o2e, "assertObjectMember");
  function l2e(t, e) {
    L("Property", t, e);
  }
  n(l2e, "assertProperty");
  function u2e(t, e) {
    L("UnaryLike", t, e);
  }
  n(u2e, "assertUnaryLike");
  function c2e(t, e) {
    L("Pattern", t, e);
  }
  n(c2e, "assertPattern");
  function p2e(t, e) {
    L("Class", t, e);
  }
  n(p2e, "assertClass");
  function h2e(t, e) {
    L("ImportOrExportDeclaration", t, e);
  }
  n(h2e, "assertImportOrExportDeclaration");
  function f2e(t, e) {
    L("ExportDeclaration", t, e);
  }
  n(f2e, "assertExportDeclaration");
  function d2e(t, e) {
    L("ModuleSpecifier", t, e);
  }
  n(d2e, "assertModuleSpecifier");
  function m2e(t, e) {
    L("Accessor", t, e);
  }
  n(m2e, "assertAccessor");
  function y2e(t, e) {
    L("Private", t, e);
  }
  n(y2e, "assertPrivate");
  function g2e(t, e) {
    L("Flow", t, e);
  }
  n(g2e, "assertFlow");
  function T2e(t, e) {
    L("FlowType", t, e);
  }
  n(T2e, "assertFlowType");
  function b2e(t, e) {
    L("FlowBaseAnnotation", t, e);
  }
  n(b2e, "assertFlowBaseAnnotation");
  function x2e(t, e) {
    L("FlowDeclaration", t, e);
  }
  n(x2e, "assertFlowDeclaration");
  function S2e(t, e) {
    L("FlowPredicate", t, e);
  }
  n(S2e, "assertFlowPredicate");
  function P2e(t, e) {
    L("EnumBody", t, e);
  }
  n(P2e, "assertEnumBody");
  function E2e(t, e) {
    L("EnumMember", t, e);
  }
  n(E2e, "assertEnumMember");
  function A2e(t, e) {
    L("JSX", t, e);
  }
  n(A2e, "assertJSX");
  function v2e(t, e) {
    L("Miscellaneous", t, e);
  }
  n(v2e, "assertMiscellaneous");
  function C2e(t, e) {
    L("TypeScript", t, e);
  }
  n(C2e, "assertTypeScript");
  function w2e(t, e) {
    L("TSTypeElement", t, e);
  }
  n(w2e, "assertTSTypeElement");
  function I2e(t, e) {
    L("TSType", t, e);
  }
  n(I2e, "assertTSType");
  function N2e(t, e) {
    L("TSBaseType", t, e);
  }
  n(N2e, "assertTSBaseType");
  function k2e(t, e) {
    (0, Jy.default)("assertNumberLiteral", "assertNumericLiteral"), L("NumberLiteral", t, e);
  }
  n(k2e, "assertNumberLiteral");
  function D2e(t, e) {
    (0, Jy.default)("assertRegexLiteral", "assertRegExpLiteral"), L("RegexLiteral", t, e);
  }
  n(D2e, "assertRegexLiteral");
  function O2e(t, e) {
    (0, Jy.default)("assertRestProperty", "assertRestElement"), L("RestProperty", t, e);
  }
  n(O2e, "assertRestProperty");
  function _2e(t, e) {
    (0, Jy.default)("assertSpreadProperty", "assertSpreadElement"), L("SpreadProperty", t, e);
  }
  n(_2e, "assertSpreadProperty");
  function L2e(t, e) {
    (0, Jy.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), L("ModuleDeclaration", t, e);
  }
  n(L2e, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var Pq = g((qb) => {
  "use strict";
  Object.defineProperty(qb, "__esModule", {
    value: !0
  });
  qb.default = void 0;
  var mo = ta(), Pjs = qb.default = B2e;
  function B2e(t) {
    switch (t) {
      case "string":
        return (0, mo.stringTypeAnnotation)();
      case "number":
        return (0, mo.numberTypeAnnotation)();
      case "undefined":
        return (0, mo.voidTypeAnnotation)();
      case "boolean":
        return (0, mo.booleanTypeAnnotation)();
      case "function":
        return (0, mo.genericTypeAnnotation)((0, mo.identifier)("Function"));
      case "object":
        return (0, mo.genericTypeAnnotation)((0, mo.identifier)("Object"));
      case "symbol":
        return (0, mo.genericTypeAnnotation)((0, mo.identifier)("Symbol"));
      case "bigint":
        return (0, mo.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  n(B2e, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var pw = g((cw) => {
  "use strict";
  Object.defineProperty(cw, "__esModule", {
    value: !0
  });
  cw.default = Aq;
  var Yy = tr();
  function Eq(t) {
    return (0, Yy.isIdentifier)(t) ? t.name : `${t.id.name}.${Eq(t.qualification)}`;
  }
  n(Eq, "getQualifiedName");
  function Aq(t) {
    let e = Array.from(t), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !a.includes(l)) {
        if ((0, Yy.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Yy.isFlowBaseAnnotation)(l)) {
          i.set(l.type, l);
          continue;
        }
        if ((0, Yy.isUnionTypeAnnotation)(l)) {
          r.has(l.types) || (e.push(...l.types), r.add(l.types));
          continue;
        }
        if ((0, Yy.isGenericTypeAnnotation)(l)) {
          let u = Eq(l.id);
          if (s.has(u)) {
            let c = s.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Aq(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            s.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of s)
      a.push(o);
    return a;
  }
  n(Aq, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var vq = g((hw) => {
  "use strict";
  Object.defineProperty(hw, "__esModule", {
    value: !0
  });
  hw.default = j2e;
  var M2e = ta(), F2e = pw();
  function j2e(t) {
    let e = (0, F2e.default)(t);
    return e.length === 1 ? e[0] : (0, M2e.unionTypeAnnotation)(e);
  }
  n(j2e, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var Iq = g((fw) => {
  "use strict";
  Object.defineProperty(fw, "__esModule", {
    value: !0
  });
  fw.default = wq;
  var id = tr();
  function Cq(t) {
    return (0, id.isIdentifier)(t) ? t.name : (0, id.isThisExpression)(t) ? "this" : `${t.right.name}.${Cq(t.left)}`;
  }
  n(Cq, "getQualifiedName");
  function wq(t) {
    let e = Array.from(t), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (!l || a.includes(l))
        continue;
      if ((0, id.isTSAnyKeyword)(l))
        return [l];
      if ((0, id.isTSBaseType)(l)) {
        i.set(l.type, l);
        continue;
      }
      if ((0, id.isTSUnionType)(l)) {
        r.has(l.types) || (e.push(...l.types), r.add(l.types));
        continue;
      }
      let u = "typeParameters";
      if ((0, id.isTSTypeReference)(l) && l[u]) {
        let c = l[u], p = Cq(l.typeName);
        if (s.has(p)) {
          let h = s.get(p), f = h[u];
          f ? (f.params.push(...c.params), f.params = wq(f.params)) : h = c;
        } else
          s.set(p, l);
        continue;
      }
      a.push(l);
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of s)
      a.push(o);
    return a;
  }
  n(wq, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var Nq = g((dw) => {
  "use strict";
  Object.defineProperty(dw, "__esModule", {
    value: !0
  });
  dw.default = K2e;
  var R2e = ta(), q2e = Iq(), U2e = tr();
  function K2e(t) {
    let e = t.map((i) => (0, U2e.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), s = (0, q2e.default)(e);
    return s.length === 1 ? s[0] : (0, R2e.tsUnionType)(s);
  }
  n(K2e, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var yw = g((mw) => {
  "use strict";
  Object.defineProperty(mw, "__esModule", {
    value: !0
  });
  mw.buildUndefinedNode = V2e;
  var kq = ta();
  function V2e() {
    return (0, kq.unaryExpression)("void", (0, kq.numericLiteral)(0), !0);
  }
  n(V2e, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Ec = g((Tw) => {
  "use strict";
  Object.defineProperty(Tw, "__esModule", {
    value: !0
  });
  Tw.default = W2e;
  var Dq = Pa(), Oq = tr(), {
    hasOwn: zo
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function _q(t, e, s, i) {
    return t && typeof t.type == "string" ? Lq(t, e, s, i) : t;
  }
  n(_q, "cloneIfNode");
  function gw(t, e, s, i) {
    return Array.isArray(t) ? t.map((r) => _q(r, e, s, i)) : _q(t, e, s, i);
  }
  n(gw, "cloneIfNodeOrArray");
  function W2e(t, e = !0, s = !1) {
    return Lq(t, e, s, /* @__PURE__ */ new Map());
  }
  n(W2e, "cloneNode");
  function Lq(t, e = !0, s = !1, i) {
    if (!t) return t;
    let {
      type: r
    } = t, a = {
      type: t.type
    };
    if ((0, Oq.isIdentifier)(t))
      a.name = t.name, zo(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), zo(t, "typeAnnotation") && (a.typeAnnotation =
      e ? gw(t.typeAnnotation, !0, s, i) : t.typeAnnotation), zo(t, "decorators") && (a.decorators = e ? gw(t.decorators, !0, s, i) : t.decorators);
    else if (zo(Dq.NODE_FIELDS, r))
      for (let o of Object.keys(Dq.NODE_FIELDS[r]))
        zo(t, o) && (e ? a[o] = (0, Oq.isFile)(t) && o === "comments" ? Ub(t.comments, e, s, i) : gw(t[o], !0, s, i) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${r}"`);
    return zo(t, "loc") && (s ? a.loc = null : a.loc = t.loc), zo(t, "leadingComments") && (a.leadingComments = Ub(t.leadingComments, e, s, i)),
    zo(t, "innerComments") && (a.innerComments = Ub(t.innerComments, e, s, i)), zo(t, "trailingComments") && (a.trailingComments = Ub(t.trailingComments,
    e, s, i)), zo(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  n(Lq, "cloneNodeInternal");
  function Ub(t, e, s, i) {
    return !t || !e ? t : t.map((r) => {
      let a = i.get(r);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = r, c = {
        type: o,
        value: l,
        loc: u
      };
      return s && (c.loc = null), i.set(r, c), c;
    });
  }
  n(Ub, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var Bq = g((bw) => {
  "use strict";
  Object.defineProperty(bw, "__esModule", {
    value: !0
  });
  bw.default = H2e;
  var $2e = Ec();
  function H2e(t) {
    return (0, $2e.default)(t, !1);
  }
  n(H2e, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var Mq = g((xw) => {
  "use strict";
  Object.defineProperty(xw, "__esModule", {
    value: !0
  });
  xw.default = Y2e;
  var J2e = Ec();
  function Y2e(t) {
    return (0, J2e.default)(t);
  }
  n(Y2e, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var Fq = g((Sw) => {
  "use strict";
  Object.defineProperty(Sw, "__esModule", {
    value: !0
  });
  Sw.default = z2e;
  var X2e = Ec();
  function z2e(t) {
    return (0, X2e.default)(t, !0, !0);
  }
  n(z2e, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var jq = g((Pw) => {
  "use strict";
  Object.defineProperty(Pw, "__esModule", {
    value: !0
  });
  Pw.default = Q2e;
  var G2e = Ec();
  function Q2e(t) {
    return (0, G2e.default)(t, !1, !0);
  }
  n(Q2e, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var Aw = g((Ew) => {
  "use strict";
  Object.defineProperty(Ew, "__esModule", {
    value: !0
  });
  Ew.default = Z2e;
  function Z2e(t, e, s) {
    if (!s || !t) return t;
    let i = `${e}Comments`;
    return t[i] ? e === "leading" ? t[i] = s.concat(t[i]) : t[i].push(...s) : t[i] = s, t;
  }
  n(Z2e, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var Rq = g((vw) => {
  "use strict";
  Object.defineProperty(vw, "__esModule", {
    value: !0
  });
  vw.default = t_e;
  var e_e = Aw();
  function t_e(t, e, s, i) {
    return (0, e_e.default)(t, e, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: s
    }]);
  }
  n(t_e, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Kb = g((Cw) => {
  "use strict";
  Object.defineProperty(Cw, "__esModule", {
    value: !0
  });
  Cw.default = s_e;
  function s_e(t, e, s) {
    e && s && (e[t] = Array.from(new Set([].concat(e[t], s[t]).filter(Boolean))));
  }
  n(s_e, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var Iw = g((ww) => {
  "use strict";
  Object.defineProperty(ww, "__esModule", {
    value: !0
  });
  ww.default = r_e;
  var i_e = Kb();
  function r_e(t, e) {
    (0, i_e.default)("innerComments", t, e);
  }
  n(r_e, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var kw = g((Nw) => {
  "use strict";
  Object.defineProperty(Nw, "__esModule", {
    value: !0
  });
  Nw.default = a_e;
  var n_e = Kb();
  function a_e(t, e) {
    (0, n_e.default)("leadingComments", t, e);
  }
  n(a_e, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var Ow = g((Dw) => {
  "use strict";
  Object.defineProperty(Dw, "__esModule", {
    value: !0
  });
  Dw.default = l_e;
  var o_e = Kb();
  function l_e(t, e) {
    (0, o_e.default)("trailingComments", t, e);
  }
  n(l_e, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var Lw = g((_w) => {
  "use strict";
  Object.defineProperty(_w, "__esModule", {
    value: !0
  });
  _w.default = h_e;
  var u_e = Ow(), c_e = kw(), p_e = Iw();
  function h_e(t, e) {
    return (0, u_e.default)(t, e), (0, c_e.default)(t, e), (0, p_e.default)(t, e), t;
  }
  n(h_e, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var qq = g((Bw) => {
  "use strict";
  Object.defineProperty(Bw, "__esModule", {
    value: !0
  });
  Bw.default = d_e;
  var f_e = Zf();
  function d_e(t) {
    return f_e.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  n(d_e, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var Uq = g((Ce) => {
  "use strict";
  Object.defineProperty(Ce, "__esModule", {
    value: !0
  });
  Ce.WHILE_TYPES = Ce.USERWHITESPACABLE_TYPES = Ce.UNARYLIKE_TYPES = Ce.TYPESCRIPT_TYPES = Ce.TSTYPE_TYPES = Ce.TSTYPEELEMENT_TYPES = Ce.TSENTITYNAME_TYPES =
  Ce.TSBASETYPE_TYPES = Ce.TERMINATORLESS_TYPES = Ce.STATEMENT_TYPES = Ce.STANDARDIZED_TYPES = Ce.SCOPABLE_TYPES = Ce.PUREISH_TYPES = Ce.PROPERTY_TYPES =
  Ce.PRIVATE_TYPES = Ce.PATTERN_TYPES = Ce.PATTERNLIKE_TYPES = Ce.OBJECTMEMBER_TYPES = Ce.MODULESPECIFIER_TYPES = Ce.MODULEDECLARATION_TYPES =
  Ce.MISCELLANEOUS_TYPES = Ce.METHOD_TYPES = Ce.LVAL_TYPES = Ce.LOOP_TYPES = Ce.LITERAL_TYPES = Ce.JSX_TYPES = Ce.IMPORTOREXPORTDECLARATION_TYPES =
  Ce.IMMUTABLE_TYPES = Ce.FUNCTION_TYPES = Ce.FUNCTIONPARENT_TYPES = Ce.FOR_TYPES = Ce.FORXSTATEMENT_TYPES = Ce.FLOW_TYPES = Ce.FLOWTYPE_TYPES =
  Ce.FLOWPREDICATE_TYPES = Ce.FLOWDECLARATION_TYPES = Ce.FLOWBASEANNOTATION_TYPES = Ce.EXPRESSION_TYPES = Ce.EXPRESSIONWRAPPER_TYPES = Ce.EXPORTDECLARATION_TYPES =
  Ce.ENUMMEMBER_TYPES = Ce.ENUMBODY_TYPES = Ce.DECLARATION_TYPES = Ce.CONDITIONAL_TYPES = Ce.COMPLETIONSTATEMENT_TYPES = Ce.CLASS_TYPES = Ce.
  BLOCK_TYPES = Ce.BLOCKPARENT_TYPES = Ce.BINARY_TYPES = Ce.ACCESSOR_TYPES = void 0;
  var Wt = Pa(), o8s = Ce.STANDARDIZED_TYPES = Wt.FLIPPED_ALIAS_KEYS.Standardized, l8s = Ce.EXPRESSION_TYPES = Wt.FLIPPED_ALIAS_KEYS.Expression,
  u8s = Ce.BINARY_TYPES = Wt.FLIPPED_ALIAS_KEYS.Binary, c8s = Ce.SCOPABLE_TYPES = Wt.FLIPPED_ALIAS_KEYS.Scopable, p8s = Ce.BLOCKPARENT_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.BlockParent, h8s = Ce.BLOCK_TYPES = Wt.FLIPPED_ALIAS_KEYS.Block, f8s = Ce.STATEMENT_TYPES = Wt.FLIPPED_ALIAS_KEYS.Statement,
  d8s = Ce.TERMINATORLESS_TYPES = Wt.FLIPPED_ALIAS_KEYS.Terminatorless, m8s = Ce.COMPLETIONSTATEMENT_TYPES = Wt.FLIPPED_ALIAS_KEYS.CompletionStatement,
  y8s = Ce.CONDITIONAL_TYPES = Wt.FLIPPED_ALIAS_KEYS.Conditional, g8s = Ce.LOOP_TYPES = Wt.FLIPPED_ALIAS_KEYS.Loop, T8s = Ce.WHILE_TYPES = Wt.
  FLIPPED_ALIAS_KEYS.While, b8s = Ce.EXPRESSIONWRAPPER_TYPES = Wt.FLIPPED_ALIAS_KEYS.ExpressionWrapper, x8s = Ce.FOR_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  For, S8s = Ce.FORXSTATEMENT_TYPES = Wt.FLIPPED_ALIAS_KEYS.ForXStatement, P8s = Ce.FUNCTION_TYPES = Wt.FLIPPED_ALIAS_KEYS.Function, E8s = Ce.
  FUNCTIONPARENT_TYPES = Wt.FLIPPED_ALIAS_KEYS.FunctionParent, A8s = Ce.PUREISH_TYPES = Wt.FLIPPED_ALIAS_KEYS.Pureish, v8s = Ce.DECLARATION_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.Declaration, C8s = Ce.PATTERNLIKE_TYPES = Wt.FLIPPED_ALIAS_KEYS.PatternLike, w8s = Ce.LVAL_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  LVal, I8s = Ce.TSENTITYNAME_TYPES = Wt.FLIPPED_ALIAS_KEYS.TSEntityName, N8s = Ce.LITERAL_TYPES = Wt.FLIPPED_ALIAS_KEYS.Literal, k8s = Ce.IMMUTABLE_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.Immutable, D8s = Ce.USERWHITESPACABLE_TYPES = Wt.FLIPPED_ALIAS_KEYS.UserWhitespacable, O8s = Ce.METHOD_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  Method, _8s = Ce.OBJECTMEMBER_TYPES = Wt.FLIPPED_ALIAS_KEYS.ObjectMember, L8s = Ce.PROPERTY_TYPES = Wt.FLIPPED_ALIAS_KEYS.Property, B8s = Ce.
  UNARYLIKE_TYPES = Wt.FLIPPED_ALIAS_KEYS.UnaryLike, M8s = Ce.PATTERN_TYPES = Wt.FLIPPED_ALIAS_KEYS.Pattern, F8s = Ce.CLASS_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  Class, m_e = Ce.IMPORTOREXPORTDECLARATION_TYPES = Wt.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, j8s = Ce.EXPORTDECLARATION_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  ExportDeclaration, R8s = Ce.MODULESPECIFIER_TYPES = Wt.FLIPPED_ALIAS_KEYS.ModuleSpecifier, q8s = Ce.ACCESSOR_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  Accessor, U8s = Ce.PRIVATE_TYPES = Wt.FLIPPED_ALIAS_KEYS.Private, K8s = Ce.FLOW_TYPES = Wt.FLIPPED_ALIAS_KEYS.Flow, V8s = Ce.FLOWTYPE_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.FlowType, W8s = Ce.FLOWBASEANNOTATION_TYPES = Wt.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, $8s = Ce.FLOWDECLARATION_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.FlowDeclaration, H8s = Ce.FLOWPREDICATE_TYPES = Wt.FLIPPED_ALIAS_KEYS.FlowPredicate, J8s = Ce.ENUMBODY_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  EnumBody, Y8s = Ce.ENUMMEMBER_TYPES = Wt.FLIPPED_ALIAS_KEYS.EnumMember, X8s = Ce.JSX_TYPES = Wt.FLIPPED_ALIAS_KEYS.JSX, z8s = Ce.MISCELLANEOUS_TYPES =
  Wt.FLIPPED_ALIAS_KEYS.Miscellaneous, G8s = Ce.TYPESCRIPT_TYPES = Wt.FLIPPED_ALIAS_KEYS.TypeScript, Q8s = Ce.TSTYPEELEMENT_TYPES = Wt.FLIPPED_ALIAS_KEYS.
  TSTypeElement, Z8s = Ce.TSTYPE_TYPES = Wt.FLIPPED_ALIAS_KEYS.TSType, e6s = Ce.TSBASETYPE_TYPES = Wt.FLIPPED_ALIAS_KEYS.TSBaseType, t6s = Ce.
  MODULEDECLARATION_TYPES = m_e;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var jw = g((Fw) => {
  "use strict";
  Object.defineProperty(Fw, "__esModule", {
    value: !0
  });
  Fw.default = y_e;
  var Vb = tr(), Mw = ta();
  function y_e(t, e) {
    if ((0, Vb.isBlockStatement)(t))
      return t;
    let s = [];
    return (0, Vb.isEmptyStatement)(t) ? s = [] : ((0, Vb.isStatement)(t) || ((0, Vb.isFunction)(e) ? t = (0, Mw.returnStatement)(t) : t = (0, Mw.
    expressionStatement)(t)), s = [t]), (0, Mw.blockStatement)(s);
  }
  n(y_e, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var Kq = g((Rw) => {
  "use strict";
  Object.defineProperty(Rw, "__esModule", {
    value: !0
  });
  Rw.default = T_e;
  var g_e = jw();
  function T_e(t, e = "body") {
    let s = (0, g_e.default)(t[e], t);
    return t[e] = s, s;
  }
  n(T_e, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Uw = g((qw) => {
  "use strict";
  Object.defineProperty(qw, "__esModule", {
    value: !0
  });
  qw.default = S_e;
  var b_e = Qf(), x_e = Ea();
  function S_e(t) {
    t = t + "";
    let e = "";
    for (let s of t)
      e += (0, x_e.isIdentifierChar)(s.codePointAt(0)) ? s : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(s, i) {
      return i ? i.toUpperCase() : "";
    }), (0, b_e.default)(e) || (e = `_${e}`), e || "_";
  }
  n(S_e, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var Vq = g((Kw) => {
  "use strict";
  Object.defineProperty(Kw, "__esModule", {
    value: !0
  });
  Kw.default = E_e;
  var P_e = Uw();
  function E_e(t) {
    return t = (0, P_e.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  n(E_e, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var Wq = g((Vw) => {
  "use strict";
  Object.defineProperty(Vw, "__esModule", {
    value: !0
  });
  Vw.default = C_e;
  var A_e = tr(), v_e = ta();
  function C_e(t, e = t.key || t.property) {
    return !t.computed && (0, A_e.isIdentifier)(e) && (e = (0, v_e.stringLiteral)(e.name)), e;
  }
  n(C_e, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var $q = g((Wb) => {
  "use strict";
  Object.defineProperty(Wb, "__esModule", {
    value: !0
  });
  Wb.default = void 0;
  var Xy = tr(), f6s = Wb.default = w_e;
  function w_e(t) {
    if ((0, Xy.isExpressionStatement)(t) && (t = t.expression), (0, Xy.isExpression)(t))
      return t;
    if ((0, Xy.isClass)(t) ? t.type = "ClassExpression" : (0, Xy.isFunction)(t) && (t.type = "FunctionExpression"), !(0, Xy.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  n(w_e, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var $w = g((Ww) => {
  "use strict";
  Object.defineProperty(Ww, "__esModule", {
    value: !0
  });
  Ww.default = zy;
  var I_e = Pa(), Hq = Symbol(), Jq = Symbol();
  function zy(t, e, s) {
    if (!t) return !1;
    let i = I_e.VISITOR_KEYS[t.type];
    if (!i) return !1;
    s = s || {};
    let r = e(t, s);
    if (r !== void 0)
      switch (r) {
        case Hq:
          return !1;
        case Jq:
          return !0;
      }
    for (let a of i) {
      let o = t[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let l of o)
            if (zy(l, e, s)) return !0;
        } else if (zy(o, e, s)) return !0;
      }
    }
    return !1;
  }
  n(zy, "traverseFast");
  zy.skip = Hq;
  zy.stop = Jq;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Jw = g((Hw) => {
  "use strict";
  Object.defineProperty(Hw, "__esModule", {
    value: !0
  });
  Hw.default = D_e;
  var N_e = Zf(), Yq = ["tokens", "start", "end", "loc", "raw", "rawValue"], k_e = [...N_e.COMMENT_KEYS, "comments", ...Yq];
  function D_e(t, e = {}) {
    let s = e.preserveComments ? Yq : k_e;
    for (let r of s)
      t[r] != null && (t[r] = void 0);
    for (let r of Object.keys(t))
      r[0] === "_" && t[r] != null && (t[r] = void 0);
    let i = Object.getOwnPropertySymbols(t);
    for (let r of i)
      t[r] = null;
  }
  n(D_e, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Xw = g((Yw) => {
  "use strict";
  Object.defineProperty(Yw, "__esModule", {
    value: !0
  });
  Yw.default = L_e;
  var O_e = $w(), __e = Jw();
  function L_e(t, e) {
    return (0, O_e.default)(t, __e.default, e), t;
  }
  n(L_e, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var zq = g((zw) => {
  "use strict";
  Object.defineProperty(zw, "__esModule", {
    value: !0
  });
  zw.default = Qp;
  var Xq = tr(), B_e = Ec(), M_e = Xw();
  function Qp(t, e = t.key) {
    let s;
    return t.kind === "method" ? Qp.increment() + "" : ((0, Xq.isIdentifier)(e) ? s = e.name : (0, Xq.isStringLiteral)(e) ? s = JSON.stringify(
    e.value) : s = JSON.stringify((0, M_e.default)((0, B_e.default)(e))), t.computed && (s = `[${s}]`), t.static && (s = `static:${s}`), s);
  }
  n(Qp, "toKeyAlias");
  Qp.uid = 0;
  Qp.increment = function() {
    return Qp.uid >= Number.MAX_SAFE_INTEGER ? Qp.uid = 0 : Qp.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var Gq = g((Hb) => {
  "use strict";
  Object.defineProperty(Hb, "__esModule", {
    value: !0
  });
  Hb.default = void 0;
  var $b = tr(), F_e = ta(), A6s = Hb.default = j_e;
  function j_e(t, e) {
    if ((0, $b.isStatement)(t))
      return t;
    let s = !1, i;
    if ((0, $b.isClass)(t))
      s = !0, i = "ClassDeclaration";
    else if ((0, $b.isFunction)(t))
      s = !0, i = "FunctionDeclaration";
    else if ((0, $b.isAssignmentExpression)(t))
      return (0, F_e.expressionStatement)(t);
    if (s && !t.id && (i = !1), !i) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = i, t;
  }
  n(j_e, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var Qq = g((Jb) => {
  "use strict";
  Object.defineProperty(Jb, "__esModule", {
    value: !0
  });
  Jb.default = void 0;
  var R_e = Qf(), Or = ta(), w6s = Jb.default = Gw, q_e = Function.call.bind(Object.prototype.toString);
  function U_e(t) {
    return q_e(t) === "[object RegExp]";
  }
  n(U_e, "isRegExp");
  function K_e(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  n(K_e, "isPlainObject");
  function Gw(t) {
    if (t === void 0)
      return (0, Or.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, Or.booleanLiteral)(t);
    if (t === null)
      return (0, Or.nullLiteral)();
    if (typeof t == "string")
      return (0, Or.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, Or.numericLiteral)(Math.abs(t));
      else {
        let s;
        Number.isNaN(t) ? s = (0, Or.numericLiteral)(0) : s = (0, Or.numericLiteral)(1), e = (0, Or.binaryExpression)("/", s, (0, Or.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, Or.unaryExpression)("-", e)), e;
    }
    if (typeof t == "bigint")
      return (0, Or.bigIntLiteral)(t.toString());
    if (U_e(t)) {
      let e = t.source, s = /\/([a-z]*)$/.exec(t.toString())[1];
      return (0, Or.regExpLiteral)(e, s);
    }
    if (Array.isArray(t))
      return (0, Or.arrayExpression)(t.map(Gw));
    if (K_e(t)) {
      let e = [];
      for (let s of Object.keys(t)) {
        let i, r = !1;
        (0, R_e.default)(s) ? s === "__proto__" ? (r = !0, i = (0, Or.stringLiteral)(s)) : i = (0, Or.identifier)(s) : i = (0, Or.stringLiteral)(
        s), e.push((0, Or.objectProperty)(i, Gw(t[s]), r));
      }
      return (0, Or.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(Gw, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var Zq = g((Qw) => {
  "use strict";
  Object.defineProperty(Qw, "__esModule", {
    value: !0
  });
  Qw.default = W_e;
  var V_e = ta();
  function W_e(t, e, s = !1) {
    return t.object = (0, V_e.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!s, t;
  }
  n(W_e, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var tU = g((Zw) => {
  "use strict";
  Object.defineProperty(Zw, "__esModule", {
    value: !0
  });
  Zw.default = H_e;
  var eU = Zf(), $_e = Lw();
  function H_e(t, e) {
    if (!t || !e) return t;
    for (let s of eU.INHERIT_KEYS.optional)
      t[s] == null && (t[s] = e[s]);
    for (let s of Object.keys(e))
      s[0] === "_" && s !== "__clone" && (t[s] = e[s]);
    for (let s of eU.INHERIT_KEYS.force)
      t[s] = e[s];
    return (0, $_e.default)(t, e), t;
  }
  n(H_e, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var sU = g((eI) => {
  "use strict";
  Object.defineProperty(eI, "__esModule", {
    value: !0
  });
  eI.default = X_e;
  var J_e = ta(), Y_e = fe();
  function X_e(t, e) {
    if ((0, Y_e.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, J_e.memberExpression)(e, t.object), t;
  }
  n(X_e, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var iU = g((tI) => {
  "use strict";
  Object.defineProperty(tI, "__esModule", {
    value: !0
  });
  tI.default = z_e;
  function z_e(t) {
    let e = [].concat(t), s = /* @__PURE__ */ Object.create(null);
    for (; e.length; ) {
      let i = e.pop();
      if (i)
        switch (i.type) {
          case "ArrayPattern":
            e.push(...i.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            e.push(i.left);
            break;
          case "ObjectPattern":
            e.push(...i.properties);
            break;
          case "ObjectProperty":
            e.push(i.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            e.push(i.argument);
            break;
          case "UnaryExpression":
            i.operator === "delete" && e.push(i.argument);
            break;
          case "Identifier":
            s[i.name] = i;
            break;
          default:
            break;
        }
    }
    return s;
  }
  n(z_e, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Gy = g((iI) => {
  "use strict";
  Object.defineProperty(iI, "__esModule", {
    value: !0
  });
  iI.default = sI;
  var Kl = tr();
  function sI(t, e, s, i) {
    let r = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; r.length; ) {
      let o = r.shift();
      if (!o || i && ((0, Kl.isAssignmentExpression)(o) || (0, Kl.isUnaryExpression)(o) || (0, Kl.isUpdateExpression)(o)))
        continue;
      if ((0, Kl.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, Kl.isExportDeclaration)(o) && !(0, Kl.isExportAllDeclaration)(o)) {
        (0, Kl.isDeclaration)(o.declaration) && r.push(o.declaration);
        continue;
      }
      if (s) {
        if ((0, Kl.isFunctionDeclaration)(o)) {
          r.push(o.id);
          continue;
        }
        if ((0, Kl.isFunctionExpression)(o))
          continue;
      }
      let l = sI.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? r.push(...p) : r.push(p));
        }
    }
    return a;
  }
  n(sI, "getBindingIdentifiers");
  var G_e = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  sI.keys = G_e;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var rU = g((Yb) => {
  "use strict";
  Object.defineProperty(Yb, "__esModule", {
    value: !0
  });
  Yb.default = void 0;
  var Q_e = Gy(), q6s = Yb.default = Z_e;
  function Z_e(t, e) {
    return (0, Q_e.default)(t, e, !0);
  }
  n(Z_e, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var aU = g((rI) => {
  "use strict";
  Object.defineProperty(rI, "__esModule", {
    value: !0
  });
  rI.default = tLe;
  var Aa = tr();
  function eLe(t) {
    return (0, Aa.isNullLiteral)(t) ? "null" : (0, Aa.isRegExpLiteral)(t) ? `/${t.pattern}/${t.flags}` : (0, Aa.isTemplateLiteral)(t) ? t.quasis.
    map((e) => e.value.raw).join("") : t.value !== void 0 ? String(t.value) : null;
  }
  n(eLe, "getNameFromLiteralId");
  function nU(t) {
    if (!t.computed || (0, Aa.isLiteral)(t.key))
      return t.key;
  }
  n(nU, "getObjectMemberKey");
  function tLe(t, e) {
    if ("id" in t && t.id)
      return {
        name: t.id.name,
        originalNode: t.id
      };
    let s = "", i;
    if ((0, Aa.isObjectProperty)(e, {
      value: t
    }) ? i = nU(e) : (0, Aa.isObjectMethod)(t) || (0, Aa.isClassMethod)(t) ? (i = nU(t), t.kind === "get" ? s = "get " : t.kind === "set" &&
    (s = "set ")) : (0, Aa.isVariableDeclarator)(e, {
      init: t
    }) ? i = e.id : (0, Aa.isAssignmentExpression)(e, {
      operator: "=",
      right: t
    }) && (i = e.left), !i) return null;
    let r = (0, Aa.isLiteral)(i) ? eLe(i) : (0, Aa.isIdentifier)(i) ? i.name : (0, Aa.isPrivateName)(i) ? i.id.name : null;
    return r == null ? null : {
      name: s + r,
      originalNode: i
    };
  }
  n(tLe, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var oU = g((aI) => {
  "use strict";
  Object.defineProperty(aI, "__esModule", {
    value: !0
  });
  aI.default = iLe;
  var sLe = Pa();
  function iLe(t, e, s) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: i,
      exit: r
    } = e;
    nI(t, i, r, s, []);
  }
  n(iLe, "traverse");
  function nI(t, e, s, i, r) {
    let a = sLe.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, r, i);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (r.push({
              node: t,
              key: o,
              index: u
            }), nI(c, e, s, i, r), r.pop());
          }
        else l && (r.push({
          node: t,
          key: o
        }), nI(l, e, s, i, r), r.pop());
      }
      s && s(t, r, i);
    }
  }
  n(nI, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var lU = g((oI) => {
  "use strict";
  Object.defineProperty(oI, "__esModule", {
    value: !0
  });
  oI.default = nLe;
  var rLe = Gy();
  function nLe(t, e, s) {
    if (s && t.type === "Identifier" && e.type === "ObjectProperty" && s.type === "ObjectExpression")
      return !1;
    let i = rLe.default.keys[e.type];
    if (i)
      for (let r = 0; r < i.length; r++) {
        let a = i[r], o = e[a];
        if (Array.isArray(o)) {
          if (o.includes(t)) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  n(nLe, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var uI = g((lI) => {
  "use strict";
  Object.defineProperty(lI, "__esModule", {
    value: !0
  });
  lI.default = oLe;
  var aLe = tr();
  uU = Symbol.for("var used to be block scoped");
  var uU;
  function oLe(t) {
    return (0, aLe.isVariableDeclaration)(t) && (t.kind !== "var" || t[uU]);
  }
  n(oLe, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var pU = g((cI) => {
  "use strict";
  Object.defineProperty(cI, "__esModule", {
    value: !0
  });
  cI.default = uLe;
  var cU = tr(), lLe = uI();
  function uLe(t) {
    return (0, cU.isFunctionDeclaration)(t) || (0, cU.isClassDeclaration)(t) || (0, lLe.default)(t);
  }
  n(uLe, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var hU = g((pI) => {
  "use strict";
  Object.defineProperty(pI, "__esModule", {
    value: !0
  });
  pI.default = hLe;
  var cLe = Nb(), pLe = tr();
  function hLe(t) {
    return (0, cLe.default)(t.type, "Immutable") ? !0 : (0, pLe.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  n(hLe, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var dU = g((fI) => {
  "use strict";
  Object.defineProperty(fI, "__esModule", {
    value: !0
  });
  fI.default = hI;
  var fU = Pa();
  function hI(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let s = Object.keys(fU.NODE_FIELDS[t.type] || t.type), i = fU.VISITOR_KEYS[t.type];
    for (let r of s) {
      let a = t[r], o = e[r];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!hI(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(r))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!hI(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(hI, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var mU = g((dI) => {
  "use strict";
  Object.defineProperty(dI, "__esModule", {
    value: !0
  });
  dI.default = fLe;
  function fLe(t, e, s) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !s || s.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return s != null && s.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  n(fLe, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var yU = g((mI) => {
  "use strict";
  Object.defineProperty(mI, "__esModule", {
    value: !0
  });
  mI.default = dLe;
  var Zp = tr();
  function dLe(t, e) {
    return (0, Zp.isBlockStatement)(t) && ((0, Zp.isFunction)(e) || (0, Zp.isCatchClause)(e)) ? !1 : (0, Zp.isPattern)(t) && ((0, Zp.isFunction)(
    e) || (0, Zp.isCatchClause)(e)) ? !0 : (0, Zp.isScopable)(t);
  }
  n(dLe, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var TU = g((yI) => {
  "use strict";
  Object.defineProperty(yI, "__esModule", {
    value: !0
  });
  yI.default = mLe;
  var gU = tr();
  function mLe(t) {
    return (0, gU.isImportDefaultSpecifier)(t) || (0, gU.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  n(mLe, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var bU = g((gI) => {
  "use strict";
  Object.defineProperty(gI, "__esModule", {
    value: !0
  });
  gI.default = TLe;
  var yLe = Qf(), gLe = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function TLe(t) {
    return (0, yLe.default)(t) && !gLe.has(t);
  }
  n(TLe, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var SU = g((TI) => {
  "use strict";
  Object.defineProperty(TI, "__esModule", {
    value: !0
  });
  TI.default = xLe;
  var bLe = tr();
  xU = Symbol.for("var used to be block scoped");
  var xU;
  function xLe(t) {
    return (0, bLe.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[xU];
  }
  n(xLe, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var PU = g((SI) => {
  "use strict";
  Object.defineProperty(SI, "__esModule", {
    value: !0
  });
  SI.default = Xb;
  var SLe = Gy(), eh = tr(), bI = ta(), xI = yw(), PLe = Ec();
  function Xb(t, e) {
    let s = [], i = !0;
    for (let r of t)
      if ((0, eh.isEmptyStatement)(r) || (i = !1), (0, eh.isExpression)(r))
        s.push(r);
      else if ((0, eh.isExpressionStatement)(r))
        s.push(r.expression);
      else if ((0, eh.isVariableDeclaration)(r)) {
        if (r.kind !== "var") return;
        for (let a of r.declarations) {
          let o = (0, SLe.default)(a);
          for (let l of Object.keys(o))
            e.push({
              kind: r.kind,
              id: (0, PLe.default)(o[l])
            });
          a.init && s.push((0, bI.assignmentExpression)("=", a.id, a.init));
        }
        i = !0;
      } else if ((0, eh.isIfStatement)(r)) {
        let a = r.consequent ? Xb([r.consequent], e) : (0, xI.buildUndefinedNode)(), o = r.alternate ? Xb([r.alternate], e) : (0, xI.buildUndefinedNode)();
        if (!a || !o) return;
        s.push((0, bI.conditionalExpression)(r.test, a, o));
      } else if ((0, eh.isBlockStatement)(r)) {
        let a = Xb(r.body, e);
        if (!a) return;
        s.push(a);
      } else if ((0, eh.isEmptyStatement)(r))
        t.indexOf(r) === 0 && (i = !0);
      else
        return;
    return i && s.push((0, xI.buildUndefinedNode)()), s.length === 1 ? s[0] : (0, bI.sequenceExpression)(s);
  }
  n(Xb, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var EU = g((PI) => {
  "use strict";
  Object.defineProperty(PI, "__esModule", {
    value: !0
  });
  PI.default = ALe;
  var ELe = PU();
  function ALe(t, e) {
    if (!(t != null && t.length)) return;
    let s = [], i = (0, ELe.default)(t, s);
    if (i) {
      for (let r of s)
        e.push(r);
      return i;
    }
  }
  n(ALe, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var fe = g((Re) => {
  "use strict";
  Object.defineProperty(Re, "__esModule", {
    value: !0
  });
  var Ac = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(Re, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return IBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return MLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return FLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return QLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ILe.default;
    }, "get")
  });
  Object.defineProperty(Re, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return OLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _Le.default;
    }, "get")
  });
  Object.defineProperty(Re, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return LLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return DLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return BLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return AU.default;
    }, "get")
  });
  Object.defineProperty(Re, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return NLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return AU.default;
    }, "get")
  });
  Object.defineProperty(Re, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return VLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return oBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return RLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ULe.default;
    }, "get")
  });
  Object.defineProperty(Re, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ZLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return mBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return TBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return SBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return PBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return EBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ABe.default;
    }, "get")
  });
  Object.defineProperty(Re, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eBe.default;
    }, "get")
  });
  Re.react = void 0;
  Object.defineProperty(Re, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return KLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return WLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $Le.default;
    }, "get")
  });
  Object.defineProperty(Re, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return HLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return JLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return YLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return XLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zLe.default;
    }, "get")
  });
  Object.defineProperty(Re, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zb.default;
    }, "get")
  });
  Object.defineProperty(Re, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return lBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return CBe.default;
    }, "get")
  });
  Object.defineProperty(Re, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return GLe.default;
    }, "get")
  });
  var vLe = w7(), CLe = I7(), wLe = bq(), ILe = xq(), EI = Sq();
  Object.keys(EI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === EI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return EI[t];
      }, "get")
    });
  });
  var NLe = Pq(), AU = vq(), kLe = Nq(), AI = yw();
  Object.keys(AI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === AI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return AI[t];
      }, "get")
    });
  });
  var vI = ta();
  Object.keys(vI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === vI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return vI[t];
      }, "get")
    });
  });
  var DLe = Ec(), OLe = Bq(), _Le = Mq(), LLe = Fq(), BLe = jq(), MLe = Rq(), FLe = Aw(), jLe = Iw(), RLe = kw(), qLe = Lw(), ULe = Ow(), KLe = qq(),
  CI = Uq();
  Object.keys(CI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === CI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return CI[t];
      }, "get")
    });
  });
  var wI = Zf();
  Object.keys(wI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === wI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return wI[t];
      }, "get")
    });
  });
  var VLe = Kq(), WLe = Vq(), $Le = jw(), HLe = Wq(), JLe = $q(), YLe = Uw(), XLe = zq(), zLe = Gq(), GLe = Qq(), II = Pa();
  Object.keys(II).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === II[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return II[t];
      }, "get")
    });
  });
  var QLe = Zq(), ZLe = tU(), eBe = sU(), tBe = Jw(), sBe = Xw(), iBe = pw(), rBe = iU(), nBe = Gy(), aBe = rU(), oBe = aU(), zb = oU();
  Object.keys(zb).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === zb[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return zb[t];
      }, "get")
    });
  });
  var lBe = $w(), uBe = wb(), cBe = Gf(), pBe = lU(), hBe = pU(), fBe = hU(), dBe = uI(), mBe = lw(), yBe = dU(), gBe = _C(), TBe = mU(), bBe = yU(),
  xBe = TU(), SBe = Nb(), PBe = bU(), EBe = Qf(), ABe = SU(), vBe = wC(), CBe = Lb(), wBe = NC(), NI = tr();
  Object.keys(NI).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Ac, t) || t in Re && Re[t] === NI[t] || Object.defineProperty(
    Re, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return NI[t];
      }, "get")
    });
  });
  var IBe = Fy(), NBe = EU(), gRs = Re.react = {
    isReactComponent: vLe.default,
    isCompatTag: CLe.default,
    buildChildren: wLe.default
  };
  Re.toSequenceExpression = NBe.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/template/lib/formatters.js
var vU = g((va) => {
  "use strict";
  Object.defineProperty(va, "__esModule", {
    value: !0
  });
  va.statements = va.statement = va.smart = va.program = va.expression = void 0;
  var kBe = fe(), {
    assertExpressionStatement: DBe
  } = kBe;
  function kI(t) {
    return {
      code: /* @__PURE__ */ n((e) => `/* @babel/template */;
${e}`, "code"),
      validate: /* @__PURE__ */ n(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ n((e) => t(e.program.body.slice(1)), "unwrap")
    };
  }
  n(kI, "makeStatementFormatter");
  var xRs = va.smart = kI((t) => t.length > 1 ? t : t[0]), SRs = va.statements = kI((t) => t), PRs = va.statement = kI((t) => {
    if (t.length === 0)
      throw new Error("Found nothing to return.");
    if (t.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return t[0];
  }), OBe = va.expression = {
    code: /* @__PURE__ */ n((t) => `(
${t}
)`, "code"),
    validate: /* @__PURE__ */ n((t) => {
      if (t.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (OBe.unwrap(t).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ n(({
      program: t
    }) => {
      let [e] = t.body;
      return DBe(e), e.expression;
    }, "unwrap")
  }, ERs = va.program = {
    code: /* @__PURE__ */ n((t) => t, "code"),
    validate: /* @__PURE__ */ n(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ n((t) => t.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var Gb = g((Qy) => {
  "use strict";
  Object.defineProperty(Qy, "__esModule", {
    value: !0
  });
  Qy.merge = BBe;
  Qy.normalizeReplacements = FBe;
  Qy.validate = MBe;
  var _Be = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function LBe(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(LBe, "_objectWithoutPropertiesLoose");
  function BBe(t, e) {
    let {
      placeholderWhitelist: s = t.placeholderWhitelist,
      placeholderPattern: i = t.placeholderPattern,
      preserveComments: r = t.preserveComments,
      syntacticPlaceholders: a = t.syntacticPlaceholders
    } = e;
    return {
      parser: Object.assign({}, t.parser, e.parser),
      placeholderWhitelist: s,
      placeholderPattern: i,
      preserveComments: r,
      syntacticPlaceholders: a
    };
  }
  n(BBe, "merge");
  function MBe(t) {
    if (t != null && typeof t != "object")
      throw new Error("Unknown template options.");
    let e = t || {}, {
      placeholderWhitelist: s,
      placeholderPattern: i,
      preserveComments: r,
      syntacticPlaceholders: a
    } = e, o = LBe(e, _Be);
    if (s != null && !(s instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (i != null && !(i instanceof RegExp) && i !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (r != null && typeof r != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (s != null || i != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: s || void 0,
      placeholderPattern: i ?? void 0,
      preserveComments: r ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  n(MBe, "validate");
  function FBe(t) {
    if (Array.isArray(t))
      return t.reduce((e, s, i) => (e["$" + i] = s, e), {});
    if (typeof t == "object" || t == null)
      return t || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  n(FBe, "normalizeReplacements");
});

// ../node_modules/@babel/template/node_modules/@babel/parser/lib/index.js
var sK = g((lg) => {
  "use strict";
  Object.defineProperty(lg, "__esModule", {
    value: !0
  });
  function jBe(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(jBe, "_objectWithoutPropertiesLoose");
  var Qo = class {
    static {
      n(this, "Position");
    }
    constructor(e, s, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = s, this.index = i;
    }
  }, ld = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, s) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = s;
    }
  };
  function gn(t, e) {
    let {
      line: s,
      column: i,
      index: r
    } = t;
    return new Qo(s, i + e, r + e);
  }
  n(gn, "createPositionWithColumnOffset");
  var CU = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", RBe = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: CU
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: CU
    }
  }, wU = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, ex = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? wU.UpdateExpression[`${t.prefix}`] : wU[t.type], "toNodeDescription"), qBe = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${ex(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${ex(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${ex(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, UBe = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, KBe = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), VBe = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${ex({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), WBe = ["message"];
  function IU(t, e, s) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: s
    });
  }
  n(IU, "defineHidden");
  function $Be({
    toMessage: t,
    code: e,
    reasonCode: s,
    syntaxPlugin: i
  }) {
    let r = s === "MissingPlugin" || s === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[s] && (s = a[s]);
    }
    return /* @__PURE__ */ n(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = s, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, r && (u.missingPlugin = l.missingPlugin), IU(u, "\
clone", /* @__PURE__ */ n(function(p = {}) {
        var h;
        let {
          line: f,
          column: d,
          index: y
        } = (h = p.loc) != null ? h : o;
        return a(new Qo(f, d, y), Object.assign({}, l, p.details));
      }, "clone")), IU(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${t(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  n($Be, "toParseErrorConstructor");
  function Hl(t, e) {
    if (Array.isArray(t))
      return (i) => Hl(i, t[0]);
    let s = {};
    for (let i of Object.keys(t)) {
      let r = t[i], a = typeof r == "string" ? {
        message: /* @__PURE__ */ n(() => r, "message")
      } : typeof r == "function" ? {
        message: r
      } : r, {
        message: o
      } = a, l = jBe(a, WBe), u = typeof o == "string" ? () => o : o;
      s[i] = $Be(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return s;
  }
  n(Hl, "ParseErrorEnum");
  var G = Object.assign({}, Hl(RBe), Hl(qBe), Hl(UBe), Hl`pipelineOperator`(VBe));
  function HBe() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  n(HBe, "createDefaultOptions");
  function JBe(t) {
    let e = HBe();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let s of Object.keys(e))
      t[s] != null && (e[s] = t[s]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  n(JBe, "getOptions");
  var {
    defineProperty: YBe
  } = Object, NU = /* @__PURE__ */ n((t, e) => {
    t && YBe(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function Zy(t) {
    return NU(t.loc.start, "index"), NU(t.loc.end, "index"), t;
  }
  n(Zy, "toESTreeLocation");
  var XBe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let s = Zy(super.parse());
      return this.optionFlags & 256 && (s.tokens = s.tokens.map(Zy)), s;
    }
    parseRegExpLiteral({
      pattern: s,
      flags: i
    }) {
      let r = null;
      try {
        r = new RegExp(s, i);
      } catch {
      }
      let a = this.estreeParseLiteral(r);
      return a.regex = {
        pattern: s,
        flags: i
      }, a;
    }
    parseBigIntLiteral(s) {
      let i;
      try {
        i = BigInt(s);
      } catch {
        i = null;
      }
      let r = this.estreeParseLiteral(i);
      return r.bigint = String(r.value || s), r;
    }
    parseDecimalLiteral(s) {
      let r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || s), r;
    }
    estreeParseLiteral(s) {
      return this.parseLiteral(s, "Literal");
    }
    parseStringLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNumericLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    directiveToStmt(s) {
      let i = s.value;
      delete s.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let r = s;
      return r.type = "ExpressionStatement", r.expression = i, r.directive = i.extra.rawValue, delete i.extra, r;
    }
    initFunction(s, i) {
      super.initFunction(s, i), s.expression = !1;
    }
    checkDeclaration(s) {
      s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
    }
    getObjectOrClassMethodParams(s) {
      return s.value.params;
    }
    isValidDirective(s) {
      var i;
      return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((i = s.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(s, i, r, a, o) {
      super.parseBlockBody(s, i, r, a, o);
      let l = s.directives.map((u) => this.directiveToStmt(u));
      s.body = l.concat(s.body), delete s.directives;
    }
    parsePrivateName() {
      let s = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
    }
    convertPrivateNameToPrivateIdentifier(s) {
      let i = super.getPrivateNameSV(s);
      return s = s, delete s.id, s.name = i, s.type = "PrivateIdentifier", s;
    }
    isPrivateName(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
    }
    getPrivateNameSV(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
    }
    parseLiteral(s, i) {
      let r = super.parseLiteral(s, i);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(s, i, r = !1) {
      super.parseFunctionBody(s, i, r), s.expression = s.body.type !== "BlockStatement";
    }
    parseMethod(s, i, r, a, o, l, u = !1) {
      let c = this.startNode();
      c.kind = s.kind, c = super.parseMethod(c, i, r, a, o, l, u), c.type = "FunctionExpression", delete c.kind, s.value = c;
      let {
        typeParameters: p
      } = s;
      return p && (delete s.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p)), l === "ClassPrivateMethod" && (s.computed =
      !1), this.finishNode(s, "MethodDefinition");
    }
    nameIsConstructor(s) {
      return s.type === "Literal" ? s.value === "constructor" : super.nameIsConstructor(s);
    }
    parseClassProperty(...s) {
      let i = super.parseClassProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...s) {
      let i = super.parseClassPrivateProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(s) {
      let i = super.parseClassAccessorProperty(s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(s, i, r, a, o) {
      let l = super.parseObjectMethod(s, i, r, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(s, i, r, a) {
      let o = super.parseObjectProperty(s, i, r, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(s, i, r) {
      return s === "Property" ? "value" : super.isValidLVal(s, i, r);
    }
    isAssignable(s, i) {
      return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      if (s != null && this.isObjectProperty(s)) {
        let {
          key: r,
          value: a
        } = s;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(s, i);
    }
    toAssignableObjectExpressionProp(s, i, r) {
      s.type === "Property" && (s.kind === "get" || s.kind === "set") ? this.raise(G.PatternHasAccessor, s.key) : s.type === "Property" && s.
      method ? this.raise(G.PatternHasMethod, s.key) : super.toAssignableObjectExpressionProp(s, i, r);
    }
    finishCallExpression(s, i) {
      let r = super.finishCallExpression(s, i);
      if (r.callee.type === "Import") {
        var a, o;
        r.type = "ImportExpression", r.source = r.arguments[0], r.options = (a = r.arguments[1]) != null ? a : null, r.attributes = (o = r.arguments[1]) !=
        null ? o : null, delete r.arguments, delete r.callee;
      }
      return r;
    }
    toReferencedArguments(s) {
      s.type !== "ImportExpression" && super.toReferencedArguments(s);
    }
    parseExport(s, i) {
      let r = this.state.lastTokStartLoc, a = super.parseExport(s, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, r);
          }
          break;
      }
      return a;
    }
    parseSubscript(s, i, r, a) {
      let o = super.parseSubscript(s, i, r, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(s) {
      return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
    }
    hasPropertyAsPrivateName(s) {
      return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
    }
    isObjectProperty(s) {
      return s.type === "Property" && s.kind === "init" && !s.method;
    }
    isObjectMethod(s) {
      return s.type === "Property" && (s.method || s.kind === "get" || s.kind === "set");
    }
    finishNodeAt(s, i, r) {
      return Zy(super.finishNodeAt(s, i, r));
    }
    resetStartLocation(s, i) {
      super.resetStartLocation(s, i), Zy(s);
    }
    resetEndLocation(s, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(s, i), Zy(s);
    }
  }, "estree"), ih = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, s) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!s;
    }
  }, Vs = {
    brace: new ih("{"),
    j_oTag: new ih("<tag"),
    j_cTag: new ih("</tag"),
    j_expr: new ih("<tag>...</tag>", !0)
  };
  Vs.template = new ih("`", !0);
  var is = !0, Ue = !0, DI = !0, eg = !0, vc = !0, zBe = !0, ix = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, s = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = s.keyword,
      this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop,
      this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.
      updateContext = null;
    }
  }, tN = /* @__PURE__ */ new Map();
  function ws(t, e = {}) {
    e.keyword = t;
    let s = Et(t, e);
    return tN.set(t, s), s;
  }
  n(ws, "createKeyword");
  function yn(t, e) {
    return Et(t, {
      beforeExpr: is,
      binop: e
    });
  }
  n(yn, "createBinop");
  var rg = -1, Wl = [], sN = [], iN = [], rN = [], nN = [], aN = [];
  function Et(t, e = {}) {
    var s, i, r, a;
    return ++rg, sN.push(t), iN.push((s = e.binop) != null ? s : -1), rN.push((i = e.beforeExpr) != null ? i : !1), nN.push((r = e.startsExpr) !=
    null ? r : !1), aN.push((a = e.prefix) != null ? a : !1), Wl.push(new ix(t, e)), rg;
  }
  n(Et, "createToken");
  function ss(t, e = {}) {
    var s, i, r, a;
    return ++rg, tN.set(t, rg), sN.push(t), iN.push((s = e.binop) != null ? s : -1), rN.push((i = e.beforeExpr) != null ? i : !1), nN.push((r =
    e.startsExpr) != null ? r : !1), aN.push((a = e.prefix) != null ? a : !1), Wl.push(new ix("name", e)), rg;
  }
  n(ss, "createKeywordLike");
  var GBe = {
    bracketL: Et("[", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    bracketHashL: Et("#[", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    bracketBarL: Et("[|", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    bracketR: Et("]"),
    bracketBarR: Et("|]"),
    braceL: Et("{", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    braceBarL: Et("{|", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    braceHashL: Et("#{", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    braceR: Et("}"),
    braceBarR: Et("|}"),
    parenL: Et("(", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    parenR: Et(")"),
    comma: Et(",", {
      beforeExpr: is
    }),
    semi: Et(";", {
      beforeExpr: is
    }),
    colon: Et(":", {
      beforeExpr: is
    }),
    doubleColon: Et("::", {
      beforeExpr: is
    }),
    dot: Et("."),
    question: Et("?", {
      beforeExpr: is
    }),
    questionDot: Et("?."),
    arrow: Et("=>", {
      beforeExpr: is
    }),
    template: Et("template"),
    ellipsis: Et("...", {
      beforeExpr: is
    }),
    backQuote: Et("`", {
      startsExpr: Ue
    }),
    dollarBraceL: Et("${", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    templateTail: Et("...`", {
      startsExpr: Ue
    }),
    templateNonTail: Et("...${", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    at: Et("@"),
    hash: Et("#", {
      startsExpr: Ue
    }),
    interpreterDirective: Et("#!..."),
    eq: Et("=", {
      beforeExpr: is,
      isAssign: eg
    }),
    assign: Et("_=", {
      beforeExpr: is,
      isAssign: eg
    }),
    slashAssign: Et("_=", {
      beforeExpr: is,
      isAssign: eg
    }),
    xorAssign: Et("_=", {
      beforeExpr: is,
      isAssign: eg
    }),
    moduloAssign: Et("_=", {
      beforeExpr: is,
      isAssign: eg
    }),
    incDec: Et("++/--", {
      prefix: vc,
      postfix: zBe,
      startsExpr: Ue
    }),
    bang: Et("!", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    tilde: Et("~", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    doubleCaret: Et("^^", {
      startsExpr: Ue
    }),
    doubleAt: Et("@@", {
      startsExpr: Ue
    }),
    pipeline: yn("|>", 0),
    nullishCoalescing: yn("??", 1),
    logicalOR: yn("||", 1),
    logicalAND: yn("&&", 2),
    bitwiseOR: yn("|", 3),
    bitwiseXOR: yn("^", 4),
    bitwiseAND: yn("&", 5),
    equality: yn("==/!=/===/!==", 6),
    lt: yn("</>/<=/>=", 7),
    gt: yn("</>/<=/>=", 7),
    relational: yn("</>/<=/>=", 7),
    bitShift: yn("<</>>/>>>", 8),
    bitShiftL: yn("<</>>/>>>", 8),
    bitShiftR: yn("<</>>/>>>", 8),
    plusMin: Et("+/-", {
      beforeExpr: is,
      binop: 9,
      prefix: vc,
      startsExpr: Ue
    }),
    modulo: Et("%", {
      binop: 10,
      startsExpr: Ue
    }),
    star: Et("*", {
      binop: 10
    }),
    slash: yn("/", 10),
    exponent: Et("**", {
      beforeExpr: is,
      binop: 11,
      rightAssociative: !0
    }),
    _in: ws("in", {
      beforeExpr: is,
      binop: 7
    }),
    _instanceof: ws("instanceof", {
      beforeExpr: is,
      binop: 7
    }),
    _break: ws("break"),
    _case: ws("case", {
      beforeExpr: is
    }),
    _catch: ws("catch"),
    _continue: ws("continue"),
    _debugger: ws("debugger"),
    _default: ws("default", {
      beforeExpr: is
    }),
    _else: ws("else", {
      beforeExpr: is
    }),
    _finally: ws("finally"),
    _function: ws("function", {
      startsExpr: Ue
    }),
    _if: ws("if"),
    _return: ws("return", {
      beforeExpr: is
    }),
    _switch: ws("switch"),
    _throw: ws("throw", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    _try: ws("try"),
    _var: ws("var"),
    _const: ws("const"),
    _with: ws("with"),
    _new: ws("new", {
      beforeExpr: is,
      startsExpr: Ue
    }),
    _this: ws("this", {
      startsExpr: Ue
    }),
    _super: ws("super", {
      startsExpr: Ue
    }),
    _class: ws("class", {
      startsExpr: Ue
    }),
    _extends: ws("extends", {
      beforeExpr: is
    }),
    _export: ws("export"),
    _import: ws("import", {
      startsExpr: Ue
    }),
    _null: ws("null", {
      startsExpr: Ue
    }),
    _true: ws("true", {
      startsExpr: Ue
    }),
    _false: ws("false", {
      startsExpr: Ue
    }),
    _typeof: ws("typeof", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    _void: ws("void", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    _delete: ws("delete", {
      beforeExpr: is,
      prefix: vc,
      startsExpr: Ue
    }),
    _do: ws("do", {
      isLoop: DI,
      beforeExpr: is
    }),
    _for: ws("for", {
      isLoop: DI
    }),
    _while: ws("while", {
      isLoop: DI
    }),
    _as: ss("as", {
      startsExpr: Ue
    }),
    _assert: ss("assert", {
      startsExpr: Ue
    }),
    _async: ss("async", {
      startsExpr: Ue
    }),
    _await: ss("await", {
      startsExpr: Ue
    }),
    _defer: ss("defer", {
      startsExpr: Ue
    }),
    _from: ss("from", {
      startsExpr: Ue
    }),
    _get: ss("get", {
      startsExpr: Ue
    }),
    _let: ss("let", {
      startsExpr: Ue
    }),
    _meta: ss("meta", {
      startsExpr: Ue
    }),
    _of: ss("of", {
      startsExpr: Ue
    }),
    _sent: ss("sent", {
      startsExpr: Ue
    }),
    _set: ss("set", {
      startsExpr: Ue
    }),
    _source: ss("source", {
      startsExpr: Ue
    }),
    _static: ss("static", {
      startsExpr: Ue
    }),
    _using: ss("using", {
      startsExpr: Ue
    }),
    _yield: ss("yield", {
      startsExpr: Ue
    }),
    _asserts: ss("asserts", {
      startsExpr: Ue
    }),
    _checks: ss("checks", {
      startsExpr: Ue
    }),
    _exports: ss("exports", {
      startsExpr: Ue
    }),
    _global: ss("global", {
      startsExpr: Ue
    }),
    _implements: ss("implements", {
      startsExpr: Ue
    }),
    _intrinsic: ss("intrinsic", {
      startsExpr: Ue
    }),
    _infer: ss("infer", {
      startsExpr: Ue
    }),
    _is: ss("is", {
      startsExpr: Ue
    }),
    _mixins: ss("mixins", {
      startsExpr: Ue
    }),
    _proto: ss("proto", {
      startsExpr: Ue
    }),
    _require: ss("require", {
      startsExpr: Ue
    }),
    _satisfies: ss("satisfies", {
      startsExpr: Ue
    }),
    _keyof: ss("keyof", {
      startsExpr: Ue
    }),
    _readonly: ss("readonly", {
      startsExpr: Ue
    }),
    _unique: ss("unique", {
      startsExpr: Ue
    }),
    _abstract: ss("abstract", {
      startsExpr: Ue
    }),
    _declare: ss("declare", {
      startsExpr: Ue
    }),
    _enum: ss("enum", {
      startsExpr: Ue
    }),
    _module: ss("module", {
      startsExpr: Ue
    }),
    _namespace: ss("namespace", {
      startsExpr: Ue
    }),
    _interface: ss("interface", {
      startsExpr: Ue
    }),
    _type: ss("type", {
      startsExpr: Ue
    }),
    _opaque: ss("opaque", {
      startsExpr: Ue
    }),
    name: Et("name", {
      startsExpr: Ue
    }),
    placeholder: Et("%%", {
      startsExpr: !0
    }),
    string: Et("string", {
      startsExpr: Ue
    }),
    num: Et("num", {
      startsExpr: Ue
    }),
    bigint: Et("bigint", {
      startsExpr: Ue
    }),
    decimal: Et("decimal", {
      startsExpr: Ue
    }),
    regexp: Et("regexp", {
      startsExpr: Ue
    }),
    privateName: Et("#name", {
      startsExpr: Ue
    }),
    eof: Et("eof"),
    jsxName: Et("jsxName"),
    jsxText: Et("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Et("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Et("jsxTagEnd")
  };
  function Ws(t) {
    return t >= 93 && t <= 133;
  }
  n(Ws, "tokenIsIdentifier");
  function QBe(t) {
    return t <= 92;
  }
  n(QBe, "tokenKeywordOrIdentifierIsKeyword");
  function yo(t) {
    return t >= 58 && t <= 133;
  }
  n(yo, "tokenIsKeywordOrIdentifier");
  function UU(t) {
    return t >= 58 && t <= 137;
  }
  n(UU, "tokenIsLiteralPropertyName");
  function ZBe(t) {
    return rN[t];
  }
  n(ZBe, "tokenComesBeforeExpression");
  function sg(t) {
    return nN[t];
  }
  n(sg, "tokenCanStartExpression");
  function eMe(t) {
    return t >= 29 && t <= 33;
  }
  n(eMe, "tokenIsAssignment");
  function kU(t) {
    return t >= 129 && t <= 131;
  }
  n(kU, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function tMe(t) {
    return t >= 90 && t <= 92;
  }
  n(tMe, "tokenIsLoop");
  function oN(t) {
    return t >= 58 && t <= 92;
  }
  n(oN, "tokenIsKeyword");
  function sMe(t) {
    return t >= 39 && t <= 59;
  }
  n(sMe, "tokenIsOperator");
  function iMe(t) {
    return t === 34;
  }
  n(iMe, "tokenIsPostfix");
  function rMe(t) {
    return aN[t];
  }
  n(rMe, "tokenIsPrefix");
  function nMe(t) {
    return t >= 121 && t <= 123;
  }
  n(nMe, "tokenIsTSTypeOperator");
  function aMe(t) {
    return t >= 124 && t <= 130;
  }
  n(aMe, "tokenIsTSDeclarationStart");
  function wc(t) {
    return sN[t];
  }
  n(wc, "tokenLabelName");
  function tx(t) {
    return iN[t];
  }
  n(tx, "tokenOperatorPrecedence");
  function oMe(t) {
    return t === 57;
  }
  n(oMe, "tokenIsRightAssociative");
  function rx(t) {
    return t >= 24 && t <= 25;
  }
  n(rx, "tokenIsTemplate");
  function Vl(t) {
    return Wl[t];
  }
  n(Vl, "getExportedToken");
  Wl[8].updateContext = (t) => {
    t.pop();
  }, Wl[5].updateContext = Wl[7].updateContext = Wl[23].updateContext = (t) => {
    t.push(Vs.brace);
  }, Wl[22].updateContext = (t) => {
    t[t.length - 1] === Vs.template ? t.pop() : t.push(Vs.template);
  }, Wl[143].updateContext = (t) => {
    t.push(Vs.j_expr, Vs.j_oTag);
  };
  var lN = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  KU = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", lMe = new RegExp("[" + lN + "]"), uMe = new RegExp("[" + lN + KU + "]");
  lN = KU = null;
  var VU = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], cMe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function MI(t, e) {
    let s = 65536;
    for (let i = 0, r = e.length; i < r; i += 2) {
      if (s += e[i], s > t) return !1;
      if (s += e[i + 1], s >= t) return !0;
    }
    return !1;
  }
  n(MI, "isInAstralSet");
  function $l(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && lMe.test(String.fromCharCode(t)) :
    MI(t, VU);
  }
  n($l, "isIdentifierStart");
  function nd(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && uMe.test(
    String.fromCharCode(t)) : MI(t, VU) || MI(t, cMe);
  }
  n(nd, "isIdentifierChar");
  var uN = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, pMe = new Set(uN.keyword), hMe = new Set(uN.strict), fMe = new Set(uN.strictBind);
  function WU(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(WU, "isReservedWord");
  function $U(t, e) {
    return WU(t, e) || hMe.has(t);
  }
  n($U, "isStrictReservedWord");
  function HU(t) {
    return fMe.has(t);
  }
  n(HU, "isStrictBindOnlyReservedWord");
  function JU(t, e) {
    return $U(t, e) || HU(t);
  }
  n(JU, "isStrictBindReservedWord");
  function dMe(t) {
    return pMe.has(t);
  }
  n(dMe, "isKeyword");
  function mMe(t, e, s) {
    return t === 64 && e === 64 && $l(s);
  }
  n(mMe, "isIteratorStart");
  var yMe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function gMe(t) {
    return yMe.has(t);
  }
  n(gMe, "canBeReservedWord");
  var ng = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, ag = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, s) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = s;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 128)
          return !0;
        if (s & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new ng(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 8 || s & 16) {
        this.checkRedeclarationInScope(r, e, s, i);
        let a = r.names.get(e) || 0;
        s & 16 ? a = a | 4 : (r.firstLexicalName || (r.firstLexicalName = e), a = a | 2), r.names.set(e, a), s & 8 && this.maybeExportDefined(
        r, e);
      } else if (s & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (r = this.scopeStack[a], this.checkRedeclarationInScope(r, e, s, i), r.names.set(
        e, (r.names.get(e) || 0) | 1), this.maybeExportDefined(r, e), !(r.flags & 387)); --a)
          ;
      this.parser.inModule && r.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, s) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(s);
    }
    checkRedeclarationInScope(e, s, i, r) {
      this.isRedeclaredInScope(e, s, i) && this.parser.raise(G.VarRedeclaration, r, {
        identifierName: s
      });
    }
    isRedeclaredInScope(e, s, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(s);
      let r = e.names.get(s);
      return i & 16 ? (r & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (r & 1) > 0 : (r & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      s) || !this.treatFunctionsAsVarInScope(e) && (r & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      this.scopeStack[0].names.has(s) || this.undefinedExports.set(s, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 387)
          return s;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 451 && !(s & 4))
          return s;
      }
    }
  }, FI = class extends ng {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, jI = class extends ag {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new FI(e);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 2048) {
        this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e), r.declareFunctions.add(e);
        return;
      }
      super.declareName(e, s, i);
    }
    isRedeclaredInScope(e, s, i) {
      if (super.isRedeclaredInScope(e, s, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(s)) {
        let r = e.names.get(s);
        return (r & 4) > 0 || (r & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, RI = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [s, i] = e;
        if (!this.hasPlugin(s))
          return !1;
        let r = this.plugins.get(s);
        for (let a of Object.keys(i))
          if (r?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, s) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[s];
    }
  };
  function YU(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(YU, "setTrailingComments");
  function TMe(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(TMe, "setLeadingComments");
  function og(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(og, "setInnerComments");
  function th(t, e, s) {
    let i = null, r = e.length;
    for (; i === null && r > 0; )
      i = e[--r];
    i === null || i.start > s.start ? og(t, s.comments) : YU(i, s.comments);
  }
  n(th, "adjustInnerComments");
  var qI = class extends RI {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: s
      } = this.state;
      this.comments.length !== s && (this.comments.length = s), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: s
      } = this.state, i = s.length;
      if (i === 0) return;
      let r = i - 1, a = s[r];
      a.start === e.end && (a.leadingNode = e, r--);
      let {
        start: o
      } = e;
      for (; r >= 0; r--) {
        let l = s[r], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), s.splice(r, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: s
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && YU(e.leadingNode, s), e.trailingNode !== null && TMe(e.trailingNode, s);
      else {
        let {
          containingNode: i,
          start: r
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(r) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              th(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              th(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              th(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              th(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              th(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              th(i, i.members, e);
              break;
            case "TSEnumBody":
              th(i, i.members, e);
              break;
            default:
              og(i, s);
          }
        else
          og(i, s);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let s = e.length - 1; s >= 0; s--)
        this.finalizeComment(e[s]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      if (i === 0) return;
      let r = s[i - 1];
      r.leadingNode === e && (r.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      i !== 0 && (s[i - 1].trailingNode === e ? s[i - 1].trailingNode = null : i >= 2 && s[i - 2].trailingNode === e && (s[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, s, i) {
      let {
        commentStack: r
      } = this.state, a = r.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = r[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === s)
          l.trailingNode = e;
        else if (u < s)
          break;
      }
    }
  }, bMe = /\r\n|[\r\n\u2028\u2029]/, Qb = new RegExp(bMe.source, "g");
  function ad(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(ad, "isNewLine");
  function DU(t, e, s) {
    for (let i = e; i < s; i++)
      if (ad(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  n(DU, "hasNewLine");
  var OI = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _I = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function xMe(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(xMe, "isWhitespace");
  var UI = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Vs.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: s,
      startIndex: i,
      startLine: r,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : s === "module", this.startIndex = i, this.curLine = r, this.lineStart = -a, this.startLoc =
      this.endLoc = new Qo(r, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new Qo(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, SMe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), OU = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Zb = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function _U(t, e, s, i, r, a) {
    let o = s, l = i, u = r, c = "", p = null, h = s, {
      length: f
    } = e;
    for (; ; ) {
      if (s >= f) {
        a.unterminated(o, l, u), c += e.slice(h, s);
        break;
      }
      let d = e.charCodeAt(s);
      if (PMe(t, d, e, s)) {
        c += e.slice(h, s);
        break;
      }
      if (d === 92) {
        c += e.slice(h, s);
        let y = EMe(e, s, i, r, t === "template", a);
        y.ch === null && !p ? p = {
          pos: s,
          lineStart: i,
          curLine: r
        } : c += y.ch, {
          pos: s,
          lineStart: i,
          curLine: r
        } = y, h = s;
      } else d === 8232 || d === 8233 ? (++s, ++r, i = s) : d === 10 || d === 13 ? t === "template" ? (c += e.slice(h, s) + `
`, ++s, d === 13 && e.charCodeAt(s) === 10 && ++s, ++r, h = i = s) : a.unterminated(o, l, u) : ++s;
    }
    return {
      pos: s,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: r,
      containsInvalid: !!p
    };
  }
  n(_U, "readStringContents");
  function PMe(t, e, s, i) {
    return t === "template" ? e === 96 || e === 36 && s.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(PMe, "isStringEnd");
  function EMe(t, e, s, i, r, a) {
    let o = !r;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: s,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = KI(t, e, s, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = zU(t, e, s, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        s = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (r)
          return l(null);
        a.strictNumericEscape(e - 1, s, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, h = /^[0-7]+/.exec(t.slice(c, e + 2))[0], f = parseInt(h, 8);
          f > 255 && (h = h.slice(0, -1), f = parseInt(h, 8)), e += h.length - 1;
          let d = t.charCodeAt(e);
          if (h !== "0" || d === 56 || d === 57) {
            if (r)
              return l(null);
            a.strictNumericEscape(c, s, i);
          }
          return l(String.fromCharCode(f));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(EMe, "readEscapedChar");
  function KI(t, e, s, i, r, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = XU(t, e, s, i, 16, r, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, s, i) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(KI, "readHexChar");
  function XU(t, e, s, i, r, a, o, l, u, c) {
    let p = e, h = r === 16 ? OU.hex : OU.decBinOct, f = r === 16 ? Zb.hex : r === 10 ? Zb.dec : r === 8 ? Zb.oct : Zb.bin, d = !1, y = 0;
    for (let m = 0, T = a ?? 1 / 0; m < T; ++m) {
      let b = t.charCodeAt(e), E;
      if (b === 95 && l !== "bail") {
        let w = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !f(K) || h.has(w) || h.has(K)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, s, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, s, i);
        }
        ++e;
        continue;
      }
      if (b >= 97 ? E = b - 97 + 10 : b >= 65 ? E = b - 65 + 10 : SMe(b) ? E = b - 48 : E = 1 / 0, E >= r) {
        if (E <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (E <= 9 && u.invalidDigit(e, s, i, r))
          E = 0;
        else if (o)
          E = 0, d = !0;
        else
          break;
      }
      ++e, y = y * r + E;
    }
    return e === p || a != null && e - p !== a || d ? {
      n: null,
      pos: e
    } : {
      n: y,
      pos: e
    };
  }
  n(XU, "readInt");
  function zU(t, e, s, i, r, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = KI(t, e, s, i, t.indexOf("}", e) - e, !0, r, a), ++e, l !== null && l > 1114111)
        if (r)
          a.invalidCodePoint(e, s, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = KI(t, e, s, i, 4, !1, r, a));
    return {
      code: l,
      pos: e
    };
  }
  n(zU, "readCodePoint");
  function tg(t, e, s) {
    return new Qo(s, t - e, t);
  }
  n(tg, "buildPosition");
  var AMe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Go = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      let s = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = s + e.start, this.end = s + e.end, this.loc = new ld(e.startLoc, e.endLoc);
    }
  }, VI = class extends qI {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, s) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((i, r, a, o) => this.optionFlags & 2048 ? (this.raise(G.InvalidDigit, tg(i, r, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(G.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(G.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(G.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(G.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((i, r, a) => {
          this.recordStrictModeErrors(G.StrictNumericEscape, tg(i, r, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(G.UnterminatedString, tg(i - 1, r, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(G.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(G.UnterminatedTemplate, tg(i, r, a));
        }, "unterminated")
      }), this.state = new UI(), this.state.init(e), this.input = s, this.length = s.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new Go(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let s = this.state;
      return this.state = e, s;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return OI.lastIndex = e, OI.test(this.input) ? OI.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return _I.lastIndex = e, _I.test(this.input) ? _I.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let s = this.input.charCodeAt(e);
      if ((s & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      return s;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([s, i]) => this.raise(s, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.state.pos, r = this.input.indexOf(e, i + 2);
      if (r === -1)
        throw this.raise(G.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = r + e.length, Qb.lastIndex = i + 2; Qb.test(this.input) && Qb.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = Qb.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, r),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(r + e.length),
        loc: new ld(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let s = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let r = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !ad(r) && ++this.state.pos < this.length; )
          r = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(s + e, a),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(a),
        loc: new ld(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, s = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let r = this.skipBlockComment("*/");
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              case 47: {
                let r = this.skipLineComment(2);
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (xMe(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (s?.length > 0) {
        let i = this.state.pos, r = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: s,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(r);
      }
    }
    finishToken(e, s) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = s, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, s = this.codePointAtPos(e);
      if (s >= 48 && s <= 57)
        throw this.raise(G.UnexpectedDigitAfterHash, this.state.curPosition());
      if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(s === 123 ? G.RecordExpressionHashIncorrectStartSyntaxType : G.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
      } else $l(s) ? (++this.state.pos, this.finishToken(139, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let s = this.state.pos;
      for (this.state.pos += 1; !ad(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(s + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let s = e === 42 ? 55 : 54, i = 1, r = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && r === 42 && (i++, r = this.input.charCodeAt(this.state.pos + 2), s = 57), r === 61 && !this.state.inType && (i++, s = e ===
      37 ? 33 : 30), this.finishOp(s, i);
    }
    readToken_pipe_amp(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (s === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(G.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(G.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (s === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.finishOp(34, 2);
        return;
      }
      s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && s === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(G.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(G.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let s = this.input.charCodeAt(this.state.pos + 1);
          if (s === 120 || s === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (s === 111 || s === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (s === 98 || s === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if ($l(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(G.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, s) {
      let i = this.input.slice(this.state.pos, this.state.pos + s);
      this.state.pos += s, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, s = this.state.start + 1, i, r, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(G.UnterminatedRegExp, gn(e, 1));
        let c = this.input.charCodeAt(a);
        if (ad(c))
          throw this.raise(G.UnterminatedRegExp, gn(e, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            r = !0;
          else if (c === 93 && r)
            r = !1;
          else if (c === 47 && !r)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(s, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => gn(e, a + 2 - s), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (AMe.has(c))
          c === 118 ? l.includes("u") && this.raise(G.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(G.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(G.DuplicateRegExpFlags, u());
        else if (nd(c) || c === 92)
          this.raise(G.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, s, i = !1, r = !0) {
      let {
        n: a,
        pos: o
      } = XU(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, s, i, r, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(G.InvalidDigit, gn(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = !0;
      else if (o === 109)
        throw this.raise(G.InvalidDecimal, i);
      if ($l(this.codePointAtPos(this.state.pos)))
        throw this.raise(G.NumberIdentifier, this.state.curPosition());
      if (r) {
        let l = this.input.slice(s, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(G.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
      if (u) {
        let d = this.input.slice(s, this.state.pos);
        if (this.recordStrictModeErrors(G.StrictOctalLiteral, i), !this.state.strict) {
          let y = d.indexOf("_");
          y > 0 && this.raise(G.ZeroDigitNumericSeparator, gn(i, y));
        }
        l = u && !/[89]/.test(d);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !l && (++this.state.pos, this.readInt(10), r = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      G.InvalidOrMissingExponent, i), r = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((r || u) && this.raise(G.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(G.InvalidDecimal, i), ++this.state.pos;
        var p = !0;
      }
      if ($l(this.codePointAtPos(this.state.pos)))
        throw this.raise(G.NumberIdentifier, this.state.curPosition());
      let h = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, h);
        return;
      }
      if (p) {
        this.finishToken(137, h);
        return;
      }
      let f = l ? parseInt(h, 8) : parseFloat(h);
      this.finishToken(135, f);
    }
    readCodePoint(e) {
      let {
        code: s,
        pos: i
      } = zU(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, s;
    }
    readString(e) {
      let {
        str: s,
        pos: i,
        curLine: r,
        lineStart: a
      } = _U(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = r, this.finishToken(134, s);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: s,
        firstInvalidLoc: i,
        pos: r,
        curLine: a,
        lineStart: o
      } = _U("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = r + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new Qo(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(r) === 96 ? this.finishToken(24, i ? null : e + s + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + s + "${"));
    }
    recordStrictModeErrors(e, s) {
      let i = s.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, s) : this.state.strictErrors.set(i, [e, s]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let s = "", i = this.state.pos, r = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (nd(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, s += this.input.slice(r, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? $l : nd;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(G.MissingUnicodeEscape, this.state.curPosition()), r = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(G.EscapedCharNotAnIdentifier, o), s += String.fromCodePoint(u)), r = this.state.pos;
        } else
          break;
      }
      return s + this.input.slice(r, this.state.pos);
    }
    readWord(e) {
      let s = this.readWord1(e), i = tN.get(s);
      i !== void 0 ? this.finishToken(i, wc(i)) : this.finishToken(132, s);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      oN(e) && this.state.containsEsc && this.raise(G.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: wc(e)
      });
    }
    raise(e, s, i = {}) {
      let r = s instanceof Qo ? s : s.loc.start, a = e(r, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, s, i = {}) {
      let r = s instanceof Qo ? s : s.loc.start, a = r.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(r, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, s, i);
    }
    updateContext(e) {
    }
    unexpected(e, s) {
      throw this.raise(G.UnexpectedToken, e ?? this.state.startLoc, {
        expected: s ? wc(s) : null
      });
    }
    expectPlugin(e, s) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(G.MissingPlugin, s ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((s) => this.hasPlugin(s)))
        throw this.raise(G.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (s, i, r) => {
        this.raise(e, tg(s, i, r));
      };
    }
  }, WI = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, $I = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new WI());
    }
    exit() {
      let e = this.stack.pop(), s = this.current();
      for (let [i, r] of Array.from(e.undefinedPrivateNames))
        s ? s.undefinedPrivateNames.has(i) || s.undefinedPrivateNames.set(i, r) : this.parser.raise(G.InvalidPrivateFieldResolution, r, {
          identifierName: i
        });
    }
    declarePrivateName(e, s, i) {
      let {
        privateNames: r,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = r.has(e);
      if (s & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = s & 4, h = u & 3, f = s & 3;
          l = h === f || c !== p, l || a.delete(e);
        } else l || a.set(e, s);
      }
      l && this.parser.raise(G.PrivateNameRedeclaration, i, {
        identifierName: e
      }), r.add(e), o.delete(e);
    }
    usePrivateName(e, s) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, s) : this.parser.raise(G.InvalidPrivateFieldResolution, s, {
        identifierName: e
      });
    }
  }, ud = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, nx = class extends ud {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, s) {
      let i = s.index;
      this.declarationErrors.set(i, [e, s]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, HI = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new ud()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, s) {
      let i = s.loc.start, {
        stack: r
      } = this, a = r.length - 1, o = r[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = r[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, s) {
      let {
        stack: i
      } = this, r = i[i.length - 1], a = s.loc.start;
      if (r.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (r.canBeArrowParameterDeclaration())
        r.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: s
      } = this, i = s.length - 1, r = s[i];
      for (; r.canBeArrowParameterDeclaration(); )
        r.type === 2 && r.recordDeclarationError(G.AwaitBindingIdentifier, e), r = s[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, s = e[e.length - 1];
      s.canBeArrowParameterDeclaration() && s.iterateErrors(([i, r]) => {
        this.parser.raise(i, r);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(r.index), o = e[--a];
      });
    }
  };
  function vMe() {
    return new ud(3);
  }
  n(vMe, "newParameterDeclarationScope");
  function CMe() {
    return new nx(1);
  }
  n(CMe, "newArrowHeadScope");
  function wMe() {
    return new nx(2);
  }
  n(wMe, "newAsyncArrowScope");
  function GU() {
    return new ud();
  }
  n(GU, "newExpressionScope");
  var JI = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function sx(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(sx, "functionFlags");
  var YI = class extends VI {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, s, i, r = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), r ? a[s] = i : Object.defineProperty(a, s, {
        enumerable: r,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, s) {
      let i = e + s.length;
      if (this.input.slice(e, i) === s) {
        let r = this.input.charCodeAt(i);
        return !(nd(r) || (r & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let s = this.nextTokenStart();
      return this.isUnparsedContextual(s, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, s) {
      if (!this.eatContextual(e)) {
        if (s != null)
          throw this.raise(s, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return DU(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return DU(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(G.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, s) {
      this.eat(e) || this.unexpected(s, e);
    }
    tryParse(e, s = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let r = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > s.errors.length) {
          let a = this.state;
          return this.state = s, this.state.tokensLength = a.tokensLength, {
            node: r,
            error: a.errors[s.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: r,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (r) {
        let a = this.state;
        if (this.state = s, r instanceof SyntaxError)
          return {
            node: null,
            error: r,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (r === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw r;
      }
    }
    checkExpressionErrors(e, s) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: r,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!r || !!o || !!a;
      if (!s)
        return l;
      i != null && this.raise(G.InvalidCoverInitializedName, i), r != null && this.raise(G.DuplicateProto, r), a != null && this.raise(G.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return UU(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let s = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let r = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new JI();
      let u = this.classScope;
      this.classScope = new $I(this);
      let c = this.expressionScope;
      return this.expressionScope = new HI(this), () => {
        this.state.labels = s, this.exportedIdentifiers = i, this.inModule = r, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: s
      } = e;
      s !== null && this.expectPlugin("destructuringPrivate", s);
    }
  }, od = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, cd = class {
    static {
      n(this, "Node");
    }
    constructor(e, s, i) {
      this.type = "", this.start = s, this.end = 0, this.loc = new ld(i), e?.optionFlags & 128 && (this.range = [s, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, cN = cd.prototype;
  cN.__clone = function() {
    let t = new cd(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let s = 0, i = e.length; s < i; s++) {
      let r = e[s];
      r !== "leadingComments" && r !== "trailingComments" && r !== "innerComments" && (t[r] = this[r]);
    }
    return t;
  };
  function IMe(t) {
    return Jl(t);
  }
  n(IMe, "clonePlaceholder");
  function Jl(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(cN);
    return u.type = e, u.start = s, u.end = i, u.loc = r, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Jl, "cloneIdentifier");
  function NMe(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return IMe(t);
    let l = Object.create(cN);
    return l.type = e, l.start = s, l.end = i, l.loc = r, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(NMe, "cloneStringLiteral");
  var XI = class extends YI {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new cd(this, e.index, e);
    }
    startNodeAt(e) {
      return new cd(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, s) {
      return this.finishNodeAt(e, s, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, s, i) {
      return e.type = s, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, s) {
      e.start = s.index, e.loc.start = s, this.optionFlags & 128 && (e.range[0] = s.index);
    }
    resetEndLocation(e, s = this.state.lastTokEndLoc) {
      e.end = s.index, e.loc.end = s, this.optionFlags & 128 && (e.range[1] = s.index);
    }
    resetStartLocationFromNode(e, s) {
      this.resetStartLocation(e, s.loc.start);
    }
  }, kMe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Ot = Hl`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: s
    }) => `Enum \`${t}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: s
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function DMe(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(DMe, "isEsModuleType");
  function LU(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(LU, "hasTypeImportKind");
  var OMe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function _Me(t, e) {
    let s = [], i = [];
    for (let r = 0; r < t.length; r++)
      (e(t[r], r, t) ? s : i).push(t[r]);
    return [s, i];
  }
  n(_Me, "partition");
  var LMe = /\*?\s*@((?:no)?flow)\b/, BMe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...s) {
      super(...s), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return jI;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(s, i) {
      s !== 134 && s !== 13 && s !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(s, i);
    }
    addComment(s) {
      if (this.flowPragma === void 0) {
        let i = LMe.exec(s.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(s);
    }
    flowParseTypeInitialiser(s) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(s || 14);
      let r = this.flowParseType();
      return this.state.inType = i, r;
    }
    flowParsePredicate() {
      let s = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(Ot.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (s.value = super.parseExpression(), this.expect(11), this.finishNode(s, "DeclaredPredicate")) : this.finishNode(s, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, r = null;
      return this.match(54) ? (this.state.inType = s, r = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = s, this.
      match(54) && (r = this.flowParsePredicate())), [i, r];
    }
    flowParseDeclareClass(s) {
      return this.next(), this.flowParseInterfaceish(s, !0), this.finishNode(s, "DeclareClass");
    }
    flowParseDeclareFunction(s) {
      this.next();
      let i = s.id = this.parseIdentifier(), r = this.startNode(), a = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, s.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(s.id.name, 2048, s.id.loc.start), this.finishNode(s, "DeclareFunction");
    }
    flowParseDeclare(s, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(s);
      if (this.match(68))
        return this.flowParseDeclareFunction(s);
      if (this.match(74))
        return this.flowParseDeclareVariable(s);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(s) : (i && this.raise(Ot.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(s));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(s);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(s);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(s);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(s, i);
      this.unexpected();
    }
    flowParseDeclareVariable(s) {
      return this.next(), s.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(s.id.name, 5, s.id.loc.start), this.semicolon(),
      this.finishNode(s, "DeclareVariable");
    }
    flowParseDeclareModule(s) {
      this.scope.enter(0), this.match(134) ? s.id = super.parseExprAtom() : s.id = this.parseIdentifier();
      let i = s.body = this.startNode(), r = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ot.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Ot.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), r.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return r.forEach((l) => {
        DMe(l) ? (a === "CommonJS" && this.raise(Ot.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Ot.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Ot.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), s.kind = a || "CommonJS", this.finishNode(s, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(s, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? s.declaration = this.flowParseDeclare(this.startNode()) : (s.declaration = this.flowParseType(),
        this.semicolon()), s.default = !0, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let r = this.state.value;
        throw this.raise(Ot.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: r,
          suggestion: OMe[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return s.declaration = this.flowParseDeclare(this.startNode()), s.default = !1, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return s = this.parseExport(s, null), s.type === "ExportNamedDeclaration" && (s.type = "ExportDeclaration", s.default = !1, delete s.
        exportKind), s.type = "Declare" + s.type, s;
      this.unexpected();
    }
    flowParseDeclareModuleExports(s) {
      return this.next(), this.expectContextual(111), s.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(s,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(s) {
      this.next();
      let i = this.flowParseTypeAlias(s);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(s) {
      this.next();
      let i = this.flowParseOpaqueType(s, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(s) {
      return this.next(), this.flowParseInterfaceish(s, !1), this.finishNode(s, "DeclareInterface");
    }
    flowParseInterfaceish(s, i) {
      if (s.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(s.id.name, i ? 17 : 8201, s.id.loc.start), this.match(47) ?
      s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (s.implements = [], s.mixins = [], this.eatContextual(117))
          do
            s.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            s.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      s.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let s = this.startNode();
      return s.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() :
      s.typeParameters = null, this.finishNode(s, "InterfaceExtends");
    }
    flowParseInterface(s) {
      return this.flowParseInterfaceish(s, !1), this.finishNode(s, "InterfaceDeclaration");
    }
    checkNotUnderscore(s) {
      s === "_" && this.raise(Ot.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(s, i, r) {
      kMe.has(s) && this.raise(r ? Ot.AssignReservedType : Ot.UnexpectedReservedType, i, {
        reservedType: s
      });
    }
    flowParseRestrictedIdentifier(s, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(s);
    }
    flowParseTypeAlias(s) {
      return s.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.
      typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(s, "TypeAlias");
    }
    flowParseOpaqueType(s, i) {
      return this.expectContextual(130), s.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.
      start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.supertype = null, this.
      match(14) && (s.supertype = this.flowParseTypeInitialiser(14)), s.impltype = null, i || (s.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(s, "OpaqueType");
    }
    flowParseTypeParameter(s = !1) {
      let i = this.state.startLoc, r = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = a, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) :
      s && this.raise(Ot.MissingTypeParamDefault, i), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let s = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = !1;
      do {
        let a = this.flowParseTypeParameter(r);
        i.params.push(a), a.default && (r = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = s, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(s) {
      if (this.curContext() !== Vs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let s = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, s.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let r = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          s.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = r;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Vs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      s, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let s = this.startNode(), i = this.state.inType;
      for (s.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        s.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(s, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let s = this.startNode();
      if (this.expectContextual(129), s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return s.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(s, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(s, i, r) {
      return s.static = i, this.lookahead().type === 14 ? (s.id = this.flowParseObjectPropertyKey(), s.key = this.flowParseTypeInitialiser()) :
      (s.id = null, s.key = this.flowParseType()), this.expect(3), s.value = this.flowParseTypeInitialiser(), s.variance = r, this.finishNode(
      s, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(s, i) {
      return s.static = i, s.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (s.method =
      !0, s.optional = !1, s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start))) : (s.method = !1, this.eat(17) && (s.
      optional = !0), s.value = this.flowParseTypeInitialiser()), this.finishNode(s, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(s) {
      for (s.params = [], s.rest = null, s.typeParameters = null, s.this = null, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (s.this = this.flowParseFunctionTypeParam(!0), s.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        s.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), s.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(s, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(s, i) {
      let r = this.startNode();
      return s.static = i, s.value = this.flowParseObjectTypeMethodish(r), this.finishNode(s, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: s,
      allowExact: i,
      allowSpread: r,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, h = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let d = !1, y = null, m = null, T = this.startNode();
        if (a && this.isContextual(118)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), y = this.state.startLoc, s = !1);
        }
        if (s && this.isContextual(106)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), d = !0);
        }
        let b = this.flowParseVariance();
        if (this.eat(0))
          y != null && this.unexpected(y), this.eat(0) ? (b && this.unexpected(b.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          T, d))) : u.indexers.push(this.flowParseObjectTypeIndexer(T, d, b));
        else if (this.match(10) || this.match(47))
          y != null && this.unexpected(y), b && this.unexpected(b.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(T, d));
        else {
          let E = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let K = this.lookahead();
            UU(K.type) && (E = this.state.value, this.next());
          }
          let w = this.flowParseObjectTypeProperty(T, d, y, b, E, r, o ?? !p);
          w === null ? (h = !0, m = this.state.lastTokStartLoc) : u.properties.push(w);
        }
        this.flowObjectTypeSemicolon(), m && !this.match(8) && !this.match(9) && this.raise(Ot.UnexpectedExplicitInexactInObject, m);
      }
      this.expect(c), r && (u.inexact = h);
      let f = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, f;
    }
    flowParseObjectTypeProperty(s, i, r, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Ot.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Ot.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Ot.InexactVariance, a), null) : (l || this.raise(
        Ot.UnexpectedSpreadType, this.state.lastTokStartLoc), r != null && this.unexpected(r), a && this.raise(Ot.SpreadVariance, a), s.argument =
        this.flowParseType(), this.finishNode(s, "ObjectTypeSpreadProperty"));
      {
        s.key = this.flowParseObjectPropertyKey(), s.static = i, s.proto = r != null, s.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (s.method = !0, r != null && this.unexpected(r), a && this.unexpected(a.loc.start), s.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(s),
        !l && s.key.name === "constructor" && s.value.this && this.raise(Ot.ThisParamBannedInConstructor, s.value.this)) : (o !== "init" && this.
        unexpected(), s.method = !1, this.eat(17) && (c = !0), s.value = this.flowParseTypeInitialiser(), s.variance = a), s.optional = c, this.
        finishNode(s, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(s) {
      let i = s.kind === "get" ? 0 : 1, r = s.value.params.length + (s.value.rest ? 1 : 0);
      s.value.this && this.raise(s.kind === "get" ? Ot.GetterMayNotHaveThisParam : Ot.SetterMayNotHaveThisParam, s.value.this), r !== i && this.
      raise(s.kind === "get" ? G.BadGetterArity : G.BadSetterArity, s), s.kind === "set" && s.value.rest && this.raise(G.BadSetterRestParameter,
      s);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(s, i) {
      s ?? (s = this.state.startLoc);
      let r = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(s);
        a.qualification = r, a.id = this.flowParseRestrictedIdentifier(!0), r = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return r;
    }
    flowParseGenericType(s, i) {
      let r = this.startNodeAt(s);
      return r.typeParameters = null, r.id = this.flowParseQualifiedTypeIdentifier(s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(r, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let s = this.startNode();
      return this.expect(87), s.argument = this.flowParsePrimaryType(), this.finishNode(s, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let s = this.startNode();
      for (s.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (s.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(s, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(s) {
      let i = null, r = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !s && this.raise(Ot.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (r = !0, u && this.raise(Ot.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = r, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(s) {
      let i = this.startNodeAt(s.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = s, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(s = []) {
      let i = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(!0), r.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        s.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: s,
        rest: i,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(s, i, r) {
      switch (r.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r.name), this.flowParseGenericType(s, r);
      }
    }
    flowParsePrimaryType() {
      let s = this.state.startLoc, i = this.startNode(), r, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r = this.flowParseFunctionTypeParams(), u.params =
          r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (Ws(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? r = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : r = this.flowParseFunctionTypeParams(),
          u.params = r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(Ot.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (oN(this.state.type)) {
            let u = wc(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (Ws(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let s = this.state.startLoc, i = this.flowParsePrimaryType(), r = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(s), o = this.eat(18);
        r = r || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), r ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let s = this.startNode();
      return this.eat(17) ? (s.typeAnnotation = this.flowParsePrefixType(), this.finishNode(s, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let s = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(s.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(s)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return s;
    }
    flowParseIntersectionType() {
      let s = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (s.types = [i]; this.eat(45); )
        s.types.push(this.flowParseAnonFunctionWithoutParens());
      return s.types.length === 1 ? i : this.finishNode(s, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let s = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (s.types = [i]; this.eat(43); )
        s.types.push(this.flowParseIntersectionType());
      return s.types.length === 1 ? i : this.finishNode(s, "UnionTypeAnnotation");
    }
    flowParseType() {
      let s = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = s, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let s = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(s, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let s = this.startNode();
      return s.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(s, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(s) {
      let i = s ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    flowParseVariance() {
      let s = null;
      return this.match(53) ? (s = this.startNode(), this.state.value === "+" ? s.kind = "plus" : s.kind = "minus", this.next(), this.finishNode(
      s, "Variance")) : s;
    }
    parseFunctionBody(s, i, r = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(s, () => super.parseFunctionBody(s, !0, r));
        return;
      }
      super.parseFunctionBody(s, !1, r);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), s.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(s, i, r);
    }
    parseStatementLike(s) {
      if (this.state.strict && this.isContextual(129)) {
        let r = this.lookahead();
        if (yo(r.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      let i = super.parseStatementLike(s);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(s, i, r) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || Ws(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(s);
        } else if (Ws(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(s);
          if (i.name === "type")
            return this.flowParseTypeAlias(s);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(s, !1);
        }
      }
      return super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      let {
        type: s
      } = this.state;
      return s === 126 || kU(s) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: s
      } = this.state;
      return s === 126 || kU(s) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let f = this.lookaheadCharCode();
        if (f === 44 || f === 61 || f === 58 || f === 41)
          return this.setOptionalParametersError(r), s;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, h] = this.getArrowLikeExpressions(u);
      if (c || h.length > 0) {
        let f = [...o];
        if (h.length > 0) {
          this.state = a, this.state.noArrowAt = f;
          for (let d = 0; d < h.length; d++)
            f.push(h[d].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, h] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Ot.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, f.push(p[0].start),
        this.state.noArrowAt = f, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = s, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let s = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: s,
        failed: i
      };
    }
    getArrowLikeExpressions(s, i) {
      let r = [s], a = [];
      for (; r.length !== 0; ) {
        let o = r.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : _Me(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(s) {
      var i;
      this.toAssignableList(s.params, (i = s.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(s, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(s, i) {
      let r;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), r = i(), this.state.noArrowParamsConversionAt.pop()) : r = i(), r;
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(s) {
      s.type === "ImportDeclaration" && (s.importKind === "type" || s.importKind === "typeof") || s.type === "ExportNamedDeclaration" && s.exportKind ===
      "type" || s.type === "ExportAllDeclaration" && s.exportKind === "type" || super.assertModuleNodeAllowed(s);
    }
    parseExportDeclaration(s) {
      if (this.isContextual(130)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (s.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(s), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        s.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(s);
    }
    eatExportStar(s) {
      return super.eatExportStar(s) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (s.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(s) {
      let {
        startLoc: i
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(s);
      return r && s.exportKind === "type" && this.unexpected(i), r;
    }
    parseClassId(s, i, r) {
      super.parseClassId(s, i, r), this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(s, i, r) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(s, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(s, i, r), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(Ot.DeclareClassElement, a) : i.value && this.raise(Ot.DeclareClassFieldInitializer, i.value));
    }
    isIterator(s) {
      return s === "iterator" || s === "asyncIterator";
    }
    readIterator() {
      let s = super.readWord1(), i = "@@" + s;
      (!this.isIterator(s) || !this.state.inType) && this.raise(G.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      s === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (s === 62 || s === 60) ? this.finishOp(s === 62 ? 48 : 47, 1) : this.
      state.inType && s === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : mMe(s, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(s);
    }
    isAssignable(s, i) {
      return s.type === "TypeCastExpression" ? this.isAssignable(s.expression, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      !i && s.type === "AssignmentExpression" && s.left.type === "TypeCastExpression" && (s.left = this.typeCastToParameter(s.left)), super.
      toAssignable(s, i);
    }
    toAssignableList(s, i, r) {
      for (let a = 0; a < s.length; a++) {
        let o = s[a];
        o?.type === "TypeCastExpression" && (s[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(s, i, r);
    }
    toReferencedList(s, i) {
      for (let a = 0; a < s.length; a++) {
        var r;
        let o = s[a];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (s.length > 1 || !i) && this.raise(Ot.TypeCastInPattern,
        o.typeAnnotation);
      }
      return s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(s, i, r) {
      return s === "TypeCastExpression" || super.isValidLVal(s, i, r);
    }
    parseClassProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(s) {
      return !this.match(14) && super.isNonstaticConstructor(s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(s, i, r, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ot.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ot.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(s, i, r, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(s, i, r, a);
    }
    parseClassSuper(s) {
      if (super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = s.implements = [];
        do {
          let r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.
          typeParameters = null, i.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(s) {
      super.checkGetterSetterParams(s);
      let i = this.getObjectOrClassMethodParams(s);
      if (i.length > 0) {
        let r = i[0];
        this.isThisParam(r) && s.kind === "get" ? this.raise(Ot.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(Ot.SetterMayNotHaveThisParam,
        r);
      }
    }
    parsePropertyNamePrefixOperator(s) {
      s.variance = this.flowParseVariance();
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(s, i, r, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseFunctionParamType(s) {
      return this.eat(17) && (s.type !== "Identifier" && this.raise(Ot.PatternIsOptional, s), this.isThisParam(s) && this.raise(Ot.ThisParamMayNotBeOptional,
      s), s.optional = !0), this.match(14) ? s.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(s) && this.raise(Ot.ThisParamAnnotationRequired,
      s), this.match(29) && this.isThisParam(s) && this.raise(Ot.ThisParamNoDefault, s), this.resetEndLocation(s), s;
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(Ot.TypeBeforeInitializer,
      r.typeAnnotation), r;
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(Ot.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(s, i, r) {
      i.local = LU(s) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), s.specifiers.push(this.finishImportSpecifier(i,
      r));
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        if (!s) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      if (super.applyImportPhase(s, i, r, a), i) {
        if (!r && this.match(65))
          return;
        s.exportKind = r === "type" ? r : "value";
      } else
        r === "type" && this.match(55) && this.unexpected(), s.importKind = r === "type" || r === "typeof" ? r : "value";
    }
    parseImportSpecifier(s, i, r, a, o) {
      let l = s.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let h = this.parseIdentifier(!0);
        u !== null && !yo(this.state.type) ? (s.imported = h, s.importKind = u, s.local = Jl(h)) : (s.imported = l, s.importKind = null, s.local =
        this.parseIdentifier());
      } else {
        if (u !== null && yo(this.state.type))
          s.imported = this.parseIdentifier(!0), s.importKind = u;
        else {
          if (i)
            throw this.raise(G.ImportBindingIsString, s, {
              importName: l.value
            });
          s.imported = l, s.importKind = null;
        }
        this.eatContextual(93) ? s.local = this.parseIdentifier() : (c = !0, s.local = Jl(s.imported));
      }
      let p = LU(s);
      return r && p && this.raise(Ot.ImportTypeShorthandOnlyInPureImport, s), (r || p) && this.checkReservedType(s.local.name, s.local.loc.start,
      !0), c && !r && !p && this.checkReservedWord(s.local.name, s.loc.start, !0, !0), this.finishImportSpecifier(s, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(s, i) {
      let r = s.kind;
      r !== "get" && r !== "set" && this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), this.match(14) && (s.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      if (this.match(14)) {
        let r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, s.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(s, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(s, i) {
      var r;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(s, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Vs.j_oTag || p === Vs.j_expr) && c.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((f) => {
          var d;
          c = this.flowParseTypeParameterDeclaration();
          let y = this.forwardNoArrowParamsConversionAt(c, () => {
            let T = super.parseMaybeAssign(s, i);
            return this.resetStartLocationFromNode(T, c), T;
          });
          (d = y.extra) != null && d.parenthesized && f();
          let m = this.maybeUnwrapTypeCastExpression(y);
          return m.type !== "ArrowFunctionExpression" && f(), m.typeParameters = c, this.resetStartLocationFromNode(m, c), y;
        }, a), h = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Ot.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          h = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (h)
          return this.state = p.failState, h;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Ot.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), s.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(s);
    }
    shouldParseArrow(s) {
      return this.match(14) || super.shouldParseArrow(s);
    }
    setArrowFunctionParameters(s, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? s.params = i : super.setArrowFunctionParameters(s, i);
    }
    checkParams(s, i, r, a = !0) {
      if (!(r && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)))) {
        for (let o = 0; o < s.params.length; o++)
          this.isThisParam(s.params[o]) && o > 0 && this.raise(Ot.ThisParamMustBeFirst, s.params[o]);
        super.checkParams(s, i, r, a);
      }
    }
    parseParenAndDistinguishExpression(s) {
      return super.parseParenAndDistinguishExpression(s && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(s, i, r) {
      if (s.type === "Identifier" && s.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = s, a.arguments = super.parseCallExpressionArguments(11), s = this.finishNode(a, "CallExpression");
      } else if (s.type === "Identifier" && s.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(s, i, r), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(s, i, r);
    }
    parseSubscript(s, i, r, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, r)
          return a.stop = !0, s;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = s, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = s;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      super.parseNewCallee(s);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), s.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(s) {
      let i = this.startNodeAt(s);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(s);
    }
    readToken_pipe_amp(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(s);
    }
    parseTopLevel(s, i) {
      let r = super.parseTopLevel(s, i);
      return this.state.hasFlowComment && this.raise(Ot.UnterminatedFlowComment, this.state.curPosition()), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ot.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let s = this.skipFlowComment();
        s && (this.state.pos += s, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: s
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(s + i)); )
        i++;
      let r = this.input.charCodeAt(i + s), a = this.input.charCodeAt(i + s + 1);
      return r === 58 && a === 58 ? i + 2 : this.input.slice(i + s, i + s + 12) === "flow-include" ? i + 12 : r === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(G.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(s, {
      enumName: i,
      memberName: r
    }) {
      this.raise(Ot.EnumBooleanMemberNotInitialized, s, {
        memberName: r,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(s, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? Ot.EnumInvalidMemberInitializerSymbolType : Ot.EnumInvalidMemberInitializerPrimaryType :
      Ot.EnumInvalidMemberInitializerUnknownType, s, i);
    }
    flowEnumErrorNumberMemberNotInitialized(s, i) {
      this.raise(Ot.EnumNumberMemberNotInitialized, s, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(s, i) {
      this.raise(Ot.EnumStringMemberInconsistentlyInitialized, s, i);
    }
    flowEnumMemberInit() {
      let s = this.state.startLoc, i = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let r = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 134: {
          let r = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 85:
        case 86: {
          let r = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        default:
          return {
            type: "invalid",
            loc: s
          };
      }
    }
    flowEnumMemberRaw() {
      let s = this.state.startLoc, i = this.parseIdentifier(!0), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: s
      };
      return {
        id: i,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(s, i, r) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== r && this.flowEnumErrorInvalidMemberInitializer(s, i);
    }
    flowEnumMembers({
      enumName: s,
      explicitType: i
    }) {
      let r = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Ot.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: s
        }), r.has(p) && this.raise(Ot.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: s
        }), r.add(p);
        let h = {
          enumName: s,
          explicitType: i,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, h);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, h);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, h);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(s, i, {
      enumName: r
    }) {
      if (s.length === 0)
        return i;
      if (i.length === 0)
        return s;
      if (i.length > s.length) {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return s;
      }
    }
    flowEnumParseExplicitType({
      enumName: s
    }) {
      if (!this.eatContextual(102)) return null;
      if (!Ws(this.state.type))
        throw this.raise(Ot.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: s
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(Ot.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: s,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(s, i) {
      let r = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (s.hasUnknownMembers = u, o) {
        case "boolean":
          return s.explicitType = !0, s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
        case "number":
          return s.explicitType = !0, s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
        case "string":
          return s.explicitType = !0, s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(s, "EnumStringBody");
        case "symbol":
          return s.members = l.defaultedMembers, this.expect(8), this.finishNode(s, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (s.members = [], this.expect(8), this.finishNode(s, "EnumStringBody")), "empty");
          s.explicitType = !1;
          let p = l.booleanMembers.length, h = l.numberMembers.length, f = l.stringMembers.length, d = l.defaultedMembers.length;
          if (!p && !h && !f && !d)
            return c();
          if (!p && !h)
            return s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(s, "EnumStringBody");
          if (!h && !f && p >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
          } else if (!p && !f && h >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
          } else
            return this.raise(Ot.EnumInconsistentMemberValues, a, {
              enumName: r
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(s) {
      let i = this.parseIdentifier();
      return s.id = i, s.body = this.flowEnumBody(this.startNode(), i), this.finishNode(s, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(s) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (s.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(s);
    }
    isLookaheadToken_lt() {
      let s = this.nextTokenStart();
      if (this.input.charCodeAt(s) === 60) {
        let i = this.input.charCodeAt(s + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    maybeUnwrapTypeCastExpression(s) {
      return s.type === "TypeCastExpression" ? s.expression : s;
    }
  }, "flow"), MMe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, sh = Hl`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Cc(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(Cc, "isFragment");
  function rd(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return rd(t.object) + "." + rd(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(rd, "getQualifiedJSXName");
  var FMe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let s = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(sh.UnterminatedJsxContent, this.state.startLoc);
        let r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r);
              return;
            }
            s += this.input.slice(i, this.state.pos), this.finishToken(142, s);
            return;
          case 38:
            s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            ad(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(s) {
      let i = this.input.charCodeAt(this.state.pos), r;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = s ? `
` : `\r
`) : r = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(s) {
      let i = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(G.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === s) break;
        a === 38 ? (i += this.input.slice(r, this.state.pos), i += this.jsxReadEntity(), r = this.state.pos) : ad(a) ? (i += this.input.slice(
        r, this.state.pos), i += this.jsxReadNewLine(!1), r = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(r, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let s = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let r = this.readInt(i, void 0, !1, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let i = 0, r = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (r) {
          let a = this.input.slice(s, this.state.pos), o = MMe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = s, "&";
    }
    jsxReadWord() {
      let s, i = this.state.pos;
      do
        s = this.input.charCodeAt(++this.state.pos);
      while (nd(s) || s === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let s = this.startNode();
      return this.match(141) ? s.name = this.state.value : oN(this.state.type) ? s.name = wc(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(s, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let s = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let r = this.startNodeAt(s);
      return r.namespace = i, r.name = this.jsxParseIdentifier(), this.finishNode(r, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let s = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let r = this.startNodeAt(s);
        r.object = i, r.property = this.jsxParseIdentifier(), i = this.finishNode(r, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let s;
      switch (this.state.type) {
        case 5:
          return s = this.startNode(), this.setContext(Vs.brace), this.next(), s = this.jsxParseExpressionContainer(s, Vs.j_oTag), s.expression.
          type === "JSXEmptyExpression" && this.raise(sh.AttributeIsEmpty, s), s;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(sh.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let s = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(s, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(s) {
      return this.next(), s.expression = this.parseExpression(), this.setContext(Vs.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(s, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(s, i) {
      if (this.match(8))
        s.expression = this.jsxParseEmptyExpression();
      else {
        let r = this.parseExpression();
        s.expression = r;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let s = this.startNode();
      return this.match(5) ? (this.setContext(Vs.brace), this.next(), this.expect(21), s.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Vs.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadAttribute")) : (s.name = this.jsxParseNamespacedName(),
      s.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(s, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(s) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return s.attributes = i, s.selfClosing = this.eat(56), this.expect(144), this.finishNode(s, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(s) {
      let i = this.startNodeAt(s), r = [], a = this.jsxParseOpeningElementAt(s), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (s = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(s);
                break e;
              }
              r.push(this.jsxParseElementAt(s));
              break;
            case 142:
              r.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Vs.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(l)) : r.push(this.jsxParseExpressionContainer(
              l, Vs.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Cc(a) && !Cc(o) && o !== null ? this.raise(sh.MissingClosingTagFragment, o) : !Cc(a) && Cc(o) ? this.raise(sh.MissingClosingTagElement,
        o, {
          openingTagName: rd(a.name)
        }) : !Cc(a) && !Cc(o) && rd(o.name) !== rd(a.name) && this.raise(sh.MissingClosingTagElement, o, {
          openingTagName: rd(a.name)
        });
      }
      if (Cc(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = r, this.match(
      47))
        throw this.raise(sh.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Cc(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let s = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(s);
    }
    setContext(s) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = s;
    }
    parseExprAtom(s) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(s);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(s) {
      let i = this.curContext();
      if (i === Vs.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Vs.j_oTag || i === Vs.j_cTag) {
        if ($l(s)) {
          this.jsxReadWord();
          return;
        }
        if (s === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((s === 34 || s === 39) && i === Vs.j_oTag) {
          this.jsxReadString(s);
          return;
        }
      }
      if (s === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(s);
    }
    updateContext(s) {
      let {
        context: i,
        type: r
      } = this.state;
      if (r === 56 && s === 143)
        i.splice(-2, 2, Vs.j_cTag), this.state.canStartJSXElement = !1;
      else if (r === 143)
        i.push(Vs.j_oTag);
      else if (r === 144) {
        let a = i[i.length - 1];
        a === Vs.j_oTag && s === 56 || a === Vs.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Vs.j_expr) : (this.setContext(
        Vs.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = ZBe(r);
    }
  }, "jsx"), zI = class extends ng {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, GI = class extends ag {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new zI(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, s) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(e))
        return !0;
      if (!s && i > 1) {
        for (let r = 0; r < i - 1; r++)
          if (this.importsStack[r].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, s, i) {
      if (s & 4096) {
        this.hasImport(e, !0) && this.parser.raise(G.VarRedeclaration, i, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let r = this.currentScope(), a = r.tsNames.get(e) || 0;
      if (s & 1024) {
        this.maybeExportDefined(r, e), r.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, s, i), s & 2 && (s & 1 || (this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e)), a = a | 1),
      s & 256 && (a = a | 2), s & 512 && (a = a | 4), s & 128 && (a = a | 8), a && r.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, s, i) {
      let r = e.tsNames.get(s);
      if ((r & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (r & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (r & 8) > 0 ? e.names.get(s) & 2 ? !!(i & 1) : !1 : i & 2 && (r & 1) > 0 ? !0 : super.isRedeclaredInScope(e, s, i);
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      if (this.hasImport(s)) return;
      let i = this.scopeStack.length;
      for (let r = i - 1; r >= 0; r--) {
        let o = this.scopeStack[r].tsNames.get(s);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, QU = /* @__PURE__ */ n((t) => t.type === "ParenthesizedExpression" ? QU(t.expression) : t, "unwrapParenthesizedExpression"), QI = class extends XI {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, s = !1) {
      var i, r;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (i = e.extra) != null && i.parenthesized) && (a = QU(e), s ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(G.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(G.InvalidParenthesizedAssignment, e) : this.raise(G.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], h = l === c;
            this.toAssignableObjectExpressionProp(p, h, s), h && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(G.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, s);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, s);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(G.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, s);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, s);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, s, i) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? G.PatternHasAccessor : G.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let r = e.argument;
        this.checkToRestConversion(r, !1), this.toAssignable(r, i), s || this.raise(G.RestTrailingComma, e);
      } else
        this.toAssignable(e, i);
    }
    toAssignableList(e, s, i) {
      let r = e.length - 1;
      for (let a = 0; a <= r; a++) {
        let o = e[a];
        o && (this.toAssignableListItem(e, a, i), o.type === "RestElement" && (a < r ? this.raise(G.RestTrailingComma, o) : s && this.raise(
        G.RestTrailingComma, s)));
      }
    }
    toAssignableListItem(e, s, i) {
      let r = e[s];
      if (r.type === "SpreadElement") {
        r.type = "RestElement";
        let a = r.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(r, i);
    }
    isAssignable(e, s) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = e.properties.length - 1;
          return e.properties.every((r, a) => r.type !== "ObjectMethod" && (a === i || r.type !== "SpreadElement") && this.isAssignable(r));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !s;
        default:
          return !1;
      }
    }
    toReferencedList(e, s) {
      return e;
    }
    toReferencedListDeep(e, s) {
      this.toReferencedList(e, s);
      for (let i of e)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(e) {
      let s = this.startNode();
      return this.next(), s.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(s, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, s, i) {
      let r = i & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), r && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(s)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(G.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: s
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return e === 139 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(this.state.value, s), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, s, !1, !1, !0, !1);
    }
    parseBindingElement(e, s) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || e & 2) && this.parseFunctionParamType(i);
      let r = this.parseMaybeDefault(i.loc.start, i);
      return s.length && (i.decorators = s), r;
    }
    parseFunctionParamType(e) {
      return e;
    }
    parseMaybeDefault(e, s) {
      if (e ?? (e = this.state.startLoc), s = s ?? this.parseBindingAtom(), !this.eat(29)) return s;
      let i = this.startNodeAt(e);
      return i.left = s, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(e, s, i) {
      switch (e) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, s, i = 64, r = !1, a = !1, o = !1) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), s.type !== "AssignmentExpression" && this.raise(G.InvalidLhsOptionalChaining,
        e, {
          ancestor: s
        })), i !== 64 && this.raise(G.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, i, a);
        let {
          name: m
        } = e;
        r && (r.has(m) ? this.raise(G.ParamDupe, e) : r.add(m));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && s.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let m = i === 64 ? G.InvalidLhs : G.InvalidLhsBinding;
        this.raise(m, e, {
          ancestor: s
        });
        return;
      }
      let h, f;
      typeof p == "string" ? (h = p, f = u === "ParenthesizedExpression") : [h, f] = p;
      let d = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : s, y = e[h];
      if (Array.isArray(y))
        for (let m of y)
          m && this.checkLVal(m, d, i, r, a, f);
      else y && this.checkLVal(y, d, i, r, a, f);
    }
    checkIdentifier(e, s, i = !1) {
      this.state.strict && (i ? JU(e.name, this.inModule) : HU(e.name)) && (s === 64 ? this.raise(G.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(G.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), s & 8192 && e.name === "let" && this.raise(G.LetInLexicalBinding, e), s & 64 || this.declareNameFromIdentifier(e, s);
    }
    declareNameFromIdentifier(e, s) {
      this.scope.declareName(e.name, s, e.loc.start);
    }
    checkToRestConversion(e, s) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, s);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (s) break;
        default:
          this.raise(G.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? G.RestTrailingComma : G.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function jMe(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(jMe, "nonNull");
  function BU(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(BU, "assert");
  var ot = Hl`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function RMe(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(RMe, "keywordTypeFromName");
  function MU(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(MU, "tsIsAccessModifier");
  function qMe(t) {
    return t === "in" || t === "out";
  }
  n(qMe, "tsIsVarianceAnnotations");
  var UMe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...s) {
      super(...s), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ot.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ot.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ot.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return GI;
    }
    tsIsIdentifier() {
      return Ws(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(s, i) {
      if (!Ws(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let r = this.state.value;
      if (s.includes(r)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      allowedModifiers: s,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: r,
      errorTemplate: a = ot.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, h, f) => {
        p === h && o[f] && this.raise(ot.InvalidModifiersOrder, c, {
          orderedModifiers: [h, f]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, h, f) => {
        (o[h] && p === f || o[f] && p === h) && this.raise(ot.IncompatibleModifiers, c, {
          modifiers: [h, f]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(s.concat(i ?? []), r);
        if (!p) break;
        MU(p) ? o.accessibility ? this.raise(ot.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : qMe(p) ? (o[p] && this.raise(ot.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(ot.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(s) {
      switch (s) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(s, i) {
      let r = [];
      for (; !this.tsIsListTerminator(s); )
        r.push(i());
      return r;
    }
    tsParseDelimitedList(s, i, r) {
      return jMe(this.tsParseDelimitedListWorker(s, i, !0, r));
    }
    tsParseDelimitedListWorker(s, i, r, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(s); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(s))
          break;
        r && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(s, i, r, a, o) {
      a || (r ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(s, i, o);
      return r ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let s = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? s.argument = this.parseStringLiteral(this.state.value) : (this.raise(ot.UnsupportedImportTypeArgument,
      this.state.startLoc), s.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (s.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : s.options = null, this.expect(11), this.eat(16) && (s.qualifier = this.tsParseEntityName(3)), this.match(47) && (s.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(s, "TSImportType");
    }
    tsParseEntityName(s) {
      let i;
      if (s & 1 && this.match(78))
        if (s & 2)
          i = this.parseIdentifier(!0);
        else {
          let r = this.startNode();
          this.next(), i = this.finishNode(r, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(s & 1));
      for (; this.eat(16); ) {
        let r = this.startNodeAtNode(i);
        r.left = i, r.right = this.parseIdentifier(!!(s & 1)), i = this.finishNode(r, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let s = this.startNode();
      return s.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(s, "TSTypeReference");
    }
    tsParseThisTypePredicate(s) {
      this.next();
      let i = this.startNodeAtNode(s);
      return i.parameterName = s, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let s = this.startNode();
      return this.next(), this.finishNode(s, "TSThisType");
    }
    tsParseTypeQuery() {
      let s = this.startNode();
      return this.expect(87), this.match(83) ? s.exprName = this.tsParseImportType() : s.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeQuery");
    }
    tsParseTypeParameter(s) {
      let i = this.startNode();
      return s(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(s) {
      if (this.match(47))
        return this.tsParseTypeParameters(s);
    }
    tsParseTypeParameters(s) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, s), !1, !0, r), i.params.
      length === 0 && this.raise(ot.EmptyTypeParameters, i), r.value !== -1 && this.addExtra(i, "trailingComma", r.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(s, i) {
      let r = s === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      r ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(s) : this.match(s) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(s));
    }
    tsParseBindingListForSignature() {
      let s = super.parseBindingList(11, 41, 2);
      for (let i of s) {
        let {
          type: r
        } = i;
        (r === "AssignmentPattern" || r === "TSParameterProperty") && this.raise(ot.UnsupportedSignatureParameterKind, i, {
          type: r
        });
      }
      return s;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(s, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, s);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Ws(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(s) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), s.parameters = [i];
      let r = this.tsTryParseTypeAnnotation();
      return r && (s.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(s, i) {
      this.eat(17) && (s.optional = !0);
      let r = s;
      if (this.match(10) || this.match(47)) {
        i && this.raise(ot.ReadonlyForMethodSignature, s);
        let a = r;
        a.kind && this.match(47) && this.raise(ot.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(G.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(ot.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(G.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(ot.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(ot.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            ot.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(ot.SetAccessorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = r;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let s = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", s);
      if (this.match(77)) {
        let r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", s) : (s.key = this.
        createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(s, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, s);
      let i = this.tsTryParseIndexSignature(s);
      return i || (super.parsePropertyName(s), !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (s.kind = s.key.name, super.parsePropertyName(s)), this.tsParsePropertyOrMethodSignature(s, !!s.readonly));
    }
    tsParseTypeLiteral() {
      let s = this.startNode();
      return s.members = this.tsParseObjectTypeMembers(), this.finishNode(s, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let s = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), s;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let s = this.startNode();
      this.expect(5), this.match(53) ? (s.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (s.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), s.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return s.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (s.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (s.optional = !0), s.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(s, "TSMappedType");
    }
    tsParseTupleType() {
      let s = this.startNode();
      s.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return s.elementTypes.forEach((r) => {
        let {
          type: a
        } = r;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && r.optional) && this.raise(ot.OptionalTypeBeforeRequired,
        r), i || (i = a === "TSNamedTupleMember" && r.optional || a === "TSOptionalType");
      }), this.finishNode(s, "TSTupleType");
    }
    tsParseTupleElementType() {
      let s = this.state.startLoc, i = this.eat(21), {
        startLoc: r
      } = this.state, a, o, l, u, p = yo(this.state.type) ? this.lookaheadCharCode() : null;
      if (p === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (p === 63) {
        l = !0;
        let h = this.state.value, f = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(r), h), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = f, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let h;
        o ? (h = this.startNodeAt(r), h.optional = l, h.label = o, h.elementType = u, this.eat(17) && (h.optional = !0, this.raise(ot.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (h = this.startNodeAt(r), h.optional = l, this.raise(ot.InvalidTupleMemberLabel, u), h.label = u, h.
        elementType = this.tsParseType()), u = this.finishNode(h, "TSNamedTupleMember");
      } else if (l) {
        let h = this.startNodeAt(r);
        h.typeAnnotation = u, u = this.finishNode(h, "TSOptionalType");
      }
      if (i) {
        let h = this.startNodeAt(s);
        h.typeAnnotation = u, u = this.finishNode(h, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let s = this.startNode();
      return this.expect(10), s.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(s, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(s, i) {
      let r = this.startNode();
      return s === "TSConstructorType" && (r.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, r)), this.finishNode(r, s);
    }
    tsParseLiteralTypeNode() {
      let s = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          s.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(s, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let s = this.startNode();
        return s.literal = super.parseTemplate(!1), this.finishNode(s, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let s = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(s) : s;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let s = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: s
          } = this.state;
          if (Ws(s) || s === 88 || s === 84) {
            let i = s === 88 ? "TSVoidKeyword" : s === 84 ? "TSNullKeyword" : RMe(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let r = this.startNode();
              return this.next(), this.finishNode(r, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: s
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let r = this.startNodeAt(s);
          r.elementType = i, this.expect(3), i = this.finishNode(r, "TSArrayType");
        } else {
          let r = this.startNodeAt(s);
          r.objectType = i, r.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(r, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let s = this.startNode(), i = this.state.value;
      return this.next(), s.operator = i, s.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      s), this.finishNode(s, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(s) {
      switch (s.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ot.UnexpectedReadonly, s);
      }
    }
    tsParseInferType() {
      let s = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), s.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(s, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let s = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return s;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return nMe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(s, i, r) {
      let a = this.startNode(), o = this.eat(r), l = [];
      do
        l.push(i());
      while (this.eat(r));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, s));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Ws(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return this.parseObjectLike(8, !0), s.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return super.parseBindingList(3, 93, 1), s.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(s) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(s);
        let r = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = !0, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, r), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (r.parameterName = this.parseIdentifier(), r.asserts = a, r.typeAnnotation = null, i.typeAnnotation = this.finishNode(r,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return r.parameterName = o, r.typeAnnotation = l, r.asserts = a, i.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let s = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), s;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let s = this.state.containsEsc;
      return this.next(), !Ws(this.state.type) && !this.match(78) ? !1 : (s && this.raise(G.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(s = !0, i = this.startNode()) {
      return this.tsInType(() => {
        s && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      BU(this.state.inType);
      let s = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return s;
      let i = this.startNodeAtNode(s);
      return i.checkType = s, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ot.ReservedTypeAssertion, this.state.startLoc);
      let s = this.startNode();
      return s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), s.expression = this.parseMaybeUnary(), this.finishNode(s, "TSTypeAssertion");
    }
    tsParseHeritageClause(s) {
      let i = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return r.length || this.raise(ot.EmptyHeritageClauseType, i, {
        token: s
      }), r;
    }
    tsParseInterfaceDeclaration(s, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (s.declare = !0), Ws(this.state.type) ? (s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, 130)) : (s.id = null, this.raise(ot.MissingInterfaceName, this.state.startLoc)), s.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (s.extends = this.tsParseHeritageClause("extends"));
      let r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), s.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(
      s, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(s) {
      return s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 2), s.typeAnnotation = this.tsInType(() => {
        if (s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(s, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(s) {
      if (this.curContext() !== Vs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    tsInType(s) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return s();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(s) {
      if (this.match(s))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(s) {
      return this.tsInType(() => (this.expect(s), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let s = this.startNode();
      return s.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (s.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(s, "TSEnumMember");
    }
    tsParseEnumDeclaration(s, i = {}) {
      return i.const && (s.const = !0), i.declare && (s.declare = !0), this.expectContextual(126), s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, s.const ? 8971 : 8459), this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(s, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let s = this.startNode();
      return this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      s, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let s = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(s.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      s, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(s, i = !1) {
      if (s.id = this.parseIdentifier(), i || this.checkIdentifier(s.id, 1024), this.eat(16)) {
        let r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, !0), s.body = r;
      } else
        this.scope.enter(256), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(s, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(s) {
      return this.isContextual(112) ? (s.kind = "global", s.global = !0, s.id = this.parseIdentifier()) : this.match(134) ? (s.kind = "modul\
e", s.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(s, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(s, i, r) {
      s.isExport = r || !1, s.id = i || this.parseIdentifier(), this.checkIdentifier(s.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return s.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(ot.ImportAliasHasImportType, a), s.moduleReference =
      a, this.semicolon(), this.finishNode(s, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let s = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), s.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExternalModuleReference");
    }
    tsLookAhead(s) {
      let i = this.state.clone(), r = s();
      return this.state = i, r;
    }
    tsTryParseAndCatch(s) {
      let i = this.tryParse((r) => s() || r());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(s) {
      let i = this.state.clone(), r = s();
      if (r !== void 0 && r !== !1)
        return r;
      this.state = i;
    }
    tsTryParseDeclare(s) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, r;
      return this.isContextual(100) && (i = 74, r = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return s.declare = !0, super.parseFunctionStatement(s, !1, !1);
          case 80:
            return s.declare = !0, this.parseClass(s, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(s, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(s);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (s.declare = !0, this.parseVarStatement(s, r || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(s, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(s, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (Ws(i))
              return this.tsParseDeclaration(s, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(s, i, r) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(s);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = s;
            return a.kind = "global", s.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(s, i.name, !1, r);
      }
    }
    tsParseDeclaration(s, i, r, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || Ws(this.state.type)))
            return this.tsParseAbstractDeclaration(s, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(s);
            if (Ws(this.state.type))
              return s.kind = "module", this.tsParseModuleOrNamespaceDeclaration(s);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && Ws(this.state.type))
            return s.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(s);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && Ws(this.state.type))
            return this.tsParseTypeAliasDeclaration(s);
          break;
      }
    }
    tsCheckLineTerminator(s) {
      return s ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(s) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let r = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(s);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!r)
        return super.parseArrowExpression(r, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let s = this.startNode();
      return s.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), s.params.length === 0 ? this.raise(ot.EmptyTypeArguments, s) : !this.state.inType && this.curContext() ===
      Vs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return aMe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(s, i) {
      let r = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(s & 4) && (o || u || l) && this.raise(ot.UnexpectedParameterModifier, r);
      let c = this.parseMaybeDefault();
      s & 2 && this.parseFunctionParamType(c);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let h = this.startNodeAt(r);
        return i.length && (h.decorators = i), o && (h.accessibility = o), u && (h.readonly = u), l && (h.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(ot.UnsupportedParameterPropertyKind, h), h.parameter = p, this.finishNode(h, "TSParamet\
erProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(s) {
      return s.type === "TSParameterProperty" && super.isSimpleParameter(s.parameter) || super.isSimpleParameter(s);
    }
    tsDisallowOptionalPattern(s) {
      for (let i of s.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(ot.PatternIsOptional, i);
    }
    setArrowFunctionParameters(s, i, r) {
      super.setArrowFunctionParameters(s, i, r), this.tsDisallowOptionalPattern(s);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      this.match(14) && (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(s, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(ot.DeclareFunctionHasImplementation, s), s.declare) ? super.parseFunctionBodyAndFinish(s, a, r) : (this.tsDisallowOptionalPattern(
      s), super.parseFunctionBodyAndFinish(s, i, r));
    }
    registerFunctionStatementId(s) {
      !s.body && s.id ? this.checkIdentifier(s.id, 1024) : super.registerFunctionStatementId(s);
    }
    tsCheckForInvalidTypeCasts(s) {
      s.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(ot.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(s, i) {
      return this.tsCheckForInvalidTypeCasts(s), s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(s, i, r, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = s, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (r)
          return a.stop = !0, s;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!r && this.atPossibleAsyncArrow(s)) {
            let f = this.tsTryParseGenericAsyncArrowFunction(i);
            if (f)
              return f;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (rx(this.state.type)) {
            let f = super.parseTaggedTemplateExpression(s, i, a);
            return f.typeParameters = c, f;
          }
          if (!r && this.eat(10)) {
            let f = this.startNodeAt(i);
            return f.callee = s, f.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters =
            c, a.optionalChainMember && (f.optional = o), this.finishCallExpression(f, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && sg(p) && !this.hasPrecedingLineBreak())
            return;
          let h = this.startNodeAt(i);
          return h.expression = s, h.typeParameters = c, this.finishNode(h, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          ot.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      var i;
      super.parseNewCallee(s);
      let {
        callee: r
      } = s;
      r.type === "TSInstantiationExpression" && !((i = r.extra) != null && i.parenthesized) && (s.typeParameters = r.typeParameters, s.callee =
      r.expression);
    }
    parseExprOp(s, i, r) {
      let a;
      if (tx(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = s, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(G.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, r);
      }
      return super.parseExprOp(s, i, r);
    }
    checkReservedWord(s, i, r, a) {
      this.state.isAmbientContext || super.checkReservedWord(s, i, r, a);
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(ot.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return s ? i === 123 || i === 42 : i !== 61;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      super.applyImportPhase(s, i, r, a), i ? s.exportKind = r === "type" ? "type" : "value" : s.importKind = r === "type" || r === "typeof" ?
      r : "value";
    }
    parseImport(s) {
      if (this.match(134))
        return s.importKind = "value", super.parseImport(s);
      let i;
      if (Ws(this.state.type) && this.lookaheadCharCode() === 61)
        return s.importKind = "value", this.tsParseImportEqualsDeclaration(s);
      if (this.isContextual(130)) {
        let r = this.parseMaybeImportPhase(s, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(s, r);
        i = super.parseImportSpecifiersAndAfter(s, r);
      } else
        i = super.parseImport(s);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ot.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(s, i) {
      if (this.match(83)) {
        let r = s;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, a, !0);
      } else if (this.eat(29)) {
        let r = s;
        return r.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let r = s;
        return this.expectContextual(128), r.id = this.parseIdentifier(), this.semicolon(), this.finishNode(r, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(s, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let s = this.startNode();
        return this.next(), s.abstract = !0, this.parseClass(s, !0, !0);
      }
      if (this.match(129)) {
        let s = this.tsParseInterfaceDeclaration(this.startNode());
        if (s) return s;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(s, i, r = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(s, i, r || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(ot.InitializerNotAllowedInAmbientContext, u) : VMe(u, this.hasPlugin("estree")) ||
        this.raise(ot.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(s, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseStatementContent(s, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(s, i) {
      return i.some((r) => MU(r) ? s.accessibility === r : !!s[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(s, i, r) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ot.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(ot.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(s, i)) : this.parseClassMemberWithIsStatic(s, i, r, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(s, i, r, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        s.body.push(o), i.abstract && this.raise(ot.IndexSignatureHasAbstract, i), i.accessibility && this.raise(ot.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(ot.IndexSignatureHasDeclare, i), i.override && this.raise(ot.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(ot.NonAbstractClassHasAbstractMethod, i), i.override && (r.hadSuperClass || this.
      raise(ot.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(s, i, r, a);
    }
    parsePostMemberNameModifiers(s) {
      this.eat(17) && (s.optional = !0), s.readonly && this.match(10) && this.raise(ot.ClassMethodHasReadonly, s), s.declare && this.match(10) &&
      this.raise(ot.ClassMethodHasDeclare, s);
    }
    parseExpressionStatement(s, i, r) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(s, i, r) : void 0) || super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(r), s;
      }
      return super.parseConditional(s, i, r);
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = s, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return s;
    }
    parseExportDeclaration(s) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(s));
      let i = this.state.startLoc, r = this.eatContextual(125);
      if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ot.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = Ws(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(s);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || r) && (s.exportKind = "type"), r && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(s, i, r, a) {
      if ((!i || r) && this.isContextual(113))
        return;
      super.parseClassId(s, i, r, s.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (s.typeParameters = o);
    }
    parseClassPropertyAnnotation(s) {
      s.optional || (this.eat(35) ? s.definite = !0 : this.eat(17) && (s.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (s.typeAnnotation = i);
    }
    parseClassProperty(s) {
      if (this.parseClassPropertyAnnotation(s), this.state.isAmbientContext && !(s.readonly && !s.typeAnnotation) && this.match(29) && this.
      raise(ot.DeclareClassFieldHasInitializer, this.state.startLoc), s.abstract && this.match(29)) {
        let {
          key: i
        } = s;
        this.raise(ot.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !s.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return s.abstract && this.raise(ot.PrivateElementHasAbstract, s), s.accessibility && this.raise(ot.PrivateElementHasAccessibility, s, {
        modifier: s.accessibility
      }), this.parseClassPropertyAnnotation(s), super.parseClassPrivateProperty(s);
    }
    parseClassAccessorProperty(s) {
      return this.parseClassPropertyAnnotation(s), s.optional && this.raise(ot.AccessorCannotBeOptional, s), super.parseClassAccessorProperty(
      s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(ot.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(ot.DeclareAccessor, i, {
        kind: p
      }), u && (i.typeParameters = u), super.pushClassMethod(s, i, r, a, o, l);
    }
    pushClassPrivateMethod(s, i, r, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(s, i, r, a);
    }
    declareClassPrivateMethodInScope(s, i) {
      s.type !== "TSDeclareMethod" && (s.type === "MethodDefinition" && !hasOwnProperty.call(s.value, "body") || super.declareClassPrivateMethodInScope(
      s, i));
    }
    parseClassSuper(s) {
      super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (s.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (s.typeParameters = c), super.parseObjPropValue(s, i, r, a, o, l, u);
    }
    parseFunctionParams(s, i) {
      let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      r && (s.typeParameters = r), super.parseFunctionParams(s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), s.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (s.definite = !0);
      let r = this.tsTryParseTypeAnnotation();
      r && (s.id.typeAnnotation = r, this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      return this.match(14) && (s.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(s, i);
    }
    parseMaybeAssign(s, i) {
      var r, a, o, l, u;
      let c, p, h;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(s, i), c), !p.error) return p.node;
        let {
          context: y
        } = this.state, m = y[y.length - 1];
        (m === Vs.j_oTag || m === Vs.j_expr) && y.pop();
      }
      if (!((r = p) != null && r.error) && !this.match(47))
        return super.parseMaybeAssign(s, i);
      (!c || c === this.state) && (c = this.state.clone());
      let f, d = this.tryParse((y) => {
        var m, T;
        f = this.tsParseTypeParameters(this.tsParseConstModifier);
        let b = super.parseMaybeAssign(s, i);
        return (b.type !== "ArrowFunctionExpression" || (m = b.extra) != null && m.parenthesized) && y(), ((T = f) == null ? void 0 : T.params.
        length) !== 0 && this.resetStartLocationFromNode(b, f), b.typeParameters = f, b;
      }, c);
      if (!d.error && !d.aborted)
        return f && this.reportReservedArrowTypeParam(f), d.node;
      if (!p && (BU(!this.hasPlugin("jsx")), h = this.tryParse(() => super.parseMaybeAssign(s, i), c), !h.error))
        return h.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (d.node)
        return this.state = d.failState, f && this.reportReservedArrowTypeParam(f), d.node;
      if ((o = h) != null && o.node)
        return this.state = h.failState, h.node;
      throw ((l = p) == null ? void 0 : l.error) || d.error || ((u = h) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(s) {
      var i;
      s.params.length === 1 && !s.params[0].constraint && !((i = s.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(ot.ReservedArrowTypeParam, s);
    }
    parseMaybeUnary(s, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse((r) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), s.returnType = i.node);
      }
      return super.parseArrow(s);
    }
    parseFunctionParamType(s) {
      this.eat(17) && (s.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i), this.resetEndLocation(s), s;
    }
    isAssignable(s, i) {
      switch (s.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(s.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(s, i);
      }
    }
    toAssignable(s, i = !1) {
      switch (s.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(s, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(ot.UnexpectedTypeCastInParameter, s) : this.raise(ot.UnexpectedTypeCastInParameter,
          s), this.toAssignable(s.expression, i);
          break;
        case "AssignmentExpression":
          !i && s.left.type === "TSTypeCastExpression" && (s.left = this.typeCastToParameter(s.left));
        default:
          super.toAssignable(s, i);
      }
    }
    toAssignableParenthesizedExpression(s, i) {
      switch (s.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(s.expression, i);
          break;
        default:
          super.toAssignable(s, i);
      }
    }
    checkToRestConversion(s, i) {
      switch (s.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(s.expression, !1);
          break;
        default:
          super.checkToRestConversion(s, i);
      }
    }
    isValidLVal(s, i, r) {
      switch (s) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (r !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(s, i, r);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(s, i) {
      if (this.match(47) || this.match(51)) {
        let r = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(s, i);
          return a.typeParameters = r, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(s, i);
    }
    checkCommaAfterRest(s) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === s ? (this.next(), !1) : super.checkCommaAfterRest(
      s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ot.TypeAnnotationAfterAssign,
      r.typeAnnotation), r;
    }
    getTokenFromCode(s) {
      if (this.state.inType) {
        if (s === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (s === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(s);
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    toAssignableListItem(s, i, r) {
      let a = s[i];
      a.type === "TSTypeCastExpression" && (s[i] = this.typeCastToParameter(a)), super.toAssignableListItem(s, i, r);
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    shouldParseArrow(s) {
      return this.match(14) ? s.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(s) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (s.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(s);
    }
    getGetterSetterExpectedParamCount(s) {
      let i = super.getGetterSetterExpectedParamCount(s), a = this.getObjectOrClassMethodParams(s)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let s = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i, this.resetEndLocation(s)), s;
    }
    tsInAmbientContext(s) {
      let {
        isAmbientContext: i,
        strict: r
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return s();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = r;
      }
    }
    parseClass(s, i, r) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!s.abstract;
      try {
        return super.parseClass(s, i, r);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(s, i) {
      if (this.match(80))
        return s.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(s, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return s.abstract = !0, this.raise(ot.NonClassMethodPropertyHasAbstractModifer, s), this.tsParseInterfaceDeclaration(s);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(s, i, r, a, o, l, u) {
      let c = super.parseMethod(s, i, r, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: f
        } = c;
        this.raise(ot.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(this.offsetToSourcePos(f.start), this.offsetToSourcePos(
          f.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(s, i, r, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !1, r), this.finishNode(s, "ExportSpecifier")) : (s.exportKind = "value",
      super.parseExportSpecifier(s, i, r, a));
    }
    parseImportSpecifier(s, i, r, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !0, r), this.finishNode(s, "ImportSpecifier")) : (s.importKind = "value",
      super.parseImportSpecifier(s, i, r, a, r ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(s, i, r) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = s[a], u, c = !1, p = !0, h = l.loc.start;
      if (this.isContextual(93)) {
        let d = this.parseIdentifier();
        if (this.isContextual(93)) {
          let y = this.parseIdentifier();
          yo(this.state.type) ? (c = !0, l = d, u = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = y, p = !1);
        } else yo(this.state.type) ? (p = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = d);
      } else yo(this.state.type) && (c = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && r && this.raise(i ? ot.TypeModifierIsUsedInTypeImports : ot.TypeModifierIsUsedInTypeExports, h), s[a] = l, s[o] = u;
      let f = i ? "importKind" : "exportKind";
      s[f] = c ? "type" : "value", p && this.eatContextual(93) && (s[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), s[o] ||
      (s[o] = Jl(s[a])), i && this.checkIdentifier(s[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function KMe(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: s
    } = t;
    return e && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? !1 : eK(t.object);
  }
  n(KMe, "isPossiblyLiteralEnum");
  function VMe(t, e) {
    var s;
    let {
      type: i
    } = t;
    if ((s = t.extra) != null && s.parenthesized)
      return !1;
    if (e) {
      if (i === "Literal") {
        let {
          value: r
        } = t;
        if (typeof r == "string" || typeof r == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(ZU(t, e) || WMe(t, e) || i === "TemplateLiteral" && t.expressions.length === 0 || KMe(t));
  }
  n(VMe, "isValidAmbientConstInitializer");
  function ZU(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(ZU, "isNumber");
  function WMe(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: s,
        argument: i
      } = t;
      if (s === "-" && ZU(i, e))
        return !0;
    }
    return !1;
  }
  n(WMe, "isNegativeNumber");
  function eK(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : eK(t.object);
  }
  n(eK, "isUncomputedMemberExpressionChain");
  var FU = Hl`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), $Me = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(s) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, s);
      }
    }
    finishPlaceholder(s, i) {
      let r = s;
      return (!r.expectedNode || !r.type) && (r = this.finishNode(r, "Placeholder")), r.expectedNode = i, r;
    }
    getTokenFromCode(s) {
      s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(s);
    }
    parseExprAtom(s) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(s);
    }
    parseIdentifier(s) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(s);
    }
    checkReservedWord(s, i, r, a) {
      s !== void 0 && super.checkReservedWord(s, i, r, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(s, i, r) {
      return s === "Placeholder" || super.isValidLVal(s, i, r);
    }
    toAssignable(s, i) {
      s && s.type === "Placeholder" && s.expectedNode === "Expression" ? s.expectedNode = "Pattern" : super.toAssignable(s, i);
    }
    chStartsBindingIdentifier(s, i) {
      return !!(super.chStartsBindingIdentifier(s, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(s, i) {
      s.label && s.label.type === "Placeholder" || super.verifyBreakContinue(s, i);
    }
    parseExpressionStatement(s, i) {
      var r;
      if (i.type !== "Placeholder" || (r = i.extra) != null && r.parenthesized)
        return super.parseExpressionStatement(s, i);
      if (this.match(14)) {
        let o = s;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = s;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(s, i, r) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(s, i, r);
    }
    parseFunctionId(s) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(s);
    }
    parseClass(s, i, r) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          s.id = l;
        else {
          if (r || !i)
            return s.id = null, s.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(s, a);
          throw this.raise(FU.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(s, i, r);
      return super.parseClassSuper(s), s.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!s.superClass, o), this.finishNode(
      s, a);
    }
    parseExport(s, i) {
      let r = this.parsePlaceholder("Identifier");
      if (!r) return super.parseExport(s, i);
      let a = s;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(r, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = r, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let s = this.nextTokenStart();
        if (this.isUnparsedContextual(s, "from") && this.input.startsWith(wc(133), this.nextTokenStartSince(s + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(s, i) {
      var r;
      return (r = s.specifiers) != null && r.length ? !0 : super.maybeParseExportDefaultSpecifier(s, i);
    }
    checkExport(s) {
      let {
        specifiers: i
      } = s;
      i != null && i.length && (s.specifiers = i.filter((r) => r.exported.type === "Placeholder")), super.checkExport(s), s.specifiers = i;
    }
    parseImport(s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(s);
      if (s.specifiers = [], !this.isContextual(98) && !this.match(12))
        return s.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(s, "ImportDeclaration");
      let r = this.startNodeAtNode(i);
      return r.local = i, s.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      s) || this.parseNamedImportSpecifiers(s)), this.expectContextual(98), s.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      s, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(FU.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), HMe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let s = this.state.startLoc, i = this.startNode();
        if (this.next(), Ws(this.state.type)) {
          let r = this.parseIdentifierName(), a = this.createIdentifier(i, r);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(s);
      }
    }
    parseExprAtom(s) {
      return this.parseV8Intrinsic() || super.parseExprAtom(s);
    }
  }, "v8intrinsic"), jU = ["minimal", "fsharp", "hack", "smart"], RU = ["^^", "@@", "^", "%", "#"];
  function JMe(t) {
    if (t.has("decorators")) {
      if (t.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let s = t.get("decorators").decoratorsBeforeExport;
      if (s != null && typeof s != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = t.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (t.has("flow") && t.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (t.has("placeholders") && t.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (t.has("pipelineOperator")) {
      var e;
      let s = t.get("pipelineOperator").proposal;
      if (!jU.includes(s)) {
        let r = jU.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      let i = ((e = t.get("recordAndTuple")) == null ? void 0 : e.syntaxType) === "hash";
      if (s === "hack") {
        if (t.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (t.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let r = t.get("pipelineOperator").topicToken;
        if (!RU.includes(r)) {
          let a = RU.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (r === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", t.get("recordAndTuple")])}\`.`);
      } else if (s === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", t.
        get("recordAndTuple")])}\`.`);
    }
    if (t.has("moduleAttributes")) {
      if (t.has("deprecatedImportAssert") || t.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (t.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (t.has("importAssertions") && t.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!t.has("deprecatedImportAssert") && t.has("importAttributes") && t.get("importAttributes").deprecatedAssertSyntax && t.set("deprecat\
edImportAssert", {}), t.has("recordAndTuple")) {
      let s = t.get("recordAndTuple").syntaxType;
      if (s != null) {
        let i = ["hash", "bar"];
        if (!i.includes(s))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((r) => `'${r}'`).join(", "));
      }
    }
    if (t.has("asyncDoExpressions") && !t.has("doExpressions")) {
      let s = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw s.missingPlugins = "doExpressions", s;
    }
    if (t.has("optionalChainingAssign") && t.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(JMe, "validatePlugins");
  var tK = {
    estree: XBe,
    jsx: FMe,
    flow: BMe,
    typescript: UMe,
    v8intrinsic: HMe,
    placeholders: $Me
  }, YMe = Object.keys(tK), ZI = class extends QI {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, s, i, r) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return i;
      let a = e.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? s ? (this.raise(G.RecordNoProto, a), !0) : (i && (r ? r.doubleProtoLoc ===
      null && (r.doubleProtoLoc = a.loc.start) : this.raise(G.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(e, s) {
      return e.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e.start) === s;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.optionFlags & 256 && (e.tokens = this.tokens), e;
    }
    parseExpression(e, s) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(s)) : this.allowInAnd(() => this.parseExpressionBase(s));
    }
    parseExpressionBase(e) {
      let s = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let r = this.startNodeAt(s);
        for (r.expressions = [i]; this.eat(12); )
          r.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(r.expressions), this.finishNode(r, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, s) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, s));
    }
    parseMaybeAssignAllowIn(e, s) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, s));
    }
    setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(e, s) {
      let i = this.state.startLoc, r = this.isContextual(108);
      if (r && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(i);
        return s && (u = s.call(this, u, i)), u;
      }
      let a;
      e ? a = !1 : (e = new od(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || Ws(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(e);
      if (s && (l = s.call(this, l, i)), eMe(this.state.type)) {
        let u = this.startNodeAt(i), c = this.state.value;
        if (u.operator = c, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let p = i.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= p && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= p && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression")), u;
      } else a && this.checkExpressionErrors(e, !0);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? sg(u) : sg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(G.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return l;
    }
    parseMaybeConditional(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprOps(e);
      return this.shouldExitDescending(r, i) ? r : this.parseConditional(r, s, e);
    }
    parseConditional(e, s, i) {
      if (this.eat(17)) {
        let r = this.startNodeAt(s);
        return r.test = e, r.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r.alternate = this.parseMaybeAssign(), this.finishNode(
        r, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(r, i) ? r : this.parseExprOp(r, s, -1);
    }
    parseExprOp(e, s, i) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (i >= tx(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(G.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let r = this.state.type;
      if (sMe(r) && (this.prodParam.hasIn || !this.match(58))) {
        let a = tx(r);
        if (a > i) {
          if (r === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, s);
          }
          let o = this.startNodeAt(s);
          o.left = e, o.operator = this.state.value;
          let l = r === 41 || r === 42, u = r === 40;
          if (u && (a = tx(42)), this.next(), r === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(G.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(r, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(G.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, s, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, s) {
      let i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(s));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(G.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, s), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(e, s);
      }
    }
    parseExprOpBaseRightExpr(e, s) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, oMe(e) ? s - 1 : s);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: s
      } = this.state, i = this.parseMaybeAssign();
      return KBe.has(i.type) && !((e = i.extra) != null && e.parenthesized) && this.raise(G.PipeUnparenthesizedBody, s, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(G.PipeTopicUnused, s), i;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(G.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, s) {
      let i = this.state.startLoc, r = this.isContextual(96);
      if (r && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return s || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (rMe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(G.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(G.DeletePrivateField, o);
        }
        if (!a)
          return s || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? sg(u) : sg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(G.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(e, s, i) {
      if (s) {
        let o = e;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), e;
      }
      let r = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; iMe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(r);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprAtom(e);
      return this.shouldExitDescending(r, i) ? r : this.parseSubscripts(r, s);
    }
    parseSubscripts(e, s, i) {
      let r = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, s, i, r), r.maybeAsyncArrow = !1;
      while (!r.stop);
      return e;
    }
    parseSubscript(e, s, i, r) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(e, s, i, r);
      if (rx(a))
        return this.parseTaggedTemplateExpression(e, s, r);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(G.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return r.stop = !0, e;
        r.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, s, r, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, s, r, l, o) : (r.stop = !0, e);
      }
    }
    parseMember(e, s, i, r, a) {
      let o = this.startNodeAt(s);
      return o.object = e, o.computed = r, r ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (e.type === "Super" &&
      this.raise(G.SuperPrivateField, s), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, s, i, r) {
      let a = this.startNodeAt(s);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), s, i);
    }
    parseCoverCallAndAsyncArrowHead(e, s, i, r) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(s);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = i;
      u && (this.expressionScope.enter(wMe()), o = new od()), c && (l.optional = r), r ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !r ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(s), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, s) {
      this.toReferencedListDeep(e.arguments, s);
    }
    parseTaggedTemplateExpression(e, s, i) {
      let r = this.startNodeAt(s);
      return r.tag = e, r.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(G.OptionalChainingNoTemplate, s), this.finishNode(
      r, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(e, s) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(G.ImportCallArity, e);
        else
          for (let i of e.arguments)
            i.type === "SpreadElement" && this.raise(G.ImportCallSpreadArgument, i);
      return this.finishNode(e, s ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, s, i, r) {
      let a = [], o = !0, l = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, r, s));
      }
      return this.state.inFSharpPipelineDirectBody = l, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, s) {
      var i;
      return this.resetPreviousNodeTrailingComments(s), this.expect(19), this.parseArrowExpression(e, s.arguments, !0, (i = s.extra) == null ?
      void 0 : i.trailingCommaLoc), s.innerComments && og(e, s.innerComments), s.callee.trailingComments && og(e, s.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let s, i = null, {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return s = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(s) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(s) : this.finishNode(s, "Import") : (this.raise(G.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          s, "Import"));
        case 78:
          return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          s = this.startNode(), this.next(), s.object = null;
          let a = s.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(s, "BindExpression");
          throw this.raise(G.UnsupportedBind, a);
        }
        case 139:
          return this.raise(G.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          $l(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (r === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (Ws(r)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (Ws(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, s) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = e, this.state.value = s, this.state.pos--, this.state.end--, this.state.endLoc = gn(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(e) {
      let s = this.startNode(), i = this.state.startLoc, r = this.state.type;
      return this.next(), this.finishTopicReference(s, i, e, r);
    }
    finishTopicReference(e, s, i, r) {
      if (this.testTopicReferenceConfiguration(i, s, r))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(G.PipeTopicUnbound, s), this.registerTopicReference(),
        this.finishNode(e, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(G.PrimaryTopicNotAllowed, s), this.
        registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"));
      throw this.raise(G.PipeTopicUnconfiguredToken, s, {
        token: wc(r)
      });
    }
    testTopicReferenceConfiguration(e, s, i) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: wc(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(G.PipeTopicRequiresHackPipes, s);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(sx(!0, this.prodParam.hasYield));
      let s = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(G.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, s, !0);
    }
    parseDo(e, s) {
      this.expectPlugin("doExpressions"), s && this.expectPlugin("asyncDoExpressions"), e.async = s, this.next();
      let i = this.state.labels;
      return this.state.labels = [], s ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(G.SuperNotAllowed, e) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(G.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(G.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), s = this.startNodeAt(gn(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), e.id = this.createIdentifier(s, i), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, s, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, s, i) {
      e.meta = s;
      let r = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== i || r) && this.raise(G.UnsupportedMetaProperty, e.property, {
        target: s.name,
        onlyValidPropertyName: i
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let s = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(G.ImportMetaOutsideModule, s), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(G.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = i ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, s, "meta");
    }
    parseLiteralAtNode(e, s, i) {
      return this.addExtra(i, "rawValue", e), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = e, this.next(), this.finishNode(i, s);
    }
    parseLiteral(e, s) {
      let i = this.startNode();
      return this.parseLiteralAtNode(e, s, i);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let s = this.startNode();
      return this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.pattern = e.pattern, s.flags = e.
      flags, this.next(), this.finishNode(s, "RegExpLiteral");
    }
    parseBooleanLiteral(e) {
      let s = this.startNode();
      return s.value = e, this.next(), this.finishNode(s, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let s = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(CMe());
      let r = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new od(), c = !0, p, h;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          h = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let y = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let f = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = r, this.state.inFSharpPipelineDirectBody = a;
      let d = this.startNodeAt(s);
      return e && this.shouldParseArrow(l) && (d = this.parseArrow(d)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(d, l, !1), d) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), h && this.unexpected(h), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      f)) : i = l[0], this.wrapParenthesis(s, i));
    }
    wrapParenthesis(e, s) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", e.index), this.takeSurroundingComments(s, e.index, this.
        state.lastTokEndLoc.index), s;
      let i = this.startNodeAt(e);
      return i.expression = s, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, s) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let i = this.parseMetaProperty(e, s, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(G.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let s = this.parseExprList(11);
        this.toReferencedList(s), e.arguments = s;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let s = this.match(83), i = this.parseNoCallExpr();
      e.callee = i, s && (i.type === "Import" || i.type === "ImportExpression") && this.raise(G.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(e) {
      let {
        start: s,
        startLoc: i,
        end: r,
        value: a
      } = this.state, o = s + 1, l = this.startNodeAt(gn(i, 1));
      a === null && (e || this.raise(G.InvalidEscapeSequenceTemplate, gn(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = r + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let h = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(h, gn(this.state.lastTokEndLoc, c)), h;
    }
    parseTemplate(e) {
      let s = this.startNode(), i = this.parseTemplateElement(e), r = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.push(i = this.parseTemplateElement(e));
      return s.expressions = a, s.quasis = r, this.finishNode(s, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        s ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(r), o = this.checkProto(p, i, o, r)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(G.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return s ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let s = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(G.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          s.push(this.parseDecorator());
      let i = this.startNode(), r = !1, a = !1, o;
      if (this.match(21))
        return s.length && this.unexpected(), this.parseSpread();
      s.length && (i.decorators = s, s = []), i.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(i, e), !l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: c
        } = i, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (r = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (l = !0, this.
        raise(G.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, r, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var s;
      let i = this.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e);
      r.length !== i && this.raise(e.kind === "get" ? G.BadGetterArity : G.BadSetterArity, e), e.kind === "set" && ((s = r[r.length - 1]) ==
      null ? void 0 : s.type) === "RestElement" && this.raise(G.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, s, i, r, a) {
      if (a) {
        let o = this.parseMethod(e, s, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || s || this.match(10))
        return r && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, s, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, s, i, r) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(r), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
          e.value = this.parseMaybeDefault(s, Jl(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          r != null ? r.shorthandAssignLoc === null && (r.shorthandAssignLoc = a) : this.raise(G.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(s, Jl(e.key));
        } else
          e.value = Jl(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, s, i, r, a, o, l) {
      let u = this.parseObjectMethod(e, i, r, a, o) || this.parseObjectProperty(e, s, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, s) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: r
        } = this.state, a;
        if (yo(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(r);
              break;
            case 134:
              a = this.parseStringLiteral(r);
              break;
            case 136:
              a = this.parseBigIntLiteral(r);
              break;
            case 139: {
              let o = this.state.startLoc;
              s != null ? s.privateKeyLoc === null && (s.privateKeyLoc = o) : this.raise(G.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(r);
                break;
              }
              this.unexpected();
          }
        e.key = a, i !== 139 && (e.computed = !1);
      }
    }
    initFunction(e, s) {
      e.id = null, e.generator = !1, e.async = s;
    }
    parseMethod(e, s, i, r, a, o, l = !1) {
      this.initFunction(e, i), e.generator = s, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(sx(i, e.generator)),
      this.parseFunctionParams(e, r);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !i, r, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, s, i, r) {
      this.scope.enter(6);
      let a = sx(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, i);
      let o = this.state.maybeInArrowParameters;
      return s && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, s, r)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, s, i) {
      this.toAssignableList(s, i, !1), e.params = s;
    }
    parseFunctionBodyAndFinish(e, s, i = !1) {
      return this.parseFunctionBody(e, !1, i), this.finishNode(e, s);
    }
    parseFunctionBody(e, s, i = !1) {
      let r = s && !this.match(5);
      if (this.expressionScope.enter(GU()), r)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, s, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(G.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !s && !i && !u, s, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let s = 0, i = e.length; s < i; s++)
        if (!this.isSimpleParameter(e[s])) return !1;
      return !0;
    }
    checkParams(e, s, i, r = !0) {
      let a = !s && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, o, 5, a, r);
    }
    parseExprList(e, s, i, r) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        a.push(this.parseExprListItem(s, i));
      }
      return a;
    }
    parseExprListItem(e, s, i) {
      let r;
      if (this.match(12))
        e || this.raise(G.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), r = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        r = this.parseParenItem(this.parseSpread(s), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(G.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), r = this.finishNode(a, "ArgumentPlaceholder");
      } else
        r = this.parseMaybeAssignAllowIn(s, this.parseParenItem);
      return r;
    }
    parseIdentifier(e) {
      let s = this.startNode(), i = this.parseIdentifierName(e);
      return this.createIdentifier(s, i);
    }
    createIdentifier(e, s) {
      return e.name = s, e.loc.identifierName = s, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let s, {
        startLoc: i,
        type: r
      } = this.state;
      yo(r) ? s = this.state.value : this.unexpected();
      let a = QBe(r);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(s, i, a, !1), this.next(), s;
    }
    checkReservedWord(e, s, i, r) {
      if (e.length > 10 || !gMe(e))
        return;
      if (i && dMe(e)) {
        this.raise(G.UnexpectedKeyword, s, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? r ? JU : $U : WU)(e, this.inModule)) {
        this.raise(G.UnexpectedReservedWord, s, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(G.YieldBindingIdentifier, s);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(G.AwaitBindingIdentifier, s);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(G.AwaitBindingIdentifierInStaticBlock, s);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(s);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(G.ArgumentsInClass, s);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
    }
    parseAwait(e) {
      let s = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(G.AwaitExpressionFormalParameter, s), this.eat(55) && this.raise(G.ObsoleteAwaitStar,
      s), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, !0)), this.finishNode(s, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || rx(e) || e === 102 && !this.state.containsEsc || e === 138 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield(e) {
      let s = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(G.YieldInParameter, s);
      let i = !1, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            r = this.parseMaybeAssign();
        }
      return s.delegate = i, s.argument = r, this.finishNode(s, "YieldExpression");
    }
    parseImportCall(e) {
      if (this.next(), e.source = this.parseMaybeAssignAllowIn(), e.options = null, this.eat(12) && !this.match(11) && (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(G.ImportCallArity, e);
      }
      return this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, s) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(G.PipelineHeadSequenceExpression, s);
    }
    parseSmartPipelineBodyInStyle(e, s) {
      if (this.isSimpleReference(e)) {
        let i = this.startNodeAt(s);
        return i.callee = e, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(s);
        return this.checkSmartPipeTopicBodyEarlyErrors(s), i.expression = e, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(G.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(G.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let s = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = s;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let s = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = s;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let s = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = s;
      }
    }
    allowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & ~s) {
        this.prodParam.enter(s | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & s) {
        this.prodParam.enter(s & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let s = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let r = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, e);
      return this.state.inFSharpPipelineDirectBody = i, r;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let s = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(s, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, LI = {
    kind: 1
  }, XMe = {
    kind: 2
  }, zMe = /[\uD800-\uDFFF]/u, BI = /in(?:stanceof)?/y;
  function GMe(t, e, s) {
    for (let i = 0; i < t.length; i++) {
      let r = t[i], {
        type: a
      } = r;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = gn(o.start, 1);
            t.splice(i, 1, new Go({
              type: Vl(27),
              value: "#",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }), new Go({
              type: Vl(132),
              value: u,
              start: p,
              end: c,
              startLoc: h,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (rx(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = gn(o.start, 1), f;
            e.charCodeAt(l - s) === 96 ? f = new Go({
              type: Vl(22),
              value: "`",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }) : f = new Go({
              type: Vl(8),
              value: "}",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            });
            let d, y, m, T;
            a === 24 ? (y = c - 1, m = gn(o.end, -1), d = u === null ? null : u.slice(1, -1), T = new Go({
              type: Vl(22),
              value: "`",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })) : (y = c - 2, m = gn(o.end, -2), d = u === null ? null : u.slice(1, -2), T = new Go({
              type: Vl(23),
              value: "${",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })), t.splice(i, 1, f, new Go({
              type: Vl(20),
              value: d,
              start: p,
              end: y,
              startLoc: h,
              endLoc: m
            }), T), i += 2;
            continue;
          }
        }
        r.type = Vl(a);
      }
    }
    return t;
  }
  n(GMe, "babel7CompatTokens");
  var eN = class extends ZI {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, s) {
      return e.program = this.parseProgram(s), e.comments = this.comments, this.optionFlags & 256 && (e.tokens = GMe(this.tokens, this.input,
      this.startIndex)), this.finishNode(e, "File");
    }
    parseProgram(e, s = 140, i = this.options.sourceType) {
      if (e.sourceType = i, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, s), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(G.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(e, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let r;
      return s === 140 ? r = this.finishNode(e, "Program") : r = this.finishNodeAt(e, "Program", gn(this.state.startLoc, -1)), r;
    }
    stmtToDirective(e) {
      let s = e;
      s.type = "Directive", s.value = s.expression, delete s.expression;
      let i = s.value, r = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", r), i.type = "DirectiveLiteral",
      s;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, s) {
      if ($l(e)) {
        if (BI.lastIndex = s, BI.test(this.input)) {
          let i = this.codePointAtPos(BI.lastIndex);
          if (!nd(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), s = this.codePointAtPos(e);
      return this.chStartsBindingPattern(s) || this.chStartsBindingIdentifier(s, e);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
      return s === 123 || this.chStartsBindingIdentifier(s, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: s
      } = this.lookahead();
      if (e === 102 && !s)
        return !1;
      if (Ws(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let s = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(s, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let s = 0;
      return this.options.annexB && !this.state.strict && (s |= 4, e && (s |= 8)), this.parseStatementLike(s);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let s = null;
      return this.match(26) && (s = this.parseDecorators(!0)), this.parseStatementContent(e, s);
    }
    parseStatementContent(e, s) {
      let i = this.state.type, r = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(r, !0);
        case 63:
          return this.parseBreakContinueStatement(r, !1);
        case 64:
          return this.parseDebuggerStatement(r);
        case 90:
          return this.parseDoWhileStatement(r);
        case 91:
          return this.parseForStatement(r);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? G.StrictFunction : this.options.annexB ? G.SloppyFunctionAnnexB : G.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(r, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(s, r), !0);
        case 69:
          return this.parseIfStatement(r);
        case 70:
          return this.parseReturnStatement(r);
        case 71:
          return this.parseSwitchStatement(r);
        case 72:
          return this.parseThrowStatement(r);
        case 73:
          return this.parseTryStatement(r);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(G.UnexpectedLexicalDeclaration, r) : this.raise(G.AwaitUsingNotInAsyncContext,
            r), this.next(), this.parseVarStatement(r, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(G.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(G.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(r, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), h = this.codePointAtPos(p);
          if (h !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(h, p) && h !== 123))
            break;
        }
        case 75:
          a || this.raise(G.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(r, p);
        }
        case 92:
          return this.parseWhileStatement(r);
        case 76:
          return this.parseWithStatement(r);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(r);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(G.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? p = this.parseImport(r) : p = this.parseExport(r, s), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(G.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(r,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return Ws(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r, u, c, e) : this.parseExpressionStatement(r, c,
      s);
    }
    assertModuleNodeAllowed(e) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(G.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, s, i) {
      if (e) {
        var r;
        (r = s.decorators) != null && r.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        G.DecoratorsBeforeAfterExport, s.decorators[0]), s.decorators.unshift(...e)) : s.decorators = e, this.resetStartLocationFromNode(s, e[0]),
        i && this.resetStartLocationFromNode(i, s);
      }
      return s;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let s = [];
      do
        s.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(G.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(G.UnexpectedLeadingDecorator, this.state.startLoc);
      return s;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let s = this.state.startLoc, i;
        if (this.match(10)) {
          let r = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(r, i);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(i, r), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          i && this.raise(G.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let r = this.startNodeAt(s);
            r.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), r.property = this.parsePrivateName()) :
            r.property = this.parseIdentifier(!0), r.computed = !1, i = this.finishNode(r, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(i, s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e, s) {
      if (this.eat(10)) {
        let i = this.startNodeAt(s);
        return i.callee = e, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, s) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, s), this.finishNode(e, s ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, s) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let r = this.state.labels[i];
        if ((e.label == null || r.name === e.label.name) && (r.kind != null && (s || r.kind === 1) || e.label && s))
          break;
      }
      if (i === this.state.labels.length) {
        let r = s ? "BreakStatement" : "ContinueStatement";
        this.raise(G.IllegalBreakContinue, e, {
          type: r
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(LI), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(LI);
      let s = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (s = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return s !== null && this.unexpected(s), this.parseFor(e, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let h = this.startNode(), f;
          u ? (f = "await using", this.recordAwaitIfAllowed() || this.raise(G.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          f = this.state.value, this.next(), this.parseVar(h, !0, f);
          let d = this.finishNode(h, "VariableDeclaration"), y = this.match(58);
          return y && c && this.raise(G.ForInUsing, d), (y || this.isContextual(102)) && d.declarations.length === 1 ? this.parseForIn(e, d,
          s) : (s !== null && this.unexpected(s), this.parseFor(e, d));
        }
      }
      let r = this.isContextual(95), a = new od(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(G.ForOfLet, o), s === null && r && o.type === "Identifier" && this.raise(G.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(e, o, s);
      } else
        this.checkExpressionErrors(a, !0);
      return s !== null && this.unexpected(s), this.parseFor(e, o);
    }
    parseFunctionStatement(e, s, i) {
      return this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (s ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(G.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let s = e.cases = [];
      this.expect(5), this.state.labels.push(XMe), this.scope.enter(0);
      let i;
      for (let r; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), s.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (r && this.raise(G.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), r = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(G.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        type: "CatchClause"
      }, 9), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let s = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), s.param = this.parseCatchClauseParam(), this.expect(11)) : (s.param = null, this.scope.
        enter(0)), s.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        s, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(G.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, s, i = !1) {
      return this.next(), this.parseVar(e, !1, s, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(LI), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(G.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, s, i, r) {
      for (let o of this.state.labels)
        o.name === s && this.raise(G.LabelRedeclaration, i, {
          labelName: s
        });
      let a = tMe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: s,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), e.body = r & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      i, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, s, i) {
      return e.expression = s, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, s = !0, i) {
      let r = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), s && this.scope.enter(0), this.parseBlockBody(r, e, !1, 8, i), s && this.
      scope.exit(), this.finishNode(r, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, s, i, r, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, s ? l : void 0, i, r, a);
    }
    parseBlockOrModuleBlockBody(e, s, i, r, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(r); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (s && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            s.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, s) {
      return e.init = s, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, s, i) {
      let r = this.match(58);
      return this.next(), r ? i !== null && this.unexpected(i) : e.await = i !== null, s.type === "VariableDeclaration" && s.declarations[0].
      init != null && (!r || !this.options.annexB || this.state.strict || s.kind !== "var" || s.declarations[0].id.type !== "Identifier") &&
      this.raise(G.ForInOfLoopInitializer, s, {
        type: r ? "ForInStatement" : "ForOfStatement"
      }), s.type === "AssignmentPattern" && this.raise(G.InvalidLhs, s, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = s, e.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, s, i, r = !1) {
      let a = e.declarations = [];
      for (e.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? s ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !r && (o.id.type !== "Identifier" && !(s && (this.match(58) || this.isContextual(102))) ? this.raise(G.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(G.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, s) {
      let i = this.parseBindingAtom();
      (s === "using" || s === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(G.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, s === "var" ? 5 : 8201), e.id = i;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, s = 0) {
      let i = s & 2, r = !!(s & 1), a = r && !(s & 4), o = !!(s & 8);
      this.initFunction(e, o), this.match(55) && (i && this.raise(G.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), r && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(sx(o, e.generator)), r || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, r ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r && !i && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || Ws(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, s) {
      this.expect(10), this.expressionScope.enter(vMe()), e.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, s, i) {
      this.next();
      let r = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, s, i), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, r), this.
      finishNode(e, s ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, s) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: e
      }, r = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (r.length > 0)
              throw this.raise(G.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            r.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          r.length && (o.decorators = r, this.resetStartLocationFromNode(o, r[0]), r = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(G.DecoratorConstructor, o);
        }
      }), this.state.strict = s, this.next(), r.length)
        throw this.raise(G.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, s) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let r = s;
        return r.kind = "method", r.computed = !1, r.key = i, r.static = !1, this.pushClassMethod(e, r, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let r = s;
        return r.computed = !1, r.key = i, r.static = !1, e.body.push(this.parseClassProperty(r)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(e, s, i) {
      let r = this.isContextual(106);
      if (r) {
        if (this.parseClassMemberFromModifier(e, s))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, s);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, s, i, r);
    }
    parseClassMemberWithIsStatic(e, s, i, r) {
      let a = s, o = s, l = s, u = s, c = s, p = a, h = a;
      if (s.static = r, this.parsePropertyNamePrefixOperator(s), this.eat(55)) {
        p.kind = "method";
        let b = this.match(139);
        if (this.parseClassElementName(p), b) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(G.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let f = !this.state.containsEsc && Ws(this.state.type), d = this.parseClassElementName(s), y = f ? d.name : null, m = this.isPrivateName(
      d), T = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(h), this.isClassMethod()) {
        if (p.kind = "method", m) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let b = this.isNonstaticConstructor(a), E = !1;
        b && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(G.DuplicateConstructor, d), b && this.
        hasPlugin("typescript") && s.override && this.raise(G.OverrideOnConstructor, d), i.hadConstructor = !0, E = i.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, b, E);
      } else if (this.isClassProperty())
        m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (y === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(d);
        let b = this.eat(55);
        h.optional && this.unexpected(T), p.kind = "method";
        let E = this.match(139);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(h), E ? this.pushClassPrivateMethod(e, o, b, !0) : (this.isNonstaticConstructor(
        a) && this.raise(G.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, b, !0, !1, !1));
      } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(d), p.kind = y;
        let b = this.match(139);
        this.parseClassElementName(a), b ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(G.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (y === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
        let b = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, b);
      } else this.isLineTerminator() ? m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: s,
        value: i
      } = this.state;
      if ((s === 132 || s === 134) && e.static && i === "prototype" && this.raise(G.StaticPrototype, this.state.startLoc), s === 139) {
        i === "constructor" && this.raise(G.ConstructorClassPrivateField, this.state.startLoc);
        let r = this.parsePrivateName();
        return e.key = r, r;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, s) {
      var i;
      this.scope.enter(208);
      let r = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = s.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, e.body.push(this.
      finishNode(s, "StaticBlock")), (i = s.decorators) != null && i.length && this.raise(G.DecoratorStaticBlock, s);
    }
    pushClassProperty(e, s) {
      !s.computed && this.nameIsConstructor(s.key) && this.raise(G.ConstructorClassField, s.key), e.body.push(this.parseClassProperty(s));
    }
    pushClassPrivateProperty(e, s) {
      let i = this.parseClassPrivateProperty(s);
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(e, s, i) {
      !i && !s.computed && this.nameIsConstructor(s.key) && this.raise(G.ConstructorClassField, s.key);
      let r = this.parseClassAccessorProperty(s);
      e.body.push(r), i && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
    }
    pushClassMethod(e, s, i, r, a, o) {
      e.body.push(this.parseMethod(s, i, r, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, s, i, r) {
      let a = this.parseMethod(s, i, r, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, s) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), s, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(GU()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, s, i, r = 8331) {
      if (Ws(this.state.type))
        e.id = this.parseIdentifier(), s && this.declareNameFromIdentifier(e.id, r);
      else if (i || !s)
        e.id = null;
      else
        throw this.raise(G.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, s) {
      let i = this.parseMaybeImportPhase(e, !0), r = this.maybeParseExportDefaultSpecifier(e, i), a = !r || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = r || o;
      if (o && !l) {
        if (r && this.unexpected(), s)
          throw this.raise(G.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.sawUnambiguousESM = !0, this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      r && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let h;
      if (c || p) {
        if (h = !1, s)
          throw this.raise(G.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        h = this.maybeParseExportDeclaration(e);
      if (c || p || h) {
        var f;
        let d = e;
        if (this.checkExport(d, !0, !1, !!d.source), ((f = d.declaration) == null ? void 0 : f.type) === "ClassDeclaration")
          this.maybeTakeDecorators(s, d.declaration, d);
        else if (s)
          throw this.raise(G.UnsupportedDecoratorExport, e);
        return this.sawUnambiguousESM = !0, this.finishNode(d, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let d = e, y = this.parseExportDefaultExpression();
        if (d.declaration = y, y.type === "ClassDeclaration")
          this.maybeTakeDecorators(s, y, d);
        else if (s)
          throw this.raise(G.UnsupportedDecoratorExport, e);
        return this.checkExport(d, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(d, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, s) {
      if (s || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", s?.loc.start);
        let i = s || this.parseIdentifier(!0), r = this.startNodeAtNode(i);
        return r.exported = i, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var s, i;
        (i = (s = e).specifiers) != null || (s.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let s = e;
        s.specifiers || (s.specifiers = []);
        let i = s.exportKind === "type";
        return s.specifiers.push(...this.parseExportSpecifiers(i)), s.source = null, this.hasPlugin("importAssertions") ? s.assertions = [] :
        s.attributes = [], s.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") ? e.assertions = [] :
      e.attributes = [], e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(G.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(G.UnsupportedDefaultExport, this.state.startLoc);
      let s = this.parseMaybeAssignAllowIn();
      return this.semicolon(), s;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (Ws(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: r
          } = this.lookahead();
          if (Ws(r) && r !== 98 || r === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let s = this.nextTokenStart(), i = this.isUnparsedContextual(s, "from");
      if (this.input.charCodeAt(s) === 44 || Ws(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let r = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
        return r === 34 || r === 39;
      }
      return !1;
    }
    parseExportFrom(e, s) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : s && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(G.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(G.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(G.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, s, i, r) {
      if (s) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            G.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !r && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(G.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let s of e.properties)
          this.checkDeclaration(s);
      else if (e.type === "ArrayPattern")
        for (let s of e.elements)
          s && this.checkDeclaration(s);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, s) {
      this.exportedIdentifiers.has(s) && (s === "default" ? this.raise(G.DuplicateDefaultExport, e) : this.raise(G.DuplicateExport, e, {
        exportName: s
      })), this.exportedIdentifiers.add(s);
    }
    parseExportSpecifiers(e) {
      let s = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let r = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), s.push(this.parseExportSpecifier(o, a, e, r));
      }
      return s;
    }
    parseExportSpecifier(e, s, i, r) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : s ? e.exported = NMe(e.local) : e.exported || (e.exported =
      Jl(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let e = this.parseStringLiteral(this.state.value), s = zMe.exec(e.value);
        return s && this.raise(G.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: s[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: s,
        value: i
      }) => i.value === "json" && (s.type === "Identifier" ? s.name === "type" : s.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: s
      } = e, i = s.length === 1 ? s[0].type : null;
      if (e.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(G.SourcePhaseImportRequiresDefault, s[0].loc.start);
      else if (e.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(G.DeferImportRequiresNamespace, s[0].loc.start);
      else if (e.module) {
        var r;
        i !== "ImportDefaultSpecifier" && this.raise(G.ImportReflectionNotBinding, s[0].loc.start), ((r = e.assertions) == null ? void 0 : r.
        length) > 0 && this.raise(G.ImportReflectionHasAssertion, s[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: s
        } = e;
        if (s != null) {
          let i = s.find((r) => {
            let a;
            if (r.type === "ExportSpecifier" ? a = r.local : r.type === "ImportSpecifier" && (a = r.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(G.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, s, i, r) {
      s || (i === "module" ? (this.expectPlugin("importReflection", r), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", r), e.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", r), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, s) {
      if (!this.isPotentialImportPhase(s))
        return this.applyImportPhase(e, s, null), null;
      let i = this.parseIdentifier(!0), {
        type: r
      } = this.state;
      return (yo(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      e, s, i.name, i.loc.start), null) : (this.applyImportPhase(e, s, null), i);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: s
      } = this.state;
      return Ws(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12;
    }
    parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, s) {
      e.specifiers = [];
      let r = !this.maybeParseDefaultImportSpecifier(e, s) || this.eat(12), a = r && this.maybeParseStarImportSpecifier(e);
      return r && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var s;
      return (s = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(e, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, s, i) {
      s.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
    }
    finishImportSpecifier(e, s, i = 8201) {
      return this.checkLVal(e.local, {
        type: s
      }, i), this.finishNode(e, s);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), r = this.state.value;
        if (s.has(r) && this.raise(G.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: r
        }), s.add(r), this.match(134) ? i.key = this.parseStringLiteral(r) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(G.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(G.ModuleAttributeDifferentFromType, i.key), s.has(i.key.name) &&
        this.raise(G.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), s.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(G.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let s;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (s = this.parseModuleAttributes(), this.addExtra(e, "deprecatedWithLegacySyntax", !0)) :
        s = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(G.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e, "depreca\
tedAssertSyntax", !0), this.next(), s = this.parseImportAttributes()) : s = [];
      !i && this.hasPlugin("importAssertions") ? e.assertions = s : e.attributes = s;
    }
    maybeParseDefaultImportSpecifier(e, s) {
      if (s) {
        let i = this.startNodeAtNode(s);
        return i.local = s, e.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (yo(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let s = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, s, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else {
          if (this.eat(14))
            throw this.raise(G.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), r = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, r, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, s, i, r, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (s)
          throw this.raise(G.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Jl(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, ax = class extends eN {
    static {
      n(this, "Parser");
    }
    constructor(e, s, i) {
      e = JBe(e), super(e, s), this.options = e, this.initializeScopes(), this.plugins = i, this.filename = e.sourceFilename, this.startIndex =
      e.startIndex;
      let r = 0;
      e.allowAwaitOutsideFunction && (r |= 1), e.allowReturnOutsideFunction && (r |= 2), e.allowImportExportEverywhere && (r |= 8), e.allowSuperOutsideMethod &&
      (r |= 16), e.allowUndeclaredExports && (r |= 64), e.allowNewTargetOutsideFunction && (r |= 4), e.allowYieldOutsideFunction && (r |= 32),
      e.ranges && (r |= 128), e.tokens && (r |= 256), e.createImportExpressions && (r |= 512), e.createParenthesizedExpressions && (r |= 1024),
      e.errorRecovery && (r |= 2048), e.attachComment && (r |= 4096), e.annexB && (r |= 8192), this.optionFlags = r;
    }
    getScopeHandler() {
      return ag;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), s = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, s), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function QMe(t, e) {
    var s;
    if (((s = e) == null ? void 0 : s.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let i = ig(e, t), r = i.parse();
        if (i.sawUnambiguousESM)
          return r;
        if (i.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", ig(e, t).parse();
          } catch {
          }
        else
          r.program.sourceType = "script";
        return r;
      } catch (i) {
        try {
          return e.sourceType = "script", ig(e, t).parse();
        } catch {
        }
        throw i;
      }
    } else
      return ig(e, t).parse();
  }
  n(QMe, "parse");
  function ZMe(t, e) {
    let s = ig(e, t);
    return s.options.strictMode && (s.state.strict = !0), s.getExpression();
  }
  n(ZMe, "parseExpression");
  function eFe(t) {
    let e = {};
    for (let s of Object.keys(t))
      e[s] = Vl(t[s]);
    return e;
  }
  n(eFe, "generateExportedTokenTypes");
  var tFe = eFe(GBe);
  function ig(t, e) {
    let s = ax, i = /* @__PURE__ */ new Map();
    if (t != null && t.plugins) {
      for (let r of t.plugins) {
        let a, o;
        typeof r == "string" ? a = r : [a, o] = r, i.has(a) || i.set(a, o || {});
      }
      JMe(i), s = sFe(i);
    }
    return new s(t, e, i);
  }
  n(ig, "getParser");
  var qU = /* @__PURE__ */ new Map();
  function sFe(t) {
    let e = [];
    for (let r of YMe)
      t.has(r) && e.push(r);
    let s = e.join("|"), i = qU.get(s);
    if (!i) {
      i = ax;
      for (let r of e)
        i = tK[r](i);
      qU.set(s, i);
    }
    return i;
  }
  n(sFe, "getParserClass");
  lg.parse = QMe;
  lg.parseExpression = ZMe;
  lg.tokTypes = tFe;
});

// ../node_modules/picocolors/picocolors.js
var nK = g((MRs, pN) => {
  var iK = process.argv || [], ox = process.env, iFe = !("NO_COLOR" in ox || iK.includes("--no-color")) && ("FORCE_COLOR" in ox || iK.includes(
  "--color") || process.platform === "win32" || require != null && require("tty").isatty(1) && ox.TERM !== "dumb" || "CI" in ox), rFe = /* @__PURE__ */ n(
  (t, e, s = t) => (i) => {
    let r = "" + i, a = r.indexOf(e, t.length);
    return ~a ? t + nFe(r, e, s, a) + e : t + r + e;
  }, "formatter"), nFe = /* @__PURE__ */ n((t, e, s, i) => {
    let r = "", a = 0;
    do
      r += t.substring(a, i) + s, a = i + e.length, i = t.indexOf(e, a);
    while (~i);
    return r + t.substring(a);
  }, "replaceClose"), rK = /* @__PURE__ */ n((t = iFe) => {
    let e = t ? rFe : () => String;
    return {
      isColorSupported: t,
      reset: e("\x1B[0m", "\x1B[0m"),
      bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: e("\x1B[3m", "\x1B[23m"),
      underline: e("\x1B[4m", "\x1B[24m"),
      inverse: e("\x1B[7m", "\x1B[27m"),
      hidden: e("\x1B[8m", "\x1B[28m"),
      strikethrough: e("\x1B[9m", "\x1B[29m"),
      black: e("\x1B[30m", "\x1B[39m"),
      red: e("\x1B[31m", "\x1B[39m"),
      green: e("\x1B[32m", "\x1B[39m"),
      yellow: e("\x1B[33m", "\x1B[39m"),
      blue: e("\x1B[34m", "\x1B[39m"),
      magenta: e("\x1B[35m", "\x1B[39m"),
      cyan: e("\x1B[36m", "\x1B[39m"),
      white: e("\x1B[37m", "\x1B[39m"),
      gray: e("\x1B[90m", "\x1B[39m"),
      bgBlack: e("\x1B[40m", "\x1B[49m"),
      bgRed: e("\x1B[41m", "\x1B[49m"),
      bgGreen: e("\x1B[42m", "\x1B[49m"),
      bgYellow: e("\x1B[43m", "\x1B[49m"),
      bgBlue: e("\x1B[44m", "\x1B[49m"),
      bgMagenta: e("\x1B[45m", "\x1B[49m"),
      bgCyan: e("\x1B[46m", "\x1B[49m"),
      bgWhite: e("\x1B[47m", "\x1B[49m"),
      blackBright: e("\x1B[90m", "\x1B[39m"),
      redBright: e("\x1B[91m", "\x1B[39m"),
      greenBright: e("\x1B[92m", "\x1B[39m"),
      yellowBright: e("\x1B[93m", "\x1B[39m"),
      blueBright: e("\x1B[94m", "\x1B[39m"),
      magentaBright: e("\x1B[95m", "\x1B[39m"),
      cyanBright: e("\x1B[96m", "\x1B[39m"),
      whiteBright: e("\x1B[97m", "\x1B[39m"),
      bgBlackBright: e("\x1B[100m", "\x1B[49m"),
      bgRedBright: e("\x1B[101m", "\x1B[49m"),
      bgGreenBright: e("\x1B[102m", "\x1B[49m"),
      bgYellowBright: e("\x1B[103m", "\x1B[49m"),
      bgBlueBright: e("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: e("\x1B[105m", "\x1B[49m"),
      bgCyanBright: e("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: e("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  pN.exports = rK();
  pN.exports.createColors = rK;
});

// ../node_modules/js-tokens/index.js
var aK = g((lx) => {
  Object.defineProperty(lx, "__esModule", {
    value: !0
  });
  lx.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  lx.matchToToken = function(t) {
    var e = { type: "invalid", value: t[0], closed: void 0 };
    return t[1] ? (e.type = "string", e.closed = !!(t[3] || t[4])) : t[5] ? e.type = "comment" : t[6] ? (e.type = "comment", e.closed = !!t[7]) :
    t[8] ? e.type = "regex" : t[9] ? e.type = "number" : t[10] ? e.type = "name" : t[11] ? e.type = "punctuator" : t[12] && (e.type = "white\
space"), e;
  };
});

// ../node_modules/@babel/code-frame/lib/index.js
var Yl = g((ug) => {
  "use strict";
  Object.defineProperty(ug, "__esModule", { value: !0 });
  var hN = nK(), oK = aK(), lK = Ea();
  function aFe() {
    return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : hN.isColorSupported;
  }
  n(aFe, "isColorSupported");
  var ux = /* @__PURE__ */ n((t, e) => (s) => t(e(s)), "compose");
  function pK(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.gray,
      invalid: ux(ux(t.white, t.bgRed), t.bold),
      gutter: t.gray,
      marker: ux(t.red, t.bold),
      message: ux(t.red, t.bold),
      reset: t.reset
    };
  }
  n(pK, "buildDefs");
  var oFe = pK(hN.createColors(!0)), lFe = pK(hN.createColors(!1));
  function hK(t) {
    return t ? oFe : lFe;
  }
  n(hK, "getDefs");
  var uFe = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), cFe = /\r\n|[\n\r\u2028\u2029]/, pFe = /^[()[\]{}]$/, fK;
  {
    let t = /^[a-z][\w-]*$/i, e = /* @__PURE__ */ n(function(s, i, r) {
      if (s.type === "name") {
        if (lK.isKeyword(s.value) || lK.isStrictReservedWord(s.value, !0) || uFe.has(s.value))
          return "keyword";
        if (t.test(s.value) && (r[i - 1] === "<" || r.slice(i - 2, i) === "</"))
          return "jsxIdentifier";
        if (s.value[0] !== s.value[0].toLowerCase())
          return "capitalized";
      }
      return s.type === "punctuator" && pFe.test(s.value) ? "bracket" : s.type === "invalid" && (s.value === "@" || s.value === "#") ? "punc\
tuator" : s.type;
    }, "getTokenType");
    fK = /* @__PURE__ */ n(function* (s) {
      let i;
      for (; i = oK.default.exec(s); ) {
        let r = oK.matchToToken(i);
        yield {
          type: e(r, i.index, s),
          value: r.value
        };
      }
    }, "tokenize");
  }
  function dK(t) {
    if (t === "") return "";
    let e = hK(!0), s = "";
    for (let {
      type: i,
      value: r
    } of fK(t))
      i in e ? s += r.split(cFe).map((a) => e[i](a)).join(`
`) : s += r;
    return s;
  }
  n(dK, "highlight");
  var uK = !1, cK = /\r\n|[\n\r\u2028\u2029]/;
  function hFe(t, e, s) {
    let i = Object.assign({
      column: 0,
      line: -1
    }, t.start), r = Object.assign({}, i, t.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = s || {}, l = i.line, u = i.column, c = r.line, p = r.column, h = Math.max(l - (a + 1), 0), f = Math.min(e.length, c + o);
    l === -1 && (h = 0), c === -1 && (f = e.length);
    let d = c - l, y = {};
    if (d)
      for (let m = 0; m <= d; m++) {
        let T = m + l;
        if (!u)
          y[T] = !0;
        else if (m === 0) {
          let b = e[T - 1].length;
          y[T] = [u, b - u + 1];
        } else if (m === d)
          y[T] = [0, p];
        else {
          let b = e[T - m].length;
          y[T] = [0, b];
        }
      }
    else
      u === p ? u ? y[l] = [u, 0] : y[l] = !0 : y[l] = [u, p - u];
    return {
      start: h,
      end: f,
      markerLines: y
    };
  }
  n(hFe, "getMarkerLines");
  function mK(t, e, s = {}) {
    let i = s.forceColor || aFe() && s.highlightCode, r = hK(i), a = t.split(cK), {
      start: o,
      end: l,
      markerLines: u
    } = hFe(e, a, s), c = e.start && typeof e.start.column == "number", p = String(l).length, f = (i ? dK(t) : t).split(cK, l).slice(o, l).map(
    (d, y) => {
      let m = o + 1 + y, b = ` ${` ${m}`.slice(-p)} |`, E = u[m], w = !u[m + 1];
      if (E) {
        let K = "";
        if (Array.isArray(E)) {
          let he = d.slice(0, Math.max(E[0] - 1, 0)).replace(/[^\t]/g, " "), de = E[1] || 1;
          K = [`
 `, r.gutter(b.replace(/\d/g, " ")), " ", he, r.marker("^").repeat(de)].join(""), w && s.message && (K += " " + r.message(s.message));
        }
        return [r.marker(">"), r.gutter(b), d.length > 0 ? ` ${d}` : "", K].join("");
      } else
        return ` ${r.gutter(b)}${d.length > 0 ? ` ${d}` : ""}`;
    }).join(`
`);
    return s.message && !c && (f = `${" ".repeat(p + 1)}${s.message}
${f}`), i ? r.reset(f) : f;
  }
  n(mK, "codeFrameColumns");
  function fFe(t, e, s, i = {}) {
    if (!uK) {
      uK = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return s = Math.max(s, 0), mK(t, {
      start: {
        column: s,
        line: e
      }
    }, i);
  }
  n(fFe, "index");
  ug.codeFrameColumns = mK;
  ug.default = fFe;
  ug.highlight = dK;
});

// ../node_modules/@babel/template/lib/parse.js
var dN = g((fN) => {
  "use strict";
  Object.defineProperty(fN, "__esModule", {
    value: !0
  });
  fN.default = wFe;
  var dFe = fe(), mFe = sK(), yFe = Yl(), {
    isCallExpression: gFe,
    isExpressionStatement: TFe,
    isFunction: bFe,
    isIdentifier: xFe,
    isJSXIdentifier: SFe,
    isNewExpression: PFe,
    isPlaceholder: cx,
    isStatement: EFe,
    isStringLiteral: yK,
    removePropertiesDeep: AFe,
    traverse: vFe
  } = dFe, CFe = /^[_$A-Z0-9]+$/;
  function wFe(t, e, s) {
    let {
      placeholderWhitelist: i,
      placeholderPattern: r,
      preserveComments: a,
      syntacticPlaceholders: o
    } = s, l = kFe(e, s.parser, o);
    AFe(l, {
      preserveComments: a
    }), t.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: i,
      placeholderPattern: r,
      syntacticPlaceholders: o
    };
    return vFe(l, IFe, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  n(wFe, "parseAndBuildMetadata");
  function IFe(t, e, s) {
    var i;
    let r, a = s.syntactic.placeholders.length > 0;
    if (cx(t)) {
      if (s.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      r = t.name.name, a = !0;
    } else {
      if (a || s.syntacticPlaceholders)
        return;
      if (xFe(t) || SFe(t))
        r = t.name;
      else if (yK(t))
        r = t.value;
      else
        return;
    }
    if (a && (s.placeholderPattern != null || s.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (s.placeholderPattern === !1 || !(s.placeholderPattern || CFe).test(r)) && !((i = s.placeholderWhitelist) != null && i.has(r)))
      return;
    e = e.slice();
    let {
      node: o,
      key: l
    } = e[e.length - 1], u;
    yK(t) || cx(t, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : PFe(o) && l === "arguments" || gFe(o) && l === "arguments" || bFe(o) && l === "params" ? u = "param" : TFe(o) && !cx(
    t) ? (u = "statement", e = e.slice(0, -1)) : EFe(t) && cx(t) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? s.syntactic : s.legacy;
    c.push({
      name: r,
      type: u,
      resolve: /* @__PURE__ */ n((h) => NFe(h, e), "resolve"),
      isDuplicate: p.has(r)
    }), p.add(r);
  }
  n(IFe, "placeholderVisitorHandler");
  function NFe(t, e) {
    let s = t;
    for (let a = 0; a < e.length - 1; a++) {
      let {
        key: o,
        index: l
      } = e[a];
      l === void 0 ? s = s[o] : s = s[o][l];
    }
    let {
      key: i,
      index: r
    } = e[e.length - 1];
    return {
      parent: s,
      key: i,
      index: r
    };
  }
  n(NFe, "resolveAncestors");
  function kFe(t, e, s) {
    let i = (e.plugins || []).slice();
    s !== !1 && i.push("placeholders"), e = Object.assign({
      allowAwaitOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      allowYieldOutsideFunction: !0,
      sourceType: "module"
    }, e, {
      plugins: i
    });
    try {
      return (0, mFe.parse)(t, e);
    } catch (r) {
      let a = r.loc;
      throw a && (r.message += `
` + (0, yFe.codeFrameColumns)(t, {
        start: a
      }), r.code = "BABEL_TEMPLATE_PARSE_ERROR"), r;
    }
  }
  n(kFe, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var TN = g((gN) => {
  "use strict";
  Object.defineProperty(gN, "__esModule", {
    value: !0
  });
  gN.default = MFe;
  var DFe = fe(), {
    blockStatement: OFe,
    cloneNode: yN,
    emptyStatement: _Fe,
    expressionStatement: mN,
    identifier: px,
    isStatement: gK,
    isStringLiteral: LFe,
    stringLiteral: BFe,
    validate: TK
  } = DFe;
  function MFe(t, e) {
    let s = yN(t.ast);
    return e && (t.placeholders.forEach((i) => {
      if (!hasOwnProperty.call(e, i.name)) {
        let r = i.name;
        throw new Error(`Error: No substitution given for "${r}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${r}'])}
            - { placeholderPattern: /^${r}$/ }`);
      }
    }), Object.keys(e).forEach((i) => {
      if (!t.placeholderNames.has(i))
        throw new Error(`Unknown substitution "${i}" given`);
    })), t.placeholders.slice().reverse().forEach((i) => {
      try {
        FFe(i, s, e && e[i.name] || null);
      } catch (r) {
        throw r.message = `@babel/template placeholder "${i.name}": ${r.message}`, r;
      }
    }), s;
  }
  n(MFe, "populatePlaceholders");
  function FFe(t, e, s) {
    t.isDuplicate && (Array.isArray(s) ? s = s.map((l) => yN(l)) : typeof s == "object" && (s = yN(s)));
    let {
      parent: i,
      key: r,
      index: a
    } = t.resolve(e);
    if (t.type === "string") {
      if (typeof s == "string" && (s = BFe(s)), !s || !LFe(s))
        throw new Error("Expected string substitution");
    } else if (t.type === "statement")
      a === void 0 ? s ? Array.isArray(s) ? s = OFe(s) : typeof s == "string" ? s = mN(px(s)) : gK(s) || (s = mN(s)) : s = _Fe() : s && !Array.
      isArray(s) && (typeof s == "string" && (s = px(s)), gK(s) || (s = mN(s)));
    else if (t.type === "param") {
      if (typeof s == "string" && (s = px(s)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof s == "string" && (s = px(s)), Array.isArray(s))
      throw new Error("Cannot replace single expression with an array.");
    function o(l, u, c) {
      let p = l[u];
      l[u] = c, (p.type === "Identifier" || p.type === "Placeholder") && (p.typeAnnotation && (c.typeAnnotation = p.typeAnnotation), p.optional &&
      (c.optional = p.optional), p.decorators && (c.decorators = p.decorators));
    }
    if (n(o, "set"), a === void 0)
      TK(i, r, s), o(i, r, s);
    else {
      let l = i[r].slice();
      t.type === "statement" || t.type === "param" ? s == null ? l.splice(a, 1) : Array.isArray(s) ? l.splice(a, 1, ...s) : o(l, a, s) : o(l,
      a, s), TK(i, r, l), i[r] = l;
    }
  }
  n(FFe, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var bK = g((bN) => {
  "use strict";
  Object.defineProperty(bN, "__esModule", {
    value: !0
  });
  bN.default = UFe;
  var jFe = Gb(), RFe = dN(), qFe = TN();
  function UFe(t, e, s) {
    e = t.code(e);
    let i;
    return (r) => {
      let a = (0, jFe.normalizeReplacements)(r);
      return i || (i = (0, RFe.default)(t, e, s)), t.unwrap((0, qFe.default)(i, a));
    };
  }
  n(UFe, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var xK = g((xN) => {
  "use strict";
  Object.defineProperty(xN, "__esModule", {
    value: !0
  });
  xN.default = $Fe;
  var KFe = Gb(), VFe = dN(), WFe = TN();
  function $Fe(t, e, s) {
    let {
      metadata: i,
      names: r
    } = HFe(t, e, s);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[r[u]] = l;
      }), (l) => {
        let u = (0, KFe.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), t.unwrap((0, WFe.default)(i, u ? Object.assign(u, o) : o));
      };
    };
  }
  n($Fe, "literalTemplate");
  function HFe(t, e, s) {
    let i = "BABEL_TPL$", r = e.join("");
    do
      i = "$$" + i;
    while (r.includes(i));
    let {
      names: a,
      code: o
    } = JFe(e, i);
    return {
      metadata: (0, VFe.default)(t, t.code(o), {
        parser: s.parser,
        placeholderWhitelist: new Set(a.concat(s.placeholderWhitelist ? Array.from(s.placeholderWhitelist) : [])),
        placeholderPattern: s.placeholderPattern,
        preserveComments: s.preserveComments,
        syntacticPlaceholders: s.syntacticPlaceholders
      }),
      names: a
    };
  }
  n(HFe, "buildLiteralData");
  function JFe(t, e) {
    let s = [], i = t[0];
    for (let r = 1; r < t.length; r++) {
      let a = `${e}${r - 1}`;
      s.push(a), i += a + t[r];
    }
    return {
      names: s,
      code: i
    };
  }
  n(JFe, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var CK = g((SN) => {
  "use strict";
  Object.defineProperty(SN, "__esModule", {
    value: !0
  });
  SN.default = vK;
  var Zo = Gb(), SK = bK(), PK = xK(), EK = (0, Zo.validate)({
    placeholderPattern: !1
  });
  function vK(t, e) {
    let s = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), r = e || (0, Zo.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return AK((0, SK.default)(t, a, (0, Zo.merge)(r, (0, Zo.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = s.get(a);
        return l || (l = (0, PK.default)(t, a, r), s.set(a, l)), AK(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return vK(t, (0, Zo.merge)(r, (0, Zo.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ n((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, SK.default)(t, a, (0, Zo.merge)((0, Zo.merge)(r, (0, Zo.validate)(o[0])), EK))();
        } else if (Array.isArray(a)) {
          let l = i.get(a);
          return l || (l = (0, PK.default)(t, a, (0, Zo.merge)(r, EK)), i.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  n(vK, "createTemplateBuilder");
  function AK(t) {
    let e = "";
    try {
      throw new Error();
    } catch (s) {
      s.stack && (e = s.stack.split(`
`).slice(3).join(`
`));
    }
    return (s) => {
      try {
        return t(s);
      } catch (i) {
        throw i.stack += `
    =============
${e}`, i;
      }
    };
  }
  n(AK, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var Xl = g((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.statements = sa.statement = sa.smart = sa.program = sa.expression = sa.default = void 0;
  var cg = vU(), pg = CK(), PN = sa.smart = (0, pg.default)(cg.smart), YFe = sa.statement = (0, pg.default)(cg.statement), XFe = sa.statements =
  (0, pg.default)(cg.statements), zFe = sa.expression = (0, pg.default)(cg.expression), GFe = sa.program = (0, pg.default)(cg.program), GRs = sa.
  default = Object.assign(PN.bind(void 0), {
    smart: PN,
    statement: YFe,
    statements: XFe,
    expression: zFe,
    program: GFe,
    ast: PN.ast
  });
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var wK = g((hx) => {
  "use strict";
  Object.defineProperty(hx, "__esModule", {
    value: !0
  });
  hx.default = void 0;
  var QFe = Xl();
  function Pe(t, e, s) {
    return Object.freeze({
      minVersion: t,
      ast: /* @__PURE__ */ n(() => QFe.default.program.ast(e, {
        preserveComments: !0
      }), "ast"),
      metadata: s
    });
  }
  n(Pe, "helper");
  var ZFe = hx.default = {
    __proto__: null,
    OverloadYield: Pe("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
      globals: [],
      locals: {
        _OverloadYield: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_OverloadYield",
      dependencies: {}
    }),
    applyDecoratedDescriptor: Pe("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((func\
tion(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().r\
everse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.init\
ializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
      globals: ["Object"],
      locals: {
        _applyDecoratedDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_applyDecoratedDescriptor",
      dependencies: {}
    }),
    applyDecs2311: Pe("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Ob\
ject.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.lengt\
h;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n|\
|"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("A\
ttempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){ret\
urn function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctio\
nName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnProp\
ertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not suppor\
ted yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["fie\
ld","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted t\
o call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,\
"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?func\
tion(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.g\
et,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N\
.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or in\
it properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,\
s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:\
!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i\
<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),\
l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c\
,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
      globals: ["Symbol", "Object", "TypeError", "Error"],
      locals: {
        applyDecs2311: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2311",
      dependencies: {
        checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.cons\
equent.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.pro\
perties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.al\
ternate.callee"]
      }
    }),
    arrayLikeToArray: Pe("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r\
[e];return n}", {
      globals: ["Array"],
      locals: {
        _arrayLikeToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayLikeToArray",
      dependencies: {}
    }),
    arrayWithHoles: Pe("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
      globals: ["Array"],
      locals: {
        _arrayWithHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithHoles",
      dependencies: {}
    }),
    arrayWithoutHoles: Pe("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
      globals: ["Array"],
      locals: {
        _arrayWithoutHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithoutHoles",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
      }
    }),
    assertClassBrand: Pe("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;t\
hrow new TypeError("Private element is not present on this object")}', {
      globals: ["TypeError"],
      locals: {
        _assertClassBrand: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertClassBrand",
      dependencies: {}
    }),
    assertThisInitialized: Pe("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been i\
nitialised - super() hasn't been called");return e}`, {
      globals: ["ReferenceError"],
      locals: {
        _assertThisInitialized: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertThisInitialized",
      dependencies: {}
    }),
    asyncGeneratorDelegate: Pe("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promi\
se((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=fun\
ction(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t\
;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
      globals: ["Promise", "Symbol"],
      locals: {
        _asyncGeneratorDelegate: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncGeneratorDelegate",
      dependencies: {
        OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
      }
    }),
    asyncIterator: Pe("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.i\
terator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o=\
"@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuatio\
n(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((functi\
on(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:n\
ull,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return \
void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.r\
eturn;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
      globals: ["Symbol", "TypeError", "Object", "Promise"],
      locals: {
        _asyncIterator: ["body.0.id"],
        AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expre\
ssions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncIterator",
      dependencies: {}
    }),
    asyncToGenerator: Pe("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i\
.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(\
r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,\
_throw,"throw",n)}_next(void 0)}))}}', {
      globals: ["Promise"],
      locals: {
        asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.c\
allee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
        _asyncToGenerator: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncToGenerator",
      dependencies: {}
    }),
    awaitAsyncGenerator: Pe("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
      globals: [],
      locals: {
        _awaitAsyncGenerator: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_awaitAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.argument.callee"]
      }
    }),
    callSuper: Pe("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Re\
flect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
      globals: ["Reflect"],
      locals: {
        _callSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_callSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.co\
nsequent.arguments.2.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
        possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    checkInRHS: Pe("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(\
null!==e?typeof e:"null"));return e}`, {
      globals: ["Object", "TypeError"],
      locals: {
        _checkInRHS: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkInRHS",
      dependencies: {}
    }),
    checkPrivateRedeclaration: Pe("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the\
 same private elements twice on an object")}', {
      globals: ["TypeError"],
      locals: {
        _checkPrivateRedeclaration: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkPrivateRedeclaration",
      dependencies: {}
    }),
    classCallCheck: Pe("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a fun\
ction")}', {
      globals: ["TypeError"],
      locals: {
        _classCallCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCallCheck",
      dependencies: {}
    }),
    classNameTDZError: Pe("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in co\
mputed property keys.')}`, {
      globals: ["ReferenceError"],
      locals: {
        _classNameTDZError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classNameTDZError",
      dependencies: {}
    }),
    classPrivateFieldGet2: Pe("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
      globals: [],
      locals: {
        _classPrivateFieldGet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    classPrivateFieldInitSpec: Pe("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
      globals: [],
      locals: {
        _classPrivateFieldInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      }
    }),
    classPrivateFieldLooseBase: Pe("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError\
("attempted to use private field on non-instance");return e}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateFieldBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldBase",
      dependencies: {}
    }),
    classPrivateFieldLooseKey: Pe("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
      globals: [],
      locals: {
        id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.righ\
t.argument"],
        _classPrivateFieldKey: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldKey",
      dependencies: {}
    }),
    classPrivateFieldSet2: Pe("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      }
    }),
    classPrivateGetter: Pe("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
      globals: [],
      locals: {
        _classPrivateGetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateGetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    classPrivateMethodInitSpec: Pe("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
      globals: [],
      locals: {
        _classPrivateMethodInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      }
    }),
    classPrivateSetter: Pe("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
      globals: [],
      locals: {
        _classPrivateSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateSetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      }
    }),
    classStaticPrivateMethodGet: Pe("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
      globals: [],
      locals: {
        _classStaticPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      }
    }),
    construct: Pe("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);v\
ar o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
      globals: ["Reflect"],
      locals: {
        _construct: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_construct",
      dependencies: {
        isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
        setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
      }
    }),
    createClass: Pe("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.\
configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_define\
Properties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
      globals: ["Object"],
      locals: {
        _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.\
1.right.callee"],
        _createClass: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createClass",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
      }
    }),
    createForOfIteratorHelper: Pe("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r\
["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function()\
{};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid att\
empt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1\
;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return|\
|t.return()}finally{if(u)throw o}}}}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelper",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
      }
    }),
    createForOfIteratorHelperLoose: Pe("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.it\
erator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeo\
f r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to \
iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelperLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelperLoose",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
      }
    }),
    createSuper: Pe("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){va\
r s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this\
,e)}}", {
      globals: ["Reflect"],
      locals: {
        _createSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.cons\
equent.body.0.declarations.0.init.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
        possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
      }
    }),
    decorate: Pe("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function\
(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.\
initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){retur\
n e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){\
r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){\
var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"\
===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"=\
==r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}\
Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this\
.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.ele\
ment),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);ret\
urn i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw\
 new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;\
n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||\
a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementP\
lacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0\
;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.eleme\
nts){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw ne\
w TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e\
.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),\
"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=t\
his.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element d\
escriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descript\
or\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toProperty\
Key(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property mu\
st be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this\
.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?th\
is.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),t\
his.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a \
field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_\
optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elem\
ents:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toCl\
assDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a de\
corator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placeme\
nt","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descript\
or"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDesc\
riptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!\
=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw\
 new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e\
.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kin\
d?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.ki\
nd?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.\
decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.des\
criptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.k\
ind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDe\
scriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated method\
s ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Deco\
rators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)\
}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e\
&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new \
TypeError("Expected '"+r+"' to be a function");return t}`, {
      globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
      locals: {
        _decorate: ["body.0.id"],
        _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
        _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
        _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
        _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
        _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.\
body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.\
body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.bo\
dy.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
        _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.conse\
quent.test.right.callee"],
        _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties\
.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
      },
      exportBindingAssignments: [],
      exportName: "_decorate",
      dependencies: {
        toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
        toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.bo\
dy.0.declarations.1.init.callee"]
      }
    }),
    defaults: Pe("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.ge\
tOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
      globals: ["Object"],
      locals: {
        _defaults: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defaults",
      dependencies: {}
    }),
    defineAccessor: Pe("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.definePropert\
y(r,n,c)}", {
      globals: ["Object"],
      locals: {
        _defineAccessor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineAccessor",
      dependencies: {}
    }),
    defineProperty: Pe("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,en\
umerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
      globals: ["Object"],
      locals: {
        _defineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineProperty",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
      }
    }),
    extends: Pe("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.\
length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
      globals: ["Object"],
      locals: {
        _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_extends",
      dependencies: {}
    }),
    get: Pe("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=s\
uperPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null\
,arguments)}', {
      globals: ["Reflect", "Object"],
      locals: {
        _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_get",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
      }
    }),
    getPrototypeOf: Pe("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind(\
):function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
      globals: ["Object"],
      locals: {
        _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_getPrototypeOf",
      dependencies: {}
    }),
    identity: Pe("7.17.0", "function _identity(t){return t}", {
      globals: [],
      locals: {
        _identity: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_identity",
      dependencies: {}
    }),
    importDeferProxy: Pe("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=funct\
ion(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constVal\
ue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:\
constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:cons\
tValue(!1)})}", {
      globals: ["Proxy", "Reflect"],
      locals: {
        _importDeferProxy: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_importDeferProxy",
      dependencies: {}
    }),
    inherits: Pe("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must eithe\
r be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.definePropert\
y(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
      globals: ["TypeError", "Object"],
      locals: {
        _inherits: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inherits",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
      }
    }),
    inheritsLoose: Pe("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setProt\
otypeOf(t,o)}", {
      globals: ["Object"],
      locals: {
        _inheritsLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inheritsLoose",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
      }
    }),
    initializerDefineProperty: Pe("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.e\
numerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
      globals: ["Object"],
      locals: {
        _initializerDefineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerDefineProperty",
      dependencies: {}
    }),
    initializerWarningHelper: Pe("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Ple\
ase ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
      globals: ["Error"],
      locals: {
        _initializerWarningHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerWarningHelper",
      dependencies: {}
    }),
    instanceof: Pe("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.h\
asInstance](n):n instanceof e}', {
      globals: ["Symbol"],
      locals: {
        _instanceof: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_instanceof",
      dependencies: {}
    }),
    interopRequireDefault: Pe("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
      globals: [],
      locals: {
        _interopRequireDefault: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireDefault",
      dependencies: {}
    }),
    interopRequireWildcard: Pe("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t\
=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)retu\
rn e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e\
);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,\
u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e\
,n),n}', {
      globals: ["WeakMap", "Object"],
      locals: {
        _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"],
        _interopRequireWildcard: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireWildcard",
      dependencies: {}
    }),
    isNativeFunction: Pe("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}ca\
tch(n){return"function"==typeof t}}', {
      globals: ["Function"],
      locals: {
        _isNativeFunction: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_isNativeFunction",
      dependencies: {}
    }),
    isNativeReflectConstruct: Pe("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(\
Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
      globals: ["Boolean", "Reflect"],
      locals: {
        _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_isNativeReflectConstruct",
      dependencies: {}
    }),
    iterableToArray: Pe("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@it\
erator"])return Array.from(r)}', {
      globals: ["Symbol", "Array"],
      locals: {
        _iterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArray",
      dependencies: {}
    }),
    iterableToArrayLimit: Pe("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.it\
erator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(\
f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==\
u))return}finally{if(o)throw n}}return a}}', {
      globals: ["Symbol", "Object"],
      locals: {
        _iterableToArrayLimit: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArrayLimit",
      dependencies: {}
    }),
    jsx: Pe("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="functi\
on"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:v\
oid 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]\
&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
      globals: ["Symbol", "Array"],
      locals: {
        REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.val\
ue", "body.1.body.body.0.expression.right.left"],
        _createRawReactElement: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createRawReactElement",
      dependencies: {}
    }),
    maybeArrayLike: Pe("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return a\
rrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
      globals: ["Array"],
      locals: {
        _maybeArrayLike: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_maybeArrayLike",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
      }
    }),
    newArrowCheck: Pe("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
      globals: ["TypeError"],
      locals: {
        _newArrowCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_newArrowCheck",
      dependencies: {}
    }),
    nonIterableRest: Pe("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instan\
ce.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableRest: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableRest",
      dependencies: {}
    }),
    nonIterableSpread: Pe("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instanc\
e.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableSpread",
      dependencies: {}
    }),
    nullishReceiverError: Pe("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',
    {
      globals: ["TypeError"],
      locals: {
        _nullishReceiverError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nullishReceiverError",
      dependencies: {}
    }),
    objectDestructuringEmpty: Pe("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "\
+t)}', {
      globals: ["TypeError"],
      locals: {
        _objectDestructuringEmpty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectDestructuringEmpty",
      dependencies: {}
    }),
    objectSpread2: Pe("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbo\
ls(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpre\
ad2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){definePro\
perty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEac\
h((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
      globals: ["Object"],
      locals: {
        ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.\
expression.alternate.alternate.callee.object.callee"],
        _objectSpread2: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread2",
      dependencies: {
        defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
      }
    }),
    objectWithoutProperties: Pe("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertie\
sLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.prope\
rtyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
      globals: ["Object"],
      locals: {
        _objectWithoutProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutProperties",
      dependencies: {
        objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
      }
    }),
    objectWithoutPropertiesLoose: Pe("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in \
r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
      globals: [],
      locals: {
        _objectWithoutPropertiesLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutPropertiesLoose",
      dependencies: {}
    }),
    possibleConstructorReturn: Pe("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e)\
)return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
      globals: ["TypeError"],
      locals: {
        _possibleConstructorReturn: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_possibleConstructorReturn",
      dependencies: {
        assertThisInitialized: ["body.0.body.body.2.argument.callee"]
      }
    }),
    readOnlyError: Pe("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
      globals: ["TypeError"],
      locals: {
        _readOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_readOnlyError",
      dependencies: {}
    }),
    regeneratorRuntime: Pe("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LI\
CENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t\
[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStr\
ingTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}\
catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(\
i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",\
arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={}\
;function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));v\
ar d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype\
=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invo\
ke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;retur\
n h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a\
)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:fun\
ction(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg\
,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Er\
ror("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c\
){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(\
o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p\
.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function ma\
ybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.a\
rg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n\
+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;ret\
urn a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw"\
,r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc\
=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",\
delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function value\
s(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){fo\
r(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new T\
ypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFuncti\
onPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displa\
yName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;r\
eturn!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.set\
PrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create\
(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){re\
turn this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);retu\
rn e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator")\
,define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[]\
;for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}r\
eturn next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this\
._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.c\
harAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.\
type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",\
a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("r\
oot"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.cat\
chLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.\
catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abru\
pt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.\
prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.\
type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;retu\
rn"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"n\
ormal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLo\
c===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var \
r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal ca\
tch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.ar\
g=t),y}},e}`, {
      globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"],
      locals: {
        _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_regeneratorRuntime",
      dependencies: {}
    }),
    set: Pe("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i\
=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getO\
wnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}\
function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
      globals: ["Reflect", "Object", "TypeError"],
      locals: {
        set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.\
body.0.argument.expressions.0.left"],
        _set: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_set",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
        defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
      }
    }),
    setFunctionName: Pe("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineP\
roperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
      globals: ["Object"],
      locals: {
        setFunctionName: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "setFunctionName",
      dependencies: {}
    }),
    setPrototypeOf: Pe("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bin\
d():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
      globals: ["Object"],
      locals: {
        _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_setPrototypeOf",
      dependencies: {}
    }),
    skipFirstGeneratorNext: Pe("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r\
.next(),r}}", {
      globals: [],
      locals: {
        _skipFirstGeneratorNext: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_skipFirstGeneratorNext",
      dependencies: {}
    }),
    slicedToArray: Pe("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterable\
ToArray(r,e)||nonIterableRest()}", {
      globals: [],
      locals: {
        _slicedToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_slicedToArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    superPropBase: Pe("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return\
 t}", {
      globals: [],
      locals: {
        _superPropBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropBase",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
      }
    }),
    superPropGet: Pe("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typ\
eof p?function(t){return p.apply(e,t)}:p}', {
      globals: [],
      locals: {
        _superPropGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropGet",
      dependencies: {
        get: ["body.0.body.body.0.declarations.0.init.callee"],
        getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
      }
    }),
    superPropSet: Pe("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
      globals: [],
      locals: {
        _superPropSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropSet",
      dependencies: {
        set: ["body.0.body.body.0.argument.callee"],
        getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
      }
    }),
    taggedTemplateLiteral: Pe("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProp\
erties(e,{raw:{value:Object.freeze(t)}}))}", {
      globals: ["Object"],
      locals: {
        _taggedTemplateLiteral: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteral",
      dependencies: {}
    }),
    taggedTemplateLiteralLoose: Pe("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
      globals: [],
      locals: {
        _taggedTemplateLiteralLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteralLoose",
      dependencies: {}
    }),
    tdz: Pe("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
      globals: ["ReferenceError"],
      locals: {
        _tdzError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_tdzError",
      dependencies: {}
    }),
    temporalRef: Pe("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
      globals: [],
      locals: {
        _temporalRef: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalRef",
      dependencies: {
        temporalUndefined: ["body.0.body.body.0.argument.test.right"],
        tdz: ["body.0.body.body.0.argument.consequent.callee"]
      }
    }),
    temporalUndefined: Pe("7.0.0-beta.0", "function _temporalUndefined(){}", {
      globals: [],
      locals: {
        _temporalUndefined: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalUndefined",
      dependencies: {}
    }),
    toArray: Pe("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterab\
leRest()}", {
      globals: [],
      locals: {
        _toArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    toConsumableArray: Pe("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterab\
leToArray(r)||nonIterableSpread()}", {
      globals: [],
      locals: {
        _toConsumableArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toConsumableArray",
      dependencies: {
        arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
      }
    }),
    toPrimitive: Pe("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=\
e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===\
r?String:Number)(t)}', {
      globals: ["Symbol", "TypeError", "String", "Number"],
      locals: {
        toPrimitive: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPrimitive",
      dependencies: {}
    }),
    toPropertyKey: Pe("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
      globals: [],
      locals: {
        toPropertyKey: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPropertyKey",
      dependencies: {
        toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    toSetter: Pe("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o\
,t.apply(n,e)}})}', {
      globals: ["Object"],
      locals: {
        _toSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toSetter",
      dependencies: {}
    }),
    tsRewriteRelativeImportExtensions: Pe("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.te\
st(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,(function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCas\
e()+"js":t})):t}', {
      globals: [],
      locals: {
        tsRewriteRelativeImportExtensions: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "tsRewriteRelativeImportExtensions",
      dependencies: {}
    }),
    typeof: Pe("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Sym\
bol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"sym\
bol":typeof o},_typeof(o)}', {
      globals: ["Symbol"],
      locals: {
        _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_typeof",
      dependencies: {}
    }),
    unsupportedIterableToArray: Pe("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r\
,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Argu\
ments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
      globals: ["Array"],
      locals: {
        _unsupportedIterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_unsupportedIterableToArray",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument\
.expressions.1.alternate.consequent.callee"]
      }
    }),
    usingCtx: Pe("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return\
 n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using \
declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispo\
se")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is no\
t disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e\
}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)r\
eturn s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}\
catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):\
n,next()}return next()}}}', {
      globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
      locals: {
        _usingCtx: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_usingCtx",
      dependencies: {}
    }),
    wrapAsyncGenerator: Pe("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,argumen\
ts))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v\
:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"no\
rmal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done\
:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e\
,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=type\
of e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){re\
turn this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._\
invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
      globals: ["Promise", "Symbol"],
      locals: {
        _wrapAsyncGenerator: ["body.0.id"],
        AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.objec\
t.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.ex\
pressions.3.left.object.object"]
      },
      exportBindingAssignments: [],
      exportName: "_wrapAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
      }
    }),
    wrapNativeSuper: Pe("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=fu\
nction(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a \
function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).\
constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),set\
PrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
      globals: ["Map", "TypeError", "Object"],
      locals: {
        _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
      exportName: "_wrapNativeSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
        setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
        isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
        construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
      }
    }),
    wrapRegExp: Pe("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=\
new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function build\
Groups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===\
e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=funct\
ion(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.\
prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(\
>|$)/g,(function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""})))}if("function"=\
=typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.cal\
l(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
      globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
      locals: {
        _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_wrapRegExp",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
        inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
      }
    }),
    writeOnlyError: Pe("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
      globals: ["TypeError"],
      locals: {
        _writeOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_writeOnlyError",
      dependencies: {}
    })
  };
  Object.assign(ZFe, {
    AwaitValue: Pe("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
      globals: [],
      locals: {
        _AwaitValue: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_AwaitValue",
      dependencies: {}
    }),
    applyDecs: Pe("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"\
getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.pr\
ivate;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_\
assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.pub\
lic={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataM\
apToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.le\
ngth;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.fr\
om(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metada\
ta||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitialize\
r"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;ca\
se 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isSt\
atic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get\
,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=functio\
n(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.\
v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMet\
adataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("fu\
nction"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"\
!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&\
old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init\
,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeErro\
r((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.in\
it)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMember\
Dec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={se\
t:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnProp\
ertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_membe\
rDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):\
f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:\
1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b\
)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.lengt\
h;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.\
value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)\
}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(v\
ar i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=\
(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw\
 Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not \
currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}\
old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a\
].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{\
var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),\
d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)})\
)}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_apply\
ClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
      globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
      locals: {
        old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body\
.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
        old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expr\
essions.3.callee"],
        old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.conse\
quent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
        old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.\
body.1.expression.left.right.right.callee"],
        old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expres\
sion.expressions.0.callee"],
        old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
        old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.con\
sequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7\
.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.\
callee"],
        old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1\
.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressio\
ns.0.callee"],
        old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.ca\
llee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
        old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
        old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
        old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressi\
ons.1.callee"],
        old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
        applyDecs: ["body.13.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs",
      dependencies: {
        setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.bo\
dy.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2203: Pe("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){\
if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}funct\
ion memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";b\
reak;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p\
)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=fu\
nction(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{retu\
rn e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertV\
alidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with \
get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor\
.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"met\
hod")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{g\
et:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.se\
t}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f)\
,0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberD\
ec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==\
g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typ\
eof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.\
push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.c\
all(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProper\
ty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){\
var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=\
c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g\
&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public me\
thod/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberD\
ec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length\
-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&\
(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;functio\
n applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
        applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee\
.left"],
        applyDecs2203: ["body.2.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2203",
      dependencies: {}
    }),
    applyDecs2203R: Pe("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t\
){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}fun\
ction memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter"\
;break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInit\
ializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!\
==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}\
:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")\
}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must retur\
n an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallabl\
e(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10\
===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(\
o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setF\
unctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:\
2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0=\
==a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(\
v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&\
(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof\
 l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.pus\
h(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call\
(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(\
t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1\
],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0\
===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorate\
d public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}a\
pplyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){f\
or(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.le\
ngth>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitiali\
zerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]\
}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2203R",
      dependencies: {
        setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2301: Pe("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){\
if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}funct\
ion assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,\
r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="\
field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n\
,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e\
){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPriva\
te(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():f\
unction(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertC\
allable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1==\
=e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");v\
oid 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.i\
nit,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function \
or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?\
(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f=\
"set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnProp\
ertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec\
(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(va\
r m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get|\
|p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0==\
=l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}\
}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.\
set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((fun\
ction(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<\
t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=funct\
ion(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===\
b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor\
. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,\
y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;\
r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=\
[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}f\
inally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}functio\
n applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2301",
      dependencies: {
        checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.b\
ody.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      }
    }),
    applyDecs2305: Pe("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}f\
unction c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeE\
rror(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e)\
)throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var\
 w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](th\
is,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){va\
r D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function\
(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(nul\
l,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e)\
,w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.acces\
s={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof\
 P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!\
==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method\
")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].c\
all(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function \
u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.l\
ength>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=func\
tion(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(\
p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)th\
row Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is n\
ot currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyK\
ey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.len\
gth&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
      globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
      locals: {
        applyDecs2305: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2305",
      dependencies: {
        checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.\
0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alte\
rnate.callee"]
      }
    }),
    classApplyDescriptorDestructureSet: Pe("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t\
.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");ret\
urn t}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorDestructureSet",
      dependencies: {}
    }),
    classApplyDescriptorGet: Pe("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
      globals: [],
      locals: {
        _classApplyDescriptorGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorGet",
      dependencies: {}
    }),
    classApplyDescriptorSet: Pe("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new \
TypeError("attempted to set read only private field");t.value=l}}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorSet",
      dependencies: {}
    }),
    classCheckPrivateStaticAccess: Pe("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
      globals: [],
      locals: {
        _classCheckPrivateStaticAccess: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticAccess",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.callee"]
      }
    }),
    classCheckPrivateStaticFieldDescriptor: Pe("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new Typ\
eError("attempted to "+e+" private static field before its declaration")}', {
      globals: ["TypeError"],
      locals: {
        _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticFieldDescriptor",
      dependencies: {}
    }),
    classExtractFieldDescriptor: Pe("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
      globals: [],
      locals: {
        _classExtractFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classExtractFieldDescriptor",
      dependencies: {
        classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
      }
    }),
    classPrivateFieldDestructureSet: Pe("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return cla\
ssApplyDescriptorDestructureSet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateFieldGet: Pe("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescript\
orGet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateFieldSet: Pe("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescri\
ptorSet(e,s,r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      }
    }),
    classPrivateMethodGet: Pe("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
      globals: [],
      locals: {
        _classPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      }
    }),
    classPrivateMethodSet: Pe("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodSet",
      dependencies: {}
    }),
    classStaticPrivateFieldDestructureSet: Pe("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t\
),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateFieldSpecGet: Pe("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPriv\
ateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateFieldSpecSet: Pe("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPr\
ivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      }
    }),
    classStaticPrivateMethodSet: Pe("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static\
 private field")}', {
      globals: ["TypeError"],
      locals: {
        _classStaticPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodSet",
      dependencies: {}
    }),
    defineEnumerableProperties: Pe("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.en\
umerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols\
(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',
    {
      globals: ["Object"],
      locals: {
        _defineEnumerableProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineEnumerableProperties",
      dependencies: {}
    }),
    dispose: Pe("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=Suppresse\
dError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Obj\
ect.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}func\
tion _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catc\
h(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
      globals: ["SuppressedError", "Error", "Object", "Promise"],
      locals: {
        dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body\
.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argumen\
t.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expre\
ssions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
        _dispose: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_dispose",
      dependencies: {}
    }),
    objectSpread: Pe("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(argument\
s[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e\
){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', {
      globals: ["Object"],
      locals: {
        _objectSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread",
      dependencies: {
        defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
      }
    }),
    using: Pe("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be use\
d with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbo\
l.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.\
push({v:n,d:r,a:e}),n}', {
      globals: ["Object", "TypeError", "Symbol"],
      locals: {
        _using: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_using",
      dependencies: {}
    })
  });
});

// ../node_modules/@babel/helpers/lib/index.js
var AN = g((el) => {
  "use strict";
  Object.defineProperty(el, "__esModule", {
    value: !0
  });
  el.default = void 0;
  el.get = kK;
  el.getDependencies = r3e;
  el.list = void 0;
  el.minVersion = i3e;
  var e3e = fe(), NK = wK(), {
    cloneNode: t3e,
    identifier: IK
  } = e3e;
  function fx(t, e, s) {
    try {
      let i = e.split("."), r = i.shift();
      for (; i.length > 0; )
        t = t[r], r = i.shift();
      if (arguments.length > 2)
        t[r] = s;
      else
        return t[r];
    } catch (i) {
      throw i.message += ` (when accessing ${e})`, i;
    }
  }
  n(fx, "deep");
  function s3e(t, e, s, i, r, a) {
    let {
      locals: o,
      dependencies: l,
      exportBindingAssignments: u,
      exportName: c
    } = e, p = new Set(i || []);
    s && p.add(s);
    for (let [h, f] of (Object.entries || ((d) => Object.keys(d).map((y) => [y, d[y]])))(o)) {
      let d = h;
      if (s && h === c)
        d = s;
      else
        for (; p.has(d); ) d = "_" + d;
      if (d !== h)
        for (let y of f)
          fx(t, y, IK(d));
    }
    for (let [h, f] of (Object.entries || ((d) => Object.keys(d).map((y) => [y, d[y]])))(l)) {
      let d = typeof r == "function" && r(h) || IK(h);
      for (let y of f)
        fx(t, y, t3e(d));
    }
    a?.(t, c, (h) => {
      u.forEach((f) => fx(t, f, h(fx(t, f))));
    });
  }
  n(s3e, "permuteHelperAST");
  var EN = /* @__PURE__ */ Object.create(null);
  function dx(t) {
    if (!EN[t]) {
      let e = NK.default[t];
      if (!e)
        throw Object.assign(new ReferenceError(`Unknown helper ${t}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: t
        });
      EN[t] = {
        minVersion: e.minVersion,
        build(s, i, r, a) {
          let o = e.ast();
          return s3e(o, e.metadata, i, r, s, a), {
            nodes: o.body,
            globals: e.metadata.globals
          };
        },
        getDependencies() {
          return Object.keys(e.metadata.dependencies);
        }
      };
    }
    return EN[t];
  }
  n(dx, "loadHelper");
  function kK(t, e, s, i, r) {
    if (typeof s == "object") {
      let a = s;
      a?.type === "Identifier" ? s = a.name : s = void 0;
    }
    return dx(t).build(e, s, i, r);
  }
  n(kK, "get");
  function i3e(t) {
    return dx(t).minVersion;
  }
  n(i3e, "minVersion");
  function r3e(t) {
    return dx(t).getDependencies();
  }
  n(r3e, "getDependencies");
  el.ensure = (t) => {
    dx(t);
  };
  var t5s = el.list = Object.keys(NK.default).map((t) => t.replace(/^_/, "")), s5s = el.default = kK;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var vN = g((ds) => {
  "use strict";
  Object.defineProperty(ds, "__esModule", {
    value: !0
  });
  ds.Var = ds.User = ds.Statement = ds.SpreadProperty = ds.Scope = ds.RestProperty = ds.ReferencedMemberExpression = ds.ReferencedIdentifier =
  ds.Referenced = ds.Pure = ds.NumericLiteralTypeAnnotation = ds.Generated = ds.ForAwaitStatement = ds.Flow = ds.Expression = ds.ExistentialTypeParam =
  ds.BlockScoped = ds.BindingIdentifier = void 0;
  var n5s = ds.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], a5s = ds.ReferencedMemberExpression = ["MemberExpression"], o5s = ds.
  BindingIdentifier = ["Identifier"], l5s = ds.Statement = ["Statement"], u5s = ds.Expression = ["Expression"], c5s = ds.Scope = ["Scopable",
  "Pattern"], p5s = ds.Referenced = null, h5s = ds.BlockScoped = null, f5s = ds.Var = ["VariableDeclaration"], d5s = ds.User = null, m5s = ds.
  Generated = null, y5s = ds.Pure = null, g5s = ds.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], T5s = ds.RestProperty =
  ["RestElement"], b5s = ds.SpreadProperty = ["RestElement"], x5s = ds.ExistentialTypeParam = ["ExistsTypeAnnotation"], S5s = ds.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], P5s = ds.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/ms/index.js
var OK = g((A5s, DK) => {
  var pd = 1e3, hd = pd * 60, fd = hd * 60, rh = fd * 24, n3e = rh * 7, a3e = rh * 365.25;
  DK.exports = function(t, e) {
    e = e || {};
    var s = typeof t;
    if (s === "string" && t.length > 0)
      return o3e(t);
    if (s === "number" && isFinite(t))
      return e.long ? u3e(t) : l3e(t);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
    );
  };
  function o3e(t) {
    if (t = String(t), !(t.length > 100)) {
      var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        t
      );
      if (e) {
        var s = parseFloat(e[1]), i = (e[2] || "ms").toLowerCase();
        switch (i) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return s * a3e;
          case "weeks":
          case "week":
          case "w":
            return s * n3e;
          case "days":
          case "day":
          case "d":
            return s * rh;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return s * fd;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return s * hd;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return s * pd;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return s;
          default:
            return;
        }
      }
    }
  }
  n(o3e, "parse");
  function l3e(t) {
    var e = Math.abs(t);
    return e >= rh ? Math.round(t / rh) + "d" : e >= fd ? Math.round(t / fd) + "h" : e >= hd ? Math.round(t / hd) + "m" : e >= pd ? Math.round(
    t / pd) + "s" : t + "ms";
  }
  n(l3e, "fmtShort");
  function u3e(t) {
    var e = Math.abs(t);
    return e >= rh ? mx(t, e, rh, "day") : e >= fd ? mx(t, e, fd, "hour") : e >= hd ? mx(t, e, hd, "minute") : e >= pd ? mx(t, e, pd, "secon\
d") : t + " ms";
  }
  n(u3e, "fmtLong");
  function mx(t, e, s, i) {
    var r = e >= s * 1.5;
    return Math.round(t / s) + " " + i + (r ? "s" : "");
  }
  n(mx, "plural");
});

// ../node_modules/debug/src/common.js
var CN = g((C5s, _K) => {
  function c3e(t) {
    s.debug = s, s.default = s, s.coerce = u, s.disable = o, s.enable = r, s.enabled = l, s.humanize = OK(), s.destroy = c, Object.keys(t).forEach(
    (p) => {
      s[p] = t[p];
    }), s.names = [], s.skips = [], s.formatters = {};
    function e(p) {
      let h = 0;
      for (let f = 0; f < p.length; f++)
        h = (h << 5) - h + p.charCodeAt(f), h |= 0;
      return s.colors[Math.abs(h) % s.colors.length];
    }
    n(e, "selectColor"), s.selectColor = e;
    function s(p) {
      let h, f = null, d, y;
      function m(...T) {
        if (!m.enabled)
          return;
        let b = m, E = Number(/* @__PURE__ */ new Date()), w = E - (h || E);
        b.diff = w, b.prev = h, b.curr = E, h = E, T[0] = s.coerce(T[0]), typeof T[0] != "string" && T.unshift("%O");
        let K = 0;
        T[0] = T[0].replace(/%([a-zA-Z%])/g, (de, me) => {
          if (de === "%%")
            return "%";
          K++;
          let ve = s.formatters[me];
          if (typeof ve == "function") {
            let ye = T[K];
            de = ve.call(b, ye), T.splice(K, 1), K--;
          }
          return de;
        }), s.formatArgs.call(b, T), (b.log || s.log).apply(b, T);
      }
      return n(m, "debug"), m.namespace = p, m.useColors = s.useColors(), m.color = s.selectColor(p), m.extend = i, m.destroy = s.destroy, Object.
      defineProperty(m, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ n(() => f !== null ? f : (d !== s.namespaces && (d = s.namespaces, y = s.enabled(p)), y), "get"),
        set: /* @__PURE__ */ n((T) => {
          f = T;
        }, "set")
      }), typeof s.init == "function" && s.init(m), m;
    }
    n(s, "createDebug");
    function i(p, h) {
      let f = s(this.namespace + (typeof h > "u" ? ":" : h) + p);
      return f.log = this.log, f;
    }
    n(i, "extend");
    function r(p) {
      s.save(p), s.namespaces = p, s.names = [], s.skips = [];
      let h = (typeof p == "string" ? p : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (let f of h)
        f[0] === "-" ? s.skips.push(f.slice(1)) : s.names.push(f);
    }
    n(r, "enable");
    function a(p, h) {
      let f = 0, d = 0, y = -1, m = 0;
      for (; f < p.length; )
        if (d < h.length && (h[d] === p[f] || h[d] === "*"))
          h[d] === "*" ? (y = d, m = f, d++) : (f++, d++);
        else if (y !== -1)
          d = y + 1, m++, f = m;
        else
          return !1;
      for (; d < h.length && h[d] === "*"; )
        d++;
      return d === h.length;
    }
    n(a, "matchesTemplate");
    function o() {
      let p = [
        ...s.names,
        ...s.skips.map((h) => "-" + h)
      ].join(",");
      return s.enable(""), p;
    }
    n(o, "disable");
    function l(p) {
      for (let h of s.skips)
        if (a(p, h))
          return !1;
      for (let h of s.names)
        if (a(p, h))
          return !0;
      return !1;
    }
    n(l, "enabled");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    n(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return n(c, "destroy"), s.enable(s.load()), s;
  }
  n(c3e, "setup");
  _K.exports = c3e;
});

// ../node_modules/debug/src/browser.js
var LK = g((la, yx) => {
  la.formatArgs = h3e;
  la.save = f3e;
  la.load = d3e;
  la.useColors = p3e;
  la.storage = m3e();
  la.destroy = /* @__PURE__ */ (() => {
    let t = !1;
    return () => {
      t || (t = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  la.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function p3e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let t;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (t = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(t[1], 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  n(p3e, "useColors");
  function h3e(t) {
    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" +
    yx.exports.humanize(this.diff), !this.useColors)
      return;
    let e = "color: " + this.color;
    t.splice(1, 0, e, "color: inherit");
    let s = 0, i = 0;
    t[0].replace(/%[a-zA-Z%]/g, (r) => {
      r !== "%%" && (s++, r === "%c" && (i = s));
    }), t.splice(i, 0, e);
  }
  n(h3e, "formatArgs");
  la.log = console.debug || console.log || (() => {
  });
  function f3e(t) {
    try {
      t ? la.storage.setItem("debug", t) : la.storage.removeItem("debug");
    } catch {
    }
  }
  n(f3e, "save");
  function d3e() {
    let t;
    try {
      t = la.storage.getItem("debug");
    } catch {
    }
    return !t && typeof process < "u" && "env" in process && (t = process.env.DEBUG), t;
  }
  n(d3e, "load");
  function m3e() {
    try {
      return localStorage;
    } catch {
    }
  }
  n(m3e, "localstorage");
  yx.exports = CN()(la);
  var { formatters: y3e } = yx.exports;
  y3e.j = function(t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var MK = g((N5s, BK) => {
  "use strict";
  BK.exports = (t, e = process.argv) => {
    let s = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", i = e.indexOf(s + t), r = e.indexOf("--");
    return i !== -1 && (r === -1 || i < r);
  };
});

// ../node_modules/supports-color/index.js
var RK = g((k5s, jK) => {
  "use strict";
  var g3e = require("os"), FK = require("tty"), Ca = MK(), { env: _r } = process, Ic;
  Ca("no-color") || Ca("no-colors") || Ca("color=false") || Ca("color=never") ? Ic = 0 : (Ca("color") || Ca("colors") || Ca("color=true") ||
  Ca("color=always")) && (Ic = 1);
  "FORCE_COLOR" in _r && (_r.FORCE_COLOR === "true" ? Ic = 1 : _r.FORCE_COLOR === "false" ? Ic = 0 : Ic = _r.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(_r.FORCE_COLOR, 10), 3));
  function wN(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(wN, "translateLevel");
  function IN(t, e) {
    if (Ic === 0)
      return 0;
    if (Ca("color=16m") || Ca("color=full") || Ca("color=truecolor"))
      return 3;
    if (Ca("color=256"))
      return 2;
    if (t && !e && Ic === void 0)
      return 0;
    let s = Ic || 0;
    if (_r.TERM === "dumb")
      return s;
    if (process.platform === "win32") {
      let i = g3e.release().split(".");
      return Number(i[0]) >= 10 && Number(i[2]) >= 10586 ? Number(i[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in _r)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((i) => i in _r) || _r.CI_NAME === "codeship" ?
      1 : s;
    if ("TEAMCITY_VERSION" in _r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(_r.TEAMCITY_VERSION) ? 1 : 0;
    if (_r.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in _r) {
      let i = parseInt((_r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (_r.TERM_PROGRAM) {
        case "iTerm.app":
          return i >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(_r.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(_r.TERM) || "COLORTERM" in
    _r ? 1 : s;
  }
  n(IN, "supportsColor");
  function T3e(t) {
    let e = IN(t, t && t.isTTY);
    return wN(e);
  }
  n(T3e, "getSupportLevel");
  jK.exports = {
    supportsColor: T3e,
    stdout: wN(IN(!0, FK.isatty(1))),
    stderr: wN(IN(!0, FK.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var UK = g((Lr, Tx) => {
  var b3e = require("tty"), gx = require("util");
  Lr.init = C3e;
  Lr.log = E3e;
  Lr.formatArgs = S3e;
  Lr.save = A3e;
  Lr.load = v3e;
  Lr.useColors = x3e;
  Lr.destroy = gx.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Lr.colors = [6, 2, 3, 4, 5, 1];
  try {
    let t = RK();
    t && (t.stderr || t).level >= 2 && (Lr.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Lr.inspectOpts = Object.keys(process.env).filter((t) => /^debug_/i.test(t)).reduce((t, e) => {
    let s = e.substring(6).toLowerCase().replace(/_([a-z])/g, (r, a) => a.toUpperCase()), i = process.env[e];
    return /^(yes|on|true|enabled)$/i.test(i) ? i = !0 : /^(no|off|false|disabled)$/i.test(i) ? i = !1 : i === "null" ? i = null : i = Number(
    i), t[s] = i, t;
  }, {});
  function x3e() {
    return "colors" in Lr.inspectOpts ? !!Lr.inspectOpts.colors : b3e.isatty(process.stderr.fd);
  }
  n(x3e, "useColors");
  function S3e(t) {
    let { namespace: e, useColors: s } = this;
    if (s) {
      let i = this.color, r = "\x1B[3" + (i < 8 ? i : "8;5;" + i), a = `  ${r};1m${e} \x1B[0m`;
      t[0] = a + t[0].split(`
`).join(`
` + a), t.push(r + "m+" + Tx.exports.humanize(this.diff) + "\x1B[0m");
    } else
      t[0] = P3e() + e + " " + t[0];
  }
  n(S3e, "formatArgs");
  function P3e() {
    return Lr.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  n(P3e, "getDate");
  function E3e(...t) {
    return process.stderr.write(gx.formatWithOptions(Lr.inspectOpts, ...t) + `
`);
  }
  n(E3e, "log");
  function A3e(t) {
    t ? process.env.DEBUG = t : delete process.env.DEBUG;
  }
  n(A3e, "save");
  function v3e() {
    return process.env.DEBUG;
  }
  n(v3e, "load");
  function C3e(t) {
    t.inspectOpts = {};
    let e = Object.keys(Lr.inspectOpts);
    for (let s = 0; s < e.length; s++)
      t.inspectOpts[e[s]] = Lr.inspectOpts[e[s]];
  }
  n(C3e, "init");
  Tx.exports = CN()(Lr);
  var { formatters: qK } = Tx.exports;
  qK.o = function(t) {
    return this.inspectOpts.colors = this.useColors, gx.inspect(t, this.inspectOpts).split(`
`).map((e) => e.trim()).join(" ");
  };
  qK.O = function(t) {
    return this.inspectOpts.colors = this.useColors, gx.inspect(t, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var go = g((_5s, NN) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? NN.exports = LK() : NN.exports = UK();
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var DN = g((Ar) => {
  "use strict";
  Object.defineProperty(Ar, "__esModule", {
    value: !0
  });
  Ar.isBindingIdentifier = X3e;
  Ar.isBlockScoped = e4e;
  Ar.isExpression = G3e;
  Ar.isFlow = n4e;
  Ar.isForAwaitStatement = l4e;
  Ar.isGenerated = i4e;
  Ar.isPure = r4e;
  Ar.isReferenced = Z3e;
  Ar.isReferencedIdentifier = J3e;
  Ar.isReferencedMemberExpression = Y3e;
  Ar.isRestProperty = a4e;
  Ar.isScope = Q3e;
  Ar.isSpreadProperty = o4e;
  Ar.isStatement = z3e;
  Ar.isUser = s4e;
  Ar.isVar = t4e;
  var w3e = fe(), {
    isBinding: I3e,
    isBlockScoped: N3e,
    isExportDeclaration: k3e,
    isExpression: D3e,
    isFlow: O3e,
    isForStatement: _3e,
    isForXStatement: L3e,
    isIdentifier: KK,
    isImportDeclaration: B3e,
    isImportSpecifier: M3e,
    isJSXIdentifier: F3e,
    isJSXMemberExpression: j3e,
    isMemberExpression: R3e,
    isRestElement: VK,
    isReferenced: kN,
    isScope: q3e,
    isStatement: U3e,
    isVar: K3e,
    isVariableDeclaration: V3e,
    react: W3e,
    isForOfStatement: $3e
  } = w3e, {
    isCompatTag: H3e
  } = W3e;
  function J3e(t) {
    let {
      node: e,
      parent: s
    } = this;
    if (!KK(e, t) && !j3e(s, t))
      if (F3e(e, t)) {
        if (H3e(e.name)) return !1;
      } else
        return !1;
    return kN(e, s, this.parentPath.parent);
  }
  n(J3e, "isReferencedIdentifier");
  function Y3e() {
    let {
      node: t,
      parent: e
    } = this;
    return R3e(t) && kN(t, e);
  }
  n(Y3e, "isReferencedMemberExpression");
  function X3e() {
    let {
      node: t,
      parent: e
    } = this, s = this.parentPath.parent;
    return KK(t) && I3e(t, e, s);
  }
  n(X3e, "isBindingIdentifier");
  function z3e() {
    let {
      node: t,
      parent: e
    } = this;
    return U3e(t) ? !(V3e(t) && (L3e(e, {
      left: t
    }) || _3e(e, {
      init: t
    }))) : !1;
  }
  n(z3e, "isStatement");
  function G3e() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : D3e(this.node);
  }
  n(G3e, "isExpression");
  function Q3e() {
    return q3e(this.node, this.parent);
  }
  n(Q3e, "isScope");
  function Z3e() {
    return kN(this.node, this.parent);
  }
  n(Z3e, "isReferenced");
  function e4e() {
    return N3e(this.node);
  }
  n(e4e, "isBlockScoped");
  function t4e() {
    return K3e(this.node);
  }
  n(t4e, "isVar");
  function s4e() {
    return this.node && !!this.node.loc;
  }
  n(s4e, "isUser");
  function i4e() {
    return !this.isUser();
  }
  n(i4e, "isGenerated");
  function r4e(t) {
    return this.scope.isPure(this.node, t);
  }
  n(r4e, "isPure");
  function n4e() {
    let {
      node: t
    } = this;
    return O3e(t) ? !0 : B3e(t) ? t.importKind === "type" || t.importKind === "typeof" : k3e(t) ? t.exportKind === "type" : M3e(t) ? t.importKind ===
    "type" || t.importKind === "typeof" : !1;
  }
  n(n4e, "isFlow");
  function a4e() {
    var t;
    return VK(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectPattern());
  }
  n(a4e, "isRestProperty");
  function o4e() {
    var t;
    return VK(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectExpression());
  }
  n(o4e, "isSpreadProperty");
  function l4e() {
    return $3e(this.node, {
      await: !0
    });
  }
  n(l4e, "isForAwaitStatement");
  Ar.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Ar.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/visitors.js
var fg = g((ah) => {
  "use strict";
  Object.defineProperty(ah, "__esModule", {
    value: !0
  });
  ah.environmentVisitor = y4e;
  ah.explode = eV;
  ah.isExplodedVisitor = ZK;
  ah.merge = sV;
  ah.verify = tV;
  var QK = vN(), u4e = DN(), c4e = fe(), WK = tl(), {
    DEPRECATED_KEYS: $K,
    DEPRECATED_ALIASES: HK,
    FLIPPED_ALIAS_KEYS: JK,
    TYPES: p4e,
    __internal__deprecationWarning: YK
  } = c4e;
  function h4e(t) {
    return t in QK;
  }
  n(h4e, "isVirtualType");
  function ZK(t) {
    return t?._exploded;
  }
  n(ZK, "isExplodedVisitor");
  function eV(t) {
    if (ZK(t)) return t;
    t._exploded = !0;
    for (let e of Object.keys(t)) {
      if (nh(e)) continue;
      let s = e.split("|");
      if (s.length === 1) continue;
      let i = t[e];
      delete t[e];
      for (let r of s)
        t[r] = i;
    }
    tV(t), delete t.__esModule, f4e(t), GK(t);
    for (let e of Object.keys(t)) {
      if (nh(e) || !h4e(e)) continue;
      let s = t[e];
      for (let r of Object.keys(s))
        s[r] = d4e(e, s[r]);
      delete t[e];
      let i = QK[e];
      if (i !== null)
        for (let r of i)
          t[r] ? hg(t[r], s) : t[r] = s;
      else
        hg(t, s);
    }
    for (let e of Object.keys(t)) {
      if (nh(e)) continue;
      let s = JK[e];
      if (e in $K) {
        let r = $K[e];
        YK(e, r, "Visitor "), s = [r];
      } else if (e in HK) {
        let r = HK[e];
        YK(e, r, "Visitor "), s = JK[r];
      }
      if (!s) continue;
      let i = t[e];
      delete t[e];
      for (let r of s) {
        let a = t[r];
        a ? hg(a, i) : t[r] = Object.assign({}, i);
      }
    }
    for (let e of Object.keys(t))
      nh(e) || GK(t[e]);
    return t;
  }
  n(eV, "explode$1");
  function tV(t) {
    if (!t._verified) {
      if (typeof t == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let e of Object.keys(t)) {
        if ((e === "enter" || e === "exit") && XK(e, t[e]), nh(e)) continue;
        if (!p4e.includes(e))
          throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type in @babel/traverse 7.26.9`);
        let s = t[e];
        if (typeof s == "object")
          for (let i of Object.keys(s))
            if (i === "enter" || i === "exit")
              XK(`${e}.${i}`, s[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${i}`);
      }
      t._verified = !0;
    }
  }
  n(tV, "verify$1");
  function XK(t, e) {
    let s = [].concat(e);
    for (let i of s)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${t} with type ${typeof i}`);
  }
  n(XK, "validateVisitorMethods");
  function sV(t, e = [], s) {
    let i = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(i, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(i, "_verified", {
      enumerable: !1
    });
    for (let r = 0; r < t.length; r++) {
      let a = eV(t[r]), o = e[r], l = a;
      (o || s) && (l = zK(l, o, s)), hg(i, l);
      for (let u of Object.keys(a)) {
        if (nh(u)) continue;
        let c = a[u];
        (o || s) && (c = zK(c, o, s));
        let p = i[u] || (i[u] = {});
        hg(p, c);
      }
    }
    return i;
  }
  n(sV, "merge");
  function zK(t, e, s) {
    let i = {};
    for (let r of ["enter", "exit"]) {
      let a = t[r];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return e && (l = /* @__PURE__ */ n(function(u) {
          o.call(e, u, e);
        }, "newFn")), s && (l = s(e?.key, r, l)), l !== o && (l.toString = () => o.toString()), l;
      }), i[r] = a);
    }
    return i;
  }
  n(zK, "wrapWithStateOrWrapper");
  function f4e(t) {
    for (let e of Object.keys(t)) {
      if (nh(e)) continue;
      let s = t[e];
      typeof s == "function" && (t[e] = {
        enter: s
      });
    }
  }
  n(f4e, "ensureEntranceObjects");
  function GK(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit]);
  }
  n(GK, "ensureCallbackArrays");
  function d4e(t, e) {
    let s = `is${t}`, i = u4e[s], r = /* @__PURE__ */ n(function(a) {
      if (i.call(a))
        return e.apply(this, arguments);
    }, "newFn");
    return r.toString = () => e.toString(), r;
  }
  n(d4e, "wrapCheck");
  function nh(t) {
    return t[0] === "_" || t === "enter" || t === "exit" || t === "shouldSkip" || t === "denylist" || t === "noScope" || t === "skipKeys" ||
    t === "blacklist";
  }
  n(nh, "shouldIgnoreKey");
  function hg(t, e) {
    for (let s of ["enter", "exit"])
      e[s] && (t[s] = [].concat(t[s] || [], e[s]));
  }
  n(hg, "mergePair");
  var m4e = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() :
      WK.requeueComputedKeyAndDecorators.call(t)));
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() : WK.requeueComputedKeyAndDecorators.
      call(t));
    }
  };
  function y4e(t) {
    return sV([m4e, t]);
  }
  n(y4e, "environmentVisitor");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var iV = g((xx) => {
  "use strict";
  Object.defineProperty(xx, "__esModule", {
    value: !0
  });
  xx.default = void 0;
  var bx = fe(), g4e = bx, T4e = Sx(), b4e = fg(), x4e = tl(), {
    getAssignmentIdentifiers: S4e
  } = g4e, P4e = {
    ReferencedIdentifier({
      node: t
    }, e) {
      t.name === e.oldName && (t.name = e.newName);
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.
      requeueComputedKeyAndDecorators() : x4e.requeueComputedKeyAndDecorators.call(t)));
    },
    ObjectProperty({
      node: t,
      scope: e
    }, s) {
      let {
        name: i
      } = t.key;
      if (t.shorthand && (i === s.oldName || i === s.newName) && e.getBindingIdentifier(i) === s.binding.identifier) {
        t.shorthand = !1;
        {
          var r;
          (r = t.extra) != null && r.shorthand && (t.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(t, e) {
      if (t.isVariableDeclaration()) return;
      let s = t.isAssignmentExpression() ? S4e(t.node) : t.getOuterBindingIdentifiers();
      for (let i in s)
        i === e.oldName && (s[i].name = e.newName);
    }
  }, ON = class {
    static {
      n(this, "Renamer");
    }
    constructor(e, s, i) {
      this.newName = i, this.oldName = s, this.binding = e;
    }
    maybeConvertFromExportDeclaration(e) {
      let s = e.parentPath;
      if (s.isExportDeclaration()) {
        if (s.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = s.node;
          if (bx.isDeclaration(i) && !i.id)
            return;
        }
        s.isExportAllDeclaration() || s.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(e) {
      return e;
    }
    maybeConvertFromClassFunctionExpression(e) {
      return e;
    }
    rename() {
      let {
        binding: e,
        oldName: s,
        newName: i
      } = this, {
        scope: r,
        path: a
      } = e, o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression());
      o && o.getOuterBindingIdentifiers()[s] === e.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || r.block, u = {
        discriminant: !0
      };
      bx.isMethod(l) && (l.computed && (u.key = !0), bx.isObjectMethod(l) || (u.decorators = !0)), (0, T4e.traverseNode)(l, (0, b4e.explode)(
      P4e), r, this, r.path, u), arguments[0] || (r.removeOwnBinding(s), r.bindings[i] = e, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  xx.default = ON;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/binding.js
var rV = g((Px) => {
  "use strict";
  Object.defineProperty(Px, "__esModule", {
    value: !0
  });
  Px.default = void 0;
  var _N = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: e,
      scope: s,
      path: i,
      kind: r
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e, this.scope = s, this.path = i, this.kind = r,
      (r === "var" || r === "hoisted") && E4e(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(e) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = e);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(e) {
      this.constant = !1, !this.constantViolations.includes(e) && this.constantViolations.push(e);
    }
    reference(e) {
      this.referencePaths.includes(e) || (this.referenced = !0, this.references++, this.referencePaths.push(e));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  Px.default = _N;
  function E4e(t) {
    for (let {
      parentPath: e,
      key: s
    } = t; e; {
      parentPath: e,
      key: s
    } = e) {
      if (e.isFunctionParent()) return !1;
      if (e.isWhile() || e.isForXStatement() || e.isForStatement() && s === "body")
        return !0;
    }
    return !1;
  }
  n(E4e, "isDeclaredInLoop");
});

// ../node_modules/globals/globals.json
var nV = g((K5s, A4e) => {
  A4e.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/globals/index.js
var dd = g((V5s, aV) => {
  "use strict";
  aV.exports = nV();
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/cache.js
var oh = g((ua) => {
  "use strict";
  Object.defineProperty(ua, "__esModule", {
    value: !0
  });
  ua.clear = C4e;
  ua.clearPath = oV;
  ua.clearScope = lV;
  ua.getCachedPaths = w4e;
  ua.getOrCreateCachedPaths = I4e;
  ua.scope = ua.path = void 0;
  var Ex = ua.path = /* @__PURE__ */ new WeakMap(), v4e = ua.scope = /* @__PURE__ */ new WeakMap();
  function C4e() {
    oV(), lV();
  }
  n(C4e, "clear");
  function oV() {
    ua.path = Ex = /* @__PURE__ */ new WeakMap();
  }
  n(oV, "clearPath");
  function lV() {
    ua.scope = v4e = /* @__PURE__ */ new WeakMap();
  }
  n(lV, "clearScope");
  var LN = Object.freeze({});
  function w4e(t, e) {
    var s, i;
    return t = null, (s = Ex.get((i = t) != null ? i : LN)) == null ? void 0 : s.get(e);
  }
  n(w4e, "getCachedPaths");
  function I4e(t, e) {
    var s, i;
    t = null;
    let r = Ex.get((s = t) != null ? s : LN);
    r || Ex.set((i = t) != null ? i : LN, r = /* @__PURE__ */ new WeakMap());
    let a = r.get(e);
    return a || r.set(e, a = /* @__PURE__ */ new Map()), a;
  }
  n(I4e, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/index.js
var jN = g((vx) => {
  "use strict";
  Object.defineProperty(vx, "__esModule", {
    value: !0
  });
  vx.default = void 0;
  var N4e = iV(), k4e = zl(), D4e = rV(), O4e = dd(), gV = fe(), TV = gV, uV = oh(), _4e = fg(), {
    NOT_LOCAL_BINDING: cV,
    assignmentExpression: L4e,
    callExpression: pV,
    cloneNode: hV,
    getBindingIdentifiers: bV,
    identifier: uh,
    isArrayExpression: xV,
    isBinary: B4e,
    isCallExpression: fV,
    isClass: M4e,
    isClassBody: F4e,
    isClassDeclaration: j4e,
    isExportAllDeclaration: SV,
    isExportDefaultDeclaration: R4e,
    isExportNamedDeclaration: BN,
    isFunctionDeclaration: q4e,
    isIdentifier: lh,
    isImportDeclaration: MN,
    isLiteral: U4e,
    isMemberExpression: K4e,
    isMethod: V4e,
    isModuleSpecifier: W4e,
    isNullLiteral: $4e,
    isObjectExpression: H4e,
    isProperty: J4e,
    isPureish: Y4e,
    isRegExpLiteral: X4e,
    isSuper: z4e,
    isTaggedTemplateExpression: G4e,
    isTemplateLiteral: PV,
    isThisExpression: dV,
    isUnaryExpression: Q4e,
    isVariableDeclaration: Z4e,
    expressionStatement: eje,
    matchesPattern: mV,
    memberExpression: FN,
    numericLiteral: tje,
    toIdentifier: sje,
    variableDeclaration: ije,
    variableDeclarator: rje,
    isRecordExpression: nje,
    isTupleExpression: aje,
    isObjectProperty: oje,
    isTopicReference: yV,
    isMetaProperty: lje,
    isPrivateName: uje,
    isExportDeclaration: cje,
    buildUndefinedNode: pje,
    sequenceExpression: hje
  } = gV;
  function vi(t, e) {
    switch (t?.type) {
      default:
        if (MN(t) || cje(t)) {
          var s;
          if ((SV(t) || BN(t) || MN(t)) && t.source)
            vi(t.source, e);
          else if ((BN(t) || MN(t)) && (s = t.specifiers) != null && s.length)
            for (let i of t.specifiers) vi(i, e);
          else (R4e(t) || BN(t)) && t.declaration && vi(t.declaration, e);
        } else W4e(t) ? vi(t.local, e) : U4e(t) && !$4e(t) && !X4e(t) && !PV(t) && e.push(t.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        vi(t.object, e), vi(t.property, e);
        break;
      case "Identifier":
      case "JSXIdentifier":
        e.push(t.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        vi(t.callee, e);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of t.properties)
          vi(i, e);
        break;
      case "SpreadElement":
      case "RestElement":
        vi(t.argument, e);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        vi(t.key, e);
        break;
      case "ThisExpression":
        e.push("this");
        break;
      case "Super":
        e.push("super");
        break;
      case "Import":
        e.push("import");
        break;
      case "DoExpression":
        e.push("do");
        break;
      case "YieldExpression":
        e.push("yield"), vi(t.argument, e);
        break;
      case "AwaitExpression":
        e.push("await"), vi(t.argument, e);
        break;
      case "AssignmentExpression":
        vi(t.left, e);
        break;
      case "VariableDeclarator":
        vi(t.id, e);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        vi(t.id, e);
        break;
      case "PrivateName":
        vi(t.id, e);
        break;
      case "ParenthesizedExpression":
        vi(t.expression, e);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        vi(t.argument, e);
        break;
      case "MetaProperty":
        vi(t.meta, e), vi(t.property, e);
        break;
      case "JSXElement":
        vi(t.openingElement, e);
        break;
      case "JSXOpeningElement":
        vi(t.name, e);
        break;
      case "JSXFragment":
        vi(t.openingFragment, e);
        break;
      case "JSXOpeningFragment":
        e.push("Fragment");
        break;
      case "JSXNamespacedName":
        vi(t.namespace, e), vi(t.name, e);
        break;
    }
  }
  n(vi, "gatherNodeParts");
  var Ax = {
    ForStatement(t) {
      let e = t.get("init");
      if (e.isVar()) {
        let {
          scope: s
        } = t;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", e);
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return;
      (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t);
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    TSImportEqualsDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    ReferencedIdentifier(t, e) {
      TV.isTSQualifiedName(t.parent) && t.parent.right === t.node || t.parentPath.isTSImportEqualsDeclaration() || e.references.push(t);
    },
    ForXStatement(t, e) {
      let s = t.get("left");
      if (s.isPattern() || s.isIdentifier())
        e.constantViolations.push(t);
      else if (s.isVar()) {
        let {
          scope: i
        } = t;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", s);
      }
    },
    ExportDeclaration: {
      exit(t) {
        let {
          node: e,
          scope: s
        } = t;
        if (SV(e)) return;
        let i = e.declaration;
        if (j4e(i) || q4e(i)) {
          let r = i.id;
          if (!r) return;
          let a = s.getBinding(r.name);
          a?.reference(t);
        } else if (Z4e(i))
          for (let r of i.declarations)
            for (let a of Object.keys(bV(r))) {
              let o = s.getBinding(a);
              o?.reference(t);
            }
      }
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t);
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t);
    },
    UnaryExpression(t, e) {
      t.node.operator === "delete" && e.constantViolations.push(t);
    },
    BlockScoped(t) {
      let e = t.scope;
      if (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id) {
        let r = t.node.id.name;
        t.scope.bindings[r] = t.scope.parent.getBinding(r);
      }
    },
    CatchClause(t) {
      t.scope.registerBinding("let", t);
    },
    Function(t) {
      let e = t.get("params");
      for (let s of e)
        t.scope.registerBinding("param", s);
      t.isFunctionExpression() && t.node.id && !t.node.id[cV] && t.scope.registerBinding("local", t.get("id"), t);
    },
    ClassExpression(t) {
      t.node.id && !t.node.id[cV] && t.scope.registerBinding("local", t.get("id"), t);
    },
    TSTypeAnnotation(t) {
      t.skip();
    }
  }, fje = 0, To = class t {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: s
      } = e, i = uV.scope.get(s);
      if (i?.path === e)
        return i;
      uV.scope.set(s, this), this.uid = fje++, this.block = s, this.path = e, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var e;
      let s, i = this.path;
      do {
        var r;
        let a = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, a && i.isMethod() && (i = i.parentPath), (r = i) != null && r.isScope() && (s = i);
      } while (i && !s);
      return (e = s) == null ? void 0 : e.scope;
    }
    generateDeclaredUidIdentifier(e) {
      let s = this.generateUidIdentifier(e);
      return this.push({
        id: s
      }), hV(s);
    }
    generateUidIdentifier(e) {
      return uh(this.generateUid(e));
    }
    generateUid(e = "temp") {
      e = sje(e).replace(/^_+/, "").replace(/\d+$/g, "");
      let s, i = 1;
      do
        s = `_${e}`, i > 1 && (s += i), i++;
      while (this.hasLabel(s) || this.hasBinding(s) || this.hasGlobal(s) || this.hasReference(s));
      let r = this.getProgramParent();
      return r.references[s] = !0, r.uids[s] = !0, s;
    }
    generateUidBasedOnNode(e, s) {
      let i = [];
      vi(e, i);
      let r = i.join("$");
      return r = r.replace(/^_/, "") || s || "ref", this.generateUid(r.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e, s) {
      return uh(this.generateUidBasedOnNode(e, s));
    }
    isStatic(e) {
      if (dV(e) || z4e(e) || yV(e))
        return !0;
      if (lh(e)) {
        let s = this.getBinding(e.name);
        return s ? s.constant : this.hasBinding(e.name);
      }
      return !1;
    }
    maybeGenerateMemoised(e, s) {
      if (this.isStatic(e))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(e);
        return s ? i : (this.push({
          id: i
        }), hV(i));
      }
    }
    checkBlockScopedCollisions(e, s, i, r) {
      if (s === "param" || e.kind === "local") return;
      if (s === "let" || e.kind === "let" || e.kind === "const" || e.kind === "module" || e.kind === "param" && s === "const")
        throw this.path.hub.buildError(r, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(e, s) {
      let i = this.getBinding(e);
      i && (s || (s = this.generateUidIdentifier(e).name), new N4e.default(i, e, s).rename(arguments[2]));
    }
    dump() {
      let e = "-".repeat(60);
      console.log(e);
      let s = this;
      do {
        console.log("#", s.block.type);
        for (let i of Object.keys(s.bindings)) {
          let r = s.bindings[i];
          console.log(" -", i, {
            constant: r.constant,
            references: r.references,
            violations: r.constantViolations.length,
            kind: r.kind
          });
        }
      } while (s = s.parent);
      console.log(e);
    }
    hasLabel(e) {
      return !!this.getLabel(e);
    }
    getLabel(e) {
      return this.labels.get(e);
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e);
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement())
        this.registerLabel(e);
      else if (e.isFunctionDeclaration())
        this.registerBinding("hoisted", e.get("id"), e);
      else if (e.isVariableDeclaration()) {
        let s = e.get("declarations"), {
          kind: i
        } = e.node;
        for (let r of s)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, r);
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return;
        this.registerBinding("let", e);
      } else if (e.isImportDeclaration()) {
        let s = e.node.importKind === "type" || e.node.importKind === "typeof", i = e.get("specifiers");
        for (let r of i) {
          let a = s || r.isImportSpecifier() && (r.node.importKind === "type" || r.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", r);
        }
      } else if (e.isExportDeclaration()) {
        let s = e.get("declaration");
        (s.isClassDeclaration() || s.isFunctionDeclaration() || s.isVariableDeclaration()) && this.registerDeclaration(s);
      } else
        this.registerBinding("unknown", e);
    }
    buildUndefinedNode() {
      return pje();
    }
    registerConstantViolation(e) {
      let s = e.getAssignmentIdentifiers();
      for (let r of Object.keys(s)) {
        var i;
        (i = this.getBinding(r)) == null || i.reassign(e);
      }
    }
    registerBinding(e, s, i = s) {
      if (!e) throw new ReferenceError("no `kind`");
      if (s.isVariableDeclaration()) {
        let o = s.get("declarations");
        for (let l of o)
          this.registerBinding(e, l);
        return;
      }
      let r = this.getProgramParent(), a = s.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        r.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, e, o, l);
          }
          u ? u.reassign(i) : this.bindings[o] = new D4e.default({
            identifier: l,
            scope: this,
            path: i,
            kind: e
          });
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e;
    }
    hasUid(e) {
      let s = this;
      do
        if (s.uids[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasGlobal(e) {
      let s = this;
      do
        if (s.globals[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e];
    }
    isPure(e, s) {
      if (lh(e)) {
        let o = this.getBinding(e.name);
        return o ? s ? o.constant : !0 : !1;
      } else {
        if (dV(e) || lje(e) || yV(e) || uje(e))
          return !0;
        if (M4e(e)) {
          var i;
          return e.superClass && !this.isPure(e.superClass, s) || ((i = e.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(e.
          body, s);
        } else if (F4e(e)) {
          for (let o of e.body)
            if (!this.isPure(o, s)) return !1;
          return !0;
        } else {
          if (B4e(e))
            return this.isPure(e.left, s) && this.isPure(e.right, s);
          if (xV(e) || aje(e)) {
            for (let o of e.elements)
              if (o !== null && !this.isPure(o, s)) return !1;
            return !0;
          } else if (H4e(e) || nje(e)) {
            for (let o of e.properties)
              if (!this.isPure(o, s)) return !1;
            return !0;
          } else if (V4e(e)) {
            var r;
            return !(e.computed && !this.isPure(e.key, s) || ((r = e.decorators) == null ? void 0 : r.length) > 0);
          } else if (J4e(e)) {
            var a;
            return !(e.computed && !this.isPure(e.key, s) || ((a = e.decorators) == null ? void 0 : a.length) > 0 || (oje(e) || e.static) &&
            e.value !== null && !this.isPure(e.value, s));
          } else {
            if (Q4e(e))
              return this.isPure(e.argument, s);
            if (PV(e)) {
              for (let o of e.expressions)
                if (!this.isPure(o, s)) return !1;
              return !0;
            } else return G4e(e) ? mV(e.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(e.quasi, s) : K4e(e) ? !e.computed && lh(e.object) && e.object.name === "Symbol" && lh(e.property) && e.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : fV(e) ? mV(e.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && e.arguments.length === 1 && TV.isStringLiteral(e.arguments[0]) : Y4e(e);
          }
        }
      }
    }
    setData(e, s) {
      return this.data[e] = s;
    }
    getData(e) {
      let s = this;
      do {
        let i = s.data[e];
        if (i != null) return i;
      } while (s = s.parent);
    }
    removeData(e) {
      let s = this;
      do
        s.data[e] != null && (s.data[e] = null);
      while (s = s.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let e = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let s = this;
      do {
        if (s.crawling) return;
        if (s.path.isProgram())
          break;
      } while (s = s.parent);
      let i = s, r = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, e.type !== "Program" && (0, _4e.isExplodedVisitor)(Ax)) {
        for (let o of Ax.enter)
          o.call(r, e, r);
        let a = Ax[e.type];
        if (a)
          for (let o of a.enter)
            o.call(r, e, r);
      }
      e.traverse(Ax, r), this.crawling = !1;
      for (let a of r.assignments) {
        let o = a.getAssignmentIdentifiers();
        for (let l of Object.keys(o))
          a.scope.getBinding(l) || i.addGlobal(o[l]);
        a.scope.registerConstantViolation(a);
      }
      for (let a of r.references) {
        let o = a.scope.getBinding(a.node.name);
        o ? o.reference(a) : i.addGlobal(a.node);
      }
      for (let a of r.constantViolations)
        a.scope.registerConstantViolation(a);
    }
    push(e) {
      let s = this.path;
      s.isPattern() ? s = this.getPatternParent().path : !s.isBlockStatement() && !s.isProgram() && (s = this.getBlockParent().path), s.isSwitchStatement() &&
      (s = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: r,
        kind: a = "var",
        id: o
      } = e;
      if (!i && !r && (a === "var" || a === "let") && s.isFunction() && !s.node.name && fV(s.parent, {
        callee: s.node
      }) && s.parent.arguments.length <= s.node.params.length && lh(o)) {
        s.pushContainer("params", o), s.scope.registerBinding("param", s.get("params")[s.node.params.length - 1]);
        return;
      }
      (s.isLoop() || s.isCatchClause() || s.isFunction()) && (s.ensureBlock(), s = s.get("body"));
      let l = e._blockHoist == null ? 2 : e._blockHoist, u = `declaration:${a}:${l}`, c = !r && s.getData(u);
      if (!c) {
        let f = ije(a, []);
        f._blockHoist = l, [c] = s.unshiftContainer("body", [f]), r || s.setData(u, c);
      }
      let p = rje(o, i), h = c.node.declarations.push(p);
      s.scope.registerBinding(a, c.get("declarations")[h - 1]);
    }
    getProgramParent() {
      let e = this;
      do
        if (e.path.isProgram())
          return e;
      while (e = e.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e = this;
      do
        if (e.path.isFunctionParent())
          return e;
      while (e = e.parent);
      return null;
    }
    getBlockParent() {
      let e = this;
      do
        if (e.path.isBlockParent())
          return e;
      while (e = e.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e = this;
      do
        if (!e.path.isPattern())
          return e.getBlockParent();
      while (e = e.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let e = /* @__PURE__ */ Object.create(null), s = this;
      do {
        for (let i of Object.keys(s.bindings))
          i in e || (e[i] = s.bindings[i]);
        s = s.parent;
      } while (s);
      return e;
    }
    bindingIdentifierEquals(e, s) {
      return this.getBindingIdentifier(e) === s;
    }
    getBinding(e) {
      let s = this, i;
      do {
        let a = s.getOwnBinding(e);
        if (a) {
          var r;
          if (!((r = i) != null && r.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && e === "arguments" && s.path.isFunction() && !s.path.isArrowFunctionExpression())
          break;
        i = s.path;
      } while (s = s.parent);
    }
    getOwnBinding(e) {
      return this.bindings[e];
    }
    getBindingIdentifier(e) {
      var s;
      return (s = this.getBinding(e)) == null ? void 0 : s.identifier;
    }
    getOwnBindingIdentifier(e) {
      let s = this.bindings[e];
      return s?.identifier;
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e);
    }
    hasBinding(e, s) {
      if (!e) return !1;
      let i = this;
      do
        if (i.hasOwnBinding(e))
          return !0;
      while (i = i.parent);
      let r, a;
      return typeof s == "object" ? (r = s.noGlobals, a = s.noUids) : typeof s == "boolean" && (r = s), !!(!a && this.hasUid(e) || !r && t.globals.
      includes(e) || !r && t.contextVariables.includes(e));
    }
    parentHasBinding(e, s) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(e, s);
    }
    moveBindingTo(e, s) {
      let i = this.getBinding(e);
      i && (i.scope.removeOwnBinding(e), i.scope = s, s.bindings[e] = i);
    }
    removeOwnBinding(e) {
      delete this.bindings[e];
    }
    removeBinding(e) {
      var s;
      (s = this.getBinding(e)) == null || s.scope.removeOwnBinding(e);
      let i = this;
      do
        i.uids[e] && (i.uids[e] = !1);
      while (i = i.parent);
    }
    hoistVariables(e = (s) => this.push({
      id: s
    })) {
      this.crawl();
      let s = /* @__PURE__ */ new Set();
      for (let r of Object.keys(this.bindings)) {
        let a = this.bindings[r];
        if (!a) continue;
        let {
          path: o
        } = a;
        if (!o.isVariableDeclarator()) continue;
        let {
          parent: l,
          parentPath: u
        } = o;
        if (l.kind !== "var" || s.has(l)) continue;
        s.add(o.parent);
        let c, p = [];
        for (let h of l.declarations) {
          var i;
          (i = c) != null || (c = h.id), h.init && p.push(L4e("=", h.id, h.init));
          let f = Object.keys(bV(h, !1, !0, !0));
          for (let d of f)
            e(uh(d), h.init != null);
        }
        if (u.parentPath.isFor({
          left: l
        }))
          u.replaceWith(c);
        else if (p.length === 0)
          u.remove();
        else {
          let h = p.length === 1 ? p[0] : hje(p);
          u.parentPath.isForStatement({
            init: l
          }) ? u.replaceWith(h) : u.replaceWith(eje(h));
        }
      }
    }
  };
  vx.default = To;
  To.globals = Object.keys(O4e.builtin);
  To.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  To.prototype._renameFromMap = /* @__PURE__ */ n(function(e, s, i, r) {
    e[s] && (e[i] = r, e[s] = null);
  }, "_renameFromMap"), To.prototype.traverse = function(t, e, s) {
    (0, k4e.default)(t, e, this, s, this.path);
  }, To.prototype._generateUid = /* @__PURE__ */ n(function(e, s) {
    let i = e;
    return s > 1 && (i += s), `_${i}`;
  }, "_generateUid"), To.prototype.toArray = /* @__PURE__ */ n(function(e, s, i) {
    if (lh(e)) {
      let o = this.getBinding(e.name);
      if (o != null && o.constant && o.path.isGenericType("Array"))
        return e;
    }
    if (xV(e))
      return e;
    if (lh(e, {
      name: "arguments"
    }))
      return pV(FN(FN(FN(uh("Array"), uh("prototype")), uh("slice")), uh("call")), [e]);
    let r, a = [e];
    return s === !0 ? r = "toConsumableArray" : typeof s == "number" ? (a.push(tje(s)), r = "slicedToArray") : r = "toArray", i && (a.unshift(
    this.path.hub.addHelper(r)), r = "maybeArrayLike"), pV(this.path.hub.addHelper(r), a);
  }, "toArray"), To.prototype.getAllBindingsOfKind = /* @__PURE__ */ n(function(...e) {
    let s = /* @__PURE__ */ Object.create(null);
    for (let i of e) {
      let r = this;
      do {
        for (let a of Object.keys(r.bindings)) {
          let o = r.bindings[a];
          o.kind === i && (s[a] = o);
        }
        r = r.parent;
      } while (r);
    }
    return s;
  }, "getAllBindingsOfKind"), Object.defineProperties(To.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  });
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var AV = g((Cx, EV) => {
  (function(t, e) {
    typeof Cx == "object" && typeof EV < "u" ? e(Cx) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.setArray = {}));
  })(Cx, function(t) {
    "use strict";
    class e {
      static {
        n(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function s(l) {
      return l;
    }
    n(s, "cast");
    function i(l, u) {
      return l._indexes[u];
    }
    n(i, "get");
    function r(l, u) {
      let c = i(l, u);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: h } = l, f = p.push(u);
      return h[u] = f - 1;
    }
    n(r, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let p = u.pop();
      c[p] = void 0;
    }
    n(a, "pop");
    function o(l, u) {
      let c = i(l, u);
      if (c === void 0)
        return;
      let { array: p, _indexes: h } = l;
      for (let f = c + 1; f < p.length; f++) {
        let d = p[f];
        p[f - 1] = d, h[d]--;
      }
      h[u] = void 0, p.pop();
    }
    n(o, "remove"), t.SetArray = e, t.get = i, t.pop = a, t.put = r, t.remove = o, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var RN = g((wx, vV) => {
  (function(t, e) {
    typeof wx == "object" && typeof vV < "u" ? e(wx) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.sourcemapCodec = {}));
  })(wx, function(t) {
    "use strict";
    let i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = new Uint8Array(64), a = new Uint8Array(128);
    for (let ye = 0; ye < i.length; ye++) {
      let ge = i.charCodeAt(ye);
      r[ye] = ge, a[ge] = ye;
    }
    function o(ye, ge) {
      let oe = 0, Ae = 0, xt = 0;
      do {
        let Oe = ye.next();
        xt = a[Oe], oe |= (xt & 31) << Ae, Ae += 5;
      } while (xt & 32);
      let kt = oe & 1;
      return oe >>>= 1, kt && (oe = -2147483648 | -oe), ge + oe;
    }
    n(o, "decodeInteger");
    function l(ye, ge, oe) {
      let Ae = ge - oe;
      Ae = Ae < 0 ? -Ae << 1 | 1 : Ae << 1;
      do {
        let xt = Ae & 31;
        Ae >>>= 5, Ae > 0 && (xt |= 32), ye.write(r[xt]);
      } while (Ae > 0);
      return ge;
    }
    n(l, "encodeInteger");
    function u(ye, ge) {
      return ye.pos >= ge ? !1 : ye.peek() !== 44;
    }
    n(u, "hasMoreVlq");
    let c = 1024 * 16, p = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(ye) {
        return Buffer.from(ye.buffer, ye.byteOffset, ye.byteLength).toString();
      }
    } : {
      decode(ye) {
        let ge = "";
        for (let oe = 0; oe < ye.length; oe++)
          ge += String.fromCharCode(ye[oe]);
        return ge;
      }
    };
    class h {
      static {
        n(this, "StringWriter");
      }
      constructor() {
        this.pos = 0, this.out = "", this.buffer = new Uint8Array(c);
      }
      write(ge) {
        let { buffer: oe } = this;
        oe[this.pos++] = ge, this.pos === c && (this.out += p.decode(oe), this.pos = 0);
      }
      flush() {
        let { buffer: ge, out: oe, pos: Ae } = this;
        return Ae > 0 ? oe + p.decode(ge.subarray(0, Ae)) : oe;
      }
    }
    class f {
      static {
        n(this, "StringReader");
      }
      constructor(ge) {
        this.pos = 0, this.buffer = ge;
      }
      next() {
        return this.buffer.charCodeAt(this.pos++);
      }
      peek() {
        return this.buffer.charCodeAt(this.pos);
      }
      indexOf(ge) {
        let { buffer: oe, pos: Ae } = this, xt = oe.indexOf(ge, Ae);
        return xt === -1 ? oe.length : xt;
      }
    }
    let d = [];
    function y(ye) {
      let { length: ge } = ye, oe = new f(ye), Ae = [], xt = [], kt = 0;
      for (; oe.pos < ge; oe.pos++) {
        kt = o(oe, kt);
        let Oe = o(oe, 0);
        if (!u(oe, ge)) {
          let Ut = xt.pop();
          Ut[2] = kt, Ut[3] = Oe;
          continue;
        }
        let ke = o(oe, 0), Ze = o(oe, 0) & 1 ? [kt, Oe, 0, 0, ke, o(oe, 0)] : [kt, Oe, 0, 0, ke], Nt = d;
        if (u(oe, ge)) {
          Nt = [];
          do {
            let Ut = o(oe, 0);
            Nt.push(Ut);
          } while (u(oe, ge));
        }
        Ze.vars = Nt, Ae.push(Ze), xt.push(Ze);
      }
      return Ae;
    }
    n(y, "decodeOriginalScopes");
    function m(ye) {
      let ge = new h();
      for (let oe = 0; oe < ye.length; )
        oe = T(ye, oe, ge, [0]);
      return ge.flush();
    }
    n(m, "encodeOriginalScopes");
    function T(ye, ge, oe, Ae) {
      let xt = ye[ge], { 0: kt, 1: Oe, 2: ke, 3: qe, 4: Qe, vars: Ze } = xt;
      ge > 0 && oe.write(44), Ae[0] = l(oe, kt, Ae[0]), l(oe, Oe, 0), l(oe, Qe, 0);
      let Nt = xt.length === 6 ? 1 : 0;
      l(oe, Nt, 0), xt.length === 6 && l(oe, xt[5], 0);
      for (let Ut of Ze)
        l(oe, Ut, 0);
      for (ge++; ge < ye.length; ) {
        let Ut = ye[ge], { 0: St, 1: gt } = Ut;
        if (St > ke || St === ke && gt >= qe)
          break;
        ge = T(ye, ge, oe, Ae);
      }
      return oe.write(44), Ae[0] = l(oe, ke, Ae[0]), l(oe, qe, 0), ge;
    }
    n(T, "_encodeOriginalScopes");
    function b(ye) {
      let { length: ge } = ye, oe = new f(ye), Ae = [], xt = [], kt = 0, Oe = 0, ke = 0, qe = 0, Qe = 0, Ze = 0, Nt = 0, Ut = 0;
      do {
        let St = oe.indexOf(";"), gt = 0;
        for (; oe.pos < St; oe.pos++) {
          if (gt = o(oe, gt), !u(oe, St)) {
            let Yi = xt.pop();
            Yi[2] = kt, Yi[3] = gt;
            continue;
          }
          let Yt = o(oe, 0), ki = Yt & 1, Pi = Yt & 2, Tr = Yt & 4, aa = null, en = d, Dr;
          if (ki) {
            let Yi = o(oe, Oe);
            ke = o(oe, Oe === Yi ? ke : 0), Oe = Yi, Dr = [kt, gt, 0, 0, Yi, ke];
          } else
            Dr = [kt, gt, 0, 0];
          if (Dr.isScope = !!Tr, Pi) {
            let Yi = qe, hn = Qe;
            qe = o(oe, qe);
            let oa = Yi === qe;
            Qe = o(oe, oa ? Qe : 0), Ze = o(oe, oa && hn === Qe ? Ze : 0), aa = [qe, Qe, Ze];
          }
          if (Dr.callsite = aa, u(oe, St)) {
            en = [];
            do {
              Nt = kt, Ut = gt;
              let Yi = o(oe, 0), hn;
              if (Yi < -1) {
                hn = [[o(oe, 0)]];
                for (let oa = -1; oa > Yi; oa--) {
                  let Xf = Nt;
                  Nt = o(oe, Nt), Ut = o(oe, Nt === Xf ? Ut : 0);
                  let Ho = o(oe, 0);
                  hn.push([Ho, Nt, Ut]);
                }
              } else
                hn = [[Yi]];
              en.push(hn);
            } while (u(oe, St));
          }
          Dr.bindings = en, Ae.push(Dr), xt.push(Dr);
        }
        kt++, oe.pos = St + 1;
      } while (oe.pos < ge);
      return Ae;
    }
    n(b, "decodeGeneratedRanges");
    function E(ye) {
      if (ye.length === 0)
        return "";
      let ge = new h();
      for (let oe = 0; oe < ye.length; )
        oe = w(ye, oe, ge, [0, 0, 0, 0, 0, 0, 0]);
      return ge.flush();
    }
    n(E, "encodeGeneratedRanges");
    function w(ye, ge, oe, Ae) {
      let xt = ye[ge], { 0: kt, 1: Oe, 2: ke, 3: qe, isScope: Qe, callsite: Ze, bindings: Nt } = xt;
      Ae[0] < kt ? (K(oe, Ae[0], kt), Ae[0] = kt, Ae[1] = 0) : ge > 0 && oe.write(44), Ae[1] = l(oe, xt[1], Ae[1]);
      let Ut = (xt.length === 6 ? 1 : 0) | (Ze ? 2 : 0) | (Qe ? 4 : 0);
      if (l(oe, Ut, 0), xt.length === 6) {
        let { 4: St, 5: gt } = xt;
        St !== Ae[2] && (Ae[3] = 0), Ae[2] = l(oe, St, Ae[2]), Ae[3] = l(oe, gt, Ae[3]);
      }
      if (Ze) {
        let { 0: St, 1: gt, 2: Yt } = xt.callsite;
        St !== Ae[4] ? (Ae[5] = 0, Ae[6] = 0) : gt !== Ae[5] && (Ae[6] = 0), Ae[4] = l(oe, St, Ae[4]), Ae[5] = l(oe, gt, Ae[5]), Ae[6] = l(oe,
        Yt, Ae[6]);
      }
      if (Nt)
        for (let St of Nt) {
          St.length > 1 && l(oe, -St.length, 0);
          let gt = St[0][0];
          l(oe, gt, 0);
          let Yt = kt, ki = Oe;
          for (let Pi = 1; Pi < St.length; Pi++) {
            let Tr = St[Pi];
            Yt = l(oe, Tr[1], Yt), ki = l(oe, Tr[2], ki), l(oe, Tr[0], 0);
          }
        }
      for (ge++; ge < ye.length; ) {
        let St = ye[ge], { 0: gt, 1: Yt } = St;
        if (gt > ke || gt === ke && Yt >= qe)
          break;
        ge = w(ye, ge, oe, Ae);
      }
      return Ae[0] < ke ? (K(oe, Ae[0], ke), Ae[0] = ke, Ae[1] = 0) : oe.write(44), Ae[1] = l(oe, qe, Ae[1]), ge;
    }
    n(w, "_encodeGeneratedRanges");
    function K(ye, ge, oe) {
      do
        ye.write(59);
      while (++ge < oe);
    }
    n(K, "catchupLine");
    function he(ye) {
      let { length: ge } = ye, oe = new f(ye), Ae = [], xt = 0, kt = 0, Oe = 0, ke = 0, qe = 0;
      do {
        let Qe = oe.indexOf(";"), Ze = [], Nt = !0, Ut = 0;
        for (xt = 0; oe.pos < Qe; ) {
          let St;
          xt = o(oe, xt), xt < Ut && (Nt = !1), Ut = xt, u(oe, Qe) ? (kt = o(oe, kt), Oe = o(oe, Oe), ke = o(oe, ke), u(oe, Qe) ? (qe = o(oe,
          qe), St = [xt, kt, Oe, ke, qe]) : St = [xt, kt, Oe, ke]) : St = [xt], Ze.push(St), oe.pos++;
        }
        Nt || de(Ze), Ae.push(Ze), oe.pos = Qe + 1;
      } while (oe.pos <= ge);
      return Ae;
    }
    n(he, "decode");
    function de(ye) {
      ye.sort(me);
    }
    n(de, "sort");
    function me(ye, ge) {
      return ye[0] - ge[0];
    }
    n(me, "sortComparator");
    function ve(ye) {
      let ge = new h(), oe = 0, Ae = 0, xt = 0, kt = 0;
      for (let Oe = 0; Oe < ye.length; Oe++) {
        let ke = ye[Oe];
        if (Oe > 0 && ge.write(59), ke.length === 0)
          continue;
        let qe = 0;
        for (let Qe = 0; Qe < ke.length; Qe++) {
          let Ze = ke[Qe];
          Qe > 0 && ge.write(44), qe = l(ge, Ze[0], qe), Ze.length !== 1 && (oe = l(ge, Ze[1], oe), Ae = l(ge, Ze[2], Ae), xt = l(ge, Ze[3],
          xt), Ze.length !== 4 && (kt = l(ge, Ze[4], kt)));
        }
      }
      return ge.flush();
    }
    n(ve, "encode"), t.decode = he, t.decodeGeneratedRanges = b, t.decodeOriginalScopes = y, t.encode = ve, t.encodeGeneratedRanges = E, t.encodeOriginalScopes =
    m, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var CV = g((qN, UN) => {
  (function(t, e) {
    typeof qN == "object" && typeof UN < "u" ? UN.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, t.resolveURI = e());
  })(qN, function() {
    "use strict";
    let t = /^[\w+.-]+:\/\//, e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, s = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var i;
    (function(b) {
      b[b.Empty = 1] = "Empty", b[b.Hash = 2] = "Hash", b[b.Query = 3] = "Query", b[b.RelativePath = 4] = "RelativePath", b[b.AbsolutePath =
      5] = "AbsolutePath", b[b.SchemeRelative = 6] = "SchemeRelative", b[b.Absolute = 7] = "Absolute";
    })(i || (i = {}));
    function r(b) {
      return t.test(b);
    }
    n(r, "isAbsoluteUrl");
    function a(b) {
      return b.startsWith("//");
    }
    n(a, "isSchemeRelativeUrl");
    function o(b) {
      return b.startsWith("/");
    }
    n(o, "isAbsolutePath");
    function l(b) {
      return b.startsWith("file:");
    }
    n(l, "isFileUrl");
    function u(b) {
      return /^[.?#]/.test(b);
    }
    n(u, "isRelative");
    function c(b) {
      let E = e.exec(b);
      return h(E[1], E[2] || "", E[3], E[4] || "", E[5] || "/", E[6] || "", E[7] || "");
    }
    n(c, "parseAbsoluteUrl");
    function p(b) {
      let E = s.exec(b), w = E[2];
      return h("file:", "", E[1] || "", "", o(w) ? w : "/" + w, E[3] || "", E[4] || "");
    }
    n(p, "parseFileUrl");
    function h(b, E, w, K, he, de, me) {
      return {
        scheme: b,
        user: E,
        host: w,
        port: K,
        path: he,
        query: de,
        hash: me,
        type: i.Absolute
      };
    }
    n(h, "makeUrl");
    function f(b) {
      if (a(b)) {
        let w = c("http:" + b);
        return w.scheme = "", w.type = i.SchemeRelative, w;
      }
      if (o(b)) {
        let w = c("http://foo.com" + b);
        return w.scheme = "", w.host = "", w.type = i.AbsolutePath, w;
      }
      if (l(b))
        return p(b);
      if (r(b))
        return c(b);
      let E = c("http://foo.com/" + b);
      return E.scheme = "", E.host = "", E.type = b ? b.startsWith("?") ? i.Query : b.startsWith("#") ? i.Hash : i.RelativePath : i.Empty, E;
    }
    n(f, "parseUrl");
    function d(b) {
      if (b.endsWith("/.."))
        return b;
      let E = b.lastIndexOf("/");
      return b.slice(0, E + 1);
    }
    n(d, "stripPathFilename");
    function y(b, E) {
      m(E, E.type), b.path === "/" ? b.path = E.path : b.path = d(E.path) + b.path;
    }
    n(y, "mergePaths");
    function m(b, E) {
      let w = E <= i.RelativePath, K = b.path.split("/"), he = 1, de = 0, me = !1;
      for (let ye = 1; ye < K.length; ye++) {
        let ge = K[ye];
        if (!ge) {
          me = !0;
          continue;
        }
        if (me = !1, ge !== ".") {
          if (ge === "..") {
            de ? (me = !0, de--, he--) : w && (K[he++] = ge);
            continue;
          }
          K[he++] = ge, de++;
        }
      }
      let ve = "";
      for (let ye = 1; ye < he; ye++)
        ve += "/" + K[ye];
      (!ve || me && !ve.endsWith("/..")) && (ve += "/"), b.path = ve;
    }
    n(m, "normalizePath");
    function T(b, E) {
      if (!b && !E)
        return "";
      let w = f(b), K = w.type;
      if (E && K !== i.Absolute) {
        let de = f(E), me = de.type;
        switch (K) {
          case i.Empty:
            w.hash = de.hash;
          // fall through
          case i.Hash:
            w.query = de.query;
          // fall through
          case i.Query:
          case i.RelativePath:
            y(w, de);
          // fall through
          case i.AbsolutePath:
            w.user = de.user, w.host = de.host, w.port = de.port;
          // fall through
          case i.SchemeRelative:
            w.scheme = de.scheme;
        }
        me > K && (K = me);
      }
      m(w, K);
      let he = w.query + w.hash;
      switch (K) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case i.Hash:
        case i.Query:
          return he;
        case i.RelativePath: {
          let de = w.path.slice(1);
          return de ? u(E || b) && !u(de) ? "./" + de + he : de + he : he || ".";
        }
        case i.AbsolutePath:
          return w.path + he;
        default:
          return w.scheme + "//" + w.user + w.host + w.port + w.path + he;
      }
    }
    return n(T, "resolve"), T;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Nc = g((Ix, wV) => {
  (function(t, e) {
    typeof Ix == "object" && typeof wV < "u" ? e(Ix, RN(), CV()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, e(t.traceMapping = {}, t.sourcemapCodec,
    t.resolveURI));
  })(Ix, function(t, e, s) {
    "use strict";
    function i(pe, be) {
      return be && !be.endsWith("/") && (be += "/"), s(pe, be);
    }
    n(i, "resolve");
    function r(pe) {
      if (!pe)
        return "";
      let be = pe.lastIndexOf("/");
      return pe.slice(0, be + 1);
    }
    n(r, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, p = 1, h = 2;
    function f(pe, be) {
      let Ne = d(pe, 0);
      if (Ne === pe.length)
        return pe;
      be || (pe = pe.slice());
      for (let De = Ne; De < pe.length; De = d(pe, De + 1))
        pe[De] = m(pe[De], be);
      return pe;
    }
    n(f, "maybeSort");
    function d(pe, be) {
      for (let Ne = be; Ne < pe.length; Ne++)
        if (!y(pe[Ne]))
          return Ne;
      return pe.length;
    }
    n(d, "nextUnsortedSegmentLine");
    function y(pe) {
      for (let be = 1; be < pe.length; be++)
        if (pe[be][a] < pe[be - 1][a])
          return !1;
      return !0;
    }
    n(y, "isSorted");
    function m(pe, be) {
      return be || (pe = pe.slice()), pe.sort(T);
    }
    n(m, "sortSegments");
    function T(pe, be) {
      return pe[a] - be[a];
    }
    n(T, "sortComparator");
    let b = !1;
    function E(pe, be, Ne, De) {
      for (; Ne <= De; ) {
        let Tt = Ne + (De - Ne >> 1), tt = pe[Tt][a] - be;
        if (tt === 0)
          return b = !0, Tt;
        tt < 0 ? Ne = Tt + 1 : De = Tt - 1;
      }
      return b = !1, Ne - 1;
    }
    n(E, "binarySearch");
    function w(pe, be, Ne) {
      for (let De = Ne + 1; De < pe.length && pe[De][a] === be; Ne = De++)
        ;
      return Ne;
    }
    n(w, "upperBound");
    function K(pe, be, Ne) {
      for (let De = Ne - 1; De >= 0 && pe[De][a] === be; Ne = De--)
        ;
      return Ne;
    }
    n(K, "lowerBound");
    function he() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    n(he, "memoizedState");
    function de(pe, be, Ne, De) {
      let { lastKey: Tt, lastNeedle: tt, lastIndex: Kt } = Ne, js = 0, Vt = pe.length - 1;
      if (De === Tt) {
        if (be === tt)
          return b = Kt !== -1 && pe[Kt][a] === be, Kt;
        be >= tt ? js = Kt === -1 ? 0 : Kt : Vt = Kt;
      }
      return Ne.lastKey = De, Ne.lastNeedle = be, Ne.lastIndex = E(pe, be, js, Vt);
    }
    n(de, "memoizedBinarySearch");
    function me(pe, be) {
      let Ne = be.map(ye);
      for (let De = 0; De < pe.length; De++) {
        let Tt = pe[De];
        for (let tt = 0; tt < Tt.length; tt++) {
          let Kt = Tt[tt];
          if (Kt.length === 1)
            continue;
          let js = Kt[o], Vt = Kt[l], Xt = Kt[u], Ai = Ne[js], Rs = Ai[Vt] || (Ai[Vt] = []), qs = be[js], Nr = w(Rs, Xt, de(Rs, Xt, qs, Vt));
          qs.lastIndex = ++Nr, ve(Rs, Nr, [Xt, De, Kt[a]]);
        }
      }
      return Ne;
    }
    n(me, "buildBySources");
    function ve(pe, be, Ne) {
      for (let De = pe.length; De > be; De--)
        pe[De] = pe[De - 1];
      pe[be] = Ne;
    }
    n(ve, "insert");
    function ye() {
      return { __proto__: null };
    }
    n(ye, "buildNullArray");
    let ge = /* @__PURE__ */ n(function(pe, be) {
      let Ne = oe(pe);
      if (!("sections" in Ne))
        return new Nt(Ne, be);
      let De = [], Tt = [], tt = [], Kt = [], js = [];
      Ae(Ne, be, De, Tt, tt, Kt, js, 0, 0, 1 / 0, 1 / 0);
      let Vt = {
        version: 3,
        file: Ne.file,
        names: Kt,
        sources: Tt,
        sourcesContent: tt,
        mappings: De,
        ignoreList: js
      };
      return hn(Vt);
    }, "AnyMap");
    function oe(pe) {
      return typeof pe == "string" ? JSON.parse(pe) : pe;
    }
    n(oe, "parse");
    function Ae(pe, be, Ne, De, Tt, tt, Kt, js, Vt, Xt, Ai) {
      let { sections: Rs } = pe;
      for (let qs = 0; qs < Rs.length; qs++) {
        let { map: Nr, offset: xa } = Rs[qs], Rl = Xt, ql = Ai;
        if (qs + 1 < Rs.length) {
          let Ul = Rs[qs + 1].offset;
          Rl = Math.min(Xt, js + Ul.line), Rl === Xt ? ql = Math.min(Ai, Vt + Ul.column) : Rl < Xt && (ql = Vt + Ul.column);
        }
        xt(Nr, be, Ne, De, Tt, tt, Kt, js + xa.line, Vt + xa.column, Rl, ql);
      }
    }
    n(Ae, "recurse");
    function xt(pe, be, Ne, De, Tt, tt, Kt, js, Vt, Xt, Ai) {
      let Rs = oe(pe);
      if ("sections" in Rs)
        return Ae(...arguments);
      let qs = new Nt(Rs, be), Nr = De.length, xa = tt.length, Rl = gt(qs), { resolvedSources: ql, sourcesContent: Ul, ignoreList: zf } = qs;
      if (kt(De, ql), kt(tt, qs.names), Ul)
        kt(Tt, Ul);
      else
        for (let Sa = 0; Sa < ql.length; Sa++)
          Tt.push(null);
      if (zf)
        for (let Sa = 0; Sa < zf.length; Sa++)
          Kt.push(zf[Sa] + Nr);
      for (let Sa = 0; Sa < Rl.length; Sa++) {
        let PC = js + Sa;
        if (PC > Xt)
          return;
        let b7 = Oe(Ne, PC), iTe = Sa === 0 ? Vt : 0, x7 = Rl[Sa];
        for (let EC = 0; EC < x7.length; EC++) {
          let Xp = x7[EC], Cb = iTe + Xp[a];
          if (PC === Xt && Cb >= Ai)
            return;
          if (Xp.length === 1) {
            b7.push([Cb]);
            continue;
          }
          let S7 = Nr + Xp[o], P7 = Xp[l], E7 = Xp[u];
          b7.push(Xp.length === 4 ? [Cb, S7, P7, E7] : [Cb, S7, P7, E7, xa + Xp[c]]);
        }
      }
    }
    n(xt, "addSection");
    function kt(pe, be) {
      for (let Ne = 0; Ne < be.length; Ne++)
        pe.push(be[Ne]);
    }
    n(kt, "append");
    function Oe(pe, be) {
      for (let Ne = pe.length; Ne <= be; Ne++)
        pe[Ne] = [];
      return pe[be];
    }
    n(Oe, "getLine");
    let ke = "`line` must be greater than 0 (lines start at line 1)", qe = "`column` must be greater than or equal to 0 (columns start at co\
lumn 0)", Qe = -1, Ze = 1;
    class Nt {
      static {
        n(this, "TraceMap");
      }
      constructor(be, Ne) {
        let De = typeof be == "string";
        if (!De && be._decodedMemo)
          return be;
        let Tt = De ? JSON.parse(be) : be, { version: tt, file: Kt, names: js, sourceRoot: Vt, sources: Xt, sourcesContent: Ai } = Tt;
        this.version = tt, this.file = Kt, this.names = js || [], this.sourceRoot = Vt, this.sources = Xt, this.sourcesContent = Ai, this.ignoreList =
        Tt.ignoreList || Tt.x_google_ignoreList || void 0;
        let Rs = i(Vt || "", r(Ne));
        this.resolvedSources = Xt.map((Nr) => i(Nr || "", Rs));
        let { mappings: qs } = Tt;
        typeof qs == "string" ? (this._encoded = qs, this._decoded = void 0) : (this._encoded = void 0, this._decoded = f(qs, De)), this._decodedMemo =
        he(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function Ut(pe) {
      return pe;
    }
    n(Ut, "cast");
    function St(pe) {
      var be, Ne;
      return (be = (Ne = pe)._encoded) !== null && be !== void 0 ? be : Ne._encoded = e.encode(pe._decoded);
    }
    n(St, "encodedMappings");
    function gt(pe) {
      var be;
      return (be = pe)._decoded || (be._decoded = e.decode(pe._encoded));
    }
    n(gt, "decodedMappings");
    function Yt(pe, be, Ne) {
      let De = gt(pe);
      if (be >= De.length)
        return null;
      let Tt = De[be], tt = Jt(Tt, pe._decodedMemo, be, Ne, Ze);
      return tt === -1 ? null : Tt[tt];
    }
    n(Yt, "traceSegment");
    function ki(pe, be) {
      let { line: Ne, column: De, bias: Tt } = be;
      if (Ne--, Ne < 0)
        throw new Error(ke);
      if (De < 0)
        throw new Error(qe);
      let tt = gt(pe);
      if (Ne >= tt.length)
        return Je(null, null, null, null);
      let Kt = tt[Ne], js = Jt(Kt, pe._decodedMemo, Ne, De, Tt || Ze);
      if (js === -1)
        return Je(null, null, null, null);
      let Vt = Kt[js];
      if (Vt.length === 1)
        return Je(null, null, null, null);
      let { names: Xt, resolvedSources: Ai } = pe;
      return Je(Ai[Vt[o]], Vt[l] + 1, Vt[u], Vt.length === 5 ? Xt[Vt[c]] : null);
    }
    n(ki, "originalPositionFor");
    function Pi(pe, be) {
      let { source: Ne, line: De, column: Tt, bias: tt } = be;
      return Xi(pe, Ne, De, Tt, tt || Ze, !1);
    }
    n(Pi, "generatedPositionFor");
    function Tr(pe, be) {
      let { source: Ne, line: De, column: Tt, bias: tt } = be;
      return Xi(pe, Ne, De, Tt, tt || Qe, !0);
    }
    n(Tr, "allGeneratedPositionsFor");
    function aa(pe, be) {
      let Ne = gt(pe), { names: De, resolvedSources: Tt } = pe;
      for (let tt = 0; tt < Ne.length; tt++) {
        let Kt = Ne[tt];
        for (let js = 0; js < Kt.length; js++) {
          let Vt = Kt[js], Xt = tt + 1, Ai = Vt[0], Rs = null, qs = null, Nr = null, xa = null;
          Vt.length !== 1 && (Rs = Tt[Vt[1]], qs = Vt[2] + 1, Nr = Vt[3]), Vt.length === 5 && (xa = De[Vt[4]]), be({
            generatedLine: Xt,
            generatedColumn: Ai,
            source: Rs,
            originalLine: qs,
            originalColumn: Nr,
            name: xa
          });
        }
      }
    }
    n(aa, "eachMapping");
    function en(pe, be) {
      let { sources: Ne, resolvedSources: De } = pe, Tt = Ne.indexOf(be);
      return Tt === -1 && (Tt = De.indexOf(be)), Tt;
    }
    n(en, "sourceIndex");
    function Dr(pe, be) {
      let { sourcesContent: Ne } = pe;
      if (Ne == null)
        return null;
      let De = en(pe, be);
      return De === -1 ? null : Ne[De];
    }
    n(Dr, "sourceContentFor");
    function Yi(pe, be) {
      let { ignoreList: Ne } = pe;
      if (Ne == null)
        return !1;
      let De = en(pe, be);
      return De === -1 ? !1 : Ne.includes(De);
    }
    n(Yi, "isIgnored");
    function hn(pe, be) {
      let Ne = new Nt(Ho(pe, []), be);
      return Ne._decoded = pe.mappings, Ne;
    }
    n(hn, "presortedDecodedMap");
    function oa(pe) {
      return Ho(pe, gt(pe));
    }
    n(oa, "decodedMap");
    function Xf(pe) {
      return Ho(pe, St(pe));
    }
    n(Xf, "encodedMap");
    function Ho(pe, be) {
      return {
        version: pe.version,
        file: pe.file,
        names: pe.names,
        sourceRoot: pe.sourceRoot,
        sources: pe.sources,
        sourcesContent: pe.sourcesContent,
        mappings: be,
        ignoreList: pe.ignoreList || pe.x_google_ignoreList
      };
    }
    n(Ho, "clone");
    function Je(pe, be, Ne, De) {
      return { source: pe, line: be, column: Ne, name: De };
    }
    n(Je, "OMapping");
    function _e(pe, be) {
      return { line: pe, column: be };
    }
    n(_e, "GMapping");
    function Jt(pe, be, Ne, De, Tt) {
      let tt = de(pe, De, be, Ne);
      return b ? tt = (Tt === Qe ? w : K)(pe, De, tt) : Tt === Qe && tt++, tt === -1 || tt === pe.length ? -1 : tt;
    }
    n(Jt, "traceSegmentInternal");
    function bi(pe, be, Ne, De, Tt) {
      let tt = Jt(pe, be, Ne, De, Ze);
      if (!b && Tt === Qe && tt++, tt === -1 || tt === pe.length)
        return [];
      let Kt = b ? De : pe[tt][a];
      b || (tt = K(pe, Kt, tt));
      let js = w(pe, Kt, tt), Vt = [];
      for (; tt <= js; tt++) {
        let Xt = pe[tt];
        Vt.push(_e(Xt[p] + 1, Xt[h]));
      }
      return Vt;
    }
    n(bi, "sliceGeneratedPositions");
    function Xi(pe, be, Ne, De, Tt, tt) {
      var Kt;
      if (Ne--, Ne < 0)
        throw new Error(ke);
      if (De < 0)
        throw new Error(qe);
      let { sources: js, resolvedSources: Vt } = pe, Xt = js.indexOf(be);
      if (Xt === -1 && (Xt = Vt.indexOf(be)), Xt === -1)
        return tt ? [] : _e(null, null);
      let Rs = ((Kt = pe)._bySources || (Kt._bySources = me(gt(pe), pe._bySourceMemos = js.map(he))))[Xt][Ne];
      if (Rs == null)
        return tt ? [] : _e(null, null);
      let qs = pe._bySourceMemos[Xt];
      if (tt)
        return bi(Rs, qs, Ne, De, Tt);
      let Nr = Jt(Rs, qs, Ne, De, Tt);
      if (Nr === -1)
        return _e(null, null);
      let xa = Rs[Nr];
      return _e(xa[p] + 1, xa[h]);
    }
    n(Xi, "generatedPosition"), t.AnyMap = ge, t.GREATEST_LOWER_BOUND = Ze, t.LEAST_UPPER_BOUND = Qe, t.TraceMap = Nt, t.allGeneratedPositionsFor =
    Tr, t.decodedMap = oa, t.decodedMappings = gt, t.eachMapping = aa, t.encodedMap = Xf, t.encodedMappings = St, t.generatedPositionFor = Pi,
    t.isIgnored = Yi, t.originalPositionFor = ki, t.presortedDecodedMap = hn, t.sourceContentFor = Dr, t.traceSegment = Yt;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var ch = g((Nx, IV) => {
  (function(t, e) {
    typeof Nx == "object" && typeof IV < "u" ? e(Nx, AV(), RN(), Nc()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self,
    e(t.genMapping = {}, t.setArray, t.sourcemapCodec, t.traceMapping));
  })(Nx, function(t, e, s, i) {
    "use strict";
    class p {
      static {
        n(this, "GenMapping");
      }
      constructor({ file: ke, sourceRoot: qe } = {}) {
        this._names = new e.SetArray(), this._sources = new e.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = ke, this.
        sourceRoot = qe, this._ignoreList = new e.SetArray();
      }
    }
    function h(Oe) {
      return Oe;
    }
    n(h, "cast");
    function f(Oe, ke, qe, Qe, Ze, Nt, Ut, St) {
      return de(!1, Oe, ke, qe, Qe, Ze, Nt, Ut, St);
    }
    n(f, "addSegment");
    function d(Oe, ke) {
      return kt(!1, Oe, ke);
    }
    n(d, "addMapping");
    let y = /* @__PURE__ */ n((Oe, ke, qe, Qe, Ze, Nt, Ut, St) => de(!0, Oe, ke, qe, Qe, Ze, Nt, Ut, St), "maybeAddSegment"), m = /* @__PURE__ */ n(
    (Oe, ke) => kt(!0, Oe, ke), "maybeAddMapping");
    function T(Oe, ke, qe) {
      let { _sources: Qe, _sourcesContent: Ze } = Oe, Nt = e.put(Qe, ke);
      Ze[Nt] = qe;
    }
    n(T, "setSourceContent");
    function b(Oe, ke, qe = !0) {
      let { _sources: Qe, _sourcesContent: Ze, _ignoreList: Nt } = Oe, Ut = e.put(Qe, ke);
      Ut === Ze.length && (Ze[Ut] = null), qe ? e.put(Nt, Ut) : e.remove(Nt, Ut);
    }
    n(b, "setIgnore");
    function E(Oe) {
      let { _mappings: ke, _sources: qe, _sourcesContent: Qe, _names: Ze, _ignoreList: Nt } = Oe;
      return ge(ke), {
        version: 3,
        file: Oe.file || void 0,
        names: Ze.array,
        sourceRoot: Oe.sourceRoot || void 0,
        sources: qe.array,
        sourcesContent: Qe,
        mappings: ke,
        ignoreList: Nt.array
      };
    }
    n(E, "toDecodedMap");
    function w(Oe) {
      let ke = E(Oe);
      return Object.assign(Object.assign({}, ke), { mappings: s.encode(ke.mappings) });
    }
    n(w, "toEncodedMap");
    function K(Oe) {
      let ke = new i.TraceMap(Oe), qe = new p({ file: ke.file, sourceRoot: ke.sourceRoot });
      return oe(qe._names, ke.names), oe(qe._sources, ke.sources), qe._sourcesContent = ke.sourcesContent || ke.sources.map(() => null), qe.
      _mappings = i.decodedMappings(ke), ke.ignoreList && oe(qe._ignoreList, ke.ignoreList), qe;
    }
    n(K, "fromMap");
    function he(Oe) {
      let ke = [], { _mappings: qe, _sources: Qe, _names: Ze } = Oe;
      for (let Nt = 0; Nt < qe.length; Nt++) {
        let Ut = qe[Nt];
        for (let St = 0; St < Ut.length; St++) {
          let gt = Ut[St], Yt = { line: Nt + 1, column: gt[0] }, ki, Pi, Tr;
          gt.length !== 1 && (ki = Qe.array[gt[1]], Pi = { line: gt[2] + 1, column: gt[3] }, gt.length === 5 && (Tr = Ze.array[gt[4]])), ke.
          push({ generated: Yt, source: ki, original: Pi, name: Tr });
        }
      }
      return ke;
    }
    n(he, "allMappings");
    function de(Oe, ke, qe, Qe, Ze, Nt, Ut, St, gt) {
      let { _mappings: Yt, _sources: ki, _sourcesContent: Pi, _names: Tr } = ke, aa = me(Yt, qe), en = ve(aa, Qe);
      if (!Ze)
        return Oe && Ae(aa, en) ? void 0 : ye(aa, en, [Qe]);
      let Dr = e.put(ki, Ze), Yi = St ? e.put(Tr, St) : -1;
      if (Dr === Pi.length && (Pi[Dr] = gt ?? null), !(Oe && xt(aa, en, Dr, Nt, Ut, Yi)))
        return ye(aa, en, St ? [Qe, Dr, Nt, Ut, Yi] : [Qe, Dr, Nt, Ut]);
    }
    n(de, "addSegmentInternal");
    function me(Oe, ke) {
      for (let qe = Oe.length; qe <= ke; qe++)
        Oe[qe] = [];
      return Oe[ke];
    }
    n(me, "getLine");
    function ve(Oe, ke) {
      let qe = Oe.length;
      for (let Qe = qe - 1; Qe >= 0; qe = Qe--) {
        let Ze = Oe[Qe];
        if (ke >= Ze[0])
          break;
      }
      return qe;
    }
    n(ve, "getColumnIndex");
    function ye(Oe, ke, qe) {
      for (let Qe = Oe.length; Qe > ke; Qe--)
        Oe[Qe] = Oe[Qe - 1];
      Oe[ke] = qe;
    }
    n(ye, "insert");
    function ge(Oe) {
      let { length: ke } = Oe, qe = ke;
      for (let Qe = qe - 1; Qe >= 0 && !(Oe[Qe].length > 0); qe = Qe, Qe--)
        ;
      qe < ke && (Oe.length = qe);
    }
    n(ge, "removeEmptyFinalLines");
    function oe(Oe, ke) {
      for (let qe = 0; qe < ke.length; qe++)
        e.put(Oe, ke[qe]);
    }
    n(oe, "putAll");
    function Ae(Oe, ke) {
      return ke === 0 ? !0 : Oe[ke - 1].length === 1;
    }
    n(Ae, "skipSourceless");
    function xt(Oe, ke, qe, Qe, Ze, Nt) {
      if (ke === 0)
        return !1;
      let Ut = Oe[ke - 1];
      return Ut.length === 1 ? !1 : qe === Ut[1] && Qe === Ut[2] && Ze === Ut[3] && Nt === (Ut.length === 5 ? Ut[4] : -1);
    }
    n(xt, "skipSource");
    function kt(Oe, ke, qe) {
      let { generated: Qe, source: Ze, original: Nt, name: Ut, content: St } = qe;
      return Ze ? de(Oe, ke, Qe.line - 1, Qe.column, Ze, Nt.line - 1, Nt.column, Ut, St) : de(Oe, ke, Qe.line - 1, Qe.column, null, null, null,
      null, null);
    }
    n(kt, "addMappingInternal"), t.GenMapping = p, t.addMapping = d, t.addSegment = f, t.allMappings = he, t.fromMap = K, t.maybeAddMapping =
    m, t.maybeAddSegment = y, t.setIgnore = b, t.setSourceContent = T, t.toDecodedMap = E, t.toEncodedMap = w, Object.defineProperty(t, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/source-map.js
var NV = g((kx) => {
  "use strict";
  Object.defineProperty(kx, "__esModule", {
    value: !0
  });
  kx.default = void 0;
  var kc = ch(), KN = Nc(), VN = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, s) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let r = this._map = new kc.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new KN.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, kc.setSourceContent)(r, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof s == "string" && !e.inputSourceMap)
        (0, kc.setSourceContent)(r, this._sourceFileName, s);
      else if (typeof s == "object")
        for (let o of Object.keys(s))
          (0, kc.setSourceContent)(r, o.replace(/\\/g, "/"), s[o]);
    }
    get() {
      return (0, kc.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, kc.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, kc.allMappings)(this._map));
    }
    mark(e, s, i, r, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (s != null)
        if (this._inputMap) {
          if (u = (0, KN.originalPositionFor)(this._inputMap, {
            line: s,
            column: i
          }), !u.name && a) {
            let c = (0, KN.originalPositionFor)(this._inputMap, a);
            c.name && (r = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: s,
            column: i
          };
      (0, kc.maybeAddMapping)(this._map, {
        name: r,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  kx.default = VN;
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/buffer.js
var kV = g((Dx) => {
  "use strict";
  Object.defineProperty(Dx, "__esModule", {
    value: !0
  });
  Dx.default = void 0;
  var WN = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, s) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = s;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(s.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let s = 0; s < 16; s++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, s, i, r, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = s, l.line = i, l.column = r, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, s = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = e ? e.get() : null;
          return s.map = i, i;
        },
        set map(i) {
          Object.defineProperty(s, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = e?.getRawMappings();
          return s.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(s, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return s;
    }
    append(e, s) {
      this._flush(), this._append(e, this._sourcePosition, s);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let s = this._sourcePosition;
      this._pushQueue(e, 1, s.line, s.column, s.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, s = this._queue;
      for (let i = 0; i < e; i++) {
        let r = s[i];
        this._appendChar(r.char, r.repeat, r);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, s, i) {
      if (this._last = e, e === -1) {
        let r = this._fastIndentations[s];
        r !== void 0 ? this._str += r : this._str += s > 1 ? this._indentChar.repeat(s) : this._indentChar;
      } else
        this._str += s > 1 ? String.fromCharCode(e).repeat(s) : String.fromCharCode(e);
      e !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += s) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(e, s, i) {
      let r = e.length, a = this._position;
      if (this._last = e.charCodeAt(r - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !i && !this._map) {
        a.column += r;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = s, p = s.line;
      (l != null || u != null) && this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
      let h = e.indexOf(`
`), f = 0;
      for (h !== 0 && this._mark(p, o, l, u, c); h !== -1; )
        a.line++, a.column = 0, f = h + 1, f < r && p !== void 0 && this._mark(++p, 0, null, null, c), h = e.indexOf(`
`, f);
      a.column += r - f;
    }
    _mark(e, s, i, r, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, s, i, r, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, s = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let i = e - 1; i >= 0 && this._queue[i].char === 10; i--)
        s++;
      return s === e && this._last === 10 ? s + 1 : s;
    }
    endsWithCharAndNewline() {
      let e = this._queue, s = this._queueCursor;
      if (s !== 0)
        return e[s - 1].char !== 10 ? void 0 : s > 1 ? e[s - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, s) {
      if (!this._map) {
        s();
        return;
      }
      this.source("start", e);
      let i = e.identifierName, r = this._sourcePosition;
      i && (this._canMarkIdName = !1, r.identifierName = i), s(), i && (this._canMarkIdName = !0, r.identifierName = void 0, r.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, s) {
      this._map && this._normalizePosition(e, s, 0);
    }
    sourceWithOffset(e, s, i) {
      this._map && this._normalizePosition(e, s, i);
    }
    _normalizePosition(e, s, i) {
      let r = s[e], a = this._sourcePosition;
      r && (a.line = r.line, a.column = Math.max(r.column + i, 0), a.filename = s.filename);
    }
    getCurrentColumn() {
      let e = this._queue, s = this._queueCursor, i = -1, r = 0;
      for (let a = 0; a < s; a++) {
        let o = e[a];
        o.char === 10 && (i = r), r += o.repeat;
      }
      return i === -1 ? this._position.column + r : r - 1 - i;
    }
    getCurrentLine() {
      let e = 0, s = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        s[i].char === 10 && e++;
      return this._position.line + e;
    }
  };
  Dx.default = WN;
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/node/whitespace.js
var BV = g((_x) => {
  "use strict";
  Object.defineProperty(_x, "__esModule", {
    value: !0
  });
  _x.nodes = void 0;
  var dje = fe(), {
    FLIPPED_ALIAS_KEYS: mje,
    isArrayExpression: yje,
    isAssignmentExpression: OV,
    isBinary: _V,
    isBlockStatement: gje,
    isCallExpression: LV,
    isFunction: dg,
    isIdentifier: Ox,
    isLiteral: Tje,
    isMemberExpression: $N,
    isObjectExpression: bje,
    isOptionalCallExpression: xje,
    isOptionalMemberExpression: Sje,
    isStringLiteral: Pje
  } = dje;
  function md(t, e) {
    return t && ($N(t) || Sje(t) ? (md(t.object, e), t.computed && md(t.property, e)) : _V(t) || OV(t) ? (md(t.left, e), md(t.right, e)) : LV(
    t) || xje(t) ? (e.hasCall = !0, md(t.callee, e)) : dg(t) ? e.hasFunction = !0 : Ox(t) && (e.hasHelper = e.hasHelper || t.callee && Gl(t.
    callee))), e;
  }
  n(md, "crawlInternal");
  function DV(t) {
    return md(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(DV, "crawl");
  function Gl(t) {
    return t ? $N(t) ? Gl(t.object) || Gl(t.property) : Ox(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : LV(t) ? Gl(t.callee) :
    _V(t) || OV(t) ? Ox(t.left) && Gl(t.left) || Gl(t.right) : !1 : !1;
  }
  n(Gl, "isHelper");
  function Eje(t) {
    return Tje(t) || bje(t) || yje(t) || Ox(t) || $N(t);
  }
  n(Eje, "isType");
  var ph = _x.nodes = {
    AssignmentExpression(t) {
      let e = DV(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (dg(t.left) || dg(t.right))
        return 2;
    },
    Literal(t) {
      if (Pje(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (dg(t.callee) || Gl(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (dg(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let s = t.declarations[e], i = Gl(s.id) && !Eje(s.init);
        if (!i && s.init) {
          let r = DV(s.init);
          i = Gl(s.init) && r.hasCall || r.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(t) {
      if (gje(t.consequent))
        return 3;
    }
  };
  ph.ObjectProperty = ph.ObjectTypeProperty = ph.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  ph.ObjectTypeCallProperty = function(t, e) {
    var s;
    if (e.callProperties[0] === t && !((s = e.properties) != null && s.length))
      return 1;
  };
  ph.ObjectTypeIndexer = function(t, e) {
    var s, i;
    if (e.indexers[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length))
      return 1;
  };
  ph.ObjectTypeInternalSlot = function(t, e) {
    var s, i, r;
    if (e.internalSlots[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length) && !((r = e.indexers) !=
    null && r.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(mje[t] || []).forEach(function(s) {
      let i = e ? 3 : 0;
      ph[s] = () => i;
    });
  });
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/node/parentheses.js
var VV = g((bs) => {
  "use strict";
  Object.defineProperty(bs, "__esModule", {
    value: !0
  });
  bs.AssignmentExpression = t8e;
  bs.Binary = qV;
  bs.BinaryExpression = Xje;
  bs.ClassExpression = Qje;
  bs.ArrowFunctionExpression = bs.ConditionalExpression = KV;
  bs.DoExpression = jje;
  bs.FunctionExpression = Zje;
  bs.FunctionTypeAnnotation = Bje;
  bs.Identifier = i8e;
  bs.LogicalExpression = s8e;
  bs.NullableTypeAnnotation = Lje;
  bs.ObjectExpression = Fje;
  bs.OptionalIndexedAccessType = qje;
  bs.OptionalCallExpression = bs.OptionalMemberExpression = e8e;
  bs.SequenceExpression = zje;
  bs.TSSatisfiesExpression = bs.TSAsExpression = Uje;
  bs.TSConditionalType = Kje;
  bs.TSConstructorType = bs.TSFunctionType = Yje;
  bs.TSInferType = $je;
  bs.TSInstantiationExpression = Jje;
  bs.TSIntersectionType = Wje;
  bs.UnaryLike = bs.TSTypeAssertion = UV;
  bs.TSTypeOperator = Hje;
  bs.TSUnionType = Vje;
  bs.IntersectionTypeAnnotation = bs.UnionTypeAnnotation = Rje;
  bs.UpdateExpression = Mje;
  bs.AwaitExpression = bs.YieldExpression = Gje;
  var Aje = fe(), wa = Dc(), {
    isArrayTypeAnnotation: vje,
    isBinaryExpression: Cje,
    isCallExpression: wje,
    isForOfStatement: Ije,
    isIndexedAccessType: Nje,
    isMemberExpression: jV,
    isObjectPattern: kje,
    isOptionalMemberExpression: Dje,
    isYieldExpression: Oje,
    isStatement: _je
  } = Aje, MV = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["\
!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function FV(t, e) {
    if (e === "BinaryExpression" || e === "LogicalExpression")
      return MV.get(t.operator);
    if (e === "TSAsExpression" || e === "TSSatisfiesExpression")
      return MV.get("in");
  }
  n(FV, "getBinaryPrecedence");
  function HN(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(HN, "isTSTypeExpression");
  var Lx = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "ClassDeclaration" || s === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), Bx = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "MemberExpression" || s === "OptionalMemberExpression") && e.object === t || (s === "CallExpression" || s === "OptionalCal\
lExpression" || s === "NewExpression") && e.callee === t || s === "TaggedTemplateExpression" && e.tag === t || s === "TSNonNullExpression";
  }, "hasPostfixPart");
  function Lje(t, e) {
    return vje(e);
  }
  n(Lje, "NullableTypeAnnotation");
  function Bje(t, e, s) {
    let i = e.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(s & wa.TokenContext.arrowFlowReturnType);
  }
  n(Bje, "FunctionTypeAnnotation");
  function Mje(t, e) {
    return Bx(t, e) || Lx(t, e);
  }
  n(Mje, "UpdateExpression");
  function RV(t) {
    return !!(t & (wa.TokenContext.expressionStatement | wa.TokenContext.arrowBody));
  }
  n(RV, "needsParenBeforeExpressionBrace");
  function Fje(t, e, s) {
    return RV(s);
  }
  n(Fje, "ObjectExpression");
  function jje(t, e, s) {
    return !t.async && !!(s & wa.TokenContext.expressionStatement);
  }
  n(jje, "DoExpression");
  function qV(t, e) {
    let s = e.type;
    if (t.type === "BinaryExpression" && t.operator === "**" && s === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (Lx(t, e) || Bx(t, e) || s === "UnaryExpression" || s === "SpreadElement" || s === "AwaitExpression")
      return !0;
    let i = FV(e, s);
    if (i != null) {
      let r = FV(t, t.type);
      if (i === r && s === "BinaryExpression" && e.right === t || i > r)
        return !0;
    }
  }
  n(qV, "Binary");
  function Rje(t, e) {
    let s = e.type;
    return s === "ArrayTypeAnnotation" || s === "NullableTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "UnionTypeAnnotation";
  }
  n(Rje, "UnionTypeAnnotation");
  function qje(t, e) {
    return Nje(e) && e.objectType === t;
  }
  n(qje, "OptionalIndexedAccessType");
  function Uje(t, e) {
    return (e.type === "AssignmentExpression" || e.type === "AssignmentPattern") && e.left === t || e.type === "BinaryExpression" && (e.operator ===
    "|" || e.operator === "&") && t === e.left ? !0 : qV(t, e);
  }
  n(Uje, "TSAsExpression");
  function Kje(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || s === "TSTypeOperator" || s ===
    "TSTypeParameter" || (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t || s === "TSConditionalType" && (e.checkType ===
    t || e.extendsType === t);
  }
  n(Kje, "TSConditionalType");
  function Vje(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t ||
    s === "TSOptionalType";
  }
  n(Vje, "TSUnionType");
  function Wje(t, e) {
    let s = e.type;
    return s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n(Wje, "TSIntersectionType");
  function $je(t, e) {
    let s = e.type;
    return !!(s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || t.typeParameter.constraint &&
    (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t);
  }
  n($je, "TSInferType");
  function Hje(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n(Hje, "TSTypeOperator");
  function Jje(t, e) {
    let s = e.type;
    return (s === "CallExpression" || s === "OptionalCallExpression" || s === "NewExpression" || s === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(Jje, "TSInstantiationExpression");
  function Yje(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSUnionType" || s === "TSTypeOperator" || s === "TSOptionalType" || s === "TSArrayType" || s ===
    "TSIndexedAccessType" && e.objectType === t || s === "TSConditionalType" && (e.checkType === t || e.extendsType === t);
  }
  n(Yje, "TSFunctionType");
  function Xje(t, e, s, i) {
    return t.operator === "in" && i;
  }
  n(Xje, "BinaryExpression");
  function zje(t, e) {
    let s = e.type;
    return s === "SequenceExpression" || s === "ParenthesizedExpression" || s === "MemberExpression" && e.property === t || s === "OptionalM\
emberExpression" && e.property === t || s === "TemplateLiteral" ? !1 : s === "ClassDeclaration" ? !0 : s === "ForOfStatement" ? e.right === t :
    s === "ExportDefaultDeclaration" ? !0 : !_je(e);
  }
  n(zje, "SequenceExpression");
  function Gje(t, e) {
    let s = e.type;
    return s === "BinaryExpression" || s === "LogicalExpression" || s === "UnaryExpression" || s === "SpreadElement" || Bx(t, e) || s === "A\
waitExpression" && Oje(t) || s === "ConditionalExpression" && t === e.test || Lx(t, e) || HN(s);
  }
  n(Gje, "YieldExpression");
  function Qje(t, e, s) {
    return !!(s & (wa.TokenContext.expressionStatement | wa.TokenContext.exportDefault));
  }
  n(Qje, "ClassExpression");
  function UV(t, e) {
    return Bx(t, e) || Cje(e) && e.operator === "**" && e.left === t || Lx(t, e);
  }
  n(UV, "UnaryLike");
  function Zje(t, e, s) {
    return !!(s & (wa.TokenContext.expressionStatement | wa.TokenContext.exportDefault));
  }
  n(Zje, "FunctionExpression");
  function KV(t, e) {
    let s = e.type;
    return s === "UnaryExpression" || s === "SpreadElement" || s === "BinaryExpression" || s === "LogicalExpression" || s === "ConditionalEx\
pression" && e.test === t || s === "AwaitExpression" || HN(s) ? !0 : UV(t, e);
  }
  n(KV, "ConditionalExpression");
  function e8e(t, e) {
    return wje(e) && e.callee === t || jV(e) && e.object === t;
  }
  n(e8e, "OptionalMemberExpression");
  function t8e(t, e, s) {
    return RV(s) && kje(t.left) ? !0 : KV(t, e);
  }
  n(t8e, "AssignmentExpression");
  function s8e(t, e) {
    let s = e.type;
    if (HN(s)) return !0;
    if (s !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(s8e, "LogicalExpression");
  function i8e(t, e, s, i, r) {
    var a;
    let o = e.type;
    if ((a = t.extra) != null && a.parenthesized && o === "AssignmentExpression" && e.left === t) {
      let l = e.right.type;
      if ((l === "FunctionExpression" || l === "ClassExpression") && e.right.id == null)
        return !0;
    }
    return r && r(t) !== t.name ? !1 : t.name === "let" ? (jV(e, {
      object: t,
      computed: !0
    }) || Dje(e, {
      object: t,
      computed: !0,
      optional: !1
    })) && s & (wa.TokenContext.expressionStatement | wa.TokenContext.forHead | wa.TokenContext.forInHead) ? !0 : !!(s & wa.TokenContext.forOfHead) :
    t.name === "async" && Ije(e, {
      left: t,
      await: !1
    });
  }
  n(i8e, "Identifier");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/node/index.js
var Dc = g((Ql) => {
  "use strict";
  Object.defineProperty(Ql, "__esModule", {
    value: !0
  });
  Ql.TokenContext = void 0;
  Ql.isLastChild = b8e;
  Ql.needsParens = T8e;
  Ql.needsWhitespace = YN;
  Ql.needsWhitespaceAfter = g8e;
  Ql.needsWhitespaceBefore = y8e;
  var r8e = BV(), n8e = VV(), a8e = fe(), {
    FLIPPED_ALIAS_KEYS: o8e,
    VISITOR_KEYS: l8e,
    isCallExpression: WV,
    isDecorator: u8e,
    isExpressionStatement: c8e,
    isMemberExpression: p8e,
    isNewExpression: h8e,
    isParenthesizedExpression: f8e
  } = a8e, o9s = Ql.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function $V(t) {
    let e = /* @__PURE__ */ new Map();
    function s(i, r) {
      let a = e.get(i);
      e.set(i, a ? function(o, l, u, c, p) {
        var h;
        return (h = a(o, l, u, c, p)) != null ? h : r(o, l, u, c, p);
      } : r);
    }
    n(s, "add");
    for (let i of Object.keys(t)) {
      let r = o8e[i];
      if (r)
        for (let a of r)
          s(a, t[i]);
      else
        s(i, t[i]);
    }
    return e;
  }
  n($V, "expandAliases");
  var d8e = $V(n8e), m8e = $V(r8e.nodes);
  function HV(t) {
    return WV(t) ? !0 : p8e(t) && HV(t.object);
  }
  n(HV, "isOrHasCallExpression");
  function YN(t, e, s) {
    var i;
    if (!t) return !1;
    c8e(t) && (t = t.expression);
    let r = (i = m8e.get(t.type)) == null ? void 0 : i(t, e);
    return typeof r == "number" ? (r & s) !== 0 : !1;
  }
  n(YN, "needsWhitespace");
  function y8e(t, e) {
    return YN(t, e, 1);
  }
  n(y8e, "needsWhitespaceBefore");
  function g8e(t, e) {
    return YN(t, e, 2);
  }
  n(g8e, "needsWhitespaceAfter");
  function T8e(t, e, s, i, r) {
    var a;
    return e ? h8e(e) && e.callee === t && HV(t) ? !0 : u8e(e) ? !JN(t) && !(WV(t) && JN(t.callee)) && !f8e(t) : (a = d8e.get(t.type)) == null ?
    void 0 : a(t, e, s, i, r) : !1;
  }
  n(T8e, "needsParens");
  function JN(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && JN(t.object);
      default:
        return !1;
    }
  }
  n(JN, "isDecoratorMemberExpression");
  function b8e(t, e) {
    let s = l8e[t.type];
    for (let i = s.length - 1; i >= 0; i--) {
      let r = t[s[i]];
      if (r === e)
        return !0;
      if (Array.isArray(r)) {
        let a = r.length - 1;
        for (; a >= 0 && r[a] === null; ) a--;
        return a >= 0 && r[a] === e;
      } else if (r)
        return !1;
    }
    return !1;
  }
  n(b8e, "isLastChild");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/token-map.js
var JV = g((Mx) => {
  "use strict";
  Object.defineProperty(Mx, "__esModule", {
    value: !0
  });
  Mx.TokenMap = void 0;
  var x8e = fe(), {
    traverseFast: S8e,
    VISITOR_KEYS: P8e
  } = x8e, XN = class {
    static {
      n(this, "TokenMap");
    }
    constructor(e, s, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = s, this._source = i, S8e(e, (r) => {
        let a = this._getTokensIndexesOfNode(r);
        a.length > 0 && this._nodesToTokenIndexes.set(r, a);
      }), this._tokensCache = null;
    }
    has(e) {
      return this._nodesToTokenIndexes.has(e);
    }
    getIndexes(e) {
      return this._nodesToTokenIndexes.get(e);
    }
    find(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = 0; r < i.length; r++) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return o;
        }
      return null;
    }
    findLastIndex(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = i.length - 1; r >= 0; r--) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return a;
        }
      return -1;
    }
    findMatching(e, s, i = 0) {
      let r = this._nodesToTokenIndexes.get(e);
      if (r) {
        let a = 0, o = i;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(e);
          l && l.test === s && l.count < o && (a = l.i + 1, i -= l.count + 1);
        }
        for (; a < r.length; a++) {
          let l = this._tokens[r[a]];
          if (this.matchesOriginal(l, s)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(e, {
                test: s,
                count: o,
                i: a
              }), l;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(e, s) {
      return e.end - e.start !== s.length ? !1 : e.value != null ? e.value === s : this._source.startsWith(s, e.start);
    }
    startMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[0]];
      return r.start !== e.start ? !1 : this.matchesOriginal(r, s);
    }
    endMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[i.length - 1]];
      return r.end !== e.end ? !1 : this.matchesOriginal(r, s);
    }
    _getTokensIndexesOfNode(e) {
      if (e.start == null || e.end == null) return [];
      let {
        first: s,
        last: i
      } = this._findTokensOfNode(e, 0, this._tokens.length - 1), r = s, a = E8e(e);
      (e.type === "ExportNamedDeclaration" || e.type === "ExportDefaultDeclaration") && e.declaration && e.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, r, i), c = u.first;
        for (let p = r; p < c; p++) o.push(p);
        r = u.last + 1;
      }
      for (let l = r; l <= i; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(e, s, i) {
      let r = this._tokensCache.get(e);
      if (r) return r;
      let a = this._findFirstTokenOfNode(e.start, s, i), o = this._findLastTokenOfNode(e.end, a, i);
      return this._tokensCache.set(e, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].start)
          i = r - 1;
        else if (e > this._tokens[r].start)
          s = r + 1;
        else
          return r;
      }
      return s;
    }
    _findLastTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].end)
          i = r - 1;
        else if (e > this._tokens[r].end)
          s = r + 1;
        else
          return r;
      }
      return i;
    }
  };
  Mx.TokenMap = XN;
  function* E8e(t) {
    if (t.type === "TemplateLiteral") {
      yield t.quasis[0];
      for (let s = 1; s < t.quasis.length; s++)
        yield t.expressions[s - 1], yield t.quasis[s];
      return;
    }
    let e = P8e[t.type];
    for (let s of e) {
      let i = t[s];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  n(E8e, "childrenIterator");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/template-literals.js
var YV = g((yd) => {
  "use strict";
  Object.defineProperty(yd, "__esModule", {
    value: !0
  });
  yd.TaggedTemplateExpression = A8e;
  yd.TemplateElement = v8e;
  yd.TemplateLiteral = w8e;
  yd._printTemplate = C8e;
  function A8e(t) {
    this.print(t.tag), this.print(t.typeParameters), this.print(t.quasi);
  }
  n(A8e, "TaggedTemplateExpression");
  function v8e() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(v8e, "TemplateElement");
  function C8e(t, e) {
    let s = t.quasis, i = "`";
    for (let r = 0; r < s.length - 1; r++)
      if (i += s[r].value.raw, this.token(i + "${", !0), this.print(e[r]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(t, "}", r);
        a && this._catchUpTo(a.loc.start);
      }
    i += s[s.length - 1].value.raw, this.token(i + "`", !0);
  }
  n(C8e, "_printTemplate");
  function w8e(t) {
    this._printTemplate(t, t.expressions);
  }
  n(w8e, "TemplateLiteral");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/expressions.js
var zV = g((ui) => {
  "use strict";
  Object.defineProperty(ui, "__esModule", {
    value: !0
  });
  ui.LogicalExpression = ui.BinaryExpression = ui.AssignmentExpression = Z8e;
  ui.AssignmentPattern = Q8e;
  ui.AwaitExpression = Y8e;
  ui.BindExpression = e6e;
  ui.CallExpression = H8e;
  ui.ConditionalExpression = F8e;
  ui.Decorator = V8e;
  ui.DoExpression = L8e;
  ui.EmptyStatement = z8e;
  ui.ExpressionStatement = G8e;
  ui.Import = J8e;
  ui.MemberExpression = t6e;
  ui.MetaProperty = s6e;
  ui.ModuleExpression = n6e;
  ui.NewExpression = j8e;
  ui.OptionalCallExpression = $8e;
  ui.OptionalMemberExpression = W8e;
  ui.ParenthesizedExpression = B8e;
  ui.PrivateName = i6e;
  ui.SequenceExpression = R8e;
  ui.Super = U8e;
  ui.ThisExpression = q8e;
  ui.UnaryExpression = _8e;
  ui.UpdateExpression = M8e;
  ui.V8IntrinsicIdentifier = r6e;
  ui.YieldExpression = X8e;
  ui._shouldPrintDecoratorsBeforeExport = K8e;
  var I8e = fe(), N8e = Dc(), {
    isCallExpression: k8e,
    isLiteral: XV,
    isMemberExpression: zN,
    isNewExpression: D8e,
    isPattern: O8e
  } = I8e;
  function _8e(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument);
  }
  n(_8e, "UnaryExpression");
  function L8e(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body);
  }
  n(L8e, "DoExpression");
  function B8e(t) {
    this.tokenChar(40);
    let e = this.enterDelimited();
    this.print(t.expression), e(), this.rightParens(t);
  }
  n(B8e, "ParenthesizedExpression");
  function M8e(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument)) : (this.print(t.argument, !0), this.token(t.operator));
  }
  n(M8e, "UpdateExpression");
  function F8e(t) {
    this.print(t.test), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(t.alternate);
  }
  n(F8e, "ConditionalExpression");
  function j8e(t, e) {
    if (this.word("new"), this.space(), this.print(t.callee), this.format.minified && t.arguments.length === 0 && !t.optional && !k8e(e, {
      callee: t
    }) && !zN(e) && !D8e(e) || (this.print(t.typeArguments), this.print(t.typeParameters), t.optional && this.token("?."), t.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(t, ")")))
      return;
    this.tokenChar(40);
    let s = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), s(), this.rightParens(t);
  }
  n(j8e, "NewExpression");
  function R8e(t) {
    this.printList(t.expressions);
  }
  n(R8e, "SequenceExpression");
  function q8e() {
    this.word("this");
  }
  n(q8e, "ThisExpression");
  function U8e() {
    this.word("super");
  }
  n(U8e, "Super");
  function K8e(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(K8e, "_shouldPrintDecoratorsBeforeExport");
  function V8e(t) {
    this.tokenChar(64), this.print(t.expression), this.newline();
  }
  n(V8e, "Decorator");
  function W8e(t) {
    let {
      computed: e
    } = t, {
      optional: s,
      property: i
    } = t;
    if (this.print(t.object), !e && zN(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    XV(i) && typeof i.value == "number" && (e = !0), s && this.token("?."), e ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (s ||
    this.tokenChar(46), this.print(i));
  }
  n(W8e, "OptionalMemberExpression");
  function $8e(t) {
    this.print(t.callee), this.print(t.typeParameters), t.optional && this.token("?."), this.print(t.typeArguments), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments), e(), this.rightParens(t);
  }
  n($8e, "OptionalCallExpression");
  function H8e(t) {
    this.print(t.callee), this.print(t.typeArguments), this.print(t.typeParameters), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), e(), this.rightParens(t);
  }
  n(H8e, "CallExpression");
  function J8e() {
    this.word("import");
  }
  n(J8e, "Import");
  function Y8e(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument));
  }
  n(Y8e, "AwaitExpression");
  function X8e(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument))) : t.argument && (this.space(),
    this.printTerminatorless(t.argument));
  }
  n(X8e, "YieldExpression");
  function z8e() {
    this.semicolon(!0);
  }
  n(z8e, "EmptyStatement");
  function G8e(t) {
    this.tokenContext |= N8e.TokenContext.expressionStatement, this.print(t.expression), this.semicolon();
  }
  n(G8e, "ExpressionStatement");
  function Q8e(t) {
    this.print(t.left), (t.left.type === "Identifier" || O8e(t.left)) && (t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(t.right);
  }
  n(Q8e, "AssignmentPattern");
  function Z8e(t) {
    this.print(t.left), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) : (this.token(t.operator), this.
    _endsWithDiv = t.operator === "/"), this.space(), this.print(t.right);
  }
  n(Z8e, "AssignmentExpression");
  function e6e(t) {
    this.print(t.object), this.token("::"), this.print(t.callee);
  }
  n(e6e, "BindExpression");
  function t6e(t) {
    if (this.print(t.object), !t.computed && zN(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    if (XV(t.property) && typeof t.property.value == "number" && (e = !0), e) {
      let s = this.enterDelimited();
      this.tokenChar(91), this.print(t.property), this.tokenChar(93), s();
    } else
      this.tokenChar(46), this.print(t.property);
  }
  n(t6e, "MemberExpression");
  function s6e(t) {
    this.print(t.meta), this.tokenChar(46), this.print(t.property);
  }
  n(s6e, "MetaProperty");
  function i6e(t) {
    this.tokenChar(35), this.print(t.id);
  }
  n(i6e, "PrivateName");
  function r6e(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(r6e, "V8IntrinsicIdentifier");
  function n6e(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e), this.dedent(), this.rightBrace(t);
  }
  n(n6e, "ModuleExpression");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/statements.js
var eW = g((zi) => {
  "use strict";
  Object.defineProperty(zi, "__esModule", {
    value: !0
  });
  zi.BreakStatement = m6e;
  zi.CatchClause = S6e;
  zi.ContinueStatement = y6e;
  zi.DebuggerStatement = A6e;
  zi.DoWhileStatement = d6e;
  zi.ForOfStatement = zi.ForInStatement = void 0;
  zi.ForStatement = h6e;
  zi.IfStatement = p6e;
  zi.LabeledStatement = b6e;
  zi.ReturnStatement = g6e;
  zi.SwitchCase = E6e;
  zi.SwitchStatement = P6e;
  zi.ThrowStatement = T6e;
  zi.TryStatement = x6e;
  zi.VariableDeclaration = v6e;
  zi.VariableDeclarator = C6e;
  zi.WhileStatement = f6e;
  zi.WithStatement = c6e;
  var a6e = fe(), GN = Dc(), {
    isFor: GV,
    isForStatement: o6e,
    isIfStatement: l6e,
    isStatement: u6e
  } = a6e;
  function c6e(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object), this.tokenChar(41), this.printBlock(t);
  }
  n(c6e, "WithStatement");
  function p6e(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.space();
    let e = t.alternate && l6e(QV(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate));
  }
  n(p6e, "IfStatement");
  function QV(t) {
    let {
      body: e
    } = t;
    return u6e(e) === !1 ? t : QV(e);
  }
  n(QV, "getLastStatement");
  function h6e(t) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let e = this.enterForStatementInit();
      this.tokenContext |= GN.TokenContext.forHead, this.print(t.init), e();
    }
    this.tokenChar(59), t.test && (this.space(), this.print(t.test)), this.token(";", !1, 1), t.update && (this.space(), this.print(t.update)),
    this.tokenChar(41), this.printBlock(t);
  }
  n(h6e, "ForStatement");
  function f6e(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.printBlock(t);
  }
  n(f6e, "WhileStatement");
  function ZV(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let s = e ? null : this.enterForStatementInit();
      this.tokenContext |= e ? GN.TokenContext.forOfHead : GN.TokenContext.forInHead, this.print(t.left), s?.();
    }
    this.space(), this.word(e ? "of" : "in"), this.space(), this.print(t.right), this.tokenChar(41), this.printBlock(t);
  }
  n(ZV, "ForXStatement");
  var y9s = zi.ForInStatement = ZV, g9s = zi.ForOfStatement = ZV;
  function d6e(t) {
    this.word("do"), this.space(), this.print(t.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test),
    this.tokenChar(41), this.semicolon();
  }
  n(d6e, "DoWhileStatement");
  function Fx(t, e) {
    e && (t.space(), t.printTerminatorless(e)), t.semicolon();
  }
  n(Fx, "printStatementAfterKeyword");
  function m6e(t) {
    this.word("break"), Fx(this, t.label);
  }
  n(m6e, "BreakStatement");
  function y6e(t) {
    this.word("continue"), Fx(this, t.label);
  }
  n(y6e, "ContinueStatement");
  function g6e(t) {
    this.word("return"), Fx(this, t.argument);
  }
  n(g6e, "ReturnStatement");
  function T6e(t) {
    this.word("throw"), Fx(this, t.argument);
  }
  n(T6e, "ThrowStatement");
  function b6e(t) {
    this.print(t.label), this.tokenChar(58), this.space(), this.print(t.body);
  }
  n(b6e, "LabeledStatement");
  function x6e(t) {
    this.word("try"), this.space(), this.print(t.block), this.space(), t.handlers ? this.print(t.handlers[0]) : this.print(t.handler), t.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(t.finalizer));
  }
  n(x6e, "TryStatement");
  function S6e(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param), this.print(t.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(t.body);
  }
  n(S6e, "CatchClause");
  function P6e(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, !0, void 0, /* @__PURE__ */ n(function(s, i) {
      if (!s && t.cases[t.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(t);
  }
  n(P6e, "SwitchStatement");
  function E6e(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, !0));
  }
  n(E6e, "SwitchCase");
  function A6e() {
    this.word("debugger"), this.semicolon();
  }
  n(A6e, "DebuggerStatement");
  function v6e(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: s
    } = t;
    s === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(s, s === "using"), this.space();
    let i = !1;
    if (!GV(e))
      for (let r of t.declarations)
        r.init && (i = !0);
    if (this.printList(t.declarations, void 0, void 0, t.declarations.length > 1, i ? function(r) {
      this.token(",", !1, r), this.newline();
    } : void 0), GV(e)) {
      if (o6e(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(v6e, "VariableDeclaration");
  function C6e(t) {
    this.print(t.id), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation), t.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(t.init));
  }
  n(C6e, "VariableDeclarator");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/classes.js
var tW = g((Ia) => {
  "use strict";
  Object.defineProperty(Ia, "__esModule", {
    value: !0
  });
  Ia.ClassAccessorProperty = L6e;
  Ia.ClassBody = D6e;
  Ia.ClassExpression = Ia.ClassDeclaration = k6e;
  Ia.ClassMethod = M6e;
  Ia.ClassPrivateMethod = F6e;
  Ia.ClassPrivateProperty = B6e;
  Ia.ClassProperty = _6e;
  Ia.StaticBlock = R6e;
  Ia._classMethodHead = j6e;
  var w6e = fe(), {
    isExportDefaultDeclaration: I6e,
    isExportNamedDeclaration: N6e
  } = w6e;
  function k6e(t, e) {
    (!(I6e(e) || N6e(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id)), this.print(
    t.typeParameters), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass), this.print(t.superTypeParameters)),
    t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements)), this.space(), this.print(t.body);
  }
  n(k6e, "ClassDeclaration");
  function D6e(t) {
    if (this.tokenChar(123), t.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let e = O6e(this, t);
      e?.(-1);
      let s = this.enterDelimited();
      this.printJoin(t.body, !0, !0, e, !0), s(), this.endsWith(10) || this.newline(), this.rightBrace(t);
    }
  }
  n(D6e, "ClassBody");
  function O6e(t, e) {
    if (!t.tokenMap || e.start == null || e.end == null)
      return null;
    let s = t.tokenMap.getIndexes(e);
    if (!s) return null;
    let i = 1, r = 0, a = 0, o = /* @__PURE__ */ n(() => {
      for (; a < e.body.length && e.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === e.body.length ? e.end : e.body[a].start, c;
      for (; i < s.length && t.tokenMap.matchesOriginal(c = t._tokens[s[i]], ";") && c.start < u; )
        t.token(";", void 0, r++), i++;
    };
  }
  n(O6e, "classBodyEmptySemicolonsPrinter");
  function _6e(t) {
    if (this.printJoin(t.decorators), !t.static && !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key), this.tokenChar(93)) : (this._variance(t), this.
    print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(_6e, "ClassProperty");
  function L6e(t) {
    var e;
    this.printJoin(t.decorators);
    let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    s && this.catchUp(s), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key), this.tokenChar(93)) : (this._variance(t), this.print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(L6e, "ClassAccessorProperty");
  function B6e(t) {
    this.printJoin(t.decorators), this.tsPrintClassMemberModifiers(t), this.print(t.key), t.optional && this.tokenChar(63), t.definite && this.
    tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(B6e, "ClassPrivateProperty");
  function M6e(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(M6e, "ClassMethod");
  function F6e(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(F6e, "ClassPrivateMethod");
  function j6e(t) {
    if (this.printJoin(t.decorators), !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(j6e, "_classMethodHead");
  function R6e(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, !0), this.rightBrace(t));
  }
  n(R6e, "StaticBlock");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/methods.js
var sW = g((Na) => {
  "use strict";
  Object.defineProperty(Na, "__esModule", {
    value: !0
  });
  Na.ArrowFunctionExpression = z6e;
  Na.FunctionDeclaration = Na.FunctionExpression = X6e;
  Na._functionHead = Y6e;
  Na._methodHead = H6e;
  Na._param = $6e;
  Na._parameters = W6e;
  Na._params = V6e;
  Na._predicate = J6e;
  Na._shouldPrintArrowParamsParens = G6e;
  var q6e = fe(), U6e = Dc(), {
    isIdentifier: K6e
  } = q6e;
  function V6e(t, e, s) {
    this.print(t.typeParameters);
    let i = Q6e.call(this, e, s);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(t.params, ")");
    let r = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, r), this._noLineTerminator = r;
  }
  n(V6e, "_params");
  function W6e(t, e) {
    let s = this.enterDelimited(), i = this.shouldPrintTrailingComma(e), r = t.length;
    for (let a = 0; a < r; a++)
      this._param(t[a]), (i || a < r - 1) && (this.token(",", null, a), this.space());
    this.token(e), s();
  }
  n(W6e, "_parameters");
  function $6e(t) {
    this.printJoin(t.decorators), this.print(t), t.optional && this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n($6e, "_param");
  function H6e(t) {
    let e = t.kind, s = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(s), this.tokenChar(93)) : this.print(s), t.optional &&
    this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(H6e, "_methodHead");
  function J6e(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, e));
  }
  n(J6e, "_predicate");
  function Y6e(t, e) {
    t.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), t.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), t.id && this.print(t.id), this._params(
    t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(t);
  }
  n(Y6e, "_functionHead");
  function X6e(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body);
  }
  n(X6e, "FunctionExpression");
  function z6e(t, e) {
    t.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(t) ? this._params(t, void 0, e) : this.print(t.params[0],
    !0), this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= U6e.TokenContext.
    arrowBody, this.print(t.body);
  }
  n(z6e, "ArrowFunctionExpression");
  function G6e(t) {
    var e, s;
    if (t.params.length !== 1 || t.typeParameters || t.returnType || t.predicate)
      return !0;
    let i = t.params[0];
    if (!K6e(i) || i.typeAnnotation || i.optional || (e = i.leadingComments) != null && e.length || (s = i.trailingComments) != null && s.length)
      return !0;
    if (this.tokenMap) {
      if (t.loc == null || this.tokenMap.findMatching(t, "(") !== null) return !0;
      let r = this.tokenMap.findMatching(t, "=>");
      return r?.loc == null ? !0 : r.loc.start.line !== t.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  n(G6e, "_shouldPrintArrowParamsParens");
  function Q6e(t, e) {
    let s = t;
    if (!s && e) {
      let u = e.type;
      u === "VariableDeclarator" ? s = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? s = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (s = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (s = e.key);
    }
    if (!s) return;
    let i;
    if (s.type === "Identifier") {
      var r, a;
      i = {
        pos: (r = s.loc) == null ? void 0 : r.start,
        name: ((a = s.loc) == null ? void 0 : a.identifierName) || s.name
      };
    } else if (s.type === "PrivateName") {
      var o;
      i = {
        pos: (o = s.loc) == null ? void 0 : o.start,
        name: "#" + s.id.name
      };
    } else if (s.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = s.loc) == null ? void 0 : l.start,
        name: s.value
      };
    }
    return i;
  }
  n(Q6e, "_getFuncIdName");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/modules.js
var QN = g((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", {
    value: !0
  });
  Tn.ExportAllDeclaration = hRe;
  Tn.ExportDefaultDeclaration = dRe;
  Tn.ExportDefaultSpecifier = lRe;
  Tn.ExportNamedDeclaration = fRe;
  Tn.ExportNamespaceSpecifier = cRe;
  Tn.ExportSpecifier = uRe;
  Tn.ImportAttribute = yRe;
  Tn.ImportDeclaration = mRe;
  Tn.ImportDefaultSpecifier = oRe;
  Tn.ImportExpression = TRe;
  Tn.ImportNamespaceSpecifier = gRe;
  Tn.ImportSpecifier = aRe;
  Tn._printAttributes = pRe;
  var Z6e = fe(), eRe = Dc(), {
    isClassDeclaration: tRe,
    isExportDefaultSpecifier: sRe,
    isExportNamespaceSpecifier: iRe,
    isImportDefaultSpecifier: rRe,
    isImportNamespaceSpecifier: nRe,
    isStatement: rW
  } = Z6e;
  function aRe(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported), t.local && t.
    local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local));
  }
  n(aRe, "ImportSpecifier");
  function oRe(t) {
    this.print(t.local);
  }
  n(oRe, "ImportDefaultSpecifier");
  function lRe(t) {
    this.print(t.exported);
  }
  n(lRe, "ExportDefaultSpecifier");
  function uRe(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported));
  }
  n(uRe, "ExportSpecifier");
  function cRe(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported);
  }
  n(cRe, "ExportNamespaceSpecifier");
  var iW = !1;
  function pRe(t, e) {
    var s;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: r,
      assertions: a
    } = t;
    r && !i && t.extra && (t.extra.deprecatedAssertSyntax || t.extra.deprecatedWithLegacySyntax) && !iW && (iW = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (s = t.extra) != null && s.deprecatedWithLegacySyntax)) {
      this.printList(r || a);
      return;
    }
    let l = e ? 1 : 0;
    this.token("{", null, l), this.space(), this.printList(r || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, l);
  }
  n(pRe, "_printAttributes");
  function hRe(t) {
    var e, s;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0),
    this.space(), this._printAttributes(t, !1)) : this.print(t.source), this.semicolon();
  }
  n(hRe, "ExportAllDeclaration");
  function nW(t, e) {
    tRe(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators);
  }
  n(nW, "maybePrintDecoratorsBeforeExport");
  function fRe(t) {
    if (nW(this, t), this.word("export"), this.space(), t.declaration) {
      let i = t.declaration;
      this.print(i), rW(i) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let i = t.specifiers.slice(0), r = !1;
      for (; ; ) {
        let o = i[0];
        if (sRe(o) || iRe(o))
          r = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !r) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), t.source) {
        var e, s;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.
        print(t.source, !0), this.space(), this._printAttributes(t, a)) : this.print(t.source);
      }
      this.semicolon();
    }
  }
  n(fRe, "ExportNamedDeclaration");
  function dRe(t) {
    nW(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    eRe.TokenContext.exportDefault;
    let e = t.declaration;
    this.print(e), rW(e) || this.semicolon();
  }
  n(dRe, "ExportDefaultDeclaration");
  function mRe(t) {
    var e, s;
    this.word("import"), this.space();
    let i = t.importKind === "type" || t.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let r = t.specifiers.slice(0), a = !!r.length;
    for (; a; ) {
      let l = r[0];
      if (rRe(l) || nRe(l))
        this.print(r.shift()), r.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    r.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(r, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (e =
    t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0), this.space(), this._printAttributes(
    t, o)) : this.print(t.source), this.semicolon();
  }
  n(mRe, "ImportDeclaration");
  function yRe(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(yRe, "ImportAttribute");
  function gRe(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local);
  }
  n(gRe, "ImportNamespaceSpecifier");
  function TRe(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options)), this.tokenChar(41);
  }
  n(TRe, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var gd = g((C9s, lW) => {
  "use strict";
  var aW = {}, bRe = aW.hasOwnProperty, oW = /* @__PURE__ */ n((t, e) => {
    for (let s in t)
      bRe.call(t, s) && e(s, t[s]);
  }, "forOwn"), xRe = /* @__PURE__ */ n((t, e) => (e && oW(e, (s, i) => {
    t[s] = i;
  }), t), "extend"), SRe = /* @__PURE__ */ n((t, e) => {
    let s = t.length, i = -1;
    for (; ++i < s; )
      e(t[i]);
  }, "forEach"), jx = /* @__PURE__ */ n((t) => "\\u" + ("0000" + t).slice(-4), "fourHexEscape"), mg = /* @__PURE__ */ n((t, e) => {
    let s = t.toString(16);
    return e ? s : s.toUpperCase();
  }, "hexadecimal"), yg = aW.toString, PRe = Array.isArray, ERe = /* @__PURE__ */ n((t) => typeof Buffer == "function" && Buffer.isBuffer(t),
  "isBuffer"), ARe = /* @__PURE__ */ n((t) => yg.call(t) == "[object Object]", "isObject"), vRe = /* @__PURE__ */ n((t) => typeof t == "stri\
ng" || yg.call(t) == "[object String]", "isString"), CRe = /* @__PURE__ */ n((t) => typeof t == "number" || yg.call(t) == "[object Number]",
  "isNumber"), wRe = /* @__PURE__ */ n((t) => typeof t == "function", "isFunction"), IRe = /* @__PURE__ */ n((t) => yg.call(t) == "[object M\
ap]", "isMap"), NRe = /* @__PURE__ */ n((t) => yg.call(t) == "[object Set]", "isSet"), kRe = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, DRe = /[\\\b\f\n\r\t]/, ORe = /[0-9]/, _Re = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, LRe = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  BRe = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, Oc = /* @__PURE__ */ n((t, e) => {
    let s = /* @__PURE__ */ n(() => {
      c = u, ++e.indentLevel, u = e.indent.repeat(e.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, r = e && e.json;
    r && (i.quotes = "double", i.wrap = !0), e = xRe(i, e), e.quotes != "single" && e.quotes != "double" && e.quotes != "backtick" && (e.quotes =
    "single");
    let a = e.quotes == "double" ? '"' : e.quotes == "backtick" ? "`" : "'", o = e.compact, l = e.lowercaseHex, u = e.indent.repeat(e.indentLevel),
    c = "", p = e.__inline1__, h = e.__inline2__, f = o ? "" : `
`, d, y = !0, m = e.numbers == "binary", T = e.numbers == "octal", b = e.numbers == "decimal", E = e.numbers == "hexadecimal";
    if (r && t && wRe(t.toJSON) && (t = t.toJSON()), !vRe(t)) {
      if (IRe(t))
        return t.size == 0 ? "new Map()" : (o || (e.__inline1__ = !0, e.__inline2__ = !1), "new Map(" + Oc(Array.from(t), e) + ")");
      if (NRe(t))
        return t.size == 0 ? "new Set()" : "new Set(" + Oc(Array.from(t), e) + ")";
      if (ERe(t))
        return t.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Oc(Array.from(t), e) + ")";
      if (PRe(t))
        return d = [], e.wrap = !0, p && (e.__inline1__ = !1, e.__inline2__ = !0), h || s(), SRe(t, (K) => {
          y = !1, h && (e.__inline2__ = !1), d.push(
            (o || h ? "" : u) + Oc(K, e)
          );
        }), y ? "[]" : h ? "[" + d.join(", ") + "]" : "[" + f + d.join("," + f) + f + (o ? "" : c) + "]";
      if (CRe(t)) {
        if (r)
          return JSON.stringify(t);
        if (b)
          return String(t);
        if (E) {
          let K = t.toString(16);
          return l || (K = K.toUpperCase()), "0x" + K;
        }
        if (m)
          return "0b" + t.toString(2);
        if (T)
          return "0o" + t.toString(8);
      } else return ARe(t) ? (d = [], e.wrap = !0, s(), oW(t, (K, he) => {
        y = !1, d.push(
          (o ? "" : u) + Oc(K, e) + ":" + (o ? "" : " ") + Oc(he, e)
        );
      }), y ? "{}" : "{" + f + d.join("," + f) + f + (o ? "" : c) + "}") : r ? JSON.stringify(t) || "null" : String(t);
    }
    let w = e.escapeEverything ? LRe : BRe;
    return d = t.replace(w, (K, he, de, me, ve, ye) => {
      if (he) {
        if (e.minimal) return he;
        let oe = he.charCodeAt(0), Ae = he.charCodeAt(1);
        if (e.es6) {
          let xt = (oe - 55296) * 1024 + Ae - 56320 + 65536;
          return "\\u{" + mg(xt, l) + "}";
        }
        return jx(mg(oe, l)) + jx(mg(Ae, l));
      }
      if (de)
        return jx(mg(de.charCodeAt(0), l));
      if (K == "\0" && !r && !ORe.test(ye.charAt(ve + 1)))
        return "\\0";
      if (me)
        return me == a || e.escapeEverything ? "\\" + me : me;
      if (DRe.test(K))
        return kRe[K];
      if (e.minimal && !_Re.test(K))
        return K;
      let ge = mg(K.charCodeAt(0), l);
      return r || ge.length > 2 ? jx(ge) : "\\x" + ("00" + ge).slice(-2);
    }), a == "`" && (d = d.replace(/\$\{/g, "\\${")), e.isScriptContext && (d = d.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, r ?
    "\\u003C!--" : "\\x3C!--")), e.wrap && (d = a + d + a), d;
  }, "jsesc");
  Oc.version = "3.0.2";
  lW.exports = Oc;
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/types.js
var ek = g((Oi) => {
  "use strict";
  Object.defineProperty(Oi, "__esModule", {
    value: !0
  });
  Oi.ArgumentPlaceholder = qRe;
  Oi.ArrayPattern = Oi.ArrayExpression = $Re;
  Oi.BigIntLiteral = ZRe;
  Oi.BooleanLiteral = XRe;
  Oi.Identifier = RRe;
  Oi.NullLiteral = zRe;
  Oi.NumericLiteral = GRe;
  Oi.ObjectPattern = Oi.ObjectExpression = KRe;
  Oi.ObjectMethod = VRe;
  Oi.ObjectProperty = WRe;
  Oi.PipelineBareFunction = s5e;
  Oi.PipelinePrimaryTopicReference = i5e;
  Oi.PipelineTopicExpression = t5e;
  Oi.RecordExpression = HRe;
  Oi.RegExpLiteral = YRe;
  Oi.SpreadElement = Oi.RestElement = URe;
  Oi.StringLiteral = QRe;
  Oi.TopicReference = e5e;
  Oi.TupleExpression = JRe;
  Oi._getRawIdentifier = jRe;
  var MRe = fe(), pW = gd(), {
    isAssignmentPattern: FRe,
    isIdentifier: ZN
  } = MRe, uW = null, Rx = "";
  function jRe(t) {
    if (t === uW) return Rx;
    uW = t;
    let {
      name: e
    } = t, s = this.tokenMap.find(t, (i) => i.value === e);
    return s ? (Rx = this._originalCode.slice(s.start, s.end), Rx) : Rx = t.name;
  }
  n(jRe, "_getRawIdentifier");
  function RRe(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(this.tokenMap ? this._getRawIdentifier(
    t) : t.name);
  }
  n(RRe, "Identifier");
  function qRe() {
    this.tokenChar(63);
  }
  n(qRe, "ArgumentPlaceholder");
  function URe(t) {
    this.token("..."), this.print(t.argument);
  }
  n(URe, "RestElement");
  function KRe(t) {
    let e = t.properties;
    if (this.tokenChar(123), e.length) {
      let s = this.enterDelimited();
      this.space(), this.printList(e, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), s();
    }
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(KRe, "ObjectExpression");
  function VRe(t) {
    this.printJoin(t.decorators), this._methodHead(t), this.space(), this.print(t.body);
  }
  n(VRe, "ObjectMethod");
  function WRe(t) {
    if (this.printJoin(t.decorators), t.computed)
      this.tokenChar(91), this.print(t.key), this.tokenChar(93);
    else {
      if (FRe(t.value) && ZN(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value);
        return;
      }
      if (this.print(t.key), t.shorthand && ZN(t.key) && ZN(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(WRe, "ObjectProperty");
  function $Re(t) {
    let e = t.elements, s = e.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let r = 0; r < e.length; r++) {
      let a = e[r];
      a ? (r > 0 && this.space(), this.print(a), (r < s - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, r)) : this.token("\
,", !1, r);
    }
    i(), this.tokenChar(93);
  }
  n($Re, "ArrayExpression");
  function HRe(t) {
    let e = t.properties, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      s = "#{", i = "}";
    }
    this.token(s), e.length && (this.space(), this.printList(e, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  n(HRe, "RecordExpression");
  function JRe(t) {
    let e = t.elements, s = e.length, i, r;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", r = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", r = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o), (a < s - 1 || this.shouldPrintTrailingComma(r)) && this.token(",", !1, a));
    }
    this.token(r);
  }
  n(JRe, "TupleExpression");
  function YRe(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(YRe, "RegExpLiteral");
  function XRe(t) {
    this.word(t.value ? "true" : "false");
  }
  n(XRe, "BooleanLiteral");
  function zRe() {
    this.word("null");
  }
  n(zRe, "NullLiteral");
  function GRe(t) {
    let e = this.getPossibleRaw(t), s = this.format.jsescOption, i = t.value, r = i + "";
    s.numbers ? this.number(pW(i, s), i) : e == null ? this.number(r, i) : this.format.minified ? this.number(e.length < r.length ? e : r, i) :
    this.number(e, i);
  }
  n(GRe, "NumericLiteral");
  function QRe(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let s = pW(t.value, this.format.jsescOption);
    this.token(s);
  }
  n(QRe, "StringLiteral");
  function ZRe(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(ZRe, "BigIntLiteral");
  var cW = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function e5e() {
    let {
      topicToken: t
    } = this.format;
    if (cW.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), s = Array.from(cW, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${s.join(", ")} (${e} received instead).`);
    }
  }
  n(e5e, "TopicReference");
  function t5e(t) {
    this.print(t.expression);
  }
  n(t5e, "PipelineTopicExpression");
  function s5e(t) {
    this.print(t.callee);
  }
  n(s5e, "PipelineBareFunction");
  function i5e() {
    this.tokenChar(35);
  }
  n(i5e, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/flow.js
var fW = g((st) => {
  "use strict";
  Object.defineProperty(st, "__esModule", {
    value: !0
  });
  st.AnyTypeAnnotation = l5e;
  st.ArrayTypeAnnotation = u5e;
  st.BooleanLiteralTypeAnnotation = p5e;
  st.BooleanTypeAnnotation = c5e;
  st.DeclareClass = f5e;
  st.DeclareExportAllDeclaration = A5e;
  st.DeclareExportDeclaration = E5e;
  st.DeclareFunction = d5e;
  st.DeclareInterface = g5e;
  st.DeclareModule = T5e;
  st.DeclareModuleExports = b5e;
  st.DeclareOpaqueType = S5e;
  st.DeclareTypeAlias = x5e;
  st.DeclareVariable = P5e;
  st.DeclaredPredicate = y5e;
  st.EmptyTypeAnnotation = H5e;
  st.EnumBooleanBody = C5e;
  st.EnumBooleanMember = D5e;
  st.EnumDeclaration = v5e;
  st.EnumDefaultedMember = k5e;
  st.EnumNumberBody = w5e;
  st.EnumNumberMember = O5e;
  st.EnumStringBody = I5e;
  st.EnumStringMember = _5e;
  st.EnumSymbolBody = N5e;
  st.ExistsTypeAnnotation = B5e;
  st.FunctionTypeAnnotation = M5e;
  st.FunctionTypeParam = F5e;
  st.IndexedAccessType = g9e;
  st.InferredPredicate = m5e;
  st.InterfaceDeclaration = U5e;
  st.GenericTypeAnnotation = st.ClassImplements = st.InterfaceExtends = j5e;
  st.InterfaceTypeAnnotation = V5e;
  st.IntersectionTypeAnnotation = W5e;
  st.MixedTypeAnnotation = $5e;
  st.NullLiteralTypeAnnotation = h5e;
  st.NullableTypeAnnotation = J5e;
  Object.defineProperty(st, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hW.NumericLiteral;
    }, "get")
  });
  st.NumberTypeAnnotation = Y5e;
  st.ObjectTypeAnnotation = r9e;
  st.ObjectTypeCallProperty = a9e;
  st.ObjectTypeIndexer = o9e;
  st.ObjectTypeInternalSlot = n9e;
  st.ObjectTypeProperty = l9e;
  st.ObjectTypeSpreadProperty = u9e;
  st.OpaqueType = i9e;
  st.OptionalIndexedAccessType = T9e;
  st.QualifiedTypeIdentifier = c9e;
  Object.defineProperty(st, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hW.StringLiteral;
    }, "get")
  });
  st.StringTypeAnnotation = X5e;
  st.SymbolTypeAnnotation = p9e;
  st.ThisTypeAnnotation = z5e;
  st.TupleTypeAnnotation = G5e;
  st.TypeAlias = Z5e;
  st.TypeAnnotation = e9e;
  st.TypeCastExpression = d9e;
  st.TypeParameter = s9e;
  st.TypeParameterDeclaration = st.TypeParameterInstantiation = t9e;
  st.TypeofTypeAnnotation = Q5e;
  st.UnionTypeAnnotation = f9e;
  st.Variance = m9e;
  st.VoidTypeAnnotation = y9e;
  st._interfaceish = R5e;
  st._variance = q5e;
  var r5e = fe(), n5e = QN(), a5e = Dc(), hW = ek(), {
    isDeclareExportDeclaration: qx,
    isStatement: o5e
  } = r5e;
  function l5e() {
    this.word("any");
  }
  n(l5e, "AnyTypeAnnotation");
  function u5e(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(u5e, "ArrayTypeAnnotation");
  function c5e() {
    this.word("boolean");
  }
  n(c5e, "BooleanTypeAnnotation");
  function p5e(t) {
    this.word(t.value ? "true" : "false");
  }
  n(p5e, "BooleanLiteralTypeAnnotation");
  function h5e() {
    this.word("null");
  }
  n(h5e, "NullLiteralTypeAnnotation");
  function f5e(t, e) {
    qx(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(f5e, "DeclareClass");
  function d5e(t, e) {
    qx(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation.typeAnnotation),
    t.predicate && (this.space(), this.print(t.predicate)), this.semicolon();
  }
  n(d5e, "DeclareFunction");
  function m5e() {
    this.tokenChar(37), this.word("checks");
  }
  n(m5e, "InferredPredicate");
  function y5e(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value), this.tokenChar(41);
  }
  n(y5e, "DeclaredPredicate");
  function g5e(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(g5e, "DeclareInterface");
  function T5e(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id), this.space(), this.print(t.body);
  }
  n(T5e, "DeclareModule");
  function b5e(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation);
  }
  n(b5e, "DeclareModuleExports");
  function x5e(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(x5e, "DeclareTypeAlias");
  function S5e(t, e) {
    qx(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(S5e, "DeclareOpaqueType");
  function P5e(t, e) {
    qx(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation), this.semicolon();
  }
  n(P5e, "DeclareVariable");
  function E5e(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), L5e.call(this,
    t);
  }
  n(E5e, "DeclareExportDeclaration");
  function A5e(t) {
    this.word("declare"), this.space(), n5e.ExportAllDeclaration.call(this, t);
  }
  n(A5e, "DeclareExportAllDeclaration");
  function v5e(t) {
    let {
      id: e,
      body: s
    } = t;
    this.word("enum"), this.space(), this.print(e), this.print(s);
  }
  n(v5e, "EnumDeclaration");
  function Ux(t, e, s) {
    s && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(Ux, "enumExplicitType");
  function Kx(t, e) {
    let {
      members: s
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let i of s)
      t.print(i), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(Kx, "enumBody");
  function C5e(t) {
    let {
      explicitType: e
    } = t;
    Ux(this, "boolean", e), Kx(this, t);
  }
  n(C5e, "EnumBooleanBody");
  function w5e(t) {
    let {
      explicitType: e
    } = t;
    Ux(this, "number", e), Kx(this, t);
  }
  n(w5e, "EnumNumberBody");
  function I5e(t) {
    let {
      explicitType: e
    } = t;
    Ux(this, "string", e), Kx(this, t);
  }
  n(I5e, "EnumStringBody");
  function N5e(t) {
    Ux(this, "symbol", !0), Kx(this, t);
  }
  n(N5e, "EnumSymbolBody");
  function k5e(t) {
    let {
      id: e
    } = t;
    this.print(e), this.tokenChar(44);
  }
  n(k5e, "EnumDefaultedMember");
  function tk(t, e) {
    t.print(e.id), t.space(), t.token("="), t.space(), t.print(e.init), t.token(",");
  }
  n(tk, "enumInitializedMember");
  function D5e(t) {
    tk(this, t);
  }
  n(D5e, "EnumBooleanMember");
  function O5e(t) {
    tk(this, t);
  }
  n(O5e, "EnumNumberMember");
  function _5e(t) {
    tk(this, t);
  }
  n(_5e, "EnumStringMember");
  function L5e(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e), o5e(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source)), this.semicolon();
  }
  n(L5e, "FlowExportDeclaration");
  function B5e() {
    this.tokenChar(42);
  }
  n(B5e, "ExistsTypeAnnotation");
  function M5e(t, e) {
    this.print(t.typeParameters), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation),
    (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params), t.rest && (t.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(t.rest)), this.tokenChar(41);
    let s = e?.type;
    s != null && (s === "ObjectTypeCallProperty" || s === "ObjectTypeInternalSlot" || s === "DeclareFunction" || s === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType);
  }
  n(M5e, "FunctionTypeAnnotation");
  function F5e(t) {
    this.print(t.name), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation);
  }
  n(F5e, "FunctionTypeParam");
  function j5e(t) {
    this.print(t.id), this.print(t.typeParameters, !0);
  }
  n(j5e, "InterfaceExtends");
  function R5e(t) {
    var e;
    if (this.print(t.id), this.print(t.typeParameters), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(),
    this.printList(t.extends)), t.type === "DeclareClass") {
      var s, i;
      (s = t.mixins) != null && s.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins)), (i = t.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements));
    }
    this.space(), this.print(t.body);
  }
  n(R5e, "_interfaceish");
  function q5e(t) {
    var e;
    let s = (e = t.variance) == null ? void 0 : e.kind;
    s != null && (s === "plus" ? this.tokenChar(43) : s === "minus" && this.tokenChar(45));
  }
  n(q5e, "_variance");
  function U5e(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(U5e, "InterfaceDeclaration");
  function K5e(t) {
    this.space(), this.token("&", !1, t), this.space();
  }
  n(K5e, "andSeparator");
  function V5e(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends)),
    this.space(), this.print(t.body);
  }
  n(V5e, "InterfaceTypeAnnotation");
  function W5e(t) {
    this.printJoin(t.types, void 0, void 0, K5e);
  }
  n(W5e, "IntersectionTypeAnnotation");
  function $5e() {
    this.word("mixed");
  }
  n($5e, "MixedTypeAnnotation");
  function H5e() {
    this.word("empty");
  }
  n(H5e, "EmptyTypeAnnotation");
  function J5e(t) {
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(J5e, "NullableTypeAnnotation");
  function Y5e() {
    this.word("number");
  }
  n(Y5e, "NumberTypeAnnotation");
  function X5e() {
    this.word("string");
  }
  n(X5e, "StringTypeAnnotation");
  function z5e() {
    this.word("this");
  }
  n(z5e, "ThisTypeAnnotation");
  function G5e(t) {
    this.tokenChar(91), this.printList(t.types), this.tokenChar(93);
  }
  n(G5e, "TupleTypeAnnotation");
  function Q5e(t) {
    this.word("typeof"), this.space(), this.print(t.argument);
  }
  n(Q5e, "TypeofTypeAnnotation");
  function Z5e(t) {
    this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    t.right), this.semicolon();
  }
  n(Z5e, "TypeAlias");
  function e9e(t, e) {
    this.tokenChar(58), this.space(), e.type === "ArrowFunctionExpression" ? this.tokenContext |= a5e.TokenContext.arrowFlowReturnType : t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(e9e, "TypeAnnotation");
  function t9e(t) {
    this.tokenChar(60), this.printList(t.params), this.tokenChar(62);
  }
  n(t9e, "TypeParameterInstantiation");
  function s9e(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default));
  }
  n(s9e, "TypeParameter");
  function i9e(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), t.supertype && (this.
    tokenChar(58), this.space(), this.print(t.supertype)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(t.impltype)),
    this.semicolon();
  }
  n(i9e, "OpaqueType");
  function r9e(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, !0, !0, void 0, void 0, /* @__PURE__ */ n(function(i) {
      if (i && !e[0]) return 1;
    }, "addNewlines"), () => {
      (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(r9e, "ObjectTypeAnnotation");
  function n9e(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value);
  }
  n(n9e, "ObjectTypeInternalSlot");
  function a9e(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value);
  }
  n(a9e, "ObjectTypeCallProperty");
  function o9e(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id), this.tokenChar(58), this.
    space()), this.print(t.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(o9e, "ObjectTypeIndexer");
  function l9e(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58),
    this.space()), this.print(t.value);
  }
  n(l9e, "ObjectTypeProperty");
  function u9e(t) {
    this.token("..."), this.print(t.argument);
  }
  n(u9e, "ObjectTypeSpreadProperty");
  function c9e(t) {
    this.print(t.qualification), this.tokenChar(46), this.print(t.id);
  }
  n(c9e, "QualifiedTypeIdentifier");
  function p9e() {
    this.word("symbol");
  }
  n(p9e, "SymbolTypeAnnotation");
  function h9e(t) {
    this.space(), this.token("|", !1, t), this.space();
  }
  n(h9e, "orSeparator");
  function f9e(t) {
    this.printJoin(t.types, void 0, void 0, h9e);
  }
  n(f9e, "UnionTypeAnnotation");
  function d9e(t) {
    this.tokenChar(40), this.print(t.expression), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(d9e, "TypeCastExpression");
  function m9e(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(m9e, "Variance");
  function y9e() {
    this.word("void");
  }
  n(y9e, "VoidTypeAnnotation");
  function g9e(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(g9e, "IndexedAccessType");
  function T9e(t) {
    this.print(t.objectType), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(T9e, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/base.js
var dW = g((Zl) => {
  "use strict";
  Object.defineProperty(Zl, "__esModule", {
    value: !0
  });
  Zl.BlockStatement = S9e;
  Zl.Directive = P9e;
  Zl.DirectiveLiteral = v9e;
  Zl.File = b9e;
  Zl.InterpreterDirective = C9e;
  Zl.Placeholder = w9e;
  Zl.Program = x9e;
  function b9e(t) {
    t.program && this.print(t.program.interpreter), this.print(t.program);
  }
  n(b9e, "File");
  function x9e(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let s = (e = t.directives) == null ? void 0 : e.length;
    if (s) {
      var i;
      let r = t.body.length ? 2 : 1;
      this.printSequence(t.directives, void 0, r), (i = t.directives[s - 1].trailingComments) != null && i.length || this.newline(r);
    }
    this.printSequence(t.body);
  }
  n(x9e, "Program");
  function S9e(t) {
    var e;
    this.tokenChar(123);
    let s = this.enterDelimited(), i = (e = t.directives) == null ? void 0 : e.length;
    if (i) {
      var r;
      let a = t.body.length ? 2 : 1;
      this.printSequence(t.directives, !0, a), (r = t.directives[i - 1].trailingComments) != null && r.length || this.newline(a);
    }
    this.printSequence(t.body, !0), s(), this.rightBrace(t);
  }
  n(S9e, "BlockStatement");
  function P9e(t) {
    this.print(t.value), this.semicolon();
  }
  n(P9e, "Directive");
  var E9e = /(?:^|[^\\])(?:\\\\)*'/, A9e = /(?:^|[^\\])(?:\\\\)*"/;
  function v9e(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: s
    } = t;
    if (!A9e.test(s))
      this.token(`"${s}"`);
    else if (!E9e.test(s))
      this.token(`'${s}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(v9e, "DirectiveLiteral");
  function C9e(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(C9e, "InterpreterDirective");
  function w9e(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(w9e, "Placeholder");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/jsx.js
var mW = g((qr) => {
  "use strict";
  Object.defineProperty(qr, "__esModule", {
    value: !0
  });
  qr.JSXAttribute = I9e;
  qr.JSXClosingElement = R9e;
  qr.JSXClosingFragment = V9e;
  qr.JSXElement = M9e;
  qr.JSXEmptyExpression = q9e;
  qr.JSXExpressionContainer = _9e;
  qr.JSXFragment = U9e;
  qr.JSXIdentifier = N9e;
  qr.JSXMemberExpression = D9e;
  qr.JSXNamespacedName = k9e;
  qr.JSXOpeningElement = j9e;
  qr.JSXOpeningFragment = K9e;
  qr.JSXSpreadAttribute = O9e;
  qr.JSXSpreadChild = L9e;
  qr.JSXText = B9e;
  function I9e(t) {
    this.print(t.name), t.value && (this.tokenChar(61), this.print(t.value));
  }
  n(I9e, "JSXAttribute");
  function N9e(t) {
    this.word(t.name);
  }
  n(N9e, "JSXIdentifier");
  function k9e(t) {
    this.print(t.namespace), this.tokenChar(58), this.print(t.name);
  }
  n(k9e, "JSXNamespacedName");
  function D9e(t) {
    this.print(t.object), this.tokenChar(46), this.print(t.property);
  }
  n(D9e, "JSXMemberExpression");
  function O9e(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument), this.rightBrace(t);
  }
  n(O9e, "JSXSpreadAttribute");
  function _9e(t) {
    this.tokenChar(123), this.print(t.expression), this.rightBrace(t);
  }
  n(_9e, "JSXExpressionContainer");
  function L9e(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression), this.rightBrace(t);
  }
  n(L9e, "JSXSpreadChild");
  function B9e(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(B9e, "JSXText");
  function M9e(t) {
    let e = t.openingElement;
    if (this.print(e), !e.selfClosing) {
      this.indent();
      for (let s of t.children)
        this.print(s);
      this.dedent(), this.print(t.closingElement);
    }
  }
  n(M9e, "JSXElement");
  function F9e() {
    this.space();
  }
  n(F9e, "spaceSeparator");
  function j9e(t) {
    this.tokenChar(60), this.print(t.name), t.typeArguments && this.print(t.typeArguments), this.print(t.typeParameters), t.attributes.length >
    0 && (this.space(), this.printJoin(t.attributes, void 0, void 0, F9e)), t.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  n(j9e, "JSXOpeningElement");
  function R9e(t) {
    this.tokenChar(60), this.tokenChar(47), this.print(t.name), this.tokenChar(62);
  }
  n(R9e, "JSXClosingElement");
  function q9e() {
    this.printInnerComments();
  }
  n(q9e, "JSXEmptyExpression");
  function U9e(t) {
    this.print(t.openingFragment), this.indent();
    for (let e of t.children)
      this.print(e);
    this.dedent(), this.print(t.closingFragment);
  }
  n(U9e, "JSXFragment");
  function K9e() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(K9e, "JSXOpeningFragment");
  function V9e() {
    this.token("</"), this.tokenChar(62);
  }
  n(V9e, "JSXClosingFragment");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/typescript.js
var xW = g((Ye) => {
  "use strict";
  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.TSAnyKeyword = i7e;
  Ye.TSArrayType = A7e;
  Ye.TSSatisfiesExpression = Ye.TSAsExpression = V7e;
  Ye.TSBigIntKeyword = r7e;
  Ye.TSBooleanKeyword = l7e;
  Ye.TSCallSignatureDeclaration = G9e;
  Ye.TSInterfaceHeritage = Ye.TSClassImplements = R7e;
  Ye.TSConditionalType = D7e;
  Ye.TSConstructSignatureDeclaration = Q9e;
  Ye.TSConstructorType = T7e;
  Ye.TSDeclareFunction = Y9e;
  Ye.TSDeclareMethod = X9e;
  Ye.TSEnumBody = bW;
  Ye.TSEnumDeclaration = H7e;
  Ye.TSEnumMember = J7e;
  Ye.TSExportAssignment = eqe;
  Ye.TSExternalModuleReference = Q7e;
  Ye.TSFunctionType = g7e;
  Ye.TSImportEqualsDeclaration = G7e;
  Ye.TSImportType = z7e;
  Ye.TSIndexSignature = s7e;
  Ye.TSIndexedAccessType = B7e;
  Ye.TSInferType = O7e;
  Ye.TSInstantiationExpression = $7e;
  Ye.TSInterfaceBody = U7e;
  Ye.TSInterfaceDeclaration = q7e;
  Ye.TSIntersectionType = k7e;
  Ye.TSIntrinsicKeyword = m7e;
  Ye.TSLiteralType = j7e;
  Ye.TSMappedType = M7e;
  Ye.TSMethodSignature = t7e;
  Ye.TSModuleBlock = X7e;
  Ye.TSModuleDeclaration = Y7e;
  Ye.TSNamedTupleMember = I7e;
  Ye.TSNamespaceExportDeclaration = tqe;
  Ye.TSNeverKeyword = d7e;
  Ye.TSNonNullExpression = Z7e;
  Ye.TSNullKeyword = f7e;
  Ye.TSNumberKeyword = a7e;
  Ye.TSObjectKeyword = o7e;
  Ye.TSOptionalType = C7e;
  Ye.TSParameterProperty = J9e;
  Ye.TSParenthesizedType = _7e;
  Ye.TSPropertySignature = Z9e;
  Ye.TSQualifiedName = z9e;
  Ye.TSRestType = w7e;
  Ye.TSStringKeyword = u7e;
  Ye.TSSymbolKeyword = c7e;
  Ye.TSTemplateLiteralType = F7e;
  Ye.TSThisType = y7e;
  Ye.TSTupleType = v7e;
  Ye.TSTypeAliasDeclaration = K7e;
  Ye.TSTypeAnnotation = W9e;
  Ye.TSTypeAssertion = W7e;
  Ye.TSTypeLiteral = E7e;
  Ye.TSTypeOperator = L7e;
  Ye.TSTypeParameter = H9e;
  Ye.TSTypeParameterDeclaration = Ye.TSTypeParameterInstantiation = $9e;
  Ye.TSTypePredicate = S7e;
  Ye.TSTypeQuery = P7e;
  Ye.TSTypeReference = x7e;
  Ye.TSUndefinedKeyword = h7e;
  Ye.TSUnionType = N7e;
  Ye.TSUnknownKeyword = n7e;
  Ye.TSVoidKeyword = p7e;
  Ye.tsPrintClassMemberModifiers = iqe;
  Ye.tsPrintFunctionOrConstructorType = b7e;
  Ye.tsPrintPropertyOrMethodName = e7e;
  Ye.tsPrintSignatureDeclarationBase = sqe;
  function W9e(t, e) {
    this.token((e.type === "TSFunctionType" || e.type === "TSConstructorType") && e.typeAnnotation === t ? "=>" : ":"), this.space(), t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(W9e, "TSTypeAnnotation");
  function $9e(t, e) {
    this.tokenChar(60);
    let s = e.type === "ArrowFunctionExpression" && t.params.length === 1;
    this.tokenMap && t.start != null && t.end != null && (s && (s = !!this.tokenMap.find(t, (i) => this.tokenMap.matchesOriginal(i, ","))), s ||
    (s = this.shouldPrintTrailingComma(">"))), this.printList(t.params, s), this.tokenChar(62);
  }
  n($9e, "TSTypeParameterInstantiation");
  function H9e(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.default));
  }
  n(H9e, "TSTypeParameter");
  function J9e(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(J9e, "TSParameterProperty");
  function Y9e(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.semicolon();
  }
  n(Y9e, "TSDeclareFunction");
  function X9e(t) {
    this._classMethodHead(t), this.semicolon();
  }
  n(X9e, "TSDeclareMethod");
  function z9e(t) {
    this.print(t.left), this.tokenChar(46), this.print(t.right);
  }
  n(z9e, "TSQualifiedName");
  function G9e(t) {
    this.tsPrintSignatureDeclarationBase(t), gg(this, t);
  }
  n(G9e, "TSCallSignatureDeclaration");
  function gg(t, e) {
    if (!t.tokenMap || !e.start || !e.end) {
      t.semicolon();
      return;
    }
    t.tokenMap.endMatches(e, ",") ? t.token(",") : t.tokenMap.endMatches(e, ";") && t.semicolon();
  }
  n(gg, "maybePrintTrailingCommaOrSemicolon");
  function Q9e(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), gg(this, t);
  }
  n(Q9e, "TSConstructSignatureDeclaration");
  function Z9e(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation), gg(this, t);
  }
  n(Z9e, "TSPropertySignature");
  function e7e(t) {
    t.computed && this.tokenChar(91), this.print(t.key), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(e7e, "tsPrintPropertyOrMethodName");
  function t7e(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), gg(this, t);
  }
  n(t7e, "TSMethodSignature");
  function s7e(t) {
    let {
      readonly: e,
      static: s
    } = t;
    s && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    "]"), this.print(t.typeAnnotation), gg(this, t);
  }
  n(s7e, "TSIndexSignature");
  function i7e() {
    this.word("any");
  }
  n(i7e, "TSAnyKeyword");
  function r7e() {
    this.word("bigint");
  }
  n(r7e, "TSBigIntKeyword");
  function n7e() {
    this.word("unknown");
  }
  n(n7e, "TSUnknownKeyword");
  function a7e() {
    this.word("number");
  }
  n(a7e, "TSNumberKeyword");
  function o7e() {
    this.word("object");
  }
  n(o7e, "TSObjectKeyword");
  function l7e() {
    this.word("boolean");
  }
  n(l7e, "TSBooleanKeyword");
  function u7e() {
    this.word("string");
  }
  n(u7e, "TSStringKeyword");
  function c7e() {
    this.word("symbol");
  }
  n(c7e, "TSSymbolKeyword");
  function p7e() {
    this.word("void");
  }
  n(p7e, "TSVoidKeyword");
  function h7e() {
    this.word("undefined");
  }
  n(h7e, "TSUndefinedKeyword");
  function f7e() {
    this.word("null");
  }
  n(f7e, "TSNullKeyword");
  function d7e() {
    this.word("never");
  }
  n(d7e, "TSNeverKeyword");
  function m7e() {
    this.word("intrinsic");
  }
  n(m7e, "TSIntrinsicKeyword");
  function y7e() {
    this.word("this");
  }
  n(y7e, "TSThisType");
  function g7e(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(g7e, "TSFunctionType");
  function T7e(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(T7e, "TSConstructorType");
  function b7e(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")"), this.space();
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(b7e, "tsPrintFunctionOrConstructorType");
  function x7e(t) {
    let e = t.typeParameters;
    this.print(t.typeName, !!e), this.print(e);
  }
  n(x7e, "TSTypeReference");
  function S7e(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(S7e, "TSTypePredicate");
  function P7e(t) {
    this.word("typeof"), this.space(), this.print(t.exprName);
    let e = t.typeParameters;
    e && this.print(e);
  }
  n(P7e, "TSTypeQuery");
  function E7e(t) {
    Vx(this, t, () => this.printJoin(t.members, !0, !0));
  }
  n(E7e, "TSTypeLiteral");
  function A7e(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(A7e, "TSArrayType");
  function v7e(t) {
    this.tokenChar(91), this.printList(t.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  n(v7e, "TSTupleType");
  function C7e(t) {
    this.print(t.typeAnnotation), this.tokenChar(63);
  }
  n(C7e, "TSOptionalType");
  function w7e(t) {
    this.token("..."), this.print(t.typeAnnotation);
  }
  n(w7e, "TSRestType");
  function I7e(t) {
    this.print(t.label), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType);
  }
  n(I7e, "TSNamedTupleMember");
  function N7e(t) {
    TW(this, t, "|");
  }
  n(N7e, "TSUnionType");
  function k7e(t) {
    TW(this, t, "&");
  }
  n(k7e, "TSIntersectionType");
  function TW(t, e, s) {
    var i;
    let r = 0;
    (i = t.tokenMap) != null && i.startMatches(e, s) && (r = 1, t.token(s)), t.printJoin(e.types, void 0, void 0, function(a) {
      this.space(), this.token(s, null, a + r), this.space();
    });
  }
  n(TW, "tsPrintUnionOrIntersectionType");
  function D7e(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(D7e, "TSConditionalType");
  function O7e(t) {
    this.word("infer"), this.print(t.typeParameter);
  }
  n(O7e, "TSInferType");
  function _7e(t) {
    this.tokenChar(40), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(_7e, "TSParenthesizedType");
  function L7e(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation);
  }
  n(L7e, "TSTypeOperator");
  function B7e(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(B7e, "TSIndexedAccessType");
  function M7e(t) {
    let {
      nameType: e,
      optional: s,
      readonly: i,
      typeAnnotation: r
    } = t;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (yW(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(t.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(t.typeParameter.constraint), e && (this.space(), this.word("as"), this.space(), this.print(e)),
    this.tokenChar(93), s && (yW(this, s), this.tokenChar(63)), r && (this.tokenChar(58), this.space(), this.print(r)), this.space(), a(), this.
    tokenChar(125);
  }
  n(M7e, "TSMappedType");
  function yW(t, e) {
    e !== !0 && t.token(e);
  }
  n(yW, "tokenIfPlusMinus");
  function F7e(t) {
    this._printTemplate(t, t.types);
  }
  n(F7e, "TSTemplateLiteralType");
  function j7e(t) {
    this.print(t.literal);
  }
  n(j7e, "TSLiteralType");
  function R7e(t) {
    this.print(t.expression), this.print(t.typeArguments);
  }
  n(R7e, "TSClassImplements");
  function q7e(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      extends: r,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(s), this.print(i), r != null && r.length && (this.
    space(), this.word("extends"), this.space(), this.printList(r)), this.space(), this.print(a);
  }
  n(q7e, "TSInterfaceDeclaration");
  function U7e(t) {
    Vx(this, t, () => this.printJoin(t.body, !0, !0));
  }
  n(U7e, "TSInterfaceBody");
  function K7e(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      typeAnnotation: r
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(s), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(r), this.semicolon();
  }
  n(K7e, "TSTypeAliasDeclaration");
  function V7e(t) {
    let {
      type: e,
      expression: s,
      typeAnnotation: i
    } = t;
    this.print(s, !0), this.space(), this.word(e === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  n(V7e, "TSTypeExpression");
  function W7e(t) {
    let {
      typeAnnotation: e,
      expression: s
    } = t;
    this.tokenChar(60), this.print(e), this.tokenChar(62), this.space(), this.print(s);
  }
  n(W7e, "TSTypeAssertion");
  function $7e(t) {
    this.print(t.expression), this.print(t.typeParameters);
  }
  n($7e, "TSInstantiationExpression");
  function H7e(t) {
    let {
      declare: e,
      const: s,
      id: i
    } = t;
    e && (this.word("declare"), this.space()), s && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), bW.call(this, t);
  }
  n(H7e, "TSEnumDeclaration");
  function bW(t) {
    Vx(this, t, () => {
      var e;
      return this.printList(t.members, (e = this.shouldPrintTrailingComma("}")) != null ? e : !0, !0, !0);
    });
  }
  n(bW, "TSEnumBody");
  function J7e(t) {
    let {
      id: e,
      initializer: s
    } = t;
    this.print(e), s && (this.space(), this.tokenChar(61), this.space(), this.print(s));
  }
  n(J7e, "TSEnumMember");
  function Y7e(t) {
    let {
      declare: e,
      id: s,
      kind: i
    } = t;
    e && (this.word("declare"), this.space());
    {
      if (t.global || (this.word(i ?? (s.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(s), !t.body) {
        this.semicolon();
        return;
      }
      let r = t.body;
      for (; r.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(r.id), r = r.body;
      this.space(), this.print(r);
    }
  }
  n(Y7e, "TSModuleDeclaration");
  function X7e(t) {
    Vx(this, t, () => this.printSequence(t.body, !0));
  }
  n(X7e, "TSModuleBlock");
  function z7e(t) {
    let {
      argument: e,
      qualifier: s,
      options: i
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), s && (this.tokenChar(
    46), this.print(s));
    let r = t.typeParameters;
    r && this.print(r);
  }
  n(z7e, "TSImportType");
  function G7e(t) {
    let {
      id: e,
      moduleReference: s
    } = t;
    t.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(e), this.space(), this.tokenChar(61), this.
    space(), this.print(s), this.semicolon();
  }
  n(G7e, "TSImportEqualsDeclaration");
  function Q7e(t) {
    this.token("require("), this.print(t.expression), this.tokenChar(41);
  }
  n(Q7e, "TSExternalModuleReference");
  function Z7e(t) {
    this.print(t.expression), this.tokenChar(33);
  }
  n(Z7e, "TSNonNullExpression");
  function eqe(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression), this.semicolon();
  }
  n(eqe, "TSExportAssignment");
  function tqe(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id), this.semicolon();
  }
  n(tqe, "TSNamespaceExportDeclaration");
  function sqe(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")");
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(sqe, "tsPrintSignatureDeclarationBase");
  function iqe(t) {
    let e = t.type === "ClassPrivateProperty", s = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    gW(this, t, [s && t.declare && "declare", !e && t.accessibility]), t.static && (this.word("static"), this.space()), gW(this, t, [!e && t.
    abstract && "abstract", !e && t.override && "override", (s || e) && t.readonly && "readonly"]);
  }
  n(iqe, "tsPrintClassMemberModifiers");
  function Vx(t, e, s) {
    t.token("{");
    let i = t.enterDelimited();
    s(), i(), t.rightBrace(e);
  }
  n(Vx, "printBraced");
  function gW(t, e, s) {
    var i;
    let r = /* @__PURE__ */ new Set();
    for (let a of s)
      a && r.add(a);
    (i = t.tokenMap) == null || i.find(e, (a) => {
      if (r.has(a.value))
        return t.token(a.value), t.space(), r.delete(a.value), r.size === 0;
    });
    for (let a of r)
      t.word(a), t.space();
  }
  n(gW, "printModifiersList");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/index.js
var SW = g((Is) => {
  "use strict";
  Object.defineProperty(Is, "__esModule", {
    value: !0
  });
  var sk = YV();
  Object.keys(sk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === sk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return sk[t];
      }, "get")
    });
  });
  var ik = zV();
  Object.keys(ik).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === ik[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ik[t];
      }, "get")
    });
  });
  var rk = eW();
  Object.keys(rk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === rk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return rk[t];
      }, "get")
    });
  });
  var nk = tW();
  Object.keys(nk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === nk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return nk[t];
      }, "get")
    });
  });
  var ak = sW();
  Object.keys(ak).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === ak[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ak[t];
      }, "get")
    });
  });
  var ok = QN();
  Object.keys(ok).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === ok[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ok[t];
      }, "get")
    });
  });
  var lk = ek();
  Object.keys(lk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === lk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return lk[t];
      }, "get")
    });
  });
  var uk = fW();
  Object.keys(uk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === uk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return uk[t];
      }, "get")
    });
  });
  var ck = dW();
  Object.keys(ck).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === ck[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ck[t];
      }, "get")
    });
  });
  var pk = mW();
  Object.keys(pk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === pk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return pk[t];
      }, "get")
    });
  });
  var hk = xW();
  Object.keys(hk).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Is && Is[t] === hk[t] || Object.defineProperty(Is, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return hk[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/generators/deprecated.js
var PW = g((fk) => {
  "use strict";
  Object.defineProperty(fk, "__esModule", {
    value: !0
  });
  fk.addDeprecatedGenerators = rqe;
  function rqe(t) {
    {
      let e = {
        Noop() {
        },
        TSExpressionWithTypeArguments(s) {
          this.print(s.expression), this.print(s.typeParameters);
        },
        DecimalLiteral(s) {
          let i = this.getPossibleRaw(s);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(s.value + "m");
        }
      };
      Object.assign(t.prototype, e);
    }
  }
  n(rqe, "addDeprecatedGenerators");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/printer.js
var CW = g((Wx) => {
  "use strict";
  Object.defineProperty(Wx, "__esModule", {
    value: !0
  });
  Wx.default = void 0;
  var nqe = kV(), AW = Dc(), aqe = fe(), oqe = JV(), lqe = SW(), uqe = PW(), {
    isExpression: cqe,
    isFunction: pqe,
    isStatement: hqe,
    isClassBody: fqe,
    isTSInterfaceBody: dqe,
    isTSEnumMember: mqe
  } = aqe, yqe = /e/i, gqe = /\.0+$/, vW = /[\n\r\u2028\u2029]/, Tqe = /[\n\r\u2028\u2029]|\*\//;
  function EW(t) {
    return t.type === "CommentLine" || vW.test(t.value);
  }
  n(EW, "commentIsNewline");
  var {
    needsParens: bqe
  } = AW, Tg = class {
    static {
      n(this, "Printer");
    }
    constructor(e, s, i, r) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e,
      this._tokens = i, this._originalCode = r, this._indentRepeat = e.indent.style.length, this._inputMap = s?._inputMap, this._buf = new nqe.
      default(s, e.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let e = this.inForStatementInit, s = this._noLineTerminatorAfterNode;
      return e === !1 && s === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = e, this._noLineTerminatorAfterNode = s;
      });
    }
    generate(e) {
      return this.format.preserveFormat && (this.tokenMap = new oqe.TokenMap(e, this._tokens, this._originalCode)), this.print(e), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent++;
    }
    dedent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent--;
    }
    semicolon(e = !1) {
      if (this._maybeAddAuxComment(), e) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let s = this._currentNode;
        if (s.start != null && s.end != null) {
          if (!this.tokenMap.endMatches(s, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      let {
        format: s
      } = this;
      if (!(s.compact || s.preserveFormat)) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(e, s = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(e), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e), (this.
      _endsWithWord || this._endsWithDiv && e.charCodeAt(0) === 47) && this._space(), this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator =
      s;
    }
    number(e, s) {
      function i(r) {
        if (r.length > 2 && r.charCodeAt(0) === 48) {
          let a = r.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(i, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(s) && !i(e) && !yqe.test(e) && !gqe.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, s = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(e, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e,
      i);
      let r = this.getLastChar(), a = e.charCodeAt(0);
      (r === 33 && (e === "--" || a === 61) || a === 43 && r === 43 || a === 45 && r === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(e, s), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this.tokenContext = 0;
      let s = String.fromCharCode(e);
      this._maybePrintInnerComments(s), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(s);
      let i = this.getLastChar();
      (e === 43 && i === 43 || e === 45 && i === 45 || e === 46 && this._endsWithInteger) && this._space(), this._appendChar(e), this._noLineTerminator =
      !1;
    }
    newline(e = 1, s) {
      if (!(e <= 0)) {
        if (!s) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let i = 0; i < e; i++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, s) {
      if (!e) {
        s();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, s);
    }
    source(e, s) {
      s && (this._catchUp(e, s), this._buf.source(e, s));
    }
    sourceWithOffset(e, s, i) {
      !s || this.format.preserveFormat || (this._catchUp(e, s), this._buf.sourceWithOffset(e, s, i));
    }
    sourceIdentifierName(e, s) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = s, i.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(e, s = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, e, s);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(e, s) {
      this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, s), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(e) {
      this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(e) {
      this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let s = e - this._buf.getCurrentLine();
      for (let i = 0; i < s; i++)
        this._newline();
    }
    _catchUp(e, s) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && s != null && s[e] && this.catchUp(s[e].line);
        return;
      }
      let r = s?.[e];
      r != null && this._catchUpTo(r);
    }
    _catchUpTo({
      line: e,
      column: s,
      index: i
    }) {
      let r = e - this._buf.getCurrentLine();
      if (r > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < r; o++)
        this._newline();
      let a = r > 0 ? s : s - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e) {
      this._noLineTerminator = !0, this.print(e);
    }
    print(e, s, i) {
      var r, a, o;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let l = e.type, u = this.format, c = u.concise;
      e._compact && (u.concise = !0);
      let p = this[l];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(e.constructor.name)}`);
      let h = this._currentNode;
      this._currentNode = e, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let f = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !f);
      let d = (r = e.extra) == null ? void 0 : r.parenthesized, y = d && u.preserveFormat || d && u.retainFunctionParens && l === "FunctionE\
xpression" || bqe(e, h, this.tokenContext, this.inForStatementInit, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!y && d && (a = e.leadingComments) != null && a.length && e.leadingComments[0].type === "CommentBlock")
        switch (h?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (h.callee !== e) break;
          default:
            y = !0;
        }
      let m = !1;
      !y && this._noLineTerminator && ((o = e.leadingComments) != null && o.some(EW) || this.format.retainLines && e.loc && e.loc.start.line >
      this._buf.getCurrentLine()) && (y = !0, m = !0);
      let T, b;
      if (!y && (s || (s = h && this._noLineTerminatorAfterNode === h && AW.isLastChild(h, e)), s)) {
        var E;
        (E = e.trailingComments) != null && E.some(EW) ? cqe(e) && (y = !0) : (T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        e);
      }
      y && (this.tokenChar(40), m && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (b = !0, this.inForStatementInit =
      !1), T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      e, h);
      let w = l === "Program" || l === "File" ? null : e.loc;
      this.exactSource(w, p.bind(this, e, h)), y ? (this._printTrailingComments(e, h), m && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = s, b && (this.inForStatementInit = !0)) : s && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(e, h)) : this._printTrailingComments(e, h, i), this._currentNode = h, u.concise = c, this._insideAux = f, T !==
      void 0 && (this._noLineTerminatorAfterNode = T), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let s = e.extra;
      if (s?.raw != null && s.rawValue != null && e.value === s.rawValue)
        return s.raw;
    }
    printJoin(e, s, i, r, a, o, l, u) {
      if (!(e != null && e.length)) return;
      if (i == null && this.format.retainLines) {
        var c;
        let m = (c = e[0].loc) == null ? void 0 : c.start.line;
        m != null && m !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let p = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, h = r?.bind(this), f = e.length;
      for (let m = 0; m < f; m++) {
        let T = e[m];
        if (T && (s && this._printNewline(m === 0, p), this.print(T, void 0, u || 0), l?.(T, m), h != null && (m < f - 1 ? h(m, !1) : a && h(
        m, !0)), s)) {
          var d;
          if ((d = T.trailingComments) != null && d.length || (this._lastCommentLine = 0), m + 1 === f)
            this.newline(1);
          else {
            var y;
            let b = e[m + 1];
            p.nextNodeStartLine = ((y = b.loc) == null ? void 0 : y.start.line) || 0, this._printNewline(!0, p);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e), s && this.dedent();
    }
    printBlock(e) {
      let s = e.body;
      s.type !== "EmptyStatement" && this.space(), this.print(s);
    }
    _printTrailingComments(e, s, i) {
      let {
        innerComments: r,
        trailingComments: a
      } = e;
      r != null && r.length && this._printComments(2, r, e, s, i), a != null && a.length && this._printComments(2, a, e, s, i);
    }
    _printLeadingComments(e, s) {
      let i = e.leadingComments;
      i != null && i.length && this._printComments(0, i, e, s);
    }
    _maybePrintInnerComments(e, s) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, e, s));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(e) {
      let s = this._currentNode, i = s.innerComments;
      if (!(i != null && i.length)) return;
      let r = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, s, void 0, void 0, e), r && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, s, i, r) {
      this.printJoin(e, !0, s ?? !1, void 0, void 0, r, void 0, i);
    }
    printList(e, s, i, r, a, o) {
      this.printJoin(e, i, r, a ?? xqe, s, void 0, o);
    }
    shouldPrintTrailingComma(e) {
      if (!this.tokenMap) return null;
      let s = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, e));
      return s <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[s - 1], ",");
    }
    _printNewline(e, s) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let r = s.nextNodeStartLine, a = this._lastCommentLine;
      if (r > 0 && a > 0) {
        let o = r - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e, s) {
      if (e.ignore || this._printedComments.has(e)) return 0;
      if (this._noLineTerminator && Tqe.test(e.value))
        return 2;
      if (s && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (r) => r.value === e.value);
        if (i && i.start > s.start)
          return 2;
      }
      return this._printedComments.add(e), this.format.shouldPrintComment(e.value) ? 1 : 0;
    }
    _printComment(e, s) {
      let i = this._noLineTerminator, r = e.type === "CommentBlock", a = r && s !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && s !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (r) {
        if (l = `/*${e.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let c = (u = e.loc) == null ? void 0 : u.start.column;
          if (c) {
            let p = new RegExp("\\n\\s{1," + c + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else i ? l = `/*${e.value}*/` : l = `//${e.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: p
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e.loc), this._append(l, r), this.
        _printSemicolonBeforeNextNode = p, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", e.loc), this._append(l, r);
      !r && !i && this.newline(1, !0), a && s !== 3 && this.newline(1);
    }
    _printComments(e, s, i, r, a = 0, o) {
      let l = i.loc, u = s.length, c = !!l, p = c ? l.start.line : 0, h = c ? l.end.line : 0, f = 0, d = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let m = 0; m < u; m++) {
        let T = s[m], b = this._shouldPrintComment(T, o);
        if (b === 2) {
          c = !1;
          break;
        }
        if (c && T.loc && b === 1) {
          let E = T.loc.start.line, w = T.loc.end.line;
          if (e === 0) {
            let K = 0;
            m === 0 ? this._buf.hasContent() && (T.type === "CommentLine" || E !== w) && (K = d = 1) : K = E - f, f = w, y(K), this._printComment(
            T, 1), m + 1 === u && (y(Math.max(p - f, d)), f = p);
          } else if (e === 1) {
            let K = E - (m === 0 ? p : f);
            f = w, y(K), this._printComment(T, 1), m + 1 === u && (y(Math.min(1, h - f)), f = h);
          } else {
            let K = E - (m === 0 ? h - a : f);
            f = w, y(K), this._printComment(T, 1);
          }
        } else {
          if (c = !1, b !== 1)
            continue;
          if (u === 1) {
            let E = T.loc ? T.loc.start.line === T.loc.end.line : !vW.test(T.value), w = E && !hqe(i) && !fqe(r) && !dqe(r) && !mqe(i);
            e === 0 ? this._printComment(T, w && i.type !== "ObjectExpression" || E && pqe(r, {
              body: i
            }) ? 1 : 0) : w && e === 2 ? this._printComment(T, 1) : this._printComment(T, 0);
          } else e === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(T, m === 0 ? 2 : m === u - 1 ? 3 : 0) : this._printComment(T, 0);
        }
      }
      e === 2 && c && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(Tg.prototype, lqe);
  (0, uqe.addDeprecatedGenerators)(Tg);
  var K9s = Wx.default = Tg;
  function xqe(t, e) {
    this.token(",", !1, t), e || this.space();
  }
  n(xqe, "commaSeparator");
});

// ../node_modules/@babel/core/node_modules/@babel/generator/lib/index.js
var $x = g((Td) => {
  "use strict";
  Object.defineProperty(Td, "__esModule", {
    value: !0
  });
  Td.default = void 0;
  Td.generate = kW;
  var wW = NV(), IW = CW();
  function NW(t, e, s) {
    if (e.experimental_preserveFormat) {
      if (typeof t != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!e.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (e.compact && e.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (e.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (e.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(s.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      preserveFormat: e.experimental_preserveFormat,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var r;
      i.decoratorsBeforeExport = e.decoratorsBeforeExport, i.jsescOption.json = e.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (r = e.
      recordAndTupleSyntaxType) != null ? r : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((u) => i.comments || u.includes("@license") || u.includes("@preserve")), i.compact === "auto" && (i.compact = typeof t == "string" && t.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = i;
    return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  n(NW, "normalizeOptions");
  Td.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, s = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = NW(i, s, e), this._map = s.sourceMaps ? new wW.
      default(s, i) : null;
    }
    generate() {
      return new IW.default(this._format, this._map).generate(this._ast);
    }
  };
  function kW(t, e = {}, s) {
    let i = NW(s, e, t), r = e.sourceMaps ? new wW.default(e, s) : null;
    return new IW.default(i, r, t.tokens, typeof s == "string" ? s : null).generate(t);
  }
  n(kW, "generate");
  var H9s = Td.default = kW;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/ancestry.js
var DW = g((ka) => {
  "use strict";
  Object.defineProperty(ka, "__esModule", {
    value: !0
  });
  ka.find = Aqe;
  ka.findParent = Eqe;
  ka.getAncestry = Nqe;
  ka.getDeepestCommonAncestorFrom = Iqe;
  ka.getEarliestCommonAncestorFrom = wqe;
  ka.getFunctionParent = vqe;
  ka.getStatementParent = Cqe;
  ka.inType = Oqe;
  ka.isAncestor = kqe;
  ka.isDescendant = Dqe;
  var Sqe = fe(), {
    VISITOR_KEYS: Pqe
  } = Sqe;
  function Eqe(t) {
    let e = this;
    for (; e = e.parentPath; )
      if (t(e)) return e;
    return null;
  }
  n(Eqe, "findParent");
  function Aqe(t) {
    let e = this;
    do
      if (t(e)) return e;
    while (e = e.parentPath);
    return null;
  }
  n(Aqe, "find");
  function vqe() {
    return this.findParent((t) => t.isFunction());
  }
  n(vqe, "getFunctionParent");
  function Cqe() {
    let t = this;
    do {
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        break;
      t = t.parentPath;
    } while (t);
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return t;
  }
  n(Cqe, "getStatementParent");
  function wqe(t) {
    return this.getDeepestCommonAncestorFrom(t, function(e, s, i) {
      let r, a = Pqe[e.type];
      for (let o of i) {
        let l = o[s + 1];
        if (!r) {
          r = l;
          continue;
        }
        if (l.listKey && r.listKey === l.listKey && l.key < r.key) {
          r = l;
          continue;
        }
        let u = a.indexOf(r.parentKey), c = a.indexOf(l.parentKey);
        u > c && (r = l);
      }
      return r;
    });
  }
  n(wqe, "getEarliestCommonAncestorFrom");
  function Iqe(t, e) {
    if (!t.length)
      return this;
    if (t.length === 1)
      return t[0];
    let s = 1 / 0, i, r, a = t.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < s && (s = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < s; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      i = l, r = u;
    }
    if (r)
      return e ? e(r, i, a) : r;
    throw new Error("Couldn't find intersection");
  }
  n(Iqe, "getDeepestCommonAncestorFrom");
  function Nqe() {
    let t = this, e = [];
    do
      e.push(t);
    while (t = t.parentPath);
    return e;
  }
  n(Nqe, "getAncestry");
  function kqe(t) {
    return t.isDescendant(this);
  }
  n(kqe, "isAncestor");
  function Dqe(t) {
    return !!this.findParent((e) => e === t);
  }
  n(Dqe, "isDescendant");
  function Oqe(...t) {
    let e = this;
    for (; e; ) {
      for (let s of t)
        if (e.node.type === s) return !0;
      e = e.parentPath;
    }
    return !1;
  }
  n(Oqe, "inType");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/util.js
var mk = g((dk) => {
  "use strict";
  Object.defineProperty(dk, "__esModule", {
    value: !0
  });
  dk.createUnionType = Fqe;
  var _qe = fe(), {
    createFlowUnionType: OW,
    createTSUnionType: _W,
    createUnionTypeAnnotation: Lqe,
    isFlowType: Bqe,
    isTSType: Mqe
  } = _qe;
  function Fqe(t) {
    {
      if (t.every((e) => Bqe(e)))
        return OW ? OW(t) : Lqe(t);
      if (t.every((e) => Mqe(e)) && _W)
        return _W(t);
    }
  }
  n(Fqe, "createUnionType");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var jW = g((yk) => {
  "use strict";
  Object.defineProperty(yk, "__esModule", {
    value: !0
  });
  yk.default = Kqe;
  var jqe = fe(), BW = mk(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: Rqe,
    createTypeAnnotationBasedOnTypeof: qqe,
    numberTypeAnnotation: MW,
    voidTypeAnnotation: Uqe
  } = jqe;
  function Kqe(t) {
    if (!this.isReferenced()) return;
    let e = this.scope.getBinding(t.name);
    if (e)
      return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : Vqe(e, this, t.name);
    if (t.name === "undefined")
      return Uqe();
    if (t.name === "NaN" || t.name === "Infinity")
      return MW();
    t.name;
  }
  n(Kqe, "_default");
  function Vqe(t, e, s) {
    let i = [], r = [], a = LW(t, e, r), o = FW(t, e, s);
    if (o) {
      let l = LW(t, o.ifStatement);
      a = a.filter((u) => !l.includes(u)), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...r);
      for (let l of a)
        i.push(l.getTypeAnnotation());
    }
    if (i.length)
      return (0, BW.createUnionType)(i);
  }
  n(Vqe, "getTypeAnnotationBindingConstantViolations");
  function LW(t, e, s) {
    let i = t.constantViolations.slice();
    return i.unshift(t.path), i.filter((r) => {
      r = r.resolve();
      let a = r._guessExecutionStatusRelativeTo(e);
      return s && a === "unknown" && s.push(r), a === "before";
    });
  }
  n(LW, "getConstantViolationsBefore");
  function Wqe(t, e) {
    let s = e.node.operator, i = e.get("right").resolve(), r = e.get("left").resolve(), a;
    if (r.isIdentifier({
      name: t
    }) ? a = i : i.isIdentifier({
      name: t
    }) && (a = r), a)
      return s === "===" ? a.getTypeAnnotation() : Rqe.includes(s) ? MW() : void 0;
    if (s !== "===" && s !== "==") return;
    let o, l;
    if (r.isUnaryExpression({
      operator: "typeof"
    }) ? (o = r, l = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, l = r), !o || !o.get("argument").isIdentifier({
      name: t
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return qqe(u);
  }
  n(Wqe, "inferAnnotationFromBinaryExpression");
  function $qe(t, e, s) {
    let i;
    for (; i = e.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return e.key === "test" ? void 0 : i;
      if (i.isFunction() && i.parentPath.scope.getBinding(s) !== t)
        return;
      e = i;
    }
  }
  n($qe, "getParentConditionalPath");
  function FW(t, e, s) {
    let i = $qe(t, e, s);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = Wqe(s, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, BW.createUnionType)(o),
      ifStatement: i
    } : FW(t, i, s);
  }
  n(FW, "getConditionalAnnotation");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferers.js
var HW = g(($s) => {
  "use strict";
  Object.defineProperty($s, "__esModule", {
    value: !0
  });
  $s.ArrayExpression = VW;
  $s.AssignmentExpression = dUe;
  $s.BinaryExpression = uUe;
  $s.BooleanLiteral = TUe;
  $s.CallExpression = wUe;
  $s.ConditionalExpression = pUe;
  $s.ClassDeclaration = $s.ClassExpression = $s.FunctionDeclaration = $s.ArrowFunctionExpression = $s.FunctionExpression = PUe;
  Object.defineProperty($s, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jqe.default;
    }, "get")
  });
  $s.LogicalExpression = cUe;
  $s.NewExpression = aUe;
  $s.NullLiteral = bUe;
  $s.NumericLiteral = gUe;
  $s.ObjectExpression = SUe;
  $s.ParenthesizedExpression = fUe;
  $s.RegExpLiteral = xUe;
  $s.RestElement = WW;
  $s.SequenceExpression = hUe;
  $s.StringLiteral = yUe;
  $s.TSAsExpression = KW;
  $s.TSNonNullExpression = nUe;
  $s.TaggedTemplateExpression = IUe;
  $s.TemplateLiteral = oUe;
  $s.TypeCastExpression = UW;
  $s.UnaryExpression = lUe;
  $s.UpdateExpression = mUe;
  $s.VariableDeclarator = rUe;
  var Hqe = fe(), Jqe = jW(), qW = mk(), {
    BOOLEAN_BINARY_OPERATORS: Yqe,
    BOOLEAN_UNARY_OPERATORS: Xqe,
    NUMBER_BINARY_OPERATORS: zqe,
    NUMBER_UNARY_OPERATORS: Gqe,
    STRING_UNARY_OPERATORS: Qqe,
    anyTypeAnnotation: RW,
    arrayTypeAnnotation: gk,
    booleanTypeAnnotation: Tk,
    buildMatchMemberExpression: Hx,
    genericTypeAnnotation: _c,
    identifier: hh,
    nullLiteralTypeAnnotation: Zqe,
    numberTypeAnnotation: bd,
    stringTypeAnnotation: fh,
    tupleTypeAnnotation: eUe,
    unionTypeAnnotation: tUe,
    voidTypeAnnotation: sUe,
    isIdentifier: iUe
  } = Hqe;
  function rUe() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(rUe, "VariableDeclarator");
  function UW(t) {
    return t.typeAnnotation;
  }
  n(UW, "TypeCastExpression");
  UW.validParent = !0;
  function KW(t) {
    return t.typeAnnotation;
  }
  n(KW, "TSAsExpression");
  KW.validParent = !0;
  function nUe() {
    return this.get("expression").getTypeAnnotation();
  }
  n(nUe, "TSNonNullExpression");
  function aUe(t) {
    if (t.callee.type === "Identifier")
      return _c(t.callee);
  }
  n(aUe, "NewExpression");
  function oUe() {
    return fh();
  }
  n(oUe, "TemplateLiteral");
  function lUe(t) {
    let e = t.operator;
    if (e === "void")
      return sUe();
    if (Gqe.includes(e))
      return bd();
    if (Qqe.includes(e))
      return fh();
    if (Xqe.includes(e))
      return Tk();
  }
  n(lUe, "UnaryExpression");
  function uUe(t) {
    let e = t.operator;
    if (zqe.includes(e))
      return bd();
    if (Yqe.includes(e))
      return Tk();
    if (e === "+") {
      let s = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && s.isBaseType("number") ? bd() : i.isBaseType("string") || s.isBaseType("string") ? fh() : tUe([fh(), bd()]);
    }
  }
  n(uUe, "BinaryExpression");
  function cUe() {
    let t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, qW.createUnionType)(t);
  }
  n(cUe, "LogicalExpression");
  function pUe() {
    let t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, qW.createUnionType)(t);
  }
  n(pUe, "ConditionalExpression");
  function hUe() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(hUe, "SequenceExpression");
  function fUe() {
    return this.get("expression").getTypeAnnotation();
  }
  n(fUe, "ParenthesizedExpression");
  function dUe() {
    return this.get("right").getTypeAnnotation();
  }
  n(dUe, "AssignmentExpression");
  function mUe(t) {
    let e = t.operator;
    if (e === "++" || e === "--")
      return bd();
  }
  n(mUe, "UpdateExpression");
  function yUe() {
    return fh();
  }
  n(yUe, "StringLiteral");
  function gUe() {
    return bd();
  }
  n(gUe, "NumericLiteral");
  function TUe() {
    return Tk();
  }
  n(TUe, "BooleanLiteral");
  function bUe() {
    return Zqe();
  }
  n(bUe, "NullLiteral");
  function xUe() {
    return _c(hh("RegExp"));
  }
  n(xUe, "RegExpLiteral");
  function SUe() {
    return _c(hh("Object"));
  }
  n(SUe, "ObjectExpression");
  function VW() {
    return _c(hh("Array"));
  }
  n(VW, "ArrayExpression");
  function WW() {
    return VW();
  }
  n(WW, "RestElement");
  WW.validParent = !0;
  function PUe() {
    return _c(hh("Function"));
  }
  n(PUe, "Func");
  var EUe = Hx("Array.from"), AUe = Hx("Object.keys"), vUe = Hx("Object.values"), CUe = Hx("Object.entries");
  function wUe() {
    let {
      callee: t
    } = this.node;
    return AUe(t) ? gk(fh()) : EUe(t) || vUe(t) || iUe(t, {
      name: "Array"
    }) ? gk(RW()) : CUe(t) ? gk(eUe([fh(), RW()])) : $W(this.get("callee"));
  }
  n(wUe, "CallExpression");
  function IUe() {
    return $W(this.get("tag"));
  }
  n(IUe, "TaggedTemplateExpression");
  function $W(t) {
    if (t = t.resolve(), t.isFunction()) {
      let {
        node: e
      } = t;
      if (e.async)
        return e.generator ? _c(hh("AsyncIterator")) : _c(hh("Promise"));
      if (e.generator)
        return _c(hh("Iterator"));
      if (t.node.returnType)
        return t.node.returnType;
    }
  }
  n($W, "resolveCall");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/index.js
var GW = g((Lc) => {
  "use strict";
  Object.defineProperty(Lc, "__esModule", {
    value: !0
  });
  Lc._getTypeAnnotation = zW;
  Lc.baseTypeStrictlyMatches = zUe;
  Lc.couldBeBaseType = XUe;
  Lc.getTypeAnnotation = JUe;
  Lc.isBaseType = YUe;
  Lc.isGenericType = GUe;
  var JW = HW(), NUe = fe(), {
    anyTypeAnnotation: XW,
    isAnyTypeAnnotation: Jx,
    isArrayTypeAnnotation: kUe,
    isBooleanTypeAnnotation: DUe,
    isEmptyTypeAnnotation: OUe,
    isFlowBaseAnnotation: _Ue,
    isGenericTypeAnnotation: LUe,
    isIdentifier: YW,
    isMixedTypeAnnotation: BUe,
    isNumberTypeAnnotation: MUe,
    isStringTypeAnnotation: FUe,
    isTSArrayType: jUe,
    isTSTypeAnnotation: RUe,
    isTSTypeReference: qUe,
    isTupleTypeAnnotation: UUe,
    isTypeAnnotation: KUe,
    isUnionTypeAnnotation: VUe,
    isVoidTypeAnnotation: WUe,
    stringTypeAnnotation: $Ue,
    voidTypeAnnotation: HUe
  } = NUe;
  function JUe() {
    let t = this.getData("typeAnnotation");
    return t != null || (t = zW.call(this) || XW(), (KUe(t) || RUe(t)) && (t = t.typeAnnotation), this.setData("typeAnnotation", t)), t;
  }
  n(JUe, "getTypeAnnotation");
  var bk = /* @__PURE__ */ new WeakSet();
  function zW() {
    let t = this.node;
    if (!t)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let s = this.parentPath.parentPath, i = s.parentPath;
        return s.key === "left" && i.isForInStatement() ? $Ue() : s.key === "left" && i.isForOfStatement() ? XW() : HUe();
      } else
        return;
    if (t.typeAnnotation)
      return t.typeAnnotation;
    if (!bk.has(t)) {
      bk.add(t);
      try {
        var e;
        let s = JW[t.type];
        if (s)
          return s.call(this, t);
        if (s = JW[this.parentPath.type], (e = s) != null && e.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        bk.delete(t);
      }
    }
  }
  n(zW, "_getTypeAnnotation");
  function YUe(t, e) {
    return xk(t, this.getTypeAnnotation(), e);
  }
  n(YUe, "isBaseType");
  function xk(t, e, s) {
    if (t === "string")
      return FUe(e);
    if (t === "number")
      return MUe(e);
    if (t === "boolean")
      return DUe(e);
    if (t === "any")
      return Jx(e);
    if (t === "mixed")
      return BUe(e);
    if (t === "empty")
      return OUe(e);
    if (t === "void")
      return WUe(e);
    if (s)
      return !1;
    throw new Error(`Unknown base type ${t}`);
  }
  n(xk, "_isBaseType");
  function XUe(t) {
    let e = this.getTypeAnnotation();
    if (Jx(e)) return !0;
    if (VUe(e)) {
      for (let s of e.types)
        if (Jx(s) || xk(t, s, !0))
          return !0;
      return !1;
    } else
      return xk(t, e, !0);
  }
  n(XUe, "couldBeBaseType");
  function zUe(t) {
    let e = this.getTypeAnnotation(), s = t.getTypeAnnotation();
    return !Jx(e) && _Ue(e) ? s.type === e.type : !1;
  }
  n(zUe, "baseTypeStrictlyMatches");
  function GUe(t) {
    let e = this.getTypeAnnotation();
    return t === "Array" && (jUe(e) || kUe(e) || UUe(e)) ? !0 : LUe(e) && YW(e.id, {
      name: t
    }) || qUe(e) && YW(e.typeName, {
      name: t
    });
  }
  n(GUe, "isGenericType");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var QW = g((Yx) => {
  "use strict";
  Object.defineProperty(Yx, "__esModule", {
    value: !0
  });
  Yx.hooks = void 0;
  var n7s = Yx.hooks = [function(t, e) {
    if (t.key === "test" && (e.isWhile() || e.isSwitchCase()) || t.key === "declaration" && e.isExportDeclaration() || t.key === "body" && e.
    isLabeledStatement() || t.listKey === "declarations" && e.isVariableDeclaration() && e.node.declarations.length === 1 || t.key === "expr\
ession" && e.isExpressionStatement())
      return e.remove(), !0;
  }, function(t, e) {
    if (e.isSequenceExpression() && e.node.expressions.length === 1)
      return e.replaceWith(e.node.expressions[0]), !0;
  }, function(t, e) {
    if (e.isBinary())
      return t.key === "left" ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0;
  }, function(t, e) {
    if (e.isIfStatement() && t.key === "consequent" || t.key === "body" && (e.isLoop() || e.isArrowFunctionExpression()))
      return t.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/removal.js
var Xx = g((Bc) => {
  "use strict";
  Object.defineProperty(Bc, "__esModule", {
    value: !0
  });
  Bc._assertUnremoved = i$;
  Bc._callRemovalHooks = t$;
  Bc._markRemoved = Sk;
  Bc._remove = s$;
  Bc._removeFromScope = e$;
  Bc.remove = nKe;
  var QUe = QW(), ZUe = oh(), eKe = Pk(), ZW = Mc(), tKe = fe(), sKe = zx(), iKe = tl(), {
    getBindingIdentifiers: rKe
  } = tKe;
  function nKe() {
    var t;
    if (i$.call(this), iKe.resync.call(this), t$.call(this)) {
      Sk.call(this);
      return;
    }
    (t = this.opts) != null && t.noScope || e$.call(this), this.shareCommentsWithSiblings(), s$.call(this), Sk.call(this);
  }
  n(nKe, "remove");
  function e$() {
    let t = rKe(this.node, !1, !1, !0);
    Object.keys(t).forEach((e) => this.scope.removeBinding(e));
  }
  n(e$, "_removeFromScope");
  function t$() {
    if (this.parentPath) {
      for (let t of QUe.hooks)
        if (t(this, this.parentPath)) return !0;
    }
  }
  n(t$, "_callRemovalHooks");
  function s$() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), sKe.updateSiblingKeys.call(this, this.key, -1)) : eKe._replaceWith.
    call(this, null);
  }
  n(s$, "_remove");
  function Sk() {
    this._traverseFlags |= ZW.SHOULD_SKIP | ZW.REMOVED, this.parent && (0, ZUe.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  n(Sk, "_markRemoved");
  function i$() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(i$, "_assertUnremoved");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/hoister.js
var n$ = g((Gx) => {
  "use strict";
  Object.defineProperty(Gx, "__esModule", {
    value: !0
  });
  Gx.default = void 0;
  var r$ = fe(), aKe = r$, {
    react: oKe
  } = r$, {
    cloneNode: lKe,
    jsxExpressionContainer: uKe,
    variableDeclaration: cKe,
    variableDeclarator: pKe
  } = aKe, hKe = {
    ReferencedIdentifier(t, e) {
      if (t.isJSXIdentifier() && oKe.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression())
        return;
      if (t.node.name === "this") {
        let i = t.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && e.breakOnScopePaths.push(i.path);
      }
      let s = t.scope.getBinding(t.node.name);
      if (s) {
        for (let i of s.constantViolations)
          if (i.scope !== s.path.scope) {
            e.mutableBinding = !0, t.stop();
            return;
          }
        s === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = s);
      }
    }
  }, Ek = class {
    static {
      n(this, "PathHoister");
    }
    constructor(e, s) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = s, this.path = e, this.attachAfter = !1;
    }
    isCompatibleScope(e) {
      for (let s of Object.keys(this.bindings)) {
        let i = this.bindings[s];
        if (!e.bindingIdentifierEquals(s, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let e = this.path.scope;
      do {
        if (this.isCompatibleScope(e))
          this.scopes.push(e);
        else
          break;
        if (this.breakOnScopePaths.includes(e.path))
          break;
      } while (e = e.parent);
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath();
      if (!e) return;
      let s = e.scope;
      if (s.path === e && (s = e.scope.parent), s.path.isProgram() || s.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!s.hasOwnBinding(i)) continue;
          let r = this.bindings[i];
          if (r.kind === "param" || r.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(r.path).key >= e.key) {
            this.attachAfter = !0, e = r.path;
            for (let o of r.constantViolations)
              this.getAttachmentParentForPath(o).key > e.key && (e = o);
          }
        }
      return e;
    }
    _getAttachmentPath() {
      let s = this.scopes.pop();
      if (s) {
        if (s.path.isFunction())
          if (this.hasOwnParamBindings(s)) {
            if (this.scope === s) return;
            let i = s.path.get("body").get("body");
            for (let r = 0; r < i.length; r++)
              if (!i[r].node._blockHoist)
                return i[r];
          } else
            return this.getNextScopeAttachmentParent();
        else if (s.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let e = this.scopes.pop();
      if (e) return this.getAttachmentParentForPath(e.path);
    }
    getAttachmentParentForPath(e) {
      do
        if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
          return e;
      while (e = e.parentPath);
    }
    hasOwnParamBindings(e) {
      for (let s of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(s)) continue;
        let i = this.bindings[s];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(hKe, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let e = this.getAttachmentPath();
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return;
      let s = e.scope.generateUidIdentifier("ref"), i = pKe(s, this.path.node), r = this.attachAfter ? "insertAfter" : "insertBefore", [a] = e[r](
      [e.isVariableDeclarator() ? i : cKe("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (s = uKe(s)), this.path.replaceWith(lKe(s)), e.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  Gx.default = Ek;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/modification.js
var zx = g((Da) => {
  "use strict";
  Object.defineProperty(Da, "__esModule", {
    value: !0
  });
  Da._containerInsert = Ik;
  Da._containerInsertAfter = l$;
  Da._containerInsertBefore = Nk;
  Da._verifyNodeList = bg;
  Da.insertAfter = NKe;
  Da.insertBefore = wKe;
  Da.pushContainer = DKe;
  Da.unshiftContainer = kKe;
  Da.updateSiblingKeys = p$;
  var fKe = oh(), wk = Mc(), Ak = tl(), Qx = Xx(), dKe = fe(), mKe = n$(), {
    arrowFunctionExpression: yKe,
    assertExpression: gKe,
    assignmentExpression: TKe,
    blockStatement: a$,
    callExpression: bKe,
    cloneNode: vk,
    expressionStatement: Ck,
    isAssignmentExpression: xKe,
    isCallExpression: SKe,
    isExportNamedDeclaration: o$,
    isExpression: PKe,
    isIdentifier: EKe,
    isSequenceExpression: AKe,
    isSuper: vKe,
    thisExpression: CKe
  } = dKe;
  function wKe(t) {
    Qx._assertUnremoved.call(this);
    let e = bg.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || o$(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertBefore(e);
    if (this.isNodeType("Expression") && !this.isJSXElement() || s.isForStatement() && this.key === "init")
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e);
    if (Array.isArray(this.container))
      return Nk.call(this, e);
    if (this.isStatementOrBlock()) {
      let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
      return this.replaceWith(a$(a ? [r] : [])), this.unshiftContainer("body", e);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(wKe, "insertBefore");
  function Ik(t, e) {
    p$.call(this, t, e.length);
    let s = [];
    this.container.splice(t, 0, ...e);
    for (let a = 0; a < e.length; a++) {
      var i;
      let o = t + a, l = this.getSibling(o);
      s.push(l), (i = this.context) != null && i.queue && Ak.pushContext.call(l, this.context);
    }
    let r = Ak._getQueueContexts.call(this);
    for (let a of s) {
      Ak.setScope.call(a), a.debug("Inserted.");
      for (let o of r)
        o.maybeQueue(a, !0);
    }
    return s;
  }
  n(Ik, "_containerInsert");
  function Nk(t) {
    return Ik.call(this, this.key, t);
  }
  n(Nk, "_containerInsertBefore");
  function l$(t) {
    return Ik.call(this, this.key + 1, t);
  }
  n(l$, "_containerInsertAfter");
  var u$ = /* @__PURE__ */ n((t) => t[t.length - 1], "last");
  function c$(t) {
    return AKe(t.parent) && (u$(t.parent.expressions) !== t.node || c$(t.parentPath));
  }
  n(c$, "isHiddenInSequenceExpression");
  function IKe(t, e) {
    if (!xKe(t) || !EKe(t.left))
      return !1;
    let s = e.getBlockParent();
    return s.hasOwnBinding(t.left.name) && s.getOwnBinding(t.left.name).constantViolations.length <= 1;
  }
  n(IKe, "isAlmostConstantAssignment");
  function NKe(t) {
    if (Qx._assertUnremoved.call(this), this.isSequenceExpression())
      return u$(this.get("expressions")).insertAfter(t);
    let e = bg.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || o$(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertAfter(e.map((r) => PKe(r) ? Ck(r) : r));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !s.isJSXElement() || s.isForStatement() && this.key === "init") {
      let r = this;
      if (r.node) {
        let a = r.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return gKe(a), r.replaceWith(bKe(yKe([], a), [])), r.get("callee.body").insertAfter(e), [r];
        if (c$(r))
          e.unshift(a);
        else if (SKe(a) && vKe(a.callee))
          e.unshift(a), e.push(CKe());
        else if (IKe(a, o))
          e.unshift(a), e.push(vk(a.left));
        else if (o.isPure(a, !0))
          e.push(a);
        else {
          s.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let l = o.generateDeclaredUidIdentifier();
          e.unshift(Ck(TKe("=", vk(l), a))), e.push(Ck(vk(l)));
        }
      }
      return this.replaceExpressionWithStatements(e);
    } else {
      if (Array.isArray(this.container))
        return l$.call(this, e);
      if (this.isStatementOrBlock()) {
        let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
        return this.replaceWith(a$(a ? [r] : [])), this.pushContainer("body", e);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(NKe, "insertAfter");
  function p$(t, e) {
    if (!this.parent) return;
    let s = (0, fKe.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, i] of s)
      typeof i.key == "number" && i.container === this.container && i.key >= t && (i.key += e);
  }
  n(p$, "updateSiblingKeys");
  function bg(t) {
    if (!t)
      return [];
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++) {
      let s = t[e], i;
      if (s ? typeof s != "object" ? i = "contains a non-object node" : s.type ? s instanceof wk.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let r = Array.isArray(s) ? "array" : typeof s;
        throw new Error(`Node list ${i} with the index of ${e} and type of ${r}`);
      }
    }
    return t;
  }
  n(bg, "_verifyNodeList");
  function kKe(t, e) {
    Qx._assertUnremoved.call(this), e = bg.call(this, e);
    let s = wk.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[t],
      listKey: t,
      key: 0
    }).setContext(this.context);
    return Nk.call(s, e);
  }
  n(kKe, "unshiftContainer");
  function DKe(t, e) {
    Qx._assertUnremoved.call(this);
    let s = bg.call(this, e), i = this.node[t];
    return wk.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: t,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(s);
  }
  n(DKe, "pushContainer");
  Da.hoist = /* @__PURE__ */ n(function(e = this.scope) {
    return new mKe.default(this, e).run();
  }, "hoist");
});

// ../node_modules/@babel/core/node_modules/@babel/parser/lib/index.js
var lS = g((Ng) => {
  "use strict";
  Object.defineProperty(Ng, "__esModule", {
    value: !0
  });
  function OKe(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(OKe, "_objectWithoutPropertiesLoose");
  var il = class {
    static {
      n(this, "Position");
    }
    constructor(e, s, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = s, this.index = i;
    }
  }, Ad = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, s) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = s;
    }
  };
  function xn(t, e) {
    let {
      line: s,
      column: i,
      index: r
    } = t;
    return new il(s, i + e, r + e);
  }
  n(xn, "createPositionWithColumnOffset");
  var h$ = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", _Ke = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: h$
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: h$
    }
  }, f$ = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, tS = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? f$.UpdateExpression[`${t.prefix}`] : f$[t.type], "toNodeDescription"), LKe = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${tS(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${tS(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${tS(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, BKe = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, MKe = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), FKe = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${tS({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), jKe = ["message"];
  function d$(t, e, s) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: s
    });
  }
  n(d$, "defineHidden");
  function RKe({
    toMessage: t,
    code: e,
    reasonCode: s,
    syntaxPlugin: i
  }) {
    let r = s === "MissingPlugin" || s === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[s] && (s = a[s]);
    }
    return /* @__PURE__ */ n(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = s, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, r && (u.missingPlugin = l.missingPlugin), d$(u, "\
clone", /* @__PURE__ */ n(function(p = {}) {
        var h;
        let {
          line: f,
          column: d,
          index: y
        } = (h = p.loc) != null ? h : o;
        return a(new il(f, d, y), Object.assign({}, l, p.details));
      }, "clone")), d$(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${t(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  n(RKe, "toParseErrorConstructor");
  function iu(t, e) {
    if (Array.isArray(t))
      return (i) => iu(i, t[0]);
    let s = {};
    for (let i of Object.keys(t)) {
      let r = t[i], a = typeof r == "string" ? {
        message: /* @__PURE__ */ n(() => r, "message")
      } : typeof r == "function" ? {
        message: r
      } : r, {
        message: o
      } = a, l = OKe(a, jKe), u = typeof o == "string" ? () => o : o;
      s[i] = RKe(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return s;
  }
  n(iu, "ParseErrorEnum");
  var Q = Object.assign({}, iu(_Ke), iu(LKe), iu(BKe), iu`pipelineOperator`(FKe));
  function qKe() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  n(qKe, "createDefaultOptions");
  function UKe(t) {
    let e = qKe();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let s of Object.keys(e))
      t[s] != null && (e[s] = t[s]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  n(UKe, "getOptions");
  var {
    defineProperty: KKe
  } = Object, m$ = /* @__PURE__ */ n((t, e) => {
    t && KKe(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function xg(t) {
    return m$(t.loc.start, "index"), m$(t.loc.end, "index"), t;
  }
  n(xg, "toESTreeLocation");
  var VKe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let s = xg(super.parse());
      return this.optionFlags & 256 && (s.tokens = s.tokens.map(xg)), s;
    }
    parseRegExpLiteral({
      pattern: s,
      flags: i
    }) {
      let r = null;
      try {
        r = new RegExp(s, i);
      } catch {
      }
      let a = this.estreeParseLiteral(r);
      return a.regex = {
        pattern: s,
        flags: i
      }, a;
    }
    parseBigIntLiteral(s) {
      let i;
      try {
        i = BigInt(s);
      } catch {
        i = null;
      }
      let r = this.estreeParseLiteral(i);
      return r.bigint = String(r.value || s), r;
    }
    parseDecimalLiteral(s) {
      let r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || s), r;
    }
    estreeParseLiteral(s) {
      return this.parseLiteral(s, "Literal");
    }
    parseStringLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNumericLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    directiveToStmt(s) {
      let i = s.value;
      delete s.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let r = s;
      return r.type = "ExpressionStatement", r.expression = i, r.directive = i.extra.rawValue, delete i.extra, r;
    }
    initFunction(s, i) {
      super.initFunction(s, i), s.expression = !1;
    }
    checkDeclaration(s) {
      s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
    }
    getObjectOrClassMethodParams(s) {
      return s.value.params;
    }
    isValidDirective(s) {
      var i;
      return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((i = s.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(s, i, r, a, o) {
      super.parseBlockBody(s, i, r, a, o);
      let l = s.directives.map((u) => this.directiveToStmt(u));
      s.body = l.concat(s.body), delete s.directives;
    }
    parsePrivateName() {
      let s = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
    }
    convertPrivateNameToPrivateIdentifier(s) {
      let i = super.getPrivateNameSV(s);
      return s = s, delete s.id, s.name = i, s.type = "PrivateIdentifier", s;
    }
    isPrivateName(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
    }
    getPrivateNameSV(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
    }
    parseLiteral(s, i) {
      let r = super.parseLiteral(s, i);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(s, i, r = !1) {
      super.parseFunctionBody(s, i, r), s.expression = s.body.type !== "BlockStatement";
    }
    parseMethod(s, i, r, a, o, l, u = !1) {
      let c = this.startNode();
      c.kind = s.kind, c = super.parseMethod(c, i, r, a, o, l, u), c.type = "FunctionExpression", delete c.kind, s.value = c;
      let {
        typeParameters: p
      } = s;
      return p && (delete s.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p)), l === "ClassPrivateMethod" && (s.computed =
      !1), this.finishNode(s, "MethodDefinition");
    }
    nameIsConstructor(s) {
      return s.type === "Literal" ? s.value === "constructor" : super.nameIsConstructor(s);
    }
    parseClassProperty(...s) {
      let i = super.parseClassProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...s) {
      let i = super.parseClassPrivateProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(s) {
      let i = super.parseClassAccessorProperty(s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(s, i, r, a, o) {
      let l = super.parseObjectMethod(s, i, r, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(s, i, r, a) {
      let o = super.parseObjectProperty(s, i, r, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(s, i, r) {
      return s === "Property" ? "value" : super.isValidLVal(s, i, r);
    }
    isAssignable(s, i) {
      return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      if (s != null && this.isObjectProperty(s)) {
        let {
          key: r,
          value: a
        } = s;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(s, i);
    }
    toAssignableObjectExpressionProp(s, i, r) {
      s.type === "Property" && (s.kind === "get" || s.kind === "set") ? this.raise(Q.PatternHasAccessor, s.key) : s.type === "Property" && s.
      method ? this.raise(Q.PatternHasMethod, s.key) : super.toAssignableObjectExpressionProp(s, i, r);
    }
    finishCallExpression(s, i) {
      let r = super.finishCallExpression(s, i);
      if (r.callee.type === "Import") {
        var a, o;
        r.type = "ImportExpression", r.source = r.arguments[0], r.options = (a = r.arguments[1]) != null ? a : null, r.attributes = (o = r.arguments[1]) !=
        null ? o : null, delete r.arguments, delete r.callee;
      }
      return r;
    }
    toReferencedArguments(s) {
      s.type !== "ImportExpression" && super.toReferencedArguments(s);
    }
    parseExport(s, i) {
      let r = this.state.lastTokStartLoc, a = super.parseExport(s, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, r);
          }
          break;
      }
      return a;
    }
    parseSubscript(s, i, r, a) {
      let o = super.parseSubscript(s, i, r, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(s) {
      return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
    }
    hasPropertyAsPrivateName(s) {
      return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
    }
    isObjectProperty(s) {
      return s.type === "Property" && s.kind === "init" && !s.method;
    }
    isObjectMethod(s) {
      return s.type === "Property" && (s.method || s.kind === "get" || s.kind === "set");
    }
    finishNodeAt(s, i, r) {
      return xg(super.finishNodeAt(s, i, r));
    }
    resetStartLocation(s, i) {
      super.resetStartLocation(s, i), xg(s);
    }
    resetEndLocation(s, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(s, i), xg(s);
    }
  }, "estree"), yh = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, s) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!s;
    }
  }, Hs = {
    brace: new yh("{"),
    j_oTag: new yh("<tag"),
    j_cTag: new yh("</tag"),
    j_expr: new yh("<tag>...</tag>", !0)
  };
  Hs.template = new yh("`", !0);
  var ns = !0, Ke = !0, kk = !0, Sg = !0, Fc = !0, WKe = !0, rS = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, s = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = s.keyword,
      this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop,
      this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.
      updateContext = null;
    }
  }, eD = /* @__PURE__ */ new Map();
  function Ns(t, e = {}) {
    e.keyword = t;
    let s = At(t, e);
    return eD.set(t, s), s;
  }
  n(Ns, "createKeyword");
  function bn(t, e) {
    return At(t, {
      beforeExpr: ns,
      binop: e
    });
  }
  n(bn, "createBinop");
  var vg = -1, tu = [], tD = [], sD = [], iD = [], rD = [], nD = [];
  function At(t, e = {}) {
    var s, i, r, a;
    return ++vg, tD.push(t), sD.push((s = e.binop) != null ? s : -1), iD.push((i = e.beforeExpr) != null ? i : !1), rD.push((r = e.startsExpr) !=
    null ? r : !1), nD.push((a = e.prefix) != null ? a : !1), tu.push(new rS(t, e)), vg;
  }
  n(At, "createToken");
  function rs(t, e = {}) {
    var s, i, r, a;
    return ++vg, eD.set(t, vg), tD.push(t), sD.push((s = e.binop) != null ? s : -1), iD.push((i = e.beforeExpr) != null ? i : !1), rD.push((r =
    e.startsExpr) != null ? r : !1), nD.push((a = e.prefix) != null ? a : !1), tu.push(new rS("name", e)), vg;
  }
  n(rs, "createKeywordLike");
  var $Ke = {
    bracketL: At("[", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    bracketHashL: At("#[", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    bracketBarL: At("[|", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    bracketR: At("]"),
    bracketBarR: At("|]"),
    braceL: At("{", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    braceBarL: At("{|", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    braceHashL: At("#{", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    braceR: At("}"),
    braceBarR: At("|}"),
    parenL: At("(", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    parenR: At(")"),
    comma: At(",", {
      beforeExpr: ns
    }),
    semi: At(";", {
      beforeExpr: ns
    }),
    colon: At(":", {
      beforeExpr: ns
    }),
    doubleColon: At("::", {
      beforeExpr: ns
    }),
    dot: At("."),
    question: At("?", {
      beforeExpr: ns
    }),
    questionDot: At("?."),
    arrow: At("=>", {
      beforeExpr: ns
    }),
    template: At("template"),
    ellipsis: At("...", {
      beforeExpr: ns
    }),
    backQuote: At("`", {
      startsExpr: Ke
    }),
    dollarBraceL: At("${", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    templateTail: At("...`", {
      startsExpr: Ke
    }),
    templateNonTail: At("...${", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    at: At("@"),
    hash: At("#", {
      startsExpr: Ke
    }),
    interpreterDirective: At("#!..."),
    eq: At("=", {
      beforeExpr: ns,
      isAssign: Sg
    }),
    assign: At("_=", {
      beforeExpr: ns,
      isAssign: Sg
    }),
    slashAssign: At("_=", {
      beforeExpr: ns,
      isAssign: Sg
    }),
    xorAssign: At("_=", {
      beforeExpr: ns,
      isAssign: Sg
    }),
    moduloAssign: At("_=", {
      beforeExpr: ns,
      isAssign: Sg
    }),
    incDec: At("++/--", {
      prefix: Fc,
      postfix: WKe,
      startsExpr: Ke
    }),
    bang: At("!", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    tilde: At("~", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    doubleCaret: At("^^", {
      startsExpr: Ke
    }),
    doubleAt: At("@@", {
      startsExpr: Ke
    }),
    pipeline: bn("|>", 0),
    nullishCoalescing: bn("??", 1),
    logicalOR: bn("||", 1),
    logicalAND: bn("&&", 2),
    bitwiseOR: bn("|", 3),
    bitwiseXOR: bn("^", 4),
    bitwiseAND: bn("&", 5),
    equality: bn("==/!=/===/!==", 6),
    lt: bn("</>/<=/>=", 7),
    gt: bn("</>/<=/>=", 7),
    relational: bn("</>/<=/>=", 7),
    bitShift: bn("<</>>/>>>", 8),
    bitShiftL: bn("<</>>/>>>", 8),
    bitShiftR: bn("<</>>/>>>", 8),
    plusMin: At("+/-", {
      beforeExpr: ns,
      binop: 9,
      prefix: Fc,
      startsExpr: Ke
    }),
    modulo: At("%", {
      binop: 10,
      startsExpr: Ke
    }),
    star: At("*", {
      binop: 10
    }),
    slash: bn("/", 10),
    exponent: At("**", {
      beforeExpr: ns,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ns("in", {
      beforeExpr: ns,
      binop: 7
    }),
    _instanceof: Ns("instanceof", {
      beforeExpr: ns,
      binop: 7
    }),
    _break: Ns("break"),
    _case: Ns("case", {
      beforeExpr: ns
    }),
    _catch: Ns("catch"),
    _continue: Ns("continue"),
    _debugger: Ns("debugger"),
    _default: Ns("default", {
      beforeExpr: ns
    }),
    _else: Ns("else", {
      beforeExpr: ns
    }),
    _finally: Ns("finally"),
    _function: Ns("function", {
      startsExpr: Ke
    }),
    _if: Ns("if"),
    _return: Ns("return", {
      beforeExpr: ns
    }),
    _switch: Ns("switch"),
    _throw: Ns("throw", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    _try: Ns("try"),
    _var: Ns("var"),
    _const: Ns("const"),
    _with: Ns("with"),
    _new: Ns("new", {
      beforeExpr: ns,
      startsExpr: Ke
    }),
    _this: Ns("this", {
      startsExpr: Ke
    }),
    _super: Ns("super", {
      startsExpr: Ke
    }),
    _class: Ns("class", {
      startsExpr: Ke
    }),
    _extends: Ns("extends", {
      beforeExpr: ns
    }),
    _export: Ns("export"),
    _import: Ns("import", {
      startsExpr: Ke
    }),
    _null: Ns("null", {
      startsExpr: Ke
    }),
    _true: Ns("true", {
      startsExpr: Ke
    }),
    _false: Ns("false", {
      startsExpr: Ke
    }),
    _typeof: Ns("typeof", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    _void: Ns("void", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    _delete: Ns("delete", {
      beforeExpr: ns,
      prefix: Fc,
      startsExpr: Ke
    }),
    _do: Ns("do", {
      isLoop: kk,
      beforeExpr: ns
    }),
    _for: Ns("for", {
      isLoop: kk
    }),
    _while: Ns("while", {
      isLoop: kk
    }),
    _as: rs("as", {
      startsExpr: Ke
    }),
    _assert: rs("assert", {
      startsExpr: Ke
    }),
    _async: rs("async", {
      startsExpr: Ke
    }),
    _await: rs("await", {
      startsExpr: Ke
    }),
    _defer: rs("defer", {
      startsExpr: Ke
    }),
    _from: rs("from", {
      startsExpr: Ke
    }),
    _get: rs("get", {
      startsExpr: Ke
    }),
    _let: rs("let", {
      startsExpr: Ke
    }),
    _meta: rs("meta", {
      startsExpr: Ke
    }),
    _of: rs("of", {
      startsExpr: Ke
    }),
    _sent: rs("sent", {
      startsExpr: Ke
    }),
    _set: rs("set", {
      startsExpr: Ke
    }),
    _source: rs("source", {
      startsExpr: Ke
    }),
    _static: rs("static", {
      startsExpr: Ke
    }),
    _using: rs("using", {
      startsExpr: Ke
    }),
    _yield: rs("yield", {
      startsExpr: Ke
    }),
    _asserts: rs("asserts", {
      startsExpr: Ke
    }),
    _checks: rs("checks", {
      startsExpr: Ke
    }),
    _exports: rs("exports", {
      startsExpr: Ke
    }),
    _global: rs("global", {
      startsExpr: Ke
    }),
    _implements: rs("implements", {
      startsExpr: Ke
    }),
    _intrinsic: rs("intrinsic", {
      startsExpr: Ke
    }),
    _infer: rs("infer", {
      startsExpr: Ke
    }),
    _is: rs("is", {
      startsExpr: Ke
    }),
    _mixins: rs("mixins", {
      startsExpr: Ke
    }),
    _proto: rs("proto", {
      startsExpr: Ke
    }),
    _require: rs("require", {
      startsExpr: Ke
    }),
    _satisfies: rs("satisfies", {
      startsExpr: Ke
    }),
    _keyof: rs("keyof", {
      startsExpr: Ke
    }),
    _readonly: rs("readonly", {
      startsExpr: Ke
    }),
    _unique: rs("unique", {
      startsExpr: Ke
    }),
    _abstract: rs("abstract", {
      startsExpr: Ke
    }),
    _declare: rs("declare", {
      startsExpr: Ke
    }),
    _enum: rs("enum", {
      startsExpr: Ke
    }),
    _module: rs("module", {
      startsExpr: Ke
    }),
    _namespace: rs("namespace", {
      startsExpr: Ke
    }),
    _interface: rs("interface", {
      startsExpr: Ke
    }),
    _type: rs("type", {
      startsExpr: Ke
    }),
    _opaque: rs("opaque", {
      startsExpr: Ke
    }),
    name: At("name", {
      startsExpr: Ke
    }),
    placeholder: At("%%", {
      startsExpr: !0
    }),
    string: At("string", {
      startsExpr: Ke
    }),
    num: At("num", {
      startsExpr: Ke
    }),
    bigint: At("bigint", {
      startsExpr: Ke
    }),
    decimal: At("decimal", {
      startsExpr: Ke
    }),
    regexp: At("regexp", {
      startsExpr: Ke
    }),
    privateName: At("#name", {
      startsExpr: Ke
    }),
    eof: At("eof"),
    jsxName: At("jsxName"),
    jsxText: At("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: At("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: At("jsxTagEnd")
  };
  function Js(t) {
    return t >= 93 && t <= 133;
  }
  n(Js, "tokenIsIdentifier");
  function HKe(t) {
    return t <= 92;
  }
  n(HKe, "tokenKeywordOrIdentifierIsKeyword");
  function bo(t) {
    return t >= 58 && t <= 133;
  }
  n(bo, "tokenIsKeywordOrIdentifier");
  function w$(t) {
    return t >= 58 && t <= 137;
  }
  n(w$, "tokenIsLiteralPropertyName");
  function JKe(t) {
    return iD[t];
  }
  n(JKe, "tokenComesBeforeExpression");
  function Eg(t) {
    return rD[t];
  }
  n(Eg, "tokenCanStartExpression");
  function YKe(t) {
    return t >= 29 && t <= 33;
  }
  n(YKe, "tokenIsAssignment");
  function y$(t) {
    return t >= 129 && t <= 131;
  }
  n(y$, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function XKe(t) {
    return t >= 90 && t <= 92;
  }
  n(XKe, "tokenIsLoop");
  function aD(t) {
    return t >= 58 && t <= 92;
  }
  n(aD, "tokenIsKeyword");
  function zKe(t) {
    return t >= 39 && t <= 59;
  }
  n(zKe, "tokenIsOperator");
  function GKe(t) {
    return t === 34;
  }
  n(GKe, "tokenIsPostfix");
  function QKe(t) {
    return nD[t];
  }
  n(QKe, "tokenIsPrefix");
  function ZKe(t) {
    return t >= 121 && t <= 123;
  }
  n(ZKe, "tokenIsTSTypeOperator");
  function eVe(t) {
    return t >= 124 && t <= 130;
  }
  n(eVe, "tokenIsTSDeclarationStart");
  function Rc(t) {
    return tD[t];
  }
  n(Rc, "tokenLabelName");
  function sS(t) {
    return sD[t];
  }
  n(sS, "tokenOperatorPrecedence");
  function tVe(t) {
    return t === 57;
  }
  n(tVe, "tokenIsRightAssociative");
  function nS(t) {
    return t >= 24 && t <= 25;
  }
  n(nS, "tokenIsTemplate");
  function eu(t) {
    return tu[t];
  }
  n(eu, "getExportedToken");
  tu[8].updateContext = (t) => {
    t.pop();
  }, tu[5].updateContext = tu[7].updateContext = tu[23].updateContext = (t) => {
    t.push(Hs.brace);
  }, tu[22].updateContext = (t) => {
    t[t.length - 1] === Hs.template ? t.pop() : t.push(Hs.template);
  }, tu[143].updateContext = (t) => {
    t.push(Hs.j_expr, Hs.j_oTag);
  };
  var oD = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  I$ = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", sVe = new RegExp("[" + oD + "]"), iVe = new RegExp("[" + oD + I$ + "]");
  oD = I$ = null;
  var N$ = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], rVe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Bk(t, e) {
    let s = 65536;
    for (let i = 0, r = e.length; i < r; i += 2) {
      if (s += e[i], s > t) return !1;
      if (s += e[i + 1], s >= t) return !0;
    }
    return !1;
  }
  n(Bk, "isInAstralSet");
  function su(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && sVe.test(String.fromCharCode(t)) :
    Bk(t, N$);
  }
  n(su, "isIdentifierStart");
  function Sd(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && iVe.test(
    String.fromCharCode(t)) : Bk(t, N$) || Bk(t, rVe);
  }
  n(Sd, "isIdentifierChar");
  var lD = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, nVe = new Set(lD.keyword), aVe = new Set(lD.strict), oVe = new Set(lD.strictBind);
  function k$(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(k$, "isReservedWord");
  function D$(t, e) {
    return k$(t, e) || aVe.has(t);
  }
  n(D$, "isStrictReservedWord");
  function O$(t) {
    return oVe.has(t);
  }
  n(O$, "isStrictBindOnlyReservedWord");
  function _$(t, e) {
    return D$(t, e) || O$(t);
  }
  n(_$, "isStrictBindReservedWord");
  function lVe(t) {
    return nVe.has(t);
  }
  n(lVe, "isKeyword");
  function uVe(t, e, s) {
    return t === 64 && e === 64 && su(s);
  }
  n(uVe, "isIteratorStart");
  var cVe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function pVe(t) {
    return cVe.has(t);
  }
  n(pVe, "canBeReservedWord");
  var Cg = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, wg = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, s) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = s;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 128)
          return !0;
        if (s & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Cg(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 8 || s & 16) {
        this.checkRedeclarationInScope(r, e, s, i);
        let a = r.names.get(e) || 0;
        s & 16 ? a = a | 4 : (r.firstLexicalName || (r.firstLexicalName = e), a = a | 2), r.names.set(e, a), s & 8 && this.maybeExportDefined(
        r, e);
      } else if (s & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (r = this.scopeStack[a], this.checkRedeclarationInScope(r, e, s, i), r.names.set(
        e, (r.names.get(e) || 0) | 1), this.maybeExportDefined(r, e), !(r.flags & 387)); --a)
          ;
      this.parser.inModule && r.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, s) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(s);
    }
    checkRedeclarationInScope(e, s, i, r) {
      this.isRedeclaredInScope(e, s, i) && this.parser.raise(Q.VarRedeclaration, r, {
        identifierName: s
      });
    }
    isRedeclaredInScope(e, s, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(s);
      let r = e.names.get(s);
      return i & 16 ? (r & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (r & 1) > 0 : (r & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      s) || !this.treatFunctionsAsVarInScope(e) && (r & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      this.scopeStack[0].names.has(s) || this.undefinedExports.set(s, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 387)
          return s;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 451 && !(s & 4))
          return s;
      }
    }
  }, Mk = class extends Cg {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Fk = class extends wg {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new Mk(e);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 2048) {
        this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e), r.declareFunctions.add(e);
        return;
      }
      super.declareName(e, s, i);
    }
    isRedeclaredInScope(e, s, i) {
      if (super.isRedeclaredInScope(e, s, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(s)) {
        let r = e.names.get(s);
        return (r & 4) > 0 || (r & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, jk = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [s, i] = e;
        if (!this.hasPlugin(s))
          return !1;
        let r = this.plugins.get(s);
        for (let a of Object.keys(i))
          if (r?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, s) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[s];
    }
  };
  function L$(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(L$, "setTrailingComments");
  function hVe(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(hVe, "setLeadingComments");
  function Ig(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(Ig, "setInnerComments");
  function dh(t, e, s) {
    let i = null, r = e.length;
    for (; i === null && r > 0; )
      i = e[--r];
    i === null || i.start > s.start ? Ig(t, s.comments) : L$(i, s.comments);
  }
  n(dh, "adjustInnerComments");
  var Rk = class extends jk {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: s
      } = this.state;
      this.comments.length !== s && (this.comments.length = s), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: s
      } = this.state, i = s.length;
      if (i === 0) return;
      let r = i - 1, a = s[r];
      a.start === e.end && (a.leadingNode = e, r--);
      let {
        start: o
      } = e;
      for (; r >= 0; r--) {
        let l = s[r], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), s.splice(r, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: s
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && L$(e.leadingNode, s), e.trailingNode !== null && hVe(e.trailingNode, s);
      else {
        let {
          containingNode: i,
          start: r
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(r) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              dh(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              dh(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              dh(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              dh(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              dh(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              dh(i, i.members, e);
              break;
            case "TSEnumBody":
              dh(i, i.members, e);
              break;
            default:
              Ig(i, s);
          }
        else
          Ig(i, s);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let s = e.length - 1; s >= 0; s--)
        this.finalizeComment(e[s]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      if (i === 0) return;
      let r = s[i - 1];
      r.leadingNode === e && (r.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      i !== 0 && (s[i - 1].trailingNode === e ? s[i - 1].trailingNode = null : i >= 2 && s[i - 2].trailingNode === e && (s[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, s, i) {
      let {
        commentStack: r
      } = this.state, a = r.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = r[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === s)
          l.trailingNode = e;
        else if (u < s)
          break;
      }
    }
  }, fVe = /\r\n|[\r\n\u2028\u2029]/, Zx = new RegExp(fVe.source, "g");
  function Pd(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(Pd, "isNewLine");
  function g$(t, e, s) {
    for (let i = e; i < s; i++)
      if (Pd(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  n(g$, "hasNewLine");
  var Dk = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ok = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function dVe(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(dVe, "isWhitespace");
  var qk = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Hs.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: s,
      startIndex: i,
      startLine: r,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : s === "module", this.startIndex = i, this.curLine = r, this.lineStart = -a, this.startLoc =
      this.endLoc = new il(r, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new il(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, mVe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), T$ = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, eS = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function b$(t, e, s, i, r, a) {
    let o = s, l = i, u = r, c = "", p = null, h = s, {
      length: f
    } = e;
    for (; ; ) {
      if (s >= f) {
        a.unterminated(o, l, u), c += e.slice(h, s);
        break;
      }
      let d = e.charCodeAt(s);
      if (yVe(t, d, e, s)) {
        c += e.slice(h, s);
        break;
      }
      if (d === 92) {
        c += e.slice(h, s);
        let y = gVe(e, s, i, r, t === "template", a);
        y.ch === null && !p ? p = {
          pos: s,
          lineStart: i,
          curLine: r
        } : c += y.ch, {
          pos: s,
          lineStart: i,
          curLine: r
        } = y, h = s;
      } else d === 8232 || d === 8233 ? (++s, ++r, i = s) : d === 10 || d === 13 ? t === "template" ? (c += e.slice(h, s) + `
`, ++s, d === 13 && e.charCodeAt(s) === 10 && ++s, ++r, h = i = s) : a.unterminated(o, l, u) : ++s;
    }
    return {
      pos: s,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: r,
      containsInvalid: !!p
    };
  }
  n(b$, "readStringContents");
  function yVe(t, e, s, i) {
    return t === "template" ? e === 96 || e === 36 && s.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(yVe, "isStringEnd");
  function gVe(t, e, s, i, r, a) {
    let o = !r;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: s,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = Uk(t, e, s, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = M$(t, e, s, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        s = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (r)
          return l(null);
        a.strictNumericEscape(e - 1, s, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, h = /^[0-7]+/.exec(t.slice(c, e + 2))[0], f = parseInt(h, 8);
          f > 255 && (h = h.slice(0, -1), f = parseInt(h, 8)), e += h.length - 1;
          let d = t.charCodeAt(e);
          if (h !== "0" || d === 56 || d === 57) {
            if (r)
              return l(null);
            a.strictNumericEscape(c, s, i);
          }
          return l(String.fromCharCode(f));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(gVe, "readEscapedChar");
  function Uk(t, e, s, i, r, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = B$(t, e, s, i, 16, r, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, s, i) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(Uk, "readHexChar");
  function B$(t, e, s, i, r, a, o, l, u, c) {
    let p = e, h = r === 16 ? T$.hex : T$.decBinOct, f = r === 16 ? eS.hex : r === 10 ? eS.dec : r === 8 ? eS.oct : eS.bin, d = !1, y = 0;
    for (let m = 0, T = a ?? 1 / 0; m < T; ++m) {
      let b = t.charCodeAt(e), E;
      if (b === 95 && l !== "bail") {
        let w = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !f(K) || h.has(w) || h.has(K)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, s, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, s, i);
        }
        ++e;
        continue;
      }
      if (b >= 97 ? E = b - 97 + 10 : b >= 65 ? E = b - 65 + 10 : mVe(b) ? E = b - 48 : E = 1 / 0, E >= r) {
        if (E <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (E <= 9 && u.invalidDigit(e, s, i, r))
          E = 0;
        else if (o)
          E = 0, d = !0;
        else
          break;
      }
      ++e, y = y * r + E;
    }
    return e === p || a != null && e - p !== a || d ? {
      n: null,
      pos: e
    } : {
      n: y,
      pos: e
    };
  }
  n(B$, "readInt");
  function M$(t, e, s, i, r, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = Uk(t, e, s, i, t.indexOf("}", e) - e, !0, r, a), ++e, l !== null && l > 1114111)
        if (r)
          a.invalidCodePoint(e, s, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = Uk(t, e, s, i, 4, !1, r, a));
    return {
      code: l,
      pos: e
    };
  }
  n(M$, "readCodePoint");
  function Pg(t, e, s) {
    return new il(s, t - e, t);
  }
  n(Pg, "buildPosition");
  var TVe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), sl = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      let s = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = s + e.start, this.end = s + e.end, this.loc = new Ad(e.startLoc, e.endLoc);
    }
  }, Kk = class extends Rk {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, s) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((i, r, a, o) => this.optionFlags & 2048 ? (this.raise(Q.InvalidDigit, Pg(i, r, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(Q.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Q.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Q.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Q.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((i, r, a) => {
          this.recordStrictModeErrors(Q.StrictNumericEscape, Pg(i, r, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(Q.UnterminatedString, Pg(i - 1, r, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Q.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(Q.UnterminatedTemplate, Pg(i, r, a));
        }, "unterminated")
      }), this.state = new qk(), this.state.init(e), this.input = s, this.length = s.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new sl(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let s = this.state;
      return this.state = e, s;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Dk.lastIndex = e, Dk.test(this.input) ? Dk.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Ok.lastIndex = e, Ok.test(this.input) ? Ok.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let s = this.input.charCodeAt(e);
      if ((s & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      return s;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([s, i]) => this.raise(s, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.state.pos, r = this.input.indexOf(e, i + 2);
      if (r === -1)
        throw this.raise(Q.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = r + e.length, Zx.lastIndex = i + 2; Zx.test(this.input) && Zx.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = Zx.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, r),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(r + e.length),
        loc: new Ad(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let s = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let r = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !Pd(r) && ++this.state.pos < this.length; )
          r = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(s + e, a),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(a),
        loc: new Ad(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, s = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let r = this.skipBlockComment("*/");
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              case 47: {
                let r = this.skipLineComment(2);
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (dVe(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (s?.length > 0) {
        let i = this.state.pos, r = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: s,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(r);
      }
    }
    finishToken(e, s) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = s, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, s = this.codePointAtPos(e);
      if (s >= 48 && s <= 57)
        throw this.raise(Q.UnexpectedDigitAfterHash, this.state.curPosition());
      if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(s === 123 ? Q.RecordExpressionHashIncorrectStartSyntaxType : Q.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
      } else su(s) ? (++this.state.pos, this.finishToken(139, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let s = this.state.pos;
      for (this.state.pos += 1; !Pd(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(s + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let s = e === 42 ? 55 : 54, i = 1, r = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && r === 42 && (i++, r = this.input.charCodeAt(this.state.pos + 2), s = 57), r === 61 && !this.state.inType && (i++, s = e ===
      37 ? 33 : 30), this.finishOp(s, i);
    }
    readToken_pipe_amp(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (s === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Q.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Q.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (s === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.finishOp(34, 2);
        return;
      }
      s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && s === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Q.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Q.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let s = this.input.charCodeAt(this.state.pos + 1);
          if (s === 120 || s === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (s === 111 || s === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (s === 98 || s === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (su(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(Q.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, s) {
      let i = this.input.slice(this.state.pos, this.state.pos + s);
      this.state.pos += s, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, s = this.state.start + 1, i, r, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(Q.UnterminatedRegExp, xn(e, 1));
        let c = this.input.charCodeAt(a);
        if (Pd(c))
          throw this.raise(Q.UnterminatedRegExp, xn(e, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            r = !0;
          else if (c === 93 && r)
            r = !1;
          else if (c === 47 && !r)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(s, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => xn(e, a + 2 - s), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (TVe.has(c))
          c === 118 ? l.includes("u") && this.raise(Q.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(Q.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(Q.DuplicateRegExpFlags, u());
        else if (Sd(c) || c === 92)
          this.raise(Q.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, s, i = !1, r = !0) {
      let {
        n: a,
        pos: o
      } = B$(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, s, i, r, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(Q.InvalidDigit, xn(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = !0;
      else if (o === 109)
        throw this.raise(Q.InvalidDecimal, i);
      if (su(this.codePointAtPos(this.state.pos)))
        throw this.raise(Q.NumberIdentifier, this.state.curPosition());
      if (r) {
        let l = this.input.slice(s, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(Q.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
      if (u) {
        let d = this.input.slice(s, this.state.pos);
        if (this.recordStrictModeErrors(Q.StrictOctalLiteral, i), !this.state.strict) {
          let y = d.indexOf("_");
          y > 0 && this.raise(Q.ZeroDigitNumericSeparator, xn(i, y));
        }
        l = u && !/[89]/.test(d);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !l && (++this.state.pos, this.readInt(10), r = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      Q.InvalidOrMissingExponent, i), r = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((r || u) && this.raise(Q.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(Q.InvalidDecimal, i), ++this.state.pos;
        var p = !0;
      }
      if (su(this.codePointAtPos(this.state.pos)))
        throw this.raise(Q.NumberIdentifier, this.state.curPosition());
      let h = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, h);
        return;
      }
      if (p) {
        this.finishToken(137, h);
        return;
      }
      let f = l ? parseInt(h, 8) : parseFloat(h);
      this.finishToken(135, f);
    }
    readCodePoint(e) {
      let {
        code: s,
        pos: i
      } = M$(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, s;
    }
    readString(e) {
      let {
        str: s,
        pos: i,
        curLine: r,
        lineStart: a
      } = b$(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = r, this.finishToken(134, s);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: s,
        firstInvalidLoc: i,
        pos: r,
        curLine: a,
        lineStart: o
      } = b$("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = r + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new il(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(r) === 96 ? this.finishToken(24, i ? null : e + s + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + s + "${"));
    }
    recordStrictModeErrors(e, s) {
      let i = s.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, s) : this.state.strictErrors.set(i, [e, s]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let s = "", i = this.state.pos, r = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Sd(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, s += this.input.slice(r, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? su : Sd;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Q.MissingUnicodeEscape, this.state.curPosition()), r = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(Q.EscapedCharNotAnIdentifier, o), s += String.fromCodePoint(u)), r = this.state.pos;
        } else
          break;
      }
      return s + this.input.slice(r, this.state.pos);
    }
    readWord(e) {
      let s = this.readWord1(e), i = eD.get(s);
      i !== void 0 ? this.finishToken(i, Rc(i)) : this.finishToken(132, s);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      aD(e) && this.state.containsEsc && this.raise(Q.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Rc(e)
      });
    }
    raise(e, s, i = {}) {
      let r = s instanceof il ? s : s.loc.start, a = e(r, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, s, i = {}) {
      let r = s instanceof il ? s : s.loc.start, a = r.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(r, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, s, i);
    }
    updateContext(e) {
    }
    unexpected(e, s) {
      throw this.raise(Q.UnexpectedToken, e ?? this.state.startLoc, {
        expected: s ? Rc(s) : null
      });
    }
    expectPlugin(e, s) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(Q.MissingPlugin, s ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((s) => this.hasPlugin(s)))
        throw this.raise(Q.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (s, i, r) => {
        this.raise(e, Pg(s, i, r));
      };
    }
  }, Vk = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Wk = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Vk());
    }
    exit() {
      let e = this.stack.pop(), s = this.current();
      for (let [i, r] of Array.from(e.undefinedPrivateNames))
        s ? s.undefinedPrivateNames.has(i) || s.undefinedPrivateNames.set(i, r) : this.parser.raise(Q.InvalidPrivateFieldResolution, r, {
          identifierName: i
        });
    }
    declarePrivateName(e, s, i) {
      let {
        privateNames: r,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = r.has(e);
      if (s & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = s & 4, h = u & 3, f = s & 3;
          l = h === f || c !== p, l || a.delete(e);
        } else l || a.set(e, s);
      }
      l && this.parser.raise(Q.PrivateNameRedeclaration, i, {
        identifierName: e
      }), r.add(e), o.delete(e);
    }
    usePrivateName(e, s) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, s) : this.parser.raise(Q.InvalidPrivateFieldResolution, s, {
        identifierName: e
      });
    }
  }, vd = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, aS = class extends vd {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, s) {
      let i = s.index;
      this.declarationErrors.set(i, [e, s]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, $k = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new vd()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, s) {
      let i = s.loc.start, {
        stack: r
      } = this, a = r.length - 1, o = r[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = r[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, s) {
      let {
        stack: i
      } = this, r = i[i.length - 1], a = s.loc.start;
      if (r.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (r.canBeArrowParameterDeclaration())
        r.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: s
      } = this, i = s.length - 1, r = s[i];
      for (; r.canBeArrowParameterDeclaration(); )
        r.type === 2 && r.recordDeclarationError(Q.AwaitBindingIdentifier, e), r = s[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, s = e[e.length - 1];
      s.canBeArrowParameterDeclaration() && s.iterateErrors(([i, r]) => {
        this.parser.raise(i, r);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(r.index), o = e[--a];
      });
    }
  };
  function bVe() {
    return new vd(3);
  }
  n(bVe, "newParameterDeclarationScope");
  function xVe() {
    return new aS(1);
  }
  n(xVe, "newArrowHeadScope");
  function SVe() {
    return new aS(2);
  }
  n(SVe, "newAsyncArrowScope");
  function F$() {
    return new vd();
  }
  n(F$, "newExpressionScope");
  var Hk = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function iS(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(iS, "functionFlags");
  var Jk = class extends Kk {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, s, i, r = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), r ? a[s] = i : Object.defineProperty(a, s, {
        enumerable: r,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, s) {
      let i = e + s.length;
      if (this.input.slice(e, i) === s) {
        let r = this.input.charCodeAt(i);
        return !(Sd(r) || (r & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let s = this.nextTokenStart();
      return this.isUnparsedContextual(s, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, s) {
      if (!this.eatContextual(e)) {
        if (s != null)
          throw this.raise(s, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return g$(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return g$(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(Q.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, s) {
      this.eat(e) || this.unexpected(s, e);
    }
    tryParse(e, s = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let r = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > s.errors.length) {
          let a = this.state;
          return this.state = s, this.state.tokensLength = a.tokensLength, {
            node: r,
            error: a.errors[s.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: r,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (r) {
        let a = this.state;
        if (this.state = s, r instanceof SyntaxError)
          return {
            node: null,
            error: r,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (r === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw r;
      }
    }
    checkExpressionErrors(e, s) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: r,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!r || !!o || !!a;
      if (!s)
        return l;
      i != null && this.raise(Q.InvalidCoverInitializedName, i), r != null && this.raise(Q.DuplicateProto, r), a != null && this.raise(Q.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return w$(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let s = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let r = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new Hk();
      let u = this.classScope;
      this.classScope = new Wk(this);
      let c = this.expressionScope;
      return this.expressionScope = new $k(this), () => {
        this.state.labels = s, this.exportedIdentifiers = i, this.inModule = r, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: s
      } = e;
      s !== null && this.expectPlugin("destructuringPrivate", s);
    }
  }, Ed = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Cd = class {
    static {
      n(this, "Node");
    }
    constructor(e, s, i) {
      this.type = "", this.start = s, this.end = 0, this.loc = new Ad(i), e?.optionFlags & 128 && (this.range = [s, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, uD = Cd.prototype;
  uD.__clone = function() {
    let t = new Cd(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let s = 0, i = e.length; s < i; s++) {
      let r = e[s];
      r !== "leadingComments" && r !== "trailingComments" && r !== "innerComments" && (t[r] = this[r]);
    }
    return t;
  };
  function PVe(t) {
    return ru(t);
  }
  n(PVe, "clonePlaceholder");
  function ru(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(uD);
    return u.type = e, u.start = s, u.end = i, u.loc = r, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(ru, "cloneIdentifier");
  function EVe(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return PVe(t);
    let l = Object.create(uD);
    return l.type = e, l.start = s, l.end = i, l.loc = r, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(EVe, "cloneStringLiteral");
  var Yk = class extends Jk {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Cd(this, e.index, e);
    }
    startNodeAt(e) {
      return new Cd(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, s) {
      return this.finishNodeAt(e, s, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, s, i) {
      return e.type = s, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, s) {
      e.start = s.index, e.loc.start = s, this.optionFlags & 128 && (e.range[0] = s.index);
    }
    resetEndLocation(e, s = this.state.lastTokEndLoc) {
      e.end = s.index, e.loc.end = s, this.optionFlags & 128 && (e.range[1] = s.index);
    }
    resetStartLocationFromNode(e, s) {
      this.resetStartLocation(e, s.loc.start);
    }
  }, AVe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), _t = iu`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: s
    }) => `Enum \`${t}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: s
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function vVe(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(vVe, "isEsModuleType");
  function x$(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(x$, "hasTypeImportKind");
  var CVe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function wVe(t, e) {
    let s = [], i = [];
    for (let r = 0; r < t.length; r++)
      (e(t[r], r, t) ? s : i).push(t[r]);
    return [s, i];
  }
  n(wVe, "partition");
  var IVe = /\*?\s*@((?:no)?flow)\b/, NVe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...s) {
      super(...s), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Fk;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(s, i) {
      s !== 134 && s !== 13 && s !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(s, i);
    }
    addComment(s) {
      if (this.flowPragma === void 0) {
        let i = IVe.exec(s.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(s);
    }
    flowParseTypeInitialiser(s) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(s || 14);
      let r = this.flowParseType();
      return this.state.inType = i, r;
    }
    flowParsePredicate() {
      let s = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(_t.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (s.value = super.parseExpression(), this.expect(11), this.finishNode(s, "DeclaredPredicate")) : this.finishNode(s, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, r = null;
      return this.match(54) ? (this.state.inType = s, r = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = s, this.
      match(54) && (r = this.flowParsePredicate())), [i, r];
    }
    flowParseDeclareClass(s) {
      return this.next(), this.flowParseInterfaceish(s, !0), this.finishNode(s, "DeclareClass");
    }
    flowParseDeclareFunction(s) {
      this.next();
      let i = s.id = this.parseIdentifier(), r = this.startNode(), a = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, s.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(s.id.name, 2048, s.id.loc.start), this.finishNode(s, "DeclareFunction");
    }
    flowParseDeclare(s, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(s);
      if (this.match(68))
        return this.flowParseDeclareFunction(s);
      if (this.match(74))
        return this.flowParseDeclareVariable(s);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(s) : (i && this.raise(_t.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(s));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(s);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(s);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(s);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(s, i);
      this.unexpected();
    }
    flowParseDeclareVariable(s) {
      return this.next(), s.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(s.id.name, 5, s.id.loc.start), this.semicolon(),
      this.finishNode(s, "DeclareVariable");
    }
    flowParseDeclareModule(s) {
      this.scope.enter(0), this.match(134) ? s.id = super.parseExprAtom() : s.id = this.parseIdentifier();
      let i = s.body = this.startNode(), r = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(_t.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, _t.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), r.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return r.forEach((l) => {
        vVe(l) ? (a === "CommonJS" && this.raise(_t.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(_t.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(_t.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), s.kind = a || "CommonJS", this.finishNode(s, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(s, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? s.declaration = this.flowParseDeclare(this.startNode()) : (s.declaration = this.flowParseType(),
        this.semicolon()), s.default = !0, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let r = this.state.value;
        throw this.raise(_t.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: r,
          suggestion: CVe[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return s.declaration = this.flowParseDeclare(this.startNode()), s.default = !1, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return s = this.parseExport(s, null), s.type === "ExportNamedDeclaration" && (s.type = "ExportDeclaration", s.default = !1, delete s.
        exportKind), s.type = "Declare" + s.type, s;
      this.unexpected();
    }
    flowParseDeclareModuleExports(s) {
      return this.next(), this.expectContextual(111), s.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(s,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(s) {
      this.next();
      let i = this.flowParseTypeAlias(s);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(s) {
      this.next();
      let i = this.flowParseOpaqueType(s, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(s) {
      return this.next(), this.flowParseInterfaceish(s, !1), this.finishNode(s, "DeclareInterface");
    }
    flowParseInterfaceish(s, i) {
      if (s.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(s.id.name, i ? 17 : 8201, s.id.loc.start), this.match(47) ?
      s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (s.implements = [], s.mixins = [], this.eatContextual(117))
          do
            s.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            s.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      s.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let s = this.startNode();
      return s.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() :
      s.typeParameters = null, this.finishNode(s, "InterfaceExtends");
    }
    flowParseInterface(s) {
      return this.flowParseInterfaceish(s, !1), this.finishNode(s, "InterfaceDeclaration");
    }
    checkNotUnderscore(s) {
      s === "_" && this.raise(_t.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(s, i, r) {
      AVe.has(s) && this.raise(r ? _t.AssignReservedType : _t.UnexpectedReservedType, i, {
        reservedType: s
      });
    }
    flowParseRestrictedIdentifier(s, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(s);
    }
    flowParseTypeAlias(s) {
      return s.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.
      typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(s, "TypeAlias");
    }
    flowParseOpaqueType(s, i) {
      return this.expectContextual(130), s.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.
      start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.supertype = null, this.
      match(14) && (s.supertype = this.flowParseTypeInitialiser(14)), s.impltype = null, i || (s.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(s, "OpaqueType");
    }
    flowParseTypeParameter(s = !1) {
      let i = this.state.startLoc, r = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = a, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) :
      s && this.raise(_t.MissingTypeParamDefault, i), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let s = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = !1;
      do {
        let a = this.flowParseTypeParameter(r);
        i.params.push(a), a.default && (r = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = s, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(s) {
      if (this.curContext() !== Hs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let s = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, s.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let r = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          s.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = r;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Hs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      s, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let s = this.startNode(), i = this.state.inType;
      for (s.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        s.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(s, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let s = this.startNode();
      if (this.expectContextual(129), s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return s.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(s, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(s, i, r) {
      return s.static = i, this.lookahead().type === 14 ? (s.id = this.flowParseObjectPropertyKey(), s.key = this.flowParseTypeInitialiser()) :
      (s.id = null, s.key = this.flowParseType()), this.expect(3), s.value = this.flowParseTypeInitialiser(), s.variance = r, this.finishNode(
      s, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(s, i) {
      return s.static = i, s.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (s.method =
      !0, s.optional = !1, s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start))) : (s.method = !1, this.eat(17) && (s.
      optional = !0), s.value = this.flowParseTypeInitialiser()), this.finishNode(s, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(s) {
      for (s.params = [], s.rest = null, s.typeParameters = null, s.this = null, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (s.this = this.flowParseFunctionTypeParam(!0), s.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        s.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), s.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(s, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(s, i) {
      let r = this.startNode();
      return s.static = i, s.value = this.flowParseObjectTypeMethodish(r), this.finishNode(s, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: s,
      allowExact: i,
      allowSpread: r,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, h = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let d = !1, y = null, m = null, T = this.startNode();
        if (a && this.isContextual(118)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), y = this.state.startLoc, s = !1);
        }
        if (s && this.isContextual(106)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), d = !0);
        }
        let b = this.flowParseVariance();
        if (this.eat(0))
          y != null && this.unexpected(y), this.eat(0) ? (b && this.unexpected(b.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          T, d))) : u.indexers.push(this.flowParseObjectTypeIndexer(T, d, b));
        else if (this.match(10) || this.match(47))
          y != null && this.unexpected(y), b && this.unexpected(b.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(T, d));
        else {
          let E = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let K = this.lookahead();
            w$(K.type) && (E = this.state.value, this.next());
          }
          let w = this.flowParseObjectTypeProperty(T, d, y, b, E, r, o ?? !p);
          w === null ? (h = !0, m = this.state.lastTokStartLoc) : u.properties.push(w);
        }
        this.flowObjectTypeSemicolon(), m && !this.match(8) && !this.match(9) && this.raise(_t.UnexpectedExplicitInexactInObject, m);
      }
      this.expect(c), r && (u.inexact = h);
      let f = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, f;
    }
    flowParseObjectTypeProperty(s, i, r, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(_t.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(_t.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(_t.InexactVariance, a), null) : (l || this.raise(
        _t.UnexpectedSpreadType, this.state.lastTokStartLoc), r != null && this.unexpected(r), a && this.raise(_t.SpreadVariance, a), s.argument =
        this.flowParseType(), this.finishNode(s, "ObjectTypeSpreadProperty"));
      {
        s.key = this.flowParseObjectPropertyKey(), s.static = i, s.proto = r != null, s.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (s.method = !0, r != null && this.unexpected(r), a && this.unexpected(a.loc.start), s.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(s),
        !l && s.key.name === "constructor" && s.value.this && this.raise(_t.ThisParamBannedInConstructor, s.value.this)) : (o !== "init" && this.
        unexpected(), s.method = !1, this.eat(17) && (c = !0), s.value = this.flowParseTypeInitialiser(), s.variance = a), s.optional = c, this.
        finishNode(s, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(s) {
      let i = s.kind === "get" ? 0 : 1, r = s.value.params.length + (s.value.rest ? 1 : 0);
      s.value.this && this.raise(s.kind === "get" ? _t.GetterMayNotHaveThisParam : _t.SetterMayNotHaveThisParam, s.value.this), r !== i && this.
      raise(s.kind === "get" ? Q.BadGetterArity : Q.BadSetterArity, s), s.kind === "set" && s.value.rest && this.raise(Q.BadSetterRestParameter,
      s);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(s, i) {
      s ?? (s = this.state.startLoc);
      let r = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(s);
        a.qualification = r, a.id = this.flowParseRestrictedIdentifier(!0), r = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return r;
    }
    flowParseGenericType(s, i) {
      let r = this.startNodeAt(s);
      return r.typeParameters = null, r.id = this.flowParseQualifiedTypeIdentifier(s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(r, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let s = this.startNode();
      return this.expect(87), s.argument = this.flowParsePrimaryType(), this.finishNode(s, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let s = this.startNode();
      for (s.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (s.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(s, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(s) {
      let i = null, r = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !s && this.raise(_t.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (r = !0, u && this.raise(_t.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = r, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(s) {
      let i = this.startNodeAt(s.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = s, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(s = []) {
      let i = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(!0), r.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        s.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: s,
        rest: i,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(s, i, r) {
      switch (r.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r.name), this.flowParseGenericType(s, r);
      }
    }
    flowParsePrimaryType() {
      let s = this.state.startLoc, i = this.startNode(), r, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r = this.flowParseFunctionTypeParams(), u.params =
          r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (Js(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? r = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : r = this.flowParseFunctionTypeParams(),
          u.params = r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(_t.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (aD(this.state.type)) {
            let u = Rc(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (Js(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let s = this.state.startLoc, i = this.flowParsePrimaryType(), r = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(s), o = this.eat(18);
        r = r || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), r ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let s = this.startNode();
      return this.eat(17) ? (s.typeAnnotation = this.flowParsePrefixType(), this.finishNode(s, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let s = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(s.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(s)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return s;
    }
    flowParseIntersectionType() {
      let s = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (s.types = [i]; this.eat(45); )
        s.types.push(this.flowParseAnonFunctionWithoutParens());
      return s.types.length === 1 ? i : this.finishNode(s, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let s = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (s.types = [i]; this.eat(43); )
        s.types.push(this.flowParseIntersectionType());
      return s.types.length === 1 ? i : this.finishNode(s, "UnionTypeAnnotation");
    }
    flowParseType() {
      let s = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = s, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let s = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(s, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let s = this.startNode();
      return s.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(s, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(s) {
      let i = s ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    flowParseVariance() {
      let s = null;
      return this.match(53) ? (s = this.startNode(), this.state.value === "+" ? s.kind = "plus" : s.kind = "minus", this.next(), this.finishNode(
      s, "Variance")) : s;
    }
    parseFunctionBody(s, i, r = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(s, () => super.parseFunctionBody(s, !0, r));
        return;
      }
      super.parseFunctionBody(s, !1, r);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), s.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(s, i, r);
    }
    parseStatementLike(s) {
      if (this.state.strict && this.isContextual(129)) {
        let r = this.lookahead();
        if (bo(r.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      let i = super.parseStatementLike(s);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(s, i, r) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || Js(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(s);
        } else if (Js(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(s);
          if (i.name === "type")
            return this.flowParseTypeAlias(s);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(s, !1);
        }
      }
      return super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      let {
        type: s
      } = this.state;
      return s === 126 || y$(s) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: s
      } = this.state;
      return s === 126 || y$(s) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let f = this.lookaheadCharCode();
        if (f === 44 || f === 61 || f === 58 || f === 41)
          return this.setOptionalParametersError(r), s;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, h] = this.getArrowLikeExpressions(u);
      if (c || h.length > 0) {
        let f = [...o];
        if (h.length > 0) {
          this.state = a, this.state.noArrowAt = f;
          for (let d = 0; d < h.length; d++)
            f.push(h[d].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, h] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(_t.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, f.push(p[0].start),
        this.state.noArrowAt = f, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = s, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let s = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: s,
        failed: i
      };
    }
    getArrowLikeExpressions(s, i) {
      let r = [s], a = [];
      for (; r.length !== 0; ) {
        let o = r.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : wVe(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(s) {
      var i;
      this.toAssignableList(s.params, (i = s.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(s, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(s, i) {
      let r;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), r = i(), this.state.noArrowParamsConversionAt.pop()) : r = i(), r;
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(s) {
      s.type === "ImportDeclaration" && (s.importKind === "type" || s.importKind === "typeof") || s.type === "ExportNamedDeclaration" && s.exportKind ===
      "type" || s.type === "ExportAllDeclaration" && s.exportKind === "type" || super.assertModuleNodeAllowed(s);
    }
    parseExportDeclaration(s) {
      if (this.isContextual(130)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (s.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(s), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        s.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(s);
    }
    eatExportStar(s) {
      return super.eatExportStar(s) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (s.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(s) {
      let {
        startLoc: i
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(s);
      return r && s.exportKind === "type" && this.unexpected(i), r;
    }
    parseClassId(s, i, r) {
      super.parseClassId(s, i, r), this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(s, i, r) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(s, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(s, i, r), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(_t.DeclareClassElement, a) : i.value && this.raise(_t.DeclareClassFieldInitializer, i.value));
    }
    isIterator(s) {
      return s === "iterator" || s === "asyncIterator";
    }
    readIterator() {
      let s = super.readWord1(), i = "@@" + s;
      (!this.isIterator(s) || !this.state.inType) && this.raise(Q.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      s === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (s === 62 || s === 60) ? this.finishOp(s === 62 ? 48 : 47, 1) : this.
      state.inType && s === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : uVe(s, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(s);
    }
    isAssignable(s, i) {
      return s.type === "TypeCastExpression" ? this.isAssignable(s.expression, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      !i && s.type === "AssignmentExpression" && s.left.type === "TypeCastExpression" && (s.left = this.typeCastToParameter(s.left)), super.
      toAssignable(s, i);
    }
    toAssignableList(s, i, r) {
      for (let a = 0; a < s.length; a++) {
        let o = s[a];
        o?.type === "TypeCastExpression" && (s[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(s, i, r);
    }
    toReferencedList(s, i) {
      for (let a = 0; a < s.length; a++) {
        var r;
        let o = s[a];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (s.length > 1 || !i) && this.raise(_t.TypeCastInPattern,
        o.typeAnnotation);
      }
      return s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(s, i, r) {
      return s === "TypeCastExpression" || super.isValidLVal(s, i, r);
    }
    parseClassProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(s) {
      return !this.match(14) && super.isNonstaticConstructor(s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(s, i, r, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(_t.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(_t.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(s, i, r, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(s, i, r, a);
    }
    parseClassSuper(s) {
      if (super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = s.implements = [];
        do {
          let r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.
          typeParameters = null, i.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(s) {
      super.checkGetterSetterParams(s);
      let i = this.getObjectOrClassMethodParams(s);
      if (i.length > 0) {
        let r = i[0];
        this.isThisParam(r) && s.kind === "get" ? this.raise(_t.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(_t.SetterMayNotHaveThisParam,
        r);
      }
    }
    parsePropertyNamePrefixOperator(s) {
      s.variance = this.flowParseVariance();
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(s, i, r, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseFunctionParamType(s) {
      return this.eat(17) && (s.type !== "Identifier" && this.raise(_t.PatternIsOptional, s), this.isThisParam(s) && this.raise(_t.ThisParamMayNotBeOptional,
      s), s.optional = !0), this.match(14) ? s.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(s) && this.raise(_t.ThisParamAnnotationRequired,
      s), this.match(29) && this.isThisParam(s) && this.raise(_t.ThisParamNoDefault, s), this.resetEndLocation(s), s;
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(_t.TypeBeforeInitializer,
      r.typeAnnotation), r;
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(_t.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(s, i, r) {
      i.local = x$(s) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), s.specifiers.push(this.finishImportSpecifier(i,
      r));
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        if (!s) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      if (super.applyImportPhase(s, i, r, a), i) {
        if (!r && this.match(65))
          return;
        s.exportKind = r === "type" ? r : "value";
      } else
        r === "type" && this.match(55) && this.unexpected(), s.importKind = r === "type" || r === "typeof" ? r : "value";
    }
    parseImportSpecifier(s, i, r, a, o) {
      let l = s.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let h = this.parseIdentifier(!0);
        u !== null && !bo(this.state.type) ? (s.imported = h, s.importKind = u, s.local = ru(h)) : (s.imported = l, s.importKind = null, s.local =
        this.parseIdentifier());
      } else {
        if (u !== null && bo(this.state.type))
          s.imported = this.parseIdentifier(!0), s.importKind = u;
        else {
          if (i)
            throw this.raise(Q.ImportBindingIsString, s, {
              importName: l.value
            });
          s.imported = l, s.importKind = null;
        }
        this.eatContextual(93) ? s.local = this.parseIdentifier() : (c = !0, s.local = ru(s.imported));
      }
      let p = x$(s);
      return r && p && this.raise(_t.ImportTypeShorthandOnlyInPureImport, s), (r || p) && this.checkReservedType(s.local.name, s.local.loc.start,
      !0), c && !r && !p && this.checkReservedWord(s.local.name, s.loc.start, !0, !0), this.finishImportSpecifier(s, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(s, i) {
      let r = s.kind;
      r !== "get" && r !== "set" && this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), this.match(14) && (s.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      if (this.match(14)) {
        let r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, s.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(s, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(s, i) {
      var r;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(s, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Hs.j_oTag || p === Hs.j_expr) && c.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((f) => {
          var d;
          c = this.flowParseTypeParameterDeclaration();
          let y = this.forwardNoArrowParamsConversionAt(c, () => {
            let T = super.parseMaybeAssign(s, i);
            return this.resetStartLocationFromNode(T, c), T;
          });
          (d = y.extra) != null && d.parenthesized && f();
          let m = this.maybeUnwrapTypeCastExpression(y);
          return m.type !== "ArrowFunctionExpression" && f(), m.typeParameters = c, this.resetStartLocationFromNode(m, c), y;
        }, a), h = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(_t.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          h = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (h)
          return this.state = p.failState, h;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(_t.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), s.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(s);
    }
    shouldParseArrow(s) {
      return this.match(14) || super.shouldParseArrow(s);
    }
    setArrowFunctionParameters(s, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? s.params = i : super.setArrowFunctionParameters(s, i);
    }
    checkParams(s, i, r, a = !0) {
      if (!(r && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)))) {
        for (let o = 0; o < s.params.length; o++)
          this.isThisParam(s.params[o]) && o > 0 && this.raise(_t.ThisParamMustBeFirst, s.params[o]);
        super.checkParams(s, i, r, a);
      }
    }
    parseParenAndDistinguishExpression(s) {
      return super.parseParenAndDistinguishExpression(s && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(s, i, r) {
      if (s.type === "Identifier" && s.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = s, a.arguments = super.parseCallExpressionArguments(11), s = this.finishNode(a, "CallExpression");
      } else if (s.type === "Identifier" && s.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(s, i, r), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(s, i, r);
    }
    parseSubscript(s, i, r, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, r)
          return a.stop = !0, s;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = s, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = s;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      super.parseNewCallee(s);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), s.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(s) {
      let i = this.startNodeAt(s);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(s);
    }
    readToken_pipe_amp(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(s);
    }
    parseTopLevel(s, i) {
      let r = super.parseTopLevel(s, i);
      return this.state.hasFlowComment && this.raise(_t.UnterminatedFlowComment, this.state.curPosition()), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(_t.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let s = this.skipFlowComment();
        s && (this.state.pos += s, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: s
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(s + i)); )
        i++;
      let r = this.input.charCodeAt(i + s), a = this.input.charCodeAt(i + s + 1);
      return r === 58 && a === 58 ? i + 2 : this.input.slice(i + s, i + s + 12) === "flow-include" ? i + 12 : r === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(Q.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(s, {
      enumName: i,
      memberName: r
    }) {
      this.raise(_t.EnumBooleanMemberNotInitialized, s, {
        memberName: r,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(s, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? _t.EnumInvalidMemberInitializerSymbolType : _t.EnumInvalidMemberInitializerPrimaryType :
      _t.EnumInvalidMemberInitializerUnknownType, s, i);
    }
    flowEnumErrorNumberMemberNotInitialized(s, i) {
      this.raise(_t.EnumNumberMemberNotInitialized, s, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(s, i) {
      this.raise(_t.EnumStringMemberInconsistentlyInitialized, s, i);
    }
    flowEnumMemberInit() {
      let s = this.state.startLoc, i = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let r = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 134: {
          let r = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 85:
        case 86: {
          let r = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        default:
          return {
            type: "invalid",
            loc: s
          };
      }
    }
    flowEnumMemberRaw() {
      let s = this.state.startLoc, i = this.parseIdentifier(!0), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: s
      };
      return {
        id: i,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(s, i, r) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== r && this.flowEnumErrorInvalidMemberInitializer(s, i);
    }
    flowEnumMembers({
      enumName: s,
      explicitType: i
    }) {
      let r = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(_t.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: s
        }), r.has(p) && this.raise(_t.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: s
        }), r.add(p);
        let h = {
          enumName: s,
          explicitType: i,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, h);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, h);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, h);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(s, i, {
      enumName: r
    }) {
      if (s.length === 0)
        return i;
      if (i.length === 0)
        return s;
      if (i.length > s.length) {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return s;
      }
    }
    flowEnumParseExplicitType({
      enumName: s
    }) {
      if (!this.eatContextual(102)) return null;
      if (!Js(this.state.type))
        throw this.raise(_t.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: s
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(_t.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: s,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(s, i) {
      let r = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (s.hasUnknownMembers = u, o) {
        case "boolean":
          return s.explicitType = !0, s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
        case "number":
          return s.explicitType = !0, s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
        case "string":
          return s.explicitType = !0, s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(s, "EnumStringBody");
        case "symbol":
          return s.members = l.defaultedMembers, this.expect(8), this.finishNode(s, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (s.members = [], this.expect(8), this.finishNode(s, "EnumStringBody")), "empty");
          s.explicitType = !1;
          let p = l.booleanMembers.length, h = l.numberMembers.length, f = l.stringMembers.length, d = l.defaultedMembers.length;
          if (!p && !h && !f && !d)
            return c();
          if (!p && !h)
            return s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(s, "EnumStringBody");
          if (!h && !f && p >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
          } else if (!p && !f && h >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
          } else
            return this.raise(_t.EnumInconsistentMemberValues, a, {
              enumName: r
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(s) {
      let i = this.parseIdentifier();
      return s.id = i, s.body = this.flowEnumBody(this.startNode(), i), this.finishNode(s, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(s) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (s.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(s);
    }
    isLookaheadToken_lt() {
      let s = this.nextTokenStart();
      if (this.input.charCodeAt(s) === 60) {
        let i = this.input.charCodeAt(s + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    maybeUnwrapTypeCastExpression(s) {
      return s.type === "TypeCastExpression" ? s.expression : s;
    }
  }, "flow"), kVe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, mh = iu`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function jc(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(jc, "isFragment");
  function xd(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return xd(t.object) + "." + xd(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(xd, "getQualifiedJSXName");
  var DVe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let s = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(mh.UnterminatedJsxContent, this.state.startLoc);
        let r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r);
              return;
            }
            s += this.input.slice(i, this.state.pos), this.finishToken(142, s);
            return;
          case 38:
            s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Pd(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(s) {
      let i = this.input.charCodeAt(this.state.pos), r;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = s ? `
` : `\r
`) : r = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(s) {
      let i = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Q.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === s) break;
        a === 38 ? (i += this.input.slice(r, this.state.pos), i += this.jsxReadEntity(), r = this.state.pos) : Pd(a) ? (i += this.input.slice(
        r, this.state.pos), i += this.jsxReadNewLine(!1), r = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(r, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let s = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let r = this.readInt(i, void 0, !1, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let i = 0, r = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (r) {
          let a = this.input.slice(s, this.state.pos), o = kVe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = s, "&";
    }
    jsxReadWord() {
      let s, i = this.state.pos;
      do
        s = this.input.charCodeAt(++this.state.pos);
      while (Sd(s) || s === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let s = this.startNode();
      return this.match(141) ? s.name = this.state.value : aD(this.state.type) ? s.name = Rc(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(s, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let s = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let r = this.startNodeAt(s);
      return r.namespace = i, r.name = this.jsxParseIdentifier(), this.finishNode(r, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let s = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let r = this.startNodeAt(s);
        r.object = i, r.property = this.jsxParseIdentifier(), i = this.finishNode(r, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let s;
      switch (this.state.type) {
        case 5:
          return s = this.startNode(), this.setContext(Hs.brace), this.next(), s = this.jsxParseExpressionContainer(s, Hs.j_oTag), s.expression.
          type === "JSXEmptyExpression" && this.raise(mh.AttributeIsEmpty, s), s;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(mh.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let s = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(s, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(s) {
      return this.next(), s.expression = this.parseExpression(), this.setContext(Hs.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(s, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(s, i) {
      if (this.match(8))
        s.expression = this.jsxParseEmptyExpression();
      else {
        let r = this.parseExpression();
        s.expression = r;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let s = this.startNode();
      return this.match(5) ? (this.setContext(Hs.brace), this.next(), this.expect(21), s.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Hs.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadAttribute")) : (s.name = this.jsxParseNamespacedName(),
      s.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(s, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(s) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return s.attributes = i, s.selfClosing = this.eat(56), this.expect(144), this.finishNode(s, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(s) {
      let i = this.startNodeAt(s), r = [], a = this.jsxParseOpeningElementAt(s), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (s = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(s);
                break e;
              }
              r.push(this.jsxParseElementAt(s));
              break;
            case 142:
              r.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Hs.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(l)) : r.push(this.jsxParseExpressionContainer(
              l, Hs.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        jc(a) && !jc(o) && o !== null ? this.raise(mh.MissingClosingTagFragment, o) : !jc(a) && jc(o) ? this.raise(mh.MissingClosingTagElement,
        o, {
          openingTagName: xd(a.name)
        }) : !jc(a) && !jc(o) && xd(o.name) !== xd(a.name) && this.raise(mh.MissingClosingTagElement, o, {
          openingTagName: xd(a.name)
        });
      }
      if (jc(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = r, this.match(
      47))
        throw this.raise(mh.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return jc(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let s = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(s);
    }
    setContext(s) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = s;
    }
    parseExprAtom(s) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(s);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(s) {
      let i = this.curContext();
      if (i === Hs.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Hs.j_oTag || i === Hs.j_cTag) {
        if (su(s)) {
          this.jsxReadWord();
          return;
        }
        if (s === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((s === 34 || s === 39) && i === Hs.j_oTag) {
          this.jsxReadString(s);
          return;
        }
      }
      if (s === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(s);
    }
    updateContext(s) {
      let {
        context: i,
        type: r
      } = this.state;
      if (r === 56 && s === 143)
        i.splice(-2, 2, Hs.j_cTag), this.state.canStartJSXElement = !1;
      else if (r === 143)
        i.push(Hs.j_oTag);
      else if (r === 144) {
        let a = i[i.length - 1];
        a === Hs.j_oTag && s === 56 || a === Hs.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Hs.j_expr) : (this.setContext(
        Hs.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = JKe(r);
    }
  }, "jsx"), Xk = class extends Cg {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, zk = class extends wg {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Xk(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, s) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(e))
        return !0;
      if (!s && i > 1) {
        for (let r = 0; r < i - 1; r++)
          if (this.importsStack[r].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, s, i) {
      if (s & 4096) {
        this.hasImport(e, !0) && this.parser.raise(Q.VarRedeclaration, i, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let r = this.currentScope(), a = r.tsNames.get(e) || 0;
      if (s & 1024) {
        this.maybeExportDefined(r, e), r.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, s, i), s & 2 && (s & 1 || (this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e)), a = a | 1),
      s & 256 && (a = a | 2), s & 512 && (a = a | 4), s & 128 && (a = a | 8), a && r.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, s, i) {
      let r = e.tsNames.get(s);
      if ((r & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (r & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (r & 8) > 0 ? e.names.get(s) & 2 ? !!(i & 1) : !1 : i & 2 && (r & 1) > 0 ? !0 : super.isRedeclaredInScope(e, s, i);
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      if (this.hasImport(s)) return;
      let i = this.scopeStack.length;
      for (let r = i - 1; r >= 0; r--) {
        let o = this.scopeStack[r].tsNames.get(s);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, j$ = /* @__PURE__ */ n((t) => t.type === "ParenthesizedExpression" ? j$(t.expression) : t, "unwrapParenthesizedExpression"), Gk = class extends Yk {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, s = !1) {
      var i, r;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (i = e.extra) != null && i.parenthesized) && (a = j$(e), s ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(Q.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(Q.InvalidParenthesizedAssignment, e) : this.raise(Q.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], h = l === c;
            this.toAssignableObjectExpressionProp(p, h, s), h && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(Q.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, s);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, s);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(Q.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, s);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, s);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, s, i) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? Q.PatternHasAccessor : Q.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let r = e.argument;
        this.checkToRestConversion(r, !1), this.toAssignable(r, i), s || this.raise(Q.RestTrailingComma, e);
      } else
        this.toAssignable(e, i);
    }
    toAssignableList(e, s, i) {
      let r = e.length - 1;
      for (let a = 0; a <= r; a++) {
        let o = e[a];
        o && (this.toAssignableListItem(e, a, i), o.type === "RestElement" && (a < r ? this.raise(Q.RestTrailingComma, o) : s && this.raise(
        Q.RestTrailingComma, s)));
      }
    }
    toAssignableListItem(e, s, i) {
      let r = e[s];
      if (r.type === "SpreadElement") {
        r.type = "RestElement";
        let a = r.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(r, i);
    }
    isAssignable(e, s) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = e.properties.length - 1;
          return e.properties.every((r, a) => r.type !== "ObjectMethod" && (a === i || r.type !== "SpreadElement") && this.isAssignable(r));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !s;
        default:
          return !1;
      }
    }
    toReferencedList(e, s) {
      return e;
    }
    toReferencedListDeep(e, s) {
      this.toReferencedList(e, s);
      for (let i of e)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(e) {
      let s = this.startNode();
      return this.next(), s.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(s, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, s, i) {
      let r = i & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), r && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(s)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(Q.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: s
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return e === 139 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(this.state.value, s), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, s, !1, !1, !0, !1);
    }
    parseBindingElement(e, s) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || e & 2) && this.parseFunctionParamType(i);
      let r = this.parseMaybeDefault(i.loc.start, i);
      return s.length && (i.decorators = s), r;
    }
    parseFunctionParamType(e) {
      return e;
    }
    parseMaybeDefault(e, s) {
      if (e ?? (e = this.state.startLoc), s = s ?? this.parseBindingAtom(), !this.eat(29)) return s;
      let i = this.startNodeAt(e);
      return i.left = s, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(e, s, i) {
      switch (e) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, s, i = 64, r = !1, a = !1, o = !1) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), s.type !== "AssignmentExpression" && this.raise(Q.InvalidLhsOptionalChaining,
        e, {
          ancestor: s
        })), i !== 64 && this.raise(Q.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, i, a);
        let {
          name: m
        } = e;
        r && (r.has(m) ? this.raise(Q.ParamDupe, e) : r.add(m));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && s.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let m = i === 64 ? Q.InvalidLhs : Q.InvalidLhsBinding;
        this.raise(m, e, {
          ancestor: s
        });
        return;
      }
      let h, f;
      typeof p == "string" ? (h = p, f = u === "ParenthesizedExpression") : [h, f] = p;
      let d = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : s, y = e[h];
      if (Array.isArray(y))
        for (let m of y)
          m && this.checkLVal(m, d, i, r, a, f);
      else y && this.checkLVal(y, d, i, r, a, f);
    }
    checkIdentifier(e, s, i = !1) {
      this.state.strict && (i ? _$(e.name, this.inModule) : O$(e.name)) && (s === 64 ? this.raise(Q.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(Q.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), s & 8192 && e.name === "let" && this.raise(Q.LetInLexicalBinding, e), s & 64 || this.declareNameFromIdentifier(e, s);
    }
    declareNameFromIdentifier(e, s) {
      this.scope.declareName(e.name, s, e.loc.start);
    }
    checkToRestConversion(e, s) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, s);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (s) break;
        default:
          this.raise(Q.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? Q.RestTrailingComma : Q.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function OVe(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(OVe, "nonNull");
  function S$(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(S$, "assert");
  var lt = iu`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function _Ve(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(_Ve, "keywordTypeFromName");
  function P$(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(P$, "tsIsAccessModifier");
  function LVe(t) {
    return t === "in" || t === "out";
  }
  n(LVe, "tsIsVarianceAnnotations");
  var BVe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...s) {
      super(...s), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: lt.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: lt.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: lt.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return zk;
    }
    tsIsIdentifier() {
      return Js(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(s, i) {
      if (!Js(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let r = this.state.value;
      if (s.includes(r)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      allowedModifiers: s,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: r,
      errorTemplate: a = lt.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, h, f) => {
        p === h && o[f] && this.raise(lt.InvalidModifiersOrder, c, {
          orderedModifiers: [h, f]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, h, f) => {
        (o[h] && p === f || o[f] && p === h) && this.raise(lt.IncompatibleModifiers, c, {
          modifiers: [h, f]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(s.concat(i ?? []), r);
        if (!p) break;
        P$(p) ? o.accessibility ? this.raise(lt.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : LVe(p) ? (o[p] && this.raise(lt.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(lt.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(s) {
      switch (s) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(s, i) {
      let r = [];
      for (; !this.tsIsListTerminator(s); )
        r.push(i());
      return r;
    }
    tsParseDelimitedList(s, i, r) {
      return OVe(this.tsParseDelimitedListWorker(s, i, !0, r));
    }
    tsParseDelimitedListWorker(s, i, r, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(s); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(s))
          break;
        r && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(s, i, r, a, o) {
      a || (r ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(s, i, o);
      return r ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let s = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? s.argument = this.parseStringLiteral(this.state.value) : (this.raise(lt.UnsupportedImportTypeArgument,
      this.state.startLoc), s.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (s.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : s.options = null, this.expect(11), this.eat(16) && (s.qualifier = this.tsParseEntityName(3)), this.match(47) && (s.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(s, "TSImportType");
    }
    tsParseEntityName(s) {
      let i;
      if (s & 1 && this.match(78))
        if (s & 2)
          i = this.parseIdentifier(!0);
        else {
          let r = this.startNode();
          this.next(), i = this.finishNode(r, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(s & 1));
      for (; this.eat(16); ) {
        let r = this.startNodeAtNode(i);
        r.left = i, r.right = this.parseIdentifier(!!(s & 1)), i = this.finishNode(r, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let s = this.startNode();
      return s.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(s, "TSTypeReference");
    }
    tsParseThisTypePredicate(s) {
      this.next();
      let i = this.startNodeAtNode(s);
      return i.parameterName = s, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let s = this.startNode();
      return this.next(), this.finishNode(s, "TSThisType");
    }
    tsParseTypeQuery() {
      let s = this.startNode();
      return this.expect(87), this.match(83) ? s.exprName = this.tsParseImportType() : s.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeQuery");
    }
    tsParseTypeParameter(s) {
      let i = this.startNode();
      return s(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(s) {
      if (this.match(47))
        return this.tsParseTypeParameters(s);
    }
    tsParseTypeParameters(s) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, s), !1, !0, r), i.params.
      length === 0 && this.raise(lt.EmptyTypeParameters, i), r.value !== -1 && this.addExtra(i, "trailingComma", r.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(s, i) {
      let r = s === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      r ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(s) : this.match(s) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(s));
    }
    tsParseBindingListForSignature() {
      let s = super.parseBindingList(11, 41, 2);
      for (let i of s) {
        let {
          type: r
        } = i;
        (r === "AssignmentPattern" || r === "TSParameterProperty") && this.raise(lt.UnsupportedSignatureParameterKind, i, {
          type: r
        });
      }
      return s;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(s, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, s);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), Js(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(s) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), s.parameters = [i];
      let r = this.tsTryParseTypeAnnotation();
      return r && (s.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(s, i) {
      this.eat(17) && (s.optional = !0);
      let r = s;
      if (this.match(10) || this.match(47)) {
        i && this.raise(lt.ReadonlyForMethodSignature, s);
        let a = r;
        a.kind && this.match(47) && this.raise(lt.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(Q.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(lt.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(Q.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(lt.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(lt.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            lt.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(lt.SetAccessorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = r;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let s = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", s);
      if (this.match(77)) {
        let r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", s) : (s.key = this.
        createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(s, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, s);
      let i = this.tsTryParseIndexSignature(s);
      return i || (super.parsePropertyName(s), !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (s.kind = s.key.name, super.parsePropertyName(s)), this.tsParsePropertyOrMethodSignature(s, !!s.readonly));
    }
    tsParseTypeLiteral() {
      let s = this.startNode();
      return s.members = this.tsParseObjectTypeMembers(), this.finishNode(s, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let s = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), s;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let s = this.startNode();
      this.expect(5), this.match(53) ? (s.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (s.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), s.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return s.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (s.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (s.optional = !0), s.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(s, "TSMappedType");
    }
    tsParseTupleType() {
      let s = this.startNode();
      s.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return s.elementTypes.forEach((r) => {
        let {
          type: a
        } = r;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && r.optional) && this.raise(lt.OptionalTypeBeforeRequired,
        r), i || (i = a === "TSNamedTupleMember" && r.optional || a === "TSOptionalType");
      }), this.finishNode(s, "TSTupleType");
    }
    tsParseTupleElementType() {
      let s = this.state.startLoc, i = this.eat(21), {
        startLoc: r
      } = this.state, a, o, l, u, p = bo(this.state.type) ? this.lookaheadCharCode() : null;
      if (p === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (p === 63) {
        l = !0;
        let h = this.state.value, f = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(r), h), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = f, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let h;
        o ? (h = this.startNodeAt(r), h.optional = l, h.label = o, h.elementType = u, this.eat(17) && (h.optional = !0, this.raise(lt.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (h = this.startNodeAt(r), h.optional = l, this.raise(lt.InvalidTupleMemberLabel, u), h.label = u, h.
        elementType = this.tsParseType()), u = this.finishNode(h, "TSNamedTupleMember");
      } else if (l) {
        let h = this.startNodeAt(r);
        h.typeAnnotation = u, u = this.finishNode(h, "TSOptionalType");
      }
      if (i) {
        let h = this.startNodeAt(s);
        h.typeAnnotation = u, u = this.finishNode(h, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let s = this.startNode();
      return this.expect(10), s.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(s, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(s, i) {
      let r = this.startNode();
      return s === "TSConstructorType" && (r.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, r)), this.finishNode(r, s);
    }
    tsParseLiteralTypeNode() {
      let s = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          s.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(s, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let s = this.startNode();
        return s.literal = super.parseTemplate(!1), this.finishNode(s, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let s = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(s) : s;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let s = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: s
          } = this.state;
          if (Js(s) || s === 88 || s === 84) {
            let i = s === 88 ? "TSVoidKeyword" : s === 84 ? "TSNullKeyword" : _Ve(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let r = this.startNode();
              return this.next(), this.finishNode(r, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: s
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let r = this.startNodeAt(s);
          r.elementType = i, this.expect(3), i = this.finishNode(r, "TSArrayType");
        } else {
          let r = this.startNodeAt(s);
          r.objectType = i, r.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(r, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let s = this.startNode(), i = this.state.value;
      return this.next(), s.operator = i, s.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      s), this.finishNode(s, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(s) {
      switch (s.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(lt.UnexpectedReadonly, s);
      }
    }
    tsParseInferType() {
      let s = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), s.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(s, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let s = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return s;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return ZKe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(s, i, r) {
      let a = this.startNode(), o = this.eat(r), l = [];
      do
        l.push(i());
      while (this.eat(r));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, s));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (Js(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return this.parseObjectLike(8, !0), s.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return super.parseBindingList(3, 93, 1), s.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(s) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(s);
        let r = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = !0, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, r), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (r.parameterName = this.parseIdentifier(), r.asserts = a, r.typeAnnotation = null, i.typeAnnotation = this.finishNode(r,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return r.parameterName = o, r.typeAnnotation = l, r.asserts = a, i.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let s = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), s;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let s = this.state.containsEsc;
      return this.next(), !Js(this.state.type) && !this.match(78) ? !1 : (s && this.raise(Q.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(s = !0, i = this.startNode()) {
      return this.tsInType(() => {
        s && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      S$(this.state.inType);
      let s = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return s;
      let i = this.startNodeAtNode(s);
      return i.checkType = s, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(lt.ReservedTypeAssertion, this.state.startLoc);
      let s = this.startNode();
      return s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), s.expression = this.parseMaybeUnary(), this.finishNode(s, "TSTypeAssertion");
    }
    tsParseHeritageClause(s) {
      let i = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return r.length || this.raise(lt.EmptyHeritageClauseType, i, {
        token: s
      }), r;
    }
    tsParseInterfaceDeclaration(s, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (s.declare = !0), Js(this.state.type) ? (s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, 130)) : (s.id = null, this.raise(lt.MissingInterfaceName, this.state.startLoc)), s.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (s.extends = this.tsParseHeritageClause("extends"));
      let r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), s.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(
      s, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(s) {
      return s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 2), s.typeAnnotation = this.tsInType(() => {
        if (s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(s, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(s) {
      if (this.curContext() !== Hs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    tsInType(s) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return s();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(s) {
      if (this.match(s))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(s) {
      return this.tsInType(() => (this.expect(s), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let s = this.startNode();
      return s.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (s.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(s, "TSEnumMember");
    }
    tsParseEnumDeclaration(s, i = {}) {
      return i.const && (s.const = !0), i.declare && (s.declare = !0), this.expectContextual(126), s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, s.const ? 8971 : 8459), this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(s, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let s = this.startNode();
      return this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      s, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let s = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(s.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      s, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(s, i = !1) {
      if (s.id = this.parseIdentifier(), i || this.checkIdentifier(s.id, 1024), this.eat(16)) {
        let r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, !0), s.body = r;
      } else
        this.scope.enter(256), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(s, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(s) {
      return this.isContextual(112) ? (s.kind = "global", s.global = !0, s.id = this.parseIdentifier()) : this.match(134) ? (s.kind = "modul\
e", s.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(s, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(s, i, r) {
      s.isExport = r || !1, s.id = i || this.parseIdentifier(), this.checkIdentifier(s.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return s.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(lt.ImportAliasHasImportType, a), s.moduleReference =
      a, this.semicolon(), this.finishNode(s, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let s = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), s.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExternalModuleReference");
    }
    tsLookAhead(s) {
      let i = this.state.clone(), r = s();
      return this.state = i, r;
    }
    tsTryParseAndCatch(s) {
      let i = this.tryParse((r) => s() || r());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(s) {
      let i = this.state.clone(), r = s();
      if (r !== void 0 && r !== !1)
        return r;
      this.state = i;
    }
    tsTryParseDeclare(s) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, r;
      return this.isContextual(100) && (i = 74, r = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return s.declare = !0, super.parseFunctionStatement(s, !1, !1);
          case 80:
            return s.declare = !0, this.parseClass(s, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(s, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(s);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (s.declare = !0, this.parseVarStatement(s, r || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(s, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(s, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (Js(i))
              return this.tsParseDeclaration(s, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(s, i, r) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(s);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = s;
            return a.kind = "global", s.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(s, i.name, !1, r);
      }
    }
    tsParseDeclaration(s, i, r, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || Js(this.state.type)))
            return this.tsParseAbstractDeclaration(s, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(s);
            if (Js(this.state.type))
              return s.kind = "module", this.tsParseModuleOrNamespaceDeclaration(s);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && Js(this.state.type))
            return s.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(s);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && Js(this.state.type))
            return this.tsParseTypeAliasDeclaration(s);
          break;
      }
    }
    tsCheckLineTerminator(s) {
      return s ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(s) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let r = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(s);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!r)
        return super.parseArrowExpression(r, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let s = this.startNode();
      return s.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), s.params.length === 0 ? this.raise(lt.EmptyTypeArguments, s) : !this.state.inType && this.curContext() ===
      Hs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return eVe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(s, i) {
      let r = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(s & 4) && (o || u || l) && this.raise(lt.UnexpectedParameterModifier, r);
      let c = this.parseMaybeDefault();
      s & 2 && this.parseFunctionParamType(c);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let h = this.startNodeAt(r);
        return i.length && (h.decorators = i), o && (h.accessibility = o), u && (h.readonly = u), l && (h.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(lt.UnsupportedParameterPropertyKind, h), h.parameter = p, this.finishNode(h, "TSParamet\
erProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(s) {
      return s.type === "TSParameterProperty" && super.isSimpleParameter(s.parameter) || super.isSimpleParameter(s);
    }
    tsDisallowOptionalPattern(s) {
      for (let i of s.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(lt.PatternIsOptional, i);
    }
    setArrowFunctionParameters(s, i, r) {
      super.setArrowFunctionParameters(s, i, r), this.tsDisallowOptionalPattern(s);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      this.match(14) && (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(s, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(lt.DeclareFunctionHasImplementation, s), s.declare) ? super.parseFunctionBodyAndFinish(s, a, r) : (this.tsDisallowOptionalPattern(
      s), super.parseFunctionBodyAndFinish(s, i, r));
    }
    registerFunctionStatementId(s) {
      !s.body && s.id ? this.checkIdentifier(s.id, 1024) : super.registerFunctionStatementId(s);
    }
    tsCheckForInvalidTypeCasts(s) {
      s.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(lt.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(s, i) {
      return this.tsCheckForInvalidTypeCasts(s), s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(s, i, r, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = s, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (r)
          return a.stop = !0, s;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!r && this.atPossibleAsyncArrow(s)) {
            let f = this.tsTryParseGenericAsyncArrowFunction(i);
            if (f)
              return f;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (nS(this.state.type)) {
            let f = super.parseTaggedTemplateExpression(s, i, a);
            return f.typeParameters = c, f;
          }
          if (!r && this.eat(10)) {
            let f = this.startNodeAt(i);
            return f.callee = s, f.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters =
            c, a.optionalChainMember && (f.optional = o), this.finishCallExpression(f, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Eg(p) && !this.hasPrecedingLineBreak())
            return;
          let h = this.startNodeAt(i);
          return h.expression = s, h.typeParameters = c, this.finishNode(h, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          lt.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      var i;
      super.parseNewCallee(s);
      let {
        callee: r
      } = s;
      r.type === "TSInstantiationExpression" && !((i = r.extra) != null && i.parenthesized) && (s.typeParameters = r.typeParameters, s.callee =
      r.expression);
    }
    parseExprOp(s, i, r) {
      let a;
      if (sS(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = s, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(Q.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, r);
      }
      return super.parseExprOp(s, i, r);
    }
    checkReservedWord(s, i, r, a) {
      this.state.isAmbientContext || super.checkReservedWord(s, i, r, a);
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(lt.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return s ? i === 123 || i === 42 : i !== 61;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      super.applyImportPhase(s, i, r, a), i ? s.exportKind = r === "type" ? "type" : "value" : s.importKind = r === "type" || r === "typeof" ?
      r : "value";
    }
    parseImport(s) {
      if (this.match(134))
        return s.importKind = "value", super.parseImport(s);
      let i;
      if (Js(this.state.type) && this.lookaheadCharCode() === 61)
        return s.importKind = "value", this.tsParseImportEqualsDeclaration(s);
      if (this.isContextual(130)) {
        let r = this.parseMaybeImportPhase(s, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(s, r);
        i = super.parseImportSpecifiersAndAfter(s, r);
      } else
        i = super.parseImport(s);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(lt.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(s, i) {
      if (this.match(83)) {
        let r = s;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, a, !0);
      } else if (this.eat(29)) {
        let r = s;
        return r.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let r = s;
        return this.expectContextual(128), r.id = this.parseIdentifier(), this.semicolon(), this.finishNode(r, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(s, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let s = this.startNode();
        return this.next(), s.abstract = !0, this.parseClass(s, !0, !0);
      }
      if (this.match(129)) {
        let s = this.tsParseInterfaceDeclaration(this.startNode());
        if (s) return s;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(s, i, r = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(s, i, r || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(lt.InitializerNotAllowedInAmbientContext, u) : FVe(u, this.hasPlugin("estree")) ||
        this.raise(lt.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(s, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseStatementContent(s, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(s, i) {
      return i.some((r) => P$(r) ? s.accessibility === r : !!s[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(s, i, r) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: lt.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(lt.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(s, i)) : this.parseClassMemberWithIsStatic(s, i, r, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(s, i, r, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        s.body.push(o), i.abstract && this.raise(lt.IndexSignatureHasAbstract, i), i.accessibility && this.raise(lt.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(lt.IndexSignatureHasDeclare, i), i.override && this.raise(lt.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(lt.NonAbstractClassHasAbstractMethod, i), i.override && (r.hadSuperClass || this.
      raise(lt.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(s, i, r, a);
    }
    parsePostMemberNameModifiers(s) {
      this.eat(17) && (s.optional = !0), s.readonly && this.match(10) && this.raise(lt.ClassMethodHasReadonly, s), s.declare && this.match(10) &&
      this.raise(lt.ClassMethodHasDeclare, s);
    }
    parseExpressionStatement(s, i, r) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(s, i, r) : void 0) || super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(r), s;
      }
      return super.parseConditional(s, i, r);
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = s, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return s;
    }
    parseExportDeclaration(s) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(s));
      let i = this.state.startLoc, r = this.eatContextual(125);
      if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(lt.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = Js(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(s);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || r) && (s.exportKind = "type"), r && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(s, i, r, a) {
      if ((!i || r) && this.isContextual(113))
        return;
      super.parseClassId(s, i, r, s.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (s.typeParameters = o);
    }
    parseClassPropertyAnnotation(s) {
      s.optional || (this.eat(35) ? s.definite = !0 : this.eat(17) && (s.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (s.typeAnnotation = i);
    }
    parseClassProperty(s) {
      if (this.parseClassPropertyAnnotation(s), this.state.isAmbientContext && !(s.readonly && !s.typeAnnotation) && this.match(29) && this.
      raise(lt.DeclareClassFieldHasInitializer, this.state.startLoc), s.abstract && this.match(29)) {
        let {
          key: i
        } = s;
        this.raise(lt.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !s.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return s.abstract && this.raise(lt.PrivateElementHasAbstract, s), s.accessibility && this.raise(lt.PrivateElementHasAccessibility, s, {
        modifier: s.accessibility
      }), this.parseClassPropertyAnnotation(s), super.parseClassPrivateProperty(s);
    }
    parseClassAccessorProperty(s) {
      return this.parseClassPropertyAnnotation(s), s.optional && this.raise(lt.AccessorCannotBeOptional, s), super.parseClassAccessorProperty(
      s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(lt.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(lt.DeclareAccessor, i, {
        kind: p
      }), u && (i.typeParameters = u), super.pushClassMethod(s, i, r, a, o, l);
    }
    pushClassPrivateMethod(s, i, r, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(s, i, r, a);
    }
    declareClassPrivateMethodInScope(s, i) {
      s.type !== "TSDeclareMethod" && (s.type === "MethodDefinition" && !hasOwnProperty.call(s.value, "body") || super.declareClassPrivateMethodInScope(
      s, i));
    }
    parseClassSuper(s) {
      super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (s.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (s.typeParameters = c), super.parseObjPropValue(s, i, r, a, o, l, u);
    }
    parseFunctionParams(s, i) {
      let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      r && (s.typeParameters = r), super.parseFunctionParams(s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), s.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (s.definite = !0);
      let r = this.tsTryParseTypeAnnotation();
      r && (s.id.typeAnnotation = r, this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      return this.match(14) && (s.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(s, i);
    }
    parseMaybeAssign(s, i) {
      var r, a, o, l, u;
      let c, p, h;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(s, i), c), !p.error) return p.node;
        let {
          context: y
        } = this.state, m = y[y.length - 1];
        (m === Hs.j_oTag || m === Hs.j_expr) && y.pop();
      }
      if (!((r = p) != null && r.error) && !this.match(47))
        return super.parseMaybeAssign(s, i);
      (!c || c === this.state) && (c = this.state.clone());
      let f, d = this.tryParse((y) => {
        var m, T;
        f = this.tsParseTypeParameters(this.tsParseConstModifier);
        let b = super.parseMaybeAssign(s, i);
        return (b.type !== "ArrowFunctionExpression" || (m = b.extra) != null && m.parenthesized) && y(), ((T = f) == null ? void 0 : T.params.
        length) !== 0 && this.resetStartLocationFromNode(b, f), b.typeParameters = f, b;
      }, c);
      if (!d.error && !d.aborted)
        return f && this.reportReservedArrowTypeParam(f), d.node;
      if (!p && (S$(!this.hasPlugin("jsx")), h = this.tryParse(() => super.parseMaybeAssign(s, i), c), !h.error))
        return h.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (d.node)
        return this.state = d.failState, f && this.reportReservedArrowTypeParam(f), d.node;
      if ((o = h) != null && o.node)
        return this.state = h.failState, h.node;
      throw ((l = p) == null ? void 0 : l.error) || d.error || ((u = h) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(s) {
      var i;
      s.params.length === 1 && !s.params[0].constraint && !((i = s.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(lt.ReservedArrowTypeParam, s);
    }
    parseMaybeUnary(s, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse((r) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), s.returnType = i.node);
      }
      return super.parseArrow(s);
    }
    parseFunctionParamType(s) {
      this.eat(17) && (s.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i), this.resetEndLocation(s), s;
    }
    isAssignable(s, i) {
      switch (s.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(s.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(s, i);
      }
    }
    toAssignable(s, i = !1) {
      switch (s.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(s, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(lt.UnexpectedTypeCastInParameter, s) : this.raise(lt.UnexpectedTypeCastInParameter,
          s), this.toAssignable(s.expression, i);
          break;
        case "AssignmentExpression":
          !i && s.left.type === "TSTypeCastExpression" && (s.left = this.typeCastToParameter(s.left));
        default:
          super.toAssignable(s, i);
      }
    }
    toAssignableParenthesizedExpression(s, i) {
      switch (s.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(s.expression, i);
          break;
        default:
          super.toAssignable(s, i);
      }
    }
    checkToRestConversion(s, i) {
      switch (s.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(s.expression, !1);
          break;
        default:
          super.checkToRestConversion(s, i);
      }
    }
    isValidLVal(s, i, r) {
      switch (s) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (r !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(s, i, r);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(s, i) {
      if (this.match(47) || this.match(51)) {
        let r = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(s, i);
          return a.typeParameters = r, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(s, i);
    }
    checkCommaAfterRest(s) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === s ? (this.next(), !1) : super.checkCommaAfterRest(
      s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(lt.TypeAnnotationAfterAssign,
      r.typeAnnotation), r;
    }
    getTokenFromCode(s) {
      if (this.state.inType) {
        if (s === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (s === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(s);
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    toAssignableListItem(s, i, r) {
      let a = s[i];
      a.type === "TSTypeCastExpression" && (s[i] = this.typeCastToParameter(a)), super.toAssignableListItem(s, i, r);
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    shouldParseArrow(s) {
      return this.match(14) ? s.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(s) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (s.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(s);
    }
    getGetterSetterExpectedParamCount(s) {
      let i = super.getGetterSetterExpectedParamCount(s), a = this.getObjectOrClassMethodParams(s)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let s = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i, this.resetEndLocation(s)), s;
    }
    tsInAmbientContext(s) {
      let {
        isAmbientContext: i,
        strict: r
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return s();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = r;
      }
    }
    parseClass(s, i, r) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!s.abstract;
      try {
        return super.parseClass(s, i, r);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(s, i) {
      if (this.match(80))
        return s.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(s, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return s.abstract = !0, this.raise(lt.NonClassMethodPropertyHasAbstractModifer, s), this.tsParseInterfaceDeclaration(s);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(s, i, r, a, o, l, u) {
      let c = super.parseMethod(s, i, r, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: f
        } = c;
        this.raise(lt.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(this.offsetToSourcePos(f.start), this.offsetToSourcePos(
          f.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(s, i, r, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !1, r), this.finishNode(s, "ExportSpecifier")) : (s.exportKind = "value",
      super.parseExportSpecifier(s, i, r, a));
    }
    parseImportSpecifier(s, i, r, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !0, r), this.finishNode(s, "ImportSpecifier")) : (s.importKind = "value",
      super.parseImportSpecifier(s, i, r, a, r ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(s, i, r) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = s[a], u, c = !1, p = !0, h = l.loc.start;
      if (this.isContextual(93)) {
        let d = this.parseIdentifier();
        if (this.isContextual(93)) {
          let y = this.parseIdentifier();
          bo(this.state.type) ? (c = !0, l = d, u = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = y, p = !1);
        } else bo(this.state.type) ? (p = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = d);
      } else bo(this.state.type) && (c = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && r && this.raise(i ? lt.TypeModifierIsUsedInTypeImports : lt.TypeModifierIsUsedInTypeExports, h), s[a] = l, s[o] = u;
      let f = i ? "importKind" : "exportKind";
      s[f] = c ? "type" : "value", p && this.eatContextual(93) && (s[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), s[o] ||
      (s[o] = ru(s[a])), i && this.checkIdentifier(s[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function MVe(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: s
    } = t;
    return e && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? !1 : q$(t.object);
  }
  n(MVe, "isPossiblyLiteralEnum");
  function FVe(t, e) {
    var s;
    let {
      type: i
    } = t;
    if ((s = t.extra) != null && s.parenthesized)
      return !1;
    if (e) {
      if (i === "Literal") {
        let {
          value: r
        } = t;
        if (typeof r == "string" || typeof r == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(R$(t, e) || jVe(t, e) || i === "TemplateLiteral" && t.expressions.length === 0 || MVe(t));
  }
  n(FVe, "isValidAmbientConstInitializer");
  function R$(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(R$, "isNumber");
  function jVe(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: s,
        argument: i
      } = t;
      if (s === "-" && R$(i, e))
        return !0;
    }
    return !1;
  }
  n(jVe, "isNegativeNumber");
  function q$(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : q$(t.object);
  }
  n(q$, "isUncomputedMemberExpressionChain");
  var E$ = iu`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), RVe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(s) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, s);
      }
    }
    finishPlaceholder(s, i) {
      let r = s;
      return (!r.expectedNode || !r.type) && (r = this.finishNode(r, "Placeholder")), r.expectedNode = i, r;
    }
    getTokenFromCode(s) {
      s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(s);
    }
    parseExprAtom(s) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(s);
    }
    parseIdentifier(s) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(s);
    }
    checkReservedWord(s, i, r, a) {
      s !== void 0 && super.checkReservedWord(s, i, r, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(s, i, r) {
      return s === "Placeholder" || super.isValidLVal(s, i, r);
    }
    toAssignable(s, i) {
      s && s.type === "Placeholder" && s.expectedNode === "Expression" ? s.expectedNode = "Pattern" : super.toAssignable(s, i);
    }
    chStartsBindingIdentifier(s, i) {
      return !!(super.chStartsBindingIdentifier(s, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(s, i) {
      s.label && s.label.type === "Placeholder" || super.verifyBreakContinue(s, i);
    }
    parseExpressionStatement(s, i) {
      var r;
      if (i.type !== "Placeholder" || (r = i.extra) != null && r.parenthesized)
        return super.parseExpressionStatement(s, i);
      if (this.match(14)) {
        let o = s;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = s;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(s, i, r) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(s, i, r);
    }
    parseFunctionId(s) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(s);
    }
    parseClass(s, i, r) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          s.id = l;
        else {
          if (r || !i)
            return s.id = null, s.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(s, a);
          throw this.raise(E$.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(s, i, r);
      return super.parseClassSuper(s), s.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!s.superClass, o), this.finishNode(
      s, a);
    }
    parseExport(s, i) {
      let r = this.parsePlaceholder("Identifier");
      if (!r) return super.parseExport(s, i);
      let a = s;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(r, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = r, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let s = this.nextTokenStart();
        if (this.isUnparsedContextual(s, "from") && this.input.startsWith(Rc(133), this.nextTokenStartSince(s + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(s, i) {
      var r;
      return (r = s.specifiers) != null && r.length ? !0 : super.maybeParseExportDefaultSpecifier(s, i);
    }
    checkExport(s) {
      let {
        specifiers: i
      } = s;
      i != null && i.length && (s.specifiers = i.filter((r) => r.exported.type === "Placeholder")), super.checkExport(s), s.specifiers = i;
    }
    parseImport(s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(s);
      if (s.specifiers = [], !this.isContextual(98) && !this.match(12))
        return s.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(s, "ImportDeclaration");
      let r = this.startNodeAtNode(i);
      return r.local = i, s.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      s) || this.parseNamedImportSpecifiers(s)), this.expectContextual(98), s.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      s, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(E$.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), qVe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let s = this.state.startLoc, i = this.startNode();
        if (this.next(), Js(this.state.type)) {
          let r = this.parseIdentifierName(), a = this.createIdentifier(i, r);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(s);
      }
    }
    parseExprAtom(s) {
      return this.parseV8Intrinsic() || super.parseExprAtom(s);
    }
  }, "v8intrinsic"), A$ = ["minimal", "fsharp", "hack", "smart"], v$ = ["^^", "@@", "^", "%", "#"];
  function UVe(t) {
    if (t.has("decorators")) {
      if (t.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let s = t.get("decorators").decoratorsBeforeExport;
      if (s != null && typeof s != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = t.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (t.has("flow") && t.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (t.has("placeholders") && t.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (t.has("pipelineOperator")) {
      var e;
      let s = t.get("pipelineOperator").proposal;
      if (!A$.includes(s)) {
        let r = A$.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      let i = ((e = t.get("recordAndTuple")) == null ? void 0 : e.syntaxType) === "hash";
      if (s === "hack") {
        if (t.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (t.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let r = t.get("pipelineOperator").topicToken;
        if (!v$.includes(r)) {
          let a = v$.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (r === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", t.get("recordAndTuple")])}\`.`);
      } else if (s === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", t.
        get("recordAndTuple")])}\`.`);
    }
    if (t.has("moduleAttributes")) {
      if (t.has("deprecatedImportAssert") || t.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (t.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (t.has("importAssertions") && t.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!t.has("deprecatedImportAssert") && t.has("importAttributes") && t.get("importAttributes").deprecatedAssertSyntax && t.set("deprecat\
edImportAssert", {}), t.has("recordAndTuple")) {
      let s = t.get("recordAndTuple").syntaxType;
      if (s != null) {
        let i = ["hash", "bar"];
        if (!i.includes(s))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((r) => `'${r}'`).join(", "));
      }
    }
    if (t.has("asyncDoExpressions") && !t.has("doExpressions")) {
      let s = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw s.missingPlugins = "doExpressions", s;
    }
    if (t.has("optionalChainingAssign") && t.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(UVe, "validatePlugins");
  var U$ = {
    estree: VKe,
    jsx: DVe,
    flow: NVe,
    typescript: BVe,
    v8intrinsic: qVe,
    placeholders: RVe
  }, KVe = Object.keys(U$), Qk = class extends Gk {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, s, i, r) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return i;
      let a = e.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? s ? (this.raise(Q.RecordNoProto, a), !0) : (i && (r ? r.doubleProtoLoc ===
      null && (r.doubleProtoLoc = a.loc.start) : this.raise(Q.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(e, s) {
      return e.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e.start) === s;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.optionFlags & 256 && (e.tokens = this.tokens), e;
    }
    parseExpression(e, s) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(s)) : this.allowInAnd(() => this.parseExpressionBase(s));
    }
    parseExpressionBase(e) {
      let s = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let r = this.startNodeAt(s);
        for (r.expressions = [i]; this.eat(12); )
          r.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(r.expressions), this.finishNode(r, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, s) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, s));
    }
    parseMaybeAssignAllowIn(e, s) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, s));
    }
    setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(e, s) {
      let i = this.state.startLoc, r = this.isContextual(108);
      if (r && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(i);
        return s && (u = s.call(this, u, i)), u;
      }
      let a;
      e ? a = !1 : (e = new Ed(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || Js(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(e);
      if (s && (l = s.call(this, l, i)), YKe(this.state.type)) {
        let u = this.startNodeAt(i), c = this.state.value;
        if (u.operator = c, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let p = i.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= p && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= p && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression")), u;
      } else a && this.checkExpressionErrors(e, !0);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Eg(u) : Eg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Q.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return l;
    }
    parseMaybeConditional(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprOps(e);
      return this.shouldExitDescending(r, i) ? r : this.parseConditional(r, s, e);
    }
    parseConditional(e, s, i) {
      if (this.eat(17)) {
        let r = this.startNodeAt(s);
        return r.test = e, r.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r.alternate = this.parseMaybeAssign(), this.finishNode(
        r, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(r, i) ? r : this.parseExprOp(r, s, -1);
    }
    parseExprOp(e, s, i) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (i >= sS(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Q.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let r = this.state.type;
      if (zKe(r) && (this.prodParam.hasIn || !this.match(58))) {
        let a = sS(r);
        if (a > i) {
          if (r === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, s);
          }
          let o = this.startNodeAt(s);
          o.left = e, o.operator = this.state.value;
          let l = r === 41 || r === 42, u = r === 40;
          if (u && (a = sS(42)), this.next(), r === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(Q.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(r, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(Q.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, s, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, s) {
      let i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(s));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(Q.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, s), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(e, s);
      }
    }
    parseExprOpBaseRightExpr(e, s) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, tVe(e) ? s - 1 : s);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: s
      } = this.state, i = this.parseMaybeAssign();
      return MKe.has(i.type) && !((e = i.extra) != null && e.parenthesized) && this.raise(Q.PipeUnparenthesizedBody, s, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Q.PipeTopicUnused, s), i;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(Q.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, s) {
      let i = this.state.startLoc, r = this.isContextual(96);
      if (r && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return s || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (QKe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(Q.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(Q.DeletePrivateField, o);
        }
        if (!a)
          return s || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Eg(u) : Eg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Q.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(e, s, i) {
      if (s) {
        let o = e;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), e;
      }
      let r = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; GKe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(r);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprAtom(e);
      return this.shouldExitDescending(r, i) ? r : this.parseSubscripts(r, s);
    }
    parseSubscripts(e, s, i) {
      let r = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, s, i, r), r.maybeAsyncArrow = !1;
      while (!r.stop);
      return e;
    }
    parseSubscript(e, s, i, r) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(e, s, i, r);
      if (nS(a))
        return this.parseTaggedTemplateExpression(e, s, r);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(Q.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return r.stop = !0, e;
        r.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, s, r, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, s, r, l, o) : (r.stop = !0, e);
      }
    }
    parseMember(e, s, i, r, a) {
      let o = this.startNodeAt(s);
      return o.object = e, o.computed = r, r ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (e.type === "Super" &&
      this.raise(Q.SuperPrivateField, s), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, s, i, r) {
      let a = this.startNodeAt(s);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), s, i);
    }
    parseCoverCallAndAsyncArrowHead(e, s, i, r) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(s);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = i;
      u && (this.expressionScope.enter(SVe()), o = new Ed()), c && (l.optional = r), r ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !r ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(s), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, s) {
      this.toReferencedListDeep(e.arguments, s);
    }
    parseTaggedTemplateExpression(e, s, i) {
      let r = this.startNodeAt(s);
      return r.tag = e, r.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(Q.OptionalChainingNoTemplate, s), this.finishNode(
      r, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(e, s) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(Q.ImportCallArity, e);
        else
          for (let i of e.arguments)
            i.type === "SpreadElement" && this.raise(Q.ImportCallSpreadArgument, i);
      return this.finishNode(e, s ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, s, i, r) {
      let a = [], o = !0, l = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, r, s));
      }
      return this.state.inFSharpPipelineDirectBody = l, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, s) {
      var i;
      return this.resetPreviousNodeTrailingComments(s), this.expect(19), this.parseArrowExpression(e, s.arguments, !0, (i = s.extra) == null ?
      void 0 : i.trailingCommaLoc), s.innerComments && Ig(e, s.innerComments), s.callee.trailingComments && Ig(e, s.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let s, i = null, {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return s = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(s) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(s) : this.finishNode(s, "Import") : (this.raise(Q.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          s, "Import"));
        case 78:
          return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          s = this.startNode(), this.next(), s.object = null;
          let a = s.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(s, "BindExpression");
          throw this.raise(Q.UnsupportedBind, a);
        }
        case 139:
          return this.raise(Q.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          su(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (r === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (Js(r)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (Js(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, s) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = e, this.state.value = s, this.state.pos--, this.state.end--, this.state.endLoc = xn(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(e) {
      let s = this.startNode(), i = this.state.startLoc, r = this.state.type;
      return this.next(), this.finishTopicReference(s, i, e, r);
    }
    finishTopicReference(e, s, i, r) {
      if (this.testTopicReferenceConfiguration(i, s, r))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Q.PipeTopicUnbound, s), this.registerTopicReference(),
        this.finishNode(e, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Q.PrimaryTopicNotAllowed, s), this.
        registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"));
      throw this.raise(Q.PipeTopicUnconfiguredToken, s, {
        token: Rc(r)
      });
    }
    testTopicReferenceConfiguration(e, s, i) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Rc(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(Q.PipeTopicRequiresHackPipes, s);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(iS(!0, this.prodParam.hasYield));
      let s = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Q.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, s, !0);
    }
    parseDo(e, s) {
      this.expectPlugin("doExpressions"), s && this.expectPlugin("asyncDoExpressions"), e.async = s, this.next();
      let i = this.state.labels;
      return this.state.labels = [], s ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(Q.SuperNotAllowed, e) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(Q.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(Q.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), s = this.startNodeAt(xn(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), e.id = this.createIdentifier(s, i), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, s, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, s, i) {
      e.meta = s;
      let r = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== i || r) && this.raise(Q.UnsupportedMetaProperty, e.property, {
        target: s.name,
        onlyValidPropertyName: i
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let s = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(Q.ImportMetaOutsideModule, s), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(Q.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = i ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, s, "meta");
    }
    parseLiteralAtNode(e, s, i) {
      return this.addExtra(i, "rawValue", e), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = e, this.next(), this.finishNode(i, s);
    }
    parseLiteral(e, s) {
      let i = this.startNode();
      return this.parseLiteralAtNode(e, s, i);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let s = this.startNode();
      return this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.pattern = e.pattern, s.flags = e.
      flags, this.next(), this.finishNode(s, "RegExpLiteral");
    }
    parseBooleanLiteral(e) {
      let s = this.startNode();
      return s.value = e, this.next(), this.finishNode(s, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let s = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(xVe());
      let r = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Ed(), c = !0, p, h;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          h = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let y = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let f = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = r, this.state.inFSharpPipelineDirectBody = a;
      let d = this.startNodeAt(s);
      return e && this.shouldParseArrow(l) && (d = this.parseArrow(d)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(d, l, !1), d) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), h && this.unexpected(h), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      f)) : i = l[0], this.wrapParenthesis(s, i));
    }
    wrapParenthesis(e, s) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", e.index), this.takeSurroundingComments(s, e.index, this.
        state.lastTokEndLoc.index), s;
      let i = this.startNodeAt(e);
      return i.expression = s, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, s) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let i = this.parseMetaProperty(e, s, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(Q.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let s = this.parseExprList(11);
        this.toReferencedList(s), e.arguments = s;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let s = this.match(83), i = this.parseNoCallExpr();
      e.callee = i, s && (i.type === "Import" || i.type === "ImportExpression") && this.raise(Q.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(e) {
      let {
        start: s,
        startLoc: i,
        end: r,
        value: a
      } = this.state, o = s + 1, l = this.startNodeAt(xn(i, 1));
      a === null && (e || this.raise(Q.InvalidEscapeSequenceTemplate, xn(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = r + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let h = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(h, xn(this.state.lastTokEndLoc, c)), h;
    }
    parseTemplate(e) {
      let s = this.startNode(), i = this.parseTemplateElement(e), r = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.push(i = this.parseTemplateElement(e));
      return s.expressions = a, s.quasis = r, this.finishNode(s, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        s ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(r), o = this.checkProto(p, i, o, r)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(Q.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return s ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let s = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(Q.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          s.push(this.parseDecorator());
      let i = this.startNode(), r = !1, a = !1, o;
      if (this.match(21))
        return s.length && this.unexpected(), this.parseSpread();
      s.length && (i.decorators = s, s = []), i.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(i, e), !l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: c
        } = i, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (r = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (l = !0, this.
        raise(Q.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, r, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var s;
      let i = this.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e);
      r.length !== i && this.raise(e.kind === "get" ? Q.BadGetterArity : Q.BadSetterArity, e), e.kind === "set" && ((s = r[r.length - 1]) ==
      null ? void 0 : s.type) === "RestElement" && this.raise(Q.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, s, i, r, a) {
      if (a) {
        let o = this.parseMethod(e, s, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || s || this.match(10))
        return r && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, s, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, s, i, r) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(r), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
          e.value = this.parseMaybeDefault(s, ru(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          r != null ? r.shorthandAssignLoc === null && (r.shorthandAssignLoc = a) : this.raise(Q.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(s, ru(e.key));
        } else
          e.value = ru(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, s, i, r, a, o, l) {
      let u = this.parseObjectMethod(e, i, r, a, o) || this.parseObjectProperty(e, s, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, s) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: r
        } = this.state, a;
        if (bo(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(r);
              break;
            case 134:
              a = this.parseStringLiteral(r);
              break;
            case 136:
              a = this.parseBigIntLiteral(r);
              break;
            case 139: {
              let o = this.state.startLoc;
              s != null ? s.privateKeyLoc === null && (s.privateKeyLoc = o) : this.raise(Q.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(r);
                break;
              }
              this.unexpected();
          }
        e.key = a, i !== 139 && (e.computed = !1);
      }
    }
    initFunction(e, s) {
      e.id = null, e.generator = !1, e.async = s;
    }
    parseMethod(e, s, i, r, a, o, l = !1) {
      this.initFunction(e, i), e.generator = s, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(iS(i, e.generator)),
      this.parseFunctionParams(e, r);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !i, r, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, s, i, r) {
      this.scope.enter(6);
      let a = iS(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, i);
      let o = this.state.maybeInArrowParameters;
      return s && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, s, r)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, s, i) {
      this.toAssignableList(s, i, !1), e.params = s;
    }
    parseFunctionBodyAndFinish(e, s, i = !1) {
      return this.parseFunctionBody(e, !1, i), this.finishNode(e, s);
    }
    parseFunctionBody(e, s, i = !1) {
      let r = s && !this.match(5);
      if (this.expressionScope.enter(F$()), r)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, s, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(Q.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !s && !i && !u, s, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let s = 0, i = e.length; s < i; s++)
        if (!this.isSimpleParameter(e[s])) return !1;
      return !0;
    }
    checkParams(e, s, i, r = !0) {
      let a = !s && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, o, 5, a, r);
    }
    parseExprList(e, s, i, r) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        a.push(this.parseExprListItem(s, i));
      }
      return a;
    }
    parseExprListItem(e, s, i) {
      let r;
      if (this.match(12))
        e || this.raise(Q.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), r = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        r = this.parseParenItem(this.parseSpread(s), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(Q.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), r = this.finishNode(a, "ArgumentPlaceholder");
      } else
        r = this.parseMaybeAssignAllowIn(s, this.parseParenItem);
      return r;
    }
    parseIdentifier(e) {
      let s = this.startNode(), i = this.parseIdentifierName(e);
      return this.createIdentifier(s, i);
    }
    createIdentifier(e, s) {
      return e.name = s, e.loc.identifierName = s, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let s, {
        startLoc: i,
        type: r
      } = this.state;
      bo(r) ? s = this.state.value : this.unexpected();
      let a = HKe(r);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(s, i, a, !1), this.next(), s;
    }
    checkReservedWord(e, s, i, r) {
      if (e.length > 10 || !pVe(e))
        return;
      if (i && lVe(e)) {
        this.raise(Q.UnexpectedKeyword, s, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? r ? _$ : D$ : k$)(e, this.inModule)) {
        this.raise(Q.UnexpectedReservedWord, s, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Q.YieldBindingIdentifier, s);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Q.AwaitBindingIdentifier, s);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Q.AwaitBindingIdentifierInStaticBlock, s);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(s);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Q.ArgumentsInClass, s);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
    }
    parseAwait(e) {
      let s = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(Q.AwaitExpressionFormalParameter, s), this.eat(55) && this.raise(Q.ObsoleteAwaitStar,
      s), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, !0)), this.finishNode(s, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || nS(e) || e === 102 && !this.state.containsEsc || e === 138 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield(e) {
      let s = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(Q.YieldInParameter, s);
      let i = !1, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            r = this.parseMaybeAssign();
        }
      return s.delegate = i, s.argument = r, this.finishNode(s, "YieldExpression");
    }
    parseImportCall(e) {
      if (this.next(), e.source = this.parseMaybeAssignAllowIn(), e.options = null, this.eat(12) && !this.match(11) && (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(Q.ImportCallArity, e);
      }
      return this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, s) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(Q.PipelineHeadSequenceExpression, s);
    }
    parseSmartPipelineBodyInStyle(e, s) {
      if (this.isSimpleReference(e)) {
        let i = this.startNodeAt(s);
        return i.callee = e, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(s);
        return this.checkSmartPipeTopicBodyEarlyErrors(s), i.expression = e, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(Q.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(Q.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let s = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = s;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let s = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = s;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let s = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = s;
      }
    }
    allowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & ~s) {
        this.prodParam.enter(s | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & s) {
        this.prodParam.enter(s & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let s = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let r = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, e);
      return this.state.inFSharpPipelineDirectBody = i, r;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let s = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(s, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, _k = {
    kind: 1
  }, VVe = {
    kind: 2
  }, WVe = /[\uD800-\uDFFF]/u, Lk = /in(?:stanceof)?/y;
  function $Ve(t, e, s) {
    for (let i = 0; i < t.length; i++) {
      let r = t[i], {
        type: a
      } = r;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = xn(o.start, 1);
            t.splice(i, 1, new sl({
              type: eu(27),
              value: "#",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }), new sl({
              type: eu(132),
              value: u,
              start: p,
              end: c,
              startLoc: h,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (nS(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = xn(o.start, 1), f;
            e.charCodeAt(l - s) === 96 ? f = new sl({
              type: eu(22),
              value: "`",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }) : f = new sl({
              type: eu(8),
              value: "}",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            });
            let d, y, m, T;
            a === 24 ? (y = c - 1, m = xn(o.end, -1), d = u === null ? null : u.slice(1, -1), T = new sl({
              type: eu(22),
              value: "`",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })) : (y = c - 2, m = xn(o.end, -2), d = u === null ? null : u.slice(1, -2), T = new sl({
              type: eu(23),
              value: "${",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })), t.splice(i, 1, f, new sl({
              type: eu(20),
              value: d,
              start: p,
              end: y,
              startLoc: h,
              endLoc: m
            }), T), i += 2;
            continue;
          }
        }
        r.type = eu(a);
      }
    }
    return t;
  }
  n($Ve, "babel7CompatTokens");
  var Zk = class extends Qk {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, s) {
      return e.program = this.parseProgram(s), e.comments = this.comments, this.optionFlags & 256 && (e.tokens = $Ve(this.tokens, this.input,
      this.startIndex)), this.finishNode(e, "File");
    }
    parseProgram(e, s = 140, i = this.options.sourceType) {
      if (e.sourceType = i, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, s), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(Q.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(e, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let r;
      return s === 140 ? r = this.finishNode(e, "Program") : r = this.finishNodeAt(e, "Program", xn(this.state.startLoc, -1)), r;
    }
    stmtToDirective(e) {
      let s = e;
      s.type = "Directive", s.value = s.expression, delete s.expression;
      let i = s.value, r = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", r), i.type = "DirectiveLiteral",
      s;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, s) {
      if (su(e)) {
        if (Lk.lastIndex = s, Lk.test(this.input)) {
          let i = this.codePointAtPos(Lk.lastIndex);
          if (!Sd(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), s = this.codePointAtPos(e);
      return this.chStartsBindingPattern(s) || this.chStartsBindingIdentifier(s, e);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
      return s === 123 || this.chStartsBindingIdentifier(s, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: s
      } = this.lookahead();
      if (e === 102 && !s)
        return !1;
      if (Js(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let s = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(s, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let s = 0;
      return this.options.annexB && !this.state.strict && (s |= 4, e && (s |= 8)), this.parseStatementLike(s);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let s = null;
      return this.match(26) && (s = this.parseDecorators(!0)), this.parseStatementContent(e, s);
    }
    parseStatementContent(e, s) {
      let i = this.state.type, r = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(r, !0);
        case 63:
          return this.parseBreakContinueStatement(r, !1);
        case 64:
          return this.parseDebuggerStatement(r);
        case 90:
          return this.parseDoWhileStatement(r);
        case 91:
          return this.parseForStatement(r);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? Q.StrictFunction : this.options.annexB ? Q.SloppyFunctionAnnexB : Q.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(r, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(s, r), !0);
        case 69:
          return this.parseIfStatement(r);
        case 70:
          return this.parseReturnStatement(r);
        case 71:
          return this.parseSwitchStatement(r);
        case 72:
          return this.parseThrowStatement(r);
        case 73:
          return this.parseTryStatement(r);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(Q.UnexpectedLexicalDeclaration, r) : this.raise(Q.AwaitUsingNotInAsyncContext,
            r), this.next(), this.parseVarStatement(r, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Q.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(Q.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(r, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), h = this.codePointAtPos(p);
          if (h !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(h, p) && h !== 123))
            break;
        }
        case 75:
          a || this.raise(Q.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(r, p);
        }
        case 92:
          return this.parseWhileStatement(r);
        case 76:
          return this.parseWithStatement(r);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(r);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(Q.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? p = this.parseImport(r) : p = this.parseExport(r, s), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(Q.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(r,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return Js(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r, u, c, e) : this.parseExpressionStatement(r, c,
      s);
    }
    assertModuleNodeAllowed(e) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(Q.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, s, i) {
      if (e) {
        var r;
        (r = s.decorators) != null && r.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        Q.DecoratorsBeforeAfterExport, s.decorators[0]), s.decorators.unshift(...e)) : s.decorators = e, this.resetStartLocationFromNode(s, e[0]),
        i && this.resetStartLocationFromNode(i, s);
      }
      return s;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let s = [];
      do
        s.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Q.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(Q.UnexpectedLeadingDecorator, this.state.startLoc);
      return s;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let s = this.state.startLoc, i;
        if (this.match(10)) {
          let r = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(r, i);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(i, r), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          i && this.raise(Q.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let r = this.startNodeAt(s);
            r.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), r.property = this.parsePrivateName()) :
            r.property = this.parseIdentifier(!0), r.computed = !1, i = this.finishNode(r, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(i, s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e, s) {
      if (this.eat(10)) {
        let i = this.startNodeAt(s);
        return i.callee = e, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, s) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, s), this.finishNode(e, s ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, s) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let r = this.state.labels[i];
        if ((e.label == null || r.name === e.label.name) && (r.kind != null && (s || r.kind === 1) || e.label && s))
          break;
      }
      if (i === this.state.labels.length) {
        let r = s ? "BreakStatement" : "ContinueStatement";
        this.raise(Q.IllegalBreakContinue, e, {
          type: r
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(_k), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(_k);
      let s = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (s = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return s !== null && this.unexpected(s), this.parseFor(e, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let h = this.startNode(), f;
          u ? (f = "await using", this.recordAwaitIfAllowed() || this.raise(Q.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          f = this.state.value, this.next(), this.parseVar(h, !0, f);
          let d = this.finishNode(h, "VariableDeclaration"), y = this.match(58);
          return y && c && this.raise(Q.ForInUsing, d), (y || this.isContextual(102)) && d.declarations.length === 1 ? this.parseForIn(e, d,
          s) : (s !== null && this.unexpected(s), this.parseFor(e, d));
        }
      }
      let r = this.isContextual(95), a = new Ed(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(Q.ForOfLet, o), s === null && r && o.type === "Identifier" && this.raise(Q.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(e, o, s);
      } else
        this.checkExpressionErrors(a, !0);
      return s !== null && this.unexpected(s), this.parseFor(e, o);
    }
    parseFunctionStatement(e, s, i) {
      return this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (s ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(Q.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let s = e.cases = [];
      this.expect(5), this.state.labels.push(VVe), this.scope.enter(0);
      let i;
      for (let r; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), s.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (r && this.raise(Q.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), r = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(Q.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        type: "CatchClause"
      }, 9), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let s = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), s.param = this.parseCatchClauseParam(), this.expect(11)) : (s.param = null, this.scope.
        enter(0)), s.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        s, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(Q.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, s, i = !1) {
      return this.next(), this.parseVar(e, !1, s, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(_k), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(Q.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, s, i, r) {
      for (let o of this.state.labels)
        o.name === s && this.raise(Q.LabelRedeclaration, i, {
          labelName: s
        });
      let a = XKe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: s,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), e.body = r & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      i, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, s, i) {
      return e.expression = s, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, s = !0, i) {
      let r = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), s && this.scope.enter(0), this.parseBlockBody(r, e, !1, 8, i), s && this.
      scope.exit(), this.finishNode(r, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, s, i, r, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, s ? l : void 0, i, r, a);
    }
    parseBlockOrModuleBlockBody(e, s, i, r, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(r); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (s && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            s.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, s) {
      return e.init = s, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, s, i) {
      let r = this.match(58);
      return this.next(), r ? i !== null && this.unexpected(i) : e.await = i !== null, s.type === "VariableDeclaration" && s.declarations[0].
      init != null && (!r || !this.options.annexB || this.state.strict || s.kind !== "var" || s.declarations[0].id.type !== "Identifier") &&
      this.raise(Q.ForInOfLoopInitializer, s, {
        type: r ? "ForInStatement" : "ForOfStatement"
      }), s.type === "AssignmentPattern" && this.raise(Q.InvalidLhs, s, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = s, e.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, s, i, r = !1) {
      let a = e.declarations = [];
      for (e.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? s ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !r && (o.id.type !== "Identifier" && !(s && (this.match(58) || this.isContextual(102))) ? this.raise(Q.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Q.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, s) {
      let i = this.parseBindingAtom();
      (s === "using" || s === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(Q.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, s === "var" ? 5 : 8201), e.id = i;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, s = 0) {
      let i = s & 2, r = !!(s & 1), a = r && !(s & 4), o = !!(s & 8);
      this.initFunction(e, o), this.match(55) && (i && this.raise(Q.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), r && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(iS(o, e.generator)), r || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, r ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r && !i && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || Js(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, s) {
      this.expect(10), this.expressionScope.enter(bVe()), e.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, s, i) {
      this.next();
      let r = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, s, i), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, r), this.
      finishNode(e, s ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, s) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: e
      }, r = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (r.length > 0)
              throw this.raise(Q.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            r.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          r.length && (o.decorators = r, this.resetStartLocationFromNode(o, r[0]), r = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(Q.DecoratorConstructor, o);
        }
      }), this.state.strict = s, this.next(), r.length)
        throw this.raise(Q.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, s) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let r = s;
        return r.kind = "method", r.computed = !1, r.key = i, r.static = !1, this.pushClassMethod(e, r, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let r = s;
        return r.computed = !1, r.key = i, r.static = !1, e.body.push(this.parseClassProperty(r)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(e, s, i) {
      let r = this.isContextual(106);
      if (r) {
        if (this.parseClassMemberFromModifier(e, s))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, s);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, s, i, r);
    }
    parseClassMemberWithIsStatic(e, s, i, r) {
      let a = s, o = s, l = s, u = s, c = s, p = a, h = a;
      if (s.static = r, this.parsePropertyNamePrefixOperator(s), this.eat(55)) {
        p.kind = "method";
        let b = this.match(139);
        if (this.parseClassElementName(p), b) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(Q.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let f = !this.state.containsEsc && Js(this.state.type), d = this.parseClassElementName(s), y = f ? d.name : null, m = this.isPrivateName(
      d), T = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(h), this.isClassMethod()) {
        if (p.kind = "method", m) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let b = this.isNonstaticConstructor(a), E = !1;
        b && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(Q.DuplicateConstructor, d), b && this.
        hasPlugin("typescript") && s.override && this.raise(Q.OverrideOnConstructor, d), i.hadConstructor = !0, E = i.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, b, E);
      } else if (this.isClassProperty())
        m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (y === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(d);
        let b = this.eat(55);
        h.optional && this.unexpected(T), p.kind = "method";
        let E = this.match(139);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(h), E ? this.pushClassPrivateMethod(e, o, b, !0) : (this.isNonstaticConstructor(
        a) && this.raise(Q.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, b, !0, !1, !1));
      } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(d), p.kind = y;
        let b = this.match(139);
        this.parseClassElementName(a), b ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(Q.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (y === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
        let b = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, b);
      } else this.isLineTerminator() ? m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: s,
        value: i
      } = this.state;
      if ((s === 132 || s === 134) && e.static && i === "prototype" && this.raise(Q.StaticPrototype, this.state.startLoc), s === 139) {
        i === "constructor" && this.raise(Q.ConstructorClassPrivateField, this.state.startLoc);
        let r = this.parsePrivateName();
        return e.key = r, r;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, s) {
      var i;
      this.scope.enter(208);
      let r = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = s.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, e.body.push(this.
      finishNode(s, "StaticBlock")), (i = s.decorators) != null && i.length && this.raise(Q.DecoratorStaticBlock, s);
    }
    pushClassProperty(e, s) {
      !s.computed && this.nameIsConstructor(s.key) && this.raise(Q.ConstructorClassField, s.key), e.body.push(this.parseClassProperty(s));
    }
    pushClassPrivateProperty(e, s) {
      let i = this.parseClassPrivateProperty(s);
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(e, s, i) {
      !i && !s.computed && this.nameIsConstructor(s.key) && this.raise(Q.ConstructorClassField, s.key);
      let r = this.parseClassAccessorProperty(s);
      e.body.push(r), i && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
    }
    pushClassMethod(e, s, i, r, a, o) {
      e.body.push(this.parseMethod(s, i, r, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, s, i, r) {
      let a = this.parseMethod(s, i, r, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, s) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), s, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(F$()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, s, i, r = 8331) {
      if (Js(this.state.type))
        e.id = this.parseIdentifier(), s && this.declareNameFromIdentifier(e.id, r);
      else if (i || !s)
        e.id = null;
      else
        throw this.raise(Q.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, s) {
      let i = this.parseMaybeImportPhase(e, !0), r = this.maybeParseExportDefaultSpecifier(e, i), a = !r || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = r || o;
      if (o && !l) {
        if (r && this.unexpected(), s)
          throw this.raise(Q.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.sawUnambiguousESM = !0, this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      r && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let h;
      if (c || p) {
        if (h = !1, s)
          throw this.raise(Q.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        h = this.maybeParseExportDeclaration(e);
      if (c || p || h) {
        var f;
        let d = e;
        if (this.checkExport(d, !0, !1, !!d.source), ((f = d.declaration) == null ? void 0 : f.type) === "ClassDeclaration")
          this.maybeTakeDecorators(s, d.declaration, d);
        else if (s)
          throw this.raise(Q.UnsupportedDecoratorExport, e);
        return this.sawUnambiguousESM = !0, this.finishNode(d, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let d = e, y = this.parseExportDefaultExpression();
        if (d.declaration = y, y.type === "ClassDeclaration")
          this.maybeTakeDecorators(s, y, d);
        else if (s)
          throw this.raise(Q.UnsupportedDecoratorExport, e);
        return this.checkExport(d, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(d, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, s) {
      if (s || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", s?.loc.start);
        let i = s || this.parseIdentifier(!0), r = this.startNodeAtNode(i);
        return r.exported = i, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var s, i;
        (i = (s = e).specifiers) != null || (s.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let s = e;
        s.specifiers || (s.specifiers = []);
        let i = s.exportKind === "type";
        return s.specifiers.push(...this.parseExportSpecifiers(i)), s.source = null, this.hasPlugin("importAssertions") ? s.assertions = [] :
        s.attributes = [], s.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") ? e.assertions = [] :
      e.attributes = [], e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Q.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(Q.UnsupportedDefaultExport, this.state.startLoc);
      let s = this.parseMaybeAssignAllowIn();
      return this.semicolon(), s;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (Js(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: r
          } = this.lookahead();
          if (Js(r) && r !== 98 || r === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let s = this.nextTokenStart(), i = this.isUnparsedContextual(s, "from");
      if (this.input.charCodeAt(s) === 44 || Js(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let r = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
        return r === 34 || r === 39;
      }
      return !1;
    }
    parseExportFrom(e, s) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : s && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(Q.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(Q.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(Q.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, s, i, r) {
      if (s) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            Q.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !r && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(Q.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let s of e.properties)
          this.checkDeclaration(s);
      else if (e.type === "ArrayPattern")
        for (let s of e.elements)
          s && this.checkDeclaration(s);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, s) {
      this.exportedIdentifiers.has(s) && (s === "default" ? this.raise(Q.DuplicateDefaultExport, e) : this.raise(Q.DuplicateExport, e, {
        exportName: s
      })), this.exportedIdentifiers.add(s);
    }
    parseExportSpecifiers(e) {
      let s = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let r = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), s.push(this.parseExportSpecifier(o, a, e, r));
      }
      return s;
    }
    parseExportSpecifier(e, s, i, r) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : s ? e.exported = EVe(e.local) : e.exported || (e.exported =
      ru(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let e = this.parseStringLiteral(this.state.value), s = WVe.exec(e.value);
        return s && this.raise(Q.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: s[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: s,
        value: i
      }) => i.value === "json" && (s.type === "Identifier" ? s.name === "type" : s.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: s
      } = e, i = s.length === 1 ? s[0].type : null;
      if (e.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(Q.SourcePhaseImportRequiresDefault, s[0].loc.start);
      else if (e.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(Q.DeferImportRequiresNamespace, s[0].loc.start);
      else if (e.module) {
        var r;
        i !== "ImportDefaultSpecifier" && this.raise(Q.ImportReflectionNotBinding, s[0].loc.start), ((r = e.assertions) == null ? void 0 : r.
        length) > 0 && this.raise(Q.ImportReflectionHasAssertion, s[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: s
        } = e;
        if (s != null) {
          let i = s.find((r) => {
            let a;
            if (r.type === "ExportSpecifier" ? a = r.local : r.type === "ImportSpecifier" && (a = r.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(Q.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, s, i, r) {
      s || (i === "module" ? (this.expectPlugin("importReflection", r), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", r), e.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", r), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, s) {
      if (!this.isPotentialImportPhase(s))
        return this.applyImportPhase(e, s, null), null;
      let i = this.parseIdentifier(!0), {
        type: r
      } = this.state;
      return (bo(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      e, s, i.name, i.loc.start), null) : (this.applyImportPhase(e, s, null), i);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: s
      } = this.state;
      return Js(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12;
    }
    parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, s) {
      e.specifiers = [];
      let r = !this.maybeParseDefaultImportSpecifier(e, s) || this.eat(12), a = r && this.maybeParseStarImportSpecifier(e);
      return r && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var s;
      return (s = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(e, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, s, i) {
      s.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
    }
    finishImportSpecifier(e, s, i = 8201) {
      return this.checkLVal(e.local, {
        type: s
      }, i), this.finishNode(e, s);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), r = this.state.value;
        if (s.has(r) && this.raise(Q.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: r
        }), s.add(r), this.match(134) ? i.key = this.parseStringLiteral(r) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(Q.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(Q.ModuleAttributeDifferentFromType, i.key), s.has(i.key.name) &&
        this.raise(Q.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), s.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(Q.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let s;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (s = this.parseModuleAttributes(), this.addExtra(e, "deprecatedWithLegacySyntax", !0)) :
        s = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(Q.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e, "depreca\
tedAssertSyntax", !0), this.next(), s = this.parseImportAttributes()) : s = [];
      !i && this.hasPlugin("importAssertions") ? e.assertions = s : e.attributes = s;
    }
    maybeParseDefaultImportSpecifier(e, s) {
      if (s) {
        let i = this.startNodeAtNode(s);
        return i.local = s, e.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (bo(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let s = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, s, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else {
          if (this.eat(14))
            throw this.raise(Q.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), r = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, r, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, s, i, r, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (s)
          throw this.raise(Q.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = ru(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, oS = class extends Zk {
    static {
      n(this, "Parser");
    }
    constructor(e, s, i) {
      e = UKe(e), super(e, s), this.options = e, this.initializeScopes(), this.plugins = i, this.filename = e.sourceFilename, this.startIndex =
      e.startIndex;
      let r = 0;
      e.allowAwaitOutsideFunction && (r |= 1), e.allowReturnOutsideFunction && (r |= 2), e.allowImportExportEverywhere && (r |= 8), e.allowSuperOutsideMethod &&
      (r |= 16), e.allowUndeclaredExports && (r |= 64), e.allowNewTargetOutsideFunction && (r |= 4), e.allowYieldOutsideFunction && (r |= 32),
      e.ranges && (r |= 128), e.tokens && (r |= 256), e.createImportExpressions && (r |= 512), e.createParenthesizedExpressions && (r |= 1024),
      e.errorRecovery && (r |= 2048), e.attachComment && (r |= 4096), e.annexB && (r |= 8192), this.optionFlags = r;
    }
    getScopeHandler() {
      return wg;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), s = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, s), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function HVe(t, e) {
    var s;
    if (((s = e) == null ? void 0 : s.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let i = Ag(e, t), r = i.parse();
        if (i.sawUnambiguousESM)
          return r;
        if (i.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Ag(e, t).parse();
          } catch {
          }
        else
          r.program.sourceType = "script";
        return r;
      } catch (i) {
        try {
          return e.sourceType = "script", Ag(e, t).parse();
        } catch {
        }
        throw i;
      }
    } else
      return Ag(e, t).parse();
  }
  n(HVe, "parse");
  function JVe(t, e) {
    let s = Ag(e, t);
    return s.options.strictMode && (s.state.strict = !0), s.getExpression();
  }
  n(JVe, "parseExpression");
  function YVe(t) {
    let e = {};
    for (let s of Object.keys(t))
      e[s] = eu(t[s]);
    return e;
  }
  n(YVe, "generateExportedTokenTypes");
  var XVe = YVe($Ke);
  function Ag(t, e) {
    let s = oS, i = /* @__PURE__ */ new Map();
    if (t != null && t.plugins) {
      for (let r of t.plugins) {
        let a, o;
        typeof r == "string" ? a = r : [a, o] = r, i.has(a) || i.set(a, o || {});
      }
      UVe(i), s = zVe(i);
    }
    return new s(t, e, i);
  }
  n(Ag, "getParser");
  var C$ = /* @__PURE__ */ new Map();
  function zVe(t) {
    let e = [];
    for (let r of KVe)
      t.has(r) && e.push(r);
    let s = e.join("|"), i = C$.get(s);
    if (!i) {
      i = oS;
      for (let r of e)
        i = U$[r](i);
      C$.set(s, i);
    }
    return i;
  }
  n(zVe, "getParserClass");
  Ng.parse = HVe;
  Ng.parseExpression = JVe;
  Ng.tokTypes = XVe;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/replacement.js
var Pk = g((qc) => {
  "use strict";
  Object.defineProperty(qc, "__esModule", {
    value: !0
  });
  qc._replaceWith = X$;
  qc.replaceExpressionWithStatements = AWe;
  qc.replaceInline = vWe;
  qc.replaceWith = EWe;
  qc.replaceWithMultiple = SWe;
  qc.replaceWithSourceString = PWe;
  var GVe = Yl(), pD = zl(), QVe = Mc(), H$ = oh(), hD = zx(), ZVe = lS(), eWe = fe(), wd = tl(), {
    FUNCTION_TYPES: K$,
    arrowFunctionExpression: tWe,
    assignmentExpression: J$,
    awaitExpression: sWe,
    blockStatement: iWe,
    buildUndefinedNode: cD,
    callExpression: rWe,
    cloneNode: fD,
    conditionalExpression: nWe,
    expressionStatement: aWe,
    getBindingIdentifiers: oWe,
    identifier: lWe,
    inheritLeadingComments: uWe,
    inheritTrailingComments: cWe,
    inheritsComments: pWe,
    isBlockStatement: hWe,
    isEmptyStatement: V$,
    isExpression: Y$,
    isExpressionStatement: fWe,
    isIfStatement: dWe,
    isProgram: mWe,
    isStatement: yWe,
    isVariableDeclaration: gWe,
    removeComments: TWe,
    returnStatement: W$,
    sequenceExpression: bWe,
    validate: $$,
    yieldExpression: xWe
  } = eWe;
  function SWe(t) {
    var e;
    wd.resync.call(this), t = hD._verifyNodeList.call(this, t), uWe(t[0], this.node), cWe(t[t.length - 1], this.node), (e = (0, H$.getCachedPaths)(
    this.hub, this.parent)) == null || e.delete(this.node), this.node = this.container[this.key] = null;
    let s = this.insertAfter(t);
    return this.node ? this.requeue() : this.remove(), s;
  }
  n(SWe, "replaceWithMultiple");
  function PWe(t) {
    wd.resync.call(this);
    let e;
    try {
      t = `(${t})`, e = (0, ZVe.parse)(t);
    } catch (i) {
      let r = i.loc;
      throw r && (i.message += ` - make sure this is an expression.
` + (0, GVe.codeFrameColumns)(t, {
        start: {
          line: r.line,
          column: r.column + 1
        }
      }), i.code = "BABEL_REPLACE_SOURCE_ERROR"), i;
    }
    let s = e.program.body[0].expression;
    return pD.default.removeProperties(s), this.replaceWith(s);
  }
  n(PWe, "replaceWithSourceString");
  function EWe(t) {
    if (wd.resync.call(this), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let e = t instanceof QVe.default ? t.node : t;
    if (!e)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === e)
      return [this];
    if (this.isProgram() && !mWe(e))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(e))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof e == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let s = "";
    if (this.isNodeType("Statement") && Y$(e) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    e) && !this.parentPath.isExportDefaultDeclaration() && (e = aWe(e), s = "expression"), this.isNodeType("Expression") && yWe(e) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(e))
      return this.replaceExpressionWithStatements([e]);
    let i = this.node;
    return i && (pWe(e, i), TWe(i)), X$.call(this, e), this.type = e.type, wd.setScope.call(this), this.requeue(), [s ? this.get(s) : this];
  }
  n(EWe, "replaceWith");
  function X$(t) {
    var e;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? $$(this.parent, this.key, [t]) : $$(this.parent, this.key, t), this.debug(`Replace with ${t?.type}`), (e = (0, H$.getCachedPaths)(
    this.hub, this.parent)) == null || e.set(t, this).delete(this.node), this.node = this.container[this.key] = t;
  }
  n(X$, "_replaceWith");
  function AWe(t) {
    wd.resync.call(this);
    let e = [], s = uS(t, e);
    if (s) {
      for (let f of e) this.scope.push({
        id: f
      });
      return this.replaceWith(s)[0].get("expressions");
    }
    let i = this.getFunctionParent(), r = i?.node.async, a = i?.node.generator, o = tWe([], iWe(t));
    this.replaceWith(rWe(o, []));
    let l = this.get("callee");
    l.get("body").scope.hoistVariables((f) => this.scope.push({
      id: f
    }));
    let u = l.getCompletionRecords();
    for (let f of u) {
      if (!f.isExpressionStatement()) continue;
      let d = f.findParent((y) => y.isLoop());
      if (d) {
        let y = d.getData("expressionReplacementReturnUid");
        y ? y = lWe(y.name) : (y = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", W$(fD(y))), d.setData("\
expressionReplacementReturnUid", y)), f.get("expression").replaceWith(J$("=", fD(y), f.node.expression));
      } else
        f.replaceWith(W$(f.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = r && pD.default.hasType(this.get("callee.body").node, "AwaitExpression", K$), h = a && pD.default.hasType(this.get("calle\
e.body").node, "YieldExpression", K$);
    return p && (c.set("async", !0), h || this.replaceWith(sWe(this.node))), h && (c.set("generator", !0), this.replaceWith(xWe(this.node, !0))),
    c.get("body.body");
  }
  n(AWe, "replaceExpressionWithStatements");
  function uS(t, e) {
    let s = [], i = !0;
    for (let r of t)
      if (V$(r) || (i = !1), Y$(r))
        s.push(r);
      else if (fWe(r))
        s.push(r.expression);
      else if (gWe(r)) {
        if (r.kind !== "var") return;
        for (let a of r.declarations) {
          let o = oWe(a);
          for (let l of Object.keys(o))
            e.push(fD(o[l]));
          a.init && s.push(J$("=", a.id, a.init));
        }
        i = !0;
      } else if (dWe(r)) {
        let a = r.consequent ? uS([r.consequent], e) : cD(), o = r.alternate ? uS([r.alternate], e) : cD();
        if (!a || !o) return;
        s.push(nWe(r.test, a, o));
      } else if (hWe(r)) {
        let a = uS(r.body, e);
        if (!a) return;
        s.push(a);
      } else if (V$(r))
        t.indexOf(r) === 0 && (i = !0);
      else
        return;
    return i && s.push(cD()), s.length === 1 ? s[0] : bWe(s);
  }
  n(uS, "gatherSequenceExpressions");
  function vWe(t) {
    if (wd.resync.call(this), Array.isArray(t))
      if (Array.isArray(this.container)) {
        t = hD._verifyNodeList.call(this, t);
        let e = hD._containerInsertAfter.call(this, t);
        return this.remove(), e;
      } else
        return this.replaceWithMultiple(t);
    else
      return this.replaceWith(t);
  }
  n(vWe, "replaceInline");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/evaluation.js
var Z$ = g((cS) => {
  "use strict";
  Object.defineProperty(cS, "__esModule", {
    value: !0
  });
  cS.evaluate = _We;
  cS.evaluateTruthy = DWe;
  var CWe = ["Number", "String", "Math"], wWe = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], IWe = ["random"];
  function z$(t) {
    return CWe.includes(t);
  }
  n(z$, "isValidObjectCallee");
  function NWe(t) {
    return wWe.includes(t);
  }
  n(NWe, "isValidIdentifierCallee");
  function kWe(t) {
    return IWe.includes(t);
  }
  n(kWe, "isInvalidMethod");
  function DWe() {
    let t = this.evaluate();
    if (t.confident) return !!t.value;
  }
  n(DWe, "evaluateTruthy");
  function nu(t, e) {
    e.confident && (e.deoptPath = t, e.confident = !1);
  }
  n(nu, "deopt");
  var G$ = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function Sn(t, e) {
    let {
      node: s
    } = t, {
      seen: i
    } = e;
    if (i.has(s)) {
      let r = i.get(s);
      if (r.resolved)
        return r.value;
      nu(t, e);
      return;
    } else {
      let r = {
        resolved: !1
      };
      i.set(s, r);
      let a = OWe(t, e);
      return e.confident && (r.resolved = !0, r.value = a), a;
    }
  }
  n(Sn, "evaluateCached");
  function OWe(t, e) {
    if (e.confident) {
      if (t.isSequenceExpression()) {
        let s = t.get("expressions");
        return Sn(s[s.length - 1], e);
      }
      if (t.isStringLiteral() || t.isNumericLiteral() || t.isBooleanLiteral())
        return t.node.value;
      if (t.isNullLiteral())
        return null;
      if (t.isTemplateLiteral())
        return Q$(t, t.node.quasis, e);
      if (t.isTaggedTemplateExpression() && t.get("tag").isMemberExpression()) {
        let s = t.get("tag.object"), {
          node: {
            name: i
          }
        } = s, r = t.get("tag.property");
        if (s.isIdentifier() && i === "String" && !t.scope.getBinding(i) && r.isIdentifier() && r.node.name === "raw")
          return Q$(t, t.node.quasi.quasis, e, !0);
      }
      if (t.isConditionalExpression()) {
        let s = Sn(t.get("test"), e);
        return e.confident ? Sn(s ? t.get("consequent") : t.get("alternate"), e) : void 0;
      }
      if (t.isExpressionWrapper())
        return Sn(t.get("expression"), e);
      if (t.isMemberExpression() && !t.parentPath.isCallExpression({
        callee: t.node
      })) {
        let s = t.get("property"), i = t.get("object");
        if (i.isLiteral()) {
          let r = i.node.value, a = typeof r, o = null;
          if (t.node.computed) {
            if (o = Sn(s, e), !e.confident) return;
          } else s.isIdentifier() && (o = s.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return r[o];
        }
      }
      if (t.isReferencedIdentifier()) {
        let s = t.scope.getBinding(t.node.name);
        if (s) {
          if (s.constantViolations.length > 0 || t.node.start < s.path.node.end) {
            nu(s.path, e);
            return;
          }
          if (s.hasValue)
            return s.value;
        }
        let i = t.node.name;
        if (G$.has(i)) {
          if (!s)
            return G$.get(i);
          nu(s.path, e);
          return;
        }
        let r = t.resolve();
        if (r === t) {
          nu(t, e);
          return;
        } else
          return Sn(r, e);
      }
      if (t.isUnaryExpression({
        prefix: !0
      })) {
        if (t.node.operator === "void")
          return;
        let s = t.get("argument");
        if (t.node.operator === "typeof" && (s.isFunction() || s.isClass()))
          return "function";
        let i = Sn(s, e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "!":
            return !i;
          case "+":
            return +i;
          case "-":
            return -i;
          case "~":
            return ~i;
          case "typeof":
            return typeof i;
        }
      }
      if (t.isArrayExpression()) {
        let s = [], i = t.get("elements");
        for (let r of i) {
          let a = r.evaluate();
          if (a.confident)
            s.push(a.value);
          else {
            nu(a.deopt, e);
            return;
          }
        }
        return s;
      }
      if (t.isObjectExpression()) {
        let s = {}, i = t.get("properties");
        for (let r of i) {
          if (r.isObjectMethod() || r.isSpreadElement()) {
            nu(r, e);
            return;
          }
          let a = r.get("key"), o;
          if (r.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              nu(o.deopt, e);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = r.get("value").evaluate();
          if (!u.confident) {
            nu(u.deopt, e);
            return;
          }
          u = u.value, s[o] = u;
        }
        return s;
      }
      if (t.isLogicalExpression()) {
        let s = e.confident, i = Sn(t.get("left"), e), r = e.confident;
        e.confident = s;
        let a = Sn(t.get("right"), e), o = e.confident;
        switch (t.node.operator) {
          case "||":
            return e.confident = r && (!!i || o), e.confident ? i || a : void 0;
          case "&&":
            return e.confident = r && (!i || o), e.confident ? i && a : void 0;
          case "??":
            return e.confident = r && (i != null || o), e.confident ? i ?? a : void 0;
        }
      }
      if (t.isBinaryExpression()) {
        let s = Sn(t.get("left"), e);
        if (!e.confident) return;
        let i = Sn(t.get("right"), e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "-":
            return s - i;
          case "+":
            return s + i;
          case "/":
            return s / i;
          case "*":
            return s * i;
          case "%":
            return s % i;
          case "**":
            return Math.pow(s, i);
          case "<":
            return s < i;
          case ">":
            return s > i;
          case "<=":
            return s <= i;
          case ">=":
            return s >= i;
          case "==":
            return s == i;
          case "!=":
            return s != i;
          case "===":
            return s === i;
          case "!==":
            return s !== i;
          case "|":
            return s | i;
          case "&":
            return s & i;
          case "^":
            return s ^ i;
          case "<<":
            return s << i;
          case ">>":
            return s >> i;
          case ">>>":
            return s >>> i;
        }
      }
      if (t.isCallExpression()) {
        let s = t.get("callee"), i, r;
        if (s.isIdentifier() && !t.scope.getBinding(s.node.name) && (z$(s.node.name) || NWe(s.node.name)) && (r = global[s.node.name]), s.isMemberExpression()) {
          let a = s.get("object"), o = s.get("property");
          if (a.isIdentifier() && o.isIdentifier() && z$(a.node.name) && !kWe(o.node.name)) {
            i = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(i, l) && (r = i[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (i = a.node.value, r = i[o.node.name]);
          }
        }
        if (r) {
          let a = t.get("arguments").map((o) => Sn(o, e));
          return e.confident ? r.apply(i, a) : void 0;
        }
      }
      nu(t, e);
    }
  }
  n(OWe, "_evaluate");
  function Q$(t, e, s, i = !1) {
    let r = "", a = 0, o = t.isTemplateLiteral() ? t.get("expressions") : t.get("quasi.expressions");
    for (let l of e) {
      if (!s.confident) break;
      r += i ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (r += String(Sn(u, s)));
    }
    if (s.confident)
      return r;
  }
  n(Q$, "evaluateQuasis");
  function _We() {
    let t = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, e = Sn(this, t);
    return t.confident || (e = void 0), {
      confident: t.confident,
      deopt: t.deoptPath,
      value: e
    };
  }
  n(_We, "evaluate");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/conversion.js
var oH = g((au) => {
  "use strict";
  Object.defineProperty(au, "__esModule", {
    value: !0
  });
  au.arrowFunctionToExpression = u$e;
  au.ensureBlock = a$e;
  au.ensureFunctionName = S$e;
  au.splitExportDeclaration = b$e;
  au.toComputedKey = n$e;
  au.unwrapFunctionEnvironment = o$e;
  var LWe = fe(), BWe = Xl(), yD = fg(), MWe = tl(), {
    arrowFunctionExpression: gD,
    assignmentExpression: gh,
    binaryExpression: dD,
    blockStatement: FWe,
    callExpression: Id,
    conditionalExpression: jWe,
    expressionStatement: sH,
    identifier: di,
    isIdentifier: RWe,
    jsxIdentifier: qWe,
    logicalExpression: UWe,
    LOGICAL_OPERATORS: KWe,
    memberExpression: xo,
    metaProperty: VWe,
    numericLiteral: WWe,
    objectExpression: $We,
    restElement: HWe,
    returnStatement: JWe,
    sequenceExpression: YWe,
    spreadElement: XWe,
    stringLiteral: iH,
    super: mD,
    thisExpression: kg,
    toExpression: rH,
    unaryExpression: zWe,
    toBindingIdentifierName: GWe,
    isFunction: QWe,
    isAssignmentPattern: ZWe,
    isRestElement: e$e,
    getFunctionName: t$e,
    cloneNode: Th,
    variableDeclaration: s$e,
    variableDeclarator: i$e,
    exportNamedDeclaration: eH,
    exportSpecifier: tH,
    inherits: r$e
  } = LWe;
  function n$e() {
    let t;
    if (this.isMemberExpression())
      t = this.node.property;
    else if (this.isProperty() || this.isMethod())
      t = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || RWe(t) && (t = iH(t.name)), t;
  }
  n(n$e, "toComputedKey");
  function a$e() {
    let t = this.get("body"), e = t.node;
    if (Array.isArray(t))
      throw new Error("Can't convert array path to a block statement");
    if (!e)
      throw new Error("Can't convert node without a body");
    if (t.isBlockStatement())
      return e;
    let s = [], i = "body", r, a;
    t.isStatement() ? (a = "body", r = 0, s.push(t.node)) : (i += ".body.0", this.isFunction() ? (r = "argument", s.push(JWe(t.node))) : (r =
    "expression", s.push(sH(t.node)))), this.node.body = FWe(s);
    let o = this.get(i);
    return MWe.setup.call(t, o, a ? o.node[a] : o.node, a, r), this.node;
  }
  n(a$e, "ensureBlock");
  au.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function o$e() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    nH(this);
  }
  n(o$e, "unwrapFunctionEnvironment");
  function l$e(t, e) {
    t.node.type = e;
  }
  n(l$e, "setType");
  function u$e({
    allowInsertArrow: t = !0,
    allowInsertArrowWithRest: e = t,
    noNewArrows: s = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let i = this;
    if (!s) {
      var r;
      i = (r = i.ensureFunctionName(!1)) != null ? r : i;
    }
    let {
      thisBinding: a,
      fnPath: o
    } = nH(i, s, t, e);
    if (o.ensureBlock(), l$e(o, "FunctionExpression"), !s) {
      let l = a ? null : o.scope.generateUidIdentifier("arrowCheckId");
      return l && o.parentPath.scope.push({
        id: l,
        init: $We([])
      }), o.get("body").unshiftContainer("body", sH(Id(this.hub.addHelper("newArrowCheck"), [kg(), di(l ? l.name : a)]))), o.replaceWith(Id(
      xo(o.node, di("bind")), [l ? di(l.name) : kg()])), o.get("callee.object");
    }
    return o;
  }
  n(u$e, "arrowFunctionToExpression");
  var c$e = (0, yD.environmentVisitor)({
    CallExpression(t, {
      allSuperCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    }
  });
  function nH(t, e = !0, s = !0, i = !0) {
    let r, a = t.findParent((d) => {
      if (d.isArrowFunctionExpression()) {
        var y;
        return (y = r) != null || (r = d), !1;
      }
      return d.isFunction() || d.isProgram() || d.isClassProperty({
        static: !1
      }) || d.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (r)
        a = r;
      else if (s)
        t.replaceWith(Id(gD([], rH(t.node)), [])), a = t.get("callee"), t = a.get("body");
      else
        throw t.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: h
    } = T$e(t);
    if (o && h.length > 0) {
      if (!s)
        throw h[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!i)
        throw h[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let d = [];
      a.traverse(c$e, {
        allSuperCalls: d
      });
      let y = m$e(a);
      d.forEach((m) => {
        let T = di(y);
        T.loc = m.node.callee.loc, m.get("callee").replaceWith(T);
      });
    }
    if (u.length > 0) {
      let d = Dg(a, "arguments", () => {
        let y = /* @__PURE__ */ n(() => di("arguments"), "args");
        return a.scope.path.isProgram() ? jWe(dD("===", zWe("typeof", y()), iH("undefined")), a.scope.buildUndefinedNode(), y()) : y();
      });
      u.forEach((y) => {
        let m = di(d);
        m.loc = y.node.loc, y.replaceWith(m);
      });
    }
    if (c.length > 0) {
      let d = Dg(a, "newtarget", () => VWe(di("new"), di("target")));
      c.forEach((y) => {
        let m = di(d);
        m.loc = y.node.loc, y.replaceWith(m);
      });
    }
    if (p.length > 0) {
      if (!s)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((y, m) => y.concat(h$e(m)), []).forEach((y) => {
        let m = y.node.computed ? "" : y.get("property").node.name, T = y.parentPath, b = T.isAssignmentExpression({
          left: y.node
        }), E = T.isCallExpression({
          callee: y.node
        }), w = T.isTaggedTemplateExpression({
          tag: y.node
        }), K = y$e(a, b, m), he = [];
        if (y.node.computed && he.push(y.get("property").node), b) {
          let me = T.node.right;
          he.push(me);
        }
        let de = Id(di(K), he);
        E ? (T.unshiftContainer("arguments", kg()), y.replaceWith(xo(de, di("call"))), l.push(T.get("arguments.0"))) : b ? T.replaceWith(de) :
        w ? (y.replaceWith(Id(xo(de, di("bind"), !1), [kg()])), l.push(y.get("arguments.0"))) : y.replaceWith(de);
      });
    }
    let f;
    return (l.length > 0 || !e) && (f = d$e(a, o), (e || o && aH(a)) && (l.forEach((d) => {
      let y = d.isJSX() ? qWe(f) : di(f);
      y.loc = d.node.loc, d.replaceWith(y);
    }), e || (f = null))), {
      thisBinding: f,
      fnPath: t
    };
  }
  n(nH, "hoistFunctionEnvironment");
  function p$e(t) {
    return KWe.includes(t);
  }
  n(p$e, "isLogicalOp");
  function h$e(t) {
    if (t.parentPath.isAssignmentExpression() && t.parentPath.node.operator !== "=") {
      let s = t.parentPath, i = s.node.operator.slice(0, -1), r = s.node.right, a = p$e(i);
      if (t.node.computed) {
        let o = t.scope.generateDeclaredUidIdentifier("tmp"), l = t.node.object, u = t.node.property;
        s.get("left").replaceWith(xo(l, gh("=", o, u), !0)), s.get("right").replaceWith(e(a ? "=" : i, xo(l, di(o.name), !0), r));
      } else {
        let o = t.node.object, l = t.node.property;
        s.get("left").replaceWith(xo(o, l)), s.get("right").replaceWith(e(a ? "=" : i, xo(o, di(l.name)), r));
      }
      return a ? s.replaceWith(UWe(i, s.node.left, s.node.right)) : s.node.operator = "=", [s.get("left"), s.get("right").get("left")];
    } else if (t.parentPath.isUpdateExpression()) {
      let s = t.parentPath, i = t.scope.generateDeclaredUidIdentifier("tmp"), r = t.node.computed ? t.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [gh("=", i, xo(t.node.object, r ? gh("=", r, t.node.property) : t.node.property, t.node.computed)), gh("=", xo(t.node.object,
      r ? di(r.name) : t.node.property, t.node.computed), dD(t.parentPath.node.operator[0], di(i.name), WWe(1)))];
      t.parentPath.node.prefix || a.push(di(i.name)), s.replaceWith(YWe(a));
      let o = s.get("expressions.0.right"), l = s.get("expressions.1.left");
      return [o, l];
    }
    return [t];
    function e(s, i, r) {
      return s === "=" ? gh("=", i, r) : dD(s, i, r);
    }
  }
  n(h$e, "standardizeSuperProperty");
  function aH(t) {
    return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass;
  }
  n(aH, "hasSuperClass");
  var f$e = (0, yD.environmentVisitor)({
    CallExpression(t, {
      supers: e,
      thisBinding: s
    }) {
      t.get("callee").isSuper() && (e.has(t.node) || (e.add(t.node), t.replaceWithMultiple([t.node, gh("=", di(s), di("this"))])));
    }
  });
  function d$e(t, e) {
    return Dg(t, "this", (s) => {
      if (!e || !aH(t)) return kg();
      t.traverse(f$e, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: s
      });
    });
  }
  n(d$e, "getThisBinding");
  function m$e(t) {
    return Dg(t, "supercall", () => {
      let e = t.scope.generateUidIdentifier("args");
      return gD([HWe(e)], Id(mD(), [XWe(di(e.name))]));
    });
  }
  n(m$e, "getSuperBinding");
  function y$e(t, e, s) {
    return Dg(t, `superprop_${e ? "set" : "get"}:${s || ""}`, () => {
      let r = [], a;
      if (s)
        a = xo(mD(), di(s));
      else {
        let o = t.scope.generateUidIdentifier("prop");
        r.unshift(o), a = xo(mD(), di(o.name), !0);
      }
      if (e) {
        let o = t.scope.generateUidIdentifier("value");
        r.push(o), a = gh("=", a, di(o.name));
      }
      return gD(r, a);
    });
  }
  n(y$e, "getSuperPropBinding");
  function Dg(t, e, s) {
    let i = "binding:" + e, r = t.getData(i);
    if (!r) {
      let a = t.scope.generateUidIdentifier(e);
      r = a.name, t.setData(i, r), t.scope.push({
        id: a,
        init: s(r)
      });
    }
    return r;
  }
  n(Dg, "getBinding");
  var g$e = (0, yD.environmentVisitor)({
    ThisExpression(t, {
      thisPaths: e
    }) {
      e.push(t);
    },
    JSXIdentifier(t, {
      thisPaths: e
    }) {
      t.node.name === "this" && (!t.parentPath.isJSXMemberExpression({
        object: t.node
      }) && !t.parentPath.isJSXOpeningElement({
        name: t.node
      }) || e.push(t));
    },
    CallExpression(t, {
      superCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    },
    MemberExpression(t, {
      superProps: e
    }) {
      t.get("object").isSuper() && e.push(t);
    },
    Identifier(t, {
      argumentsPaths: e
    }) {
      if (!t.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let s = t.scope;
      do {
        if (s.hasOwnBinding("arguments")) {
          s.rename("arguments");
          return;
        }
        if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
          break;
      } while (s = s.parent);
      e.push(t);
    },
    MetaProperty(t, {
      newTargetPaths: e
    }) {
      t.get("meta").isIdentifier({
        name: "new"
      }) && t.get("property").isIdentifier({
        name: "target"
      }) && e.push(t);
    }
  });
  function T$e(t) {
    let e = [], s = [], i = [], r = [], a = [];
    return t.traverse(g$e, {
      thisPaths: e,
      argumentsPaths: s,
      newTargetPaths: i,
      superProps: r,
      superCalls: a
    }), {
      thisPaths: e,
      argumentsPaths: s,
      newTargetPaths: i,
      superProps: r,
      superCalls: a
    };
  }
  n(T$e, "getScopeInformation");
  function b$e() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      let r = t.isFunctionDeclaration() || t.isClassDeclaration(), a = t.isFunctionExpression() || t.isClassExpression(), o = t.isScope() ? t.
      scope.parent : t.scope, l = t.node.id, u = !1;
      l ? a && o.hasBinding(l.name) && (u = !0, l = o.generateUidIdentifier(l.name)) : (u = !0, l = o.generateUidIdentifier("default"), (r ||
      a) && (t.node.id = Th(l)));
      let c = r ? t.node : s$e("var", [i$e(Th(l), t.node)]), p = eH(null, [tH(Th(l), di("default"))]);
      return this.insertAfter(p), this.replaceWith(c), u && o.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = t.getOuterBindingIdentifiers(), s = Object.keys(e).map((r) => tH(di(r), di(r))), i = eH(null, s);
    return this.insertAfter(i), this.replaceWith(t.node), this;
  }
  n(b$e, "splitExportDeclaration");
  var x$e = {
    "ReferencedIdentifier|BindingIdentifier"(t, e) {
      t.node.name === e.name && (e.needsRename = !0, t.stop());
    },
    Scope(t, e) {
      t.scope.hasOwnBinding(e.name) && t.skip();
    }
  };
  function S$e(t) {
    if (this.node.id) return this;
    let e = t$e(this.node, this.parent);
    if (e == null) return this;
    let {
      name: s
    } = e;
    if (!t && /[\uD800-\uDFFF]/.test(s) || s.startsWith("get ") || s.startsWith("set "))
      return null;
    s = GWe(s.replace(/[/ ]/g, "_"));
    let i = di(s);
    r$e(i, e.originalNode);
    let r = {
      needsRename: !1,
      name: s
    }, {
      scope: a
    } = this, o = a.getOwnBinding(s);
    if (o ? o.kind === "param" && (r.needsRename = !0) : (a.parent.hasBinding(s) || a.hasGlobal(s)) && this.traverse(x$e, r), !r.needsRename)
      return this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (a.hasBinding(i.name) && !a.hasGlobal(i.name))
      return a.rename(i.name), this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (!QWe(this.node)) return null;
    let l = a.generateUidIdentifier(i.name), u = [];
    for (let p = 0, h = P$e(this.node); p < h; p++)
      u.push(a.generateUidIdentifier("x"));
    let c = BWe.default.expression.ast`
    (function (${l}) {
      function ${i}(${u}) {
        return ${Th(l)}.apply(this, arguments);
      }

      ${Th(i)}.toString = function () {
        return ${Th(l)}.toString();
      }

      return ${Th(i)};
    })(${rH(this.node)})
  `;
    return this.replaceWith(c)[0].get("arguments.0");
  }
  n(S$e, "ensureFunctionName");
  function P$e(t) {
    let e = t.params.findIndex((s) => ZWe(s) || e$e(s));
    return e === -1 ? t.params.length : e;
  }
  n(P$e, "getFunctionArity");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/introspection.js
var fH = g((sr) => {
  "use strict";
  Object.defineProperty(sr, "__esModule", {
    value: !0
  });
  sr._guessExecutionStatusRelativeTo = V$e;
  sr._resolve = hH;
  sr.canHaveVariableDeclarationOrExpression = B$e;
  sr.canSwapBetweenExpressionAndStatement = M$e;
  sr.getSource = q$e;
  sr.isCompletionRecord = F$e;
  sr.isConstantExpression = J$e;
  sr.isInStrictMode = Y$e;
  sr.isNodeType = L$e;
  sr.isStatementOrBlock = j$e;
  sr.isStatic = _$e;
  sr.matchesPattern = O$e;
  sr.referencesImport = R$e;
  sr.resolve = H$e;
  sr.willIMaybeExecuteBefore = U$e;
  var E$e = fe(), {
    STATEMENT_OR_BLOCK_KEYS: A$e,
    VISITOR_KEYS: v$e,
    isBlockStatement: pH,
    isExpression: C$e,
    isIdentifier: w$e,
    isLiteral: I$e,
    isStringLiteral: N$e,
    isType: k$e,
    matchesPattern: D$e
  } = E$e;
  function O$e(t, e) {
    return D$e(this.node, t, e);
  }
  n(O$e, "matchesPattern");
  sr.has = /* @__PURE__ */ n(function(e) {
    var s;
    let i = (s = this.node) == null ? void 0 : s[e];
    return i && Array.isArray(i) ? !!i.length : !!i;
  }, "has");
  function _$e() {
    return this.scope.isStatic(this.node);
  }
  n(_$e, "isStatic");
  sr.is = sr.has, sr.isnt = /* @__PURE__ */ n(function(e) {
    return !this.has(e);
  }, "isnt"), sr.equals = /* @__PURE__ */ n(function(e, s) {
    return this.node[e] === s;
  }, "equals");
  function L$e(t) {
    return k$e(this.type, t);
  }
  n(L$e, "isNodeType");
  function B$e() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  n(B$e, "canHaveVariableDeclarationOrExpression");
  function M$e(t) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? pH(t) : this.isBlockStatement() ?
    C$e(t) : !1;
  }
  n(M$e, "canSwapBetweenExpressionAndStatement");
  function F$e(t) {
    let e = this, s = !0;
    do {
      let {
        type: i,
        container: r
      } = e;
      if (!s && (e.isFunction() || i === "StaticBlock"))
        return !!t;
      if (s = !1, Array.isArray(r) && e.key !== r.length - 1)
        return !1;
    } while ((e = e.parentPath) && !e.isProgram() && !e.isDoExpression());
    return !0;
  }
  n(F$e, "isCompletionRecord");
  function j$e() {
    return this.parentPath.isLabeledStatement() || pH(this.container) ? !1 : A$e.includes(this.key);
  }
  n(j$e, "isStatementOrBlock");
  function R$e(t, e) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === e || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? N$e(this.node.property, {
        value: e
      }) : this.node.property.name === e)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(t, "*");
      }
      return !1;
    }
    let s = this.scope.getBinding(this.node.name);
    if (!s || s.kind !== "module") return !1;
    let i = s.path, r = i.parentPath;
    if (!r.isImportDeclaration()) return !1;
    if (r.node.source.value === t) {
      if (!e) return !0;
    } else
      return !1;
    return !!(i.isImportDefaultSpecifier() && e === "default" || i.isImportNamespaceSpecifier() && e === "*" || i.isImportSpecifier() && w$e(
    i.node.imported, {
      name: e
    }));
  }
  n(R$e, "referencesImport");
  function q$e() {
    let t = this.node;
    if (t.end) {
      let e = this.hub.getCode();
      if (e) return e.slice(t.start, t.end);
    }
    return "";
  }
  n(q$e, "getSource");
  function U$e(t) {
    return this._guessExecutionStatusRelativeTo(t) !== "after";
  }
  n(U$e, "willIMaybeExecuteBefore");
  function lH(t) {
    return t.isProgram() ? t : (t.parentPath.scope.getFunctionParent() || t.parentPath.scope.getProgramParent()).path;
  }
  n(lH, "getOuterFunction");
  function K$e(t, e) {
    switch (t) {
      case "LogicalExpression":
        return e === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return e === "consequent" || e === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return e === "body";
      case "ForStatement":
        return e === "body" || e === "update";
      case "SwitchStatement":
        return e === "cases";
      case "TryStatement":
        return e === "handler";
      case "AssignmentPattern":
        return e === "right";
      case "OptionalMemberExpression":
        return e === "property";
      case "OptionalCallExpression":
        return e === "arguments";
      default:
        return !1;
    }
  }
  n(K$e, "isExecutionUncertain");
  function uH(t, e) {
    for (let s = 0; s < e; s++) {
      let i = t[s];
      if (K$e(i.parent.type, i.parentKey))
        return !0;
    }
    return !1;
  }
  n(uH, "isExecutionUncertainInList");
  var cH = Symbol();
  function V$e(t) {
    return TD(this, t, /* @__PURE__ */ new Map());
  }
  n(V$e, "_guessExecutionStatusRelativeTo");
  function TD(t, e, s) {
    let i = {
      this: lH(t),
      target: lH(e)
    };
    if (i.target.node !== i.this.node)
      return $$e(t, i.target, s);
    let r = {
      target: e.getAncestry(),
      this: t.getAncestry()
    };
    if (r.target.includes(t)) return "after";
    if (r.this.includes(e)) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < r.this.length; ) {
      let p = r.this[o.this];
      o.target = r.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (uH(r.this, o.this - 1) || uH(r.target, o.target - 1))
      return "unknown";
    let l = {
      this: r.this[o.this - 1],
      target: r.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = v$e[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  n(TD, "_guessExecutionStatusRelativeToCached");
  function W$e(t, e, s) {
    if (e.isFunctionDeclaration()) {
      if (e.parentPath.isExportDeclaration())
        return "unknown";
    } else return TD(t, e, s) === "before" ? "before" : "unknown";
    let i = e.scope.getBinding(e.node.id.name);
    if (!i.references) return "before";
    let r = i.referencePaths, a;
    for (let o of r) {
      if (!!o.find((c) => c.node === e.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = TD(t, o, s);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  n(W$e, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function $$e(t, e, s) {
    let i = s.get(t.node), r;
    if (!i)
      s.set(t.node, i = /* @__PURE__ */ new Map());
    else if (r = i.get(e.node))
      return r === cH ? "unknown" : r;
    i.set(e.node, cH);
    let a = W$e(t, e, s);
    return i.set(e.node, a), a;
  }
  n($$e, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function H$e(t, e) {
    return hH.call(this, t, e) || this;
  }
  n(H$e, "resolve");
  function hH(t, e) {
    var s;
    if (!((s = e) != null && s.includes(this)))
      if (e = e || [], e.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(t, e);
      } else if (this.isReferencedIdentifier()) {
        let i = this.scope.getBinding(this.node.name);
        if (!i || !i.constant || i.kind === "module") return;
        if (i.path !== this) {
          let r = i.path.resolve(t, e);
          return this.find((a) => a.node === r.node) ? void 0 : r;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(t, e);
        if (t && this.isMemberExpression()) {
          let i = this.toComputedKey();
          if (!I$e(i)) return;
          let r = i.value, a = this.get("object").resolve(t, e);
          if (a.isObjectExpression()) {
            let o = a.get("properties");
            for (let l of o) {
              if (!l.isProperty()) continue;
              let u = l.get("key"), c = l.isnt("computed") && u.isIdentifier({
                name: r
              });
              if (c = c || u.isLiteral({
                value: r
              }), c) return l.get("value").resolve(t, e);
            }
          } else if (a.isArrayExpression() && !isNaN(+r)) {
            let l = a.get("elements")[r];
            if (l) return l.resolve(t, e);
          }
        }
      }
  }
  n(hH, "_resolve");
  function J$e() {
    if (this.isIdentifier()) {
      let t = this.scope.getBinding(this.node.name);
      return t ? t.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((t) => t.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: t
      } = this.node;
      return t !== "in" && t !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  n(J$e, "isConstantExpression");
  function Y$e() {
    return !!(this.isProgram() ? this : this.parentPath).find((s) => {
      if (s.isProgram({
        sourceType: "module"
      }) || s.isClass()) return !0;
      if (s.isArrowFunctionExpression() && !s.get("body").isBlockStatement())
        return !1;
      let i;
      if (s.isFunction())
        i = s.node.body;
      else if (s.isProgram())
        i = s.node;
      else
        return !1;
      for (let r of i.directives)
        if (r.value.value === "use strict")
          return !0;
    });
  }
  n(Y$e, "isInStrictMode");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/family.js
var TH = g((Ur) => {
  "use strict";
  Object.defineProperty(Ur, "__esModule", {
    value: !0
  });
  Ur._getKey = yH;
  Ur._getPattern = gH;
  Ur.get = pHe;
  Ur.getAllNextSiblings = uHe;
  Ur.getAllPrevSiblings = cHe;
  Ur.getAssignmentIdentifiers = hHe;
  Ur.getBindingIdentifierPaths = mHe;
  Ur.getBindingIdentifiers = fHe;
  Ur.getCompletionRecords = nHe;
  Ur.getNextSibling = lHe;
  Ur.getOpposite = sHe;
  Ur.getOuterBindingIdentifierPaths = yHe;
  Ur.getOuterBindingIdentifiers = dHe;
  Ur.getPrevSibling = oHe;
  Ur.getSibling = aHe;
  var xD = Mc(), X$e = fe(), {
    getAssignmentIdentifiers: z$e,
    getBindingIdentifiers: mH,
    getOuterBindingIdentifiers: G$e,
    numericLiteral: Q$e,
    unaryExpression: Z$e
  } = X$e, SD = 0, Og = 1;
  function eHe(t) {
    return {
      type: SD,
      path: t
    };
  }
  n(eHe, "NormalCompletion");
  function tHe(t) {
    return {
      type: Og,
      path: t
    };
  }
  n(tHe, "BreakCompletion");
  function sHe() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  n(sHe, "getOpposite");
  function Nd(t, e, s) {
    return t && e.push(...kd(t, s)), e;
  }
  n(Nd, "addCompletionRecords");
  function iHe(t, e, s) {
    let i = [];
    for (let r = 0; r < t.length; r++) {
      let a = t[r], o = kd(a, s), l = [], u = [];
      for (let c of o)
        c.type === SD && l.push(c), c.type === Og && u.push(c);
      l.length && (i = l), e.push(...u);
    }
    return e.push(...i), e;
  }
  n(iHe, "completionRecordForSwitch");
  function rHe(t) {
    t.forEach((e) => {
      e.type = Og;
    });
  }
  n(rHe, "normalCompletionToBreak");
  function bD(t, e) {
    t.forEach((s) => {
      s.path.isBreakStatement({
        label: null
      }) && (e ? s.path.replaceWith(Z$e("void", Q$e(0))) : s.path.remove());
    });
  }
  n(bD, "replaceBreakStatementInBreakCompletion");
  function dH(t, e) {
    let s = [];
    if (e.canHaveBreak) {
      let i = [];
      for (let r = 0; r < t.length; r++) {
        let a = t[r], o = Object.assign({}, e, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (e.inCaseClause || e.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = kd(a, o);
        if (l.length > 0 && l.every((u) => u.type === Og)) {
          i.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (rHe(i), s.push(...i), i.some((u) => u.path.isDeclaration()) && (s.push(...l), bD(l, !0)), bD(l, !1)) : (s.push(...l), e.shouldPopulateBreak ||
          bD(l, !0));
          break;
        }
        if (r === t.length - 1)
          s.push(...l);
        else {
          i = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === Og && s.push(c), c.type === SD && i.push(c);
          }
        }
      }
    } else if (t.length)
      for (let i = t.length - 1; i >= 0; i--) {
        let r = kd(t[i], e);
        if (r.length > 1 || r.length === 1 && !r[0].path.isVariableDeclaration()) {
          s.push(...r);
          break;
        }
      }
    return s;
  }
  n(dH, "getStatementListCompletion");
  function kd(t, e) {
    let s = [];
    if (t.isIfStatement())
      s = Nd(t.get("consequent"), s, e), s = Nd(t.get("alternate"), s, e);
    else {
      if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement())
        return Nd(t.get("body"), s, e);
      if (t.isProgram() || t.isBlockStatement())
        return dH(t.get("body"), e);
      if (t.isFunction())
        return kd(t.get("body"), e);
      if (t.isTryStatement())
        s = Nd(t.get("block"), s, e), s = Nd(t.get("handler"), s, e);
      else {
        if (t.isCatchClause())
          return Nd(t.get("body"), s, e);
        if (t.isSwitchStatement())
          return iHe(t.get("cases"), s, e);
        if (t.isSwitchCase())
          return dH(t.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        t.isBreakStatement() ? s.push(tHe(t)) : s.push(eHe(t));
      }
    }
    return s;
  }
  n(kd, "_getCompletionRecords");
  function nHe() {
    return kd(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((e) => e.path);
  }
  n(nHe, "getCompletionRecords");
  function aHe(t) {
    return xD.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: t
    }).setContext(this.context);
  }
  n(aHe, "getSibling");
  function oHe() {
    return this.getSibling(this.key - 1);
  }
  n(oHe, "getPrevSibling");
  function lHe() {
    return this.getSibling(this.key + 1);
  }
  n(lHe, "getNextSibling");
  function uHe() {
    let t = this.key, e = this.getSibling(++t), s = [];
    for (; e.node; )
      s.push(e), e = this.getSibling(++t);
    return s;
  }
  n(uHe, "getAllNextSiblings");
  function cHe() {
    let t = this.key, e = this.getSibling(--t), s = [];
    for (; e.node; )
      s.push(e), e = this.getSibling(--t);
    return s;
  }
  n(cHe, "getAllPrevSiblings");
  function pHe(t, e = !0) {
    e === !0 && (e = this.context);
    let s = t.split(".");
    return s.length === 1 ? yH.call(this, t, e) : gH.call(this, s, e);
  }
  n(pHe, "get");
  function yH(t, e) {
    let s = this.node, i = s[t];
    return Array.isArray(i) ? i.map((r, a) => xD.default.get({
      listKey: t,
      parentPath: this,
      parent: s,
      container: i,
      key: a
    }).setContext(e)) : xD.default.get({
      parentPath: this,
      parent: s,
      container: s,
      key: t
    }).setContext(e);
  }
  n(yH, "_getKey");
  function gH(t, e) {
    let s = this;
    for (let i of t)
      i === "." ? s = s.parentPath : Array.isArray(s) ? s = s[i] : s = s.get(i, e);
    return s;
  }
  n(gH, "_getPattern");
  function hHe() {
    return z$e(this.node);
  }
  n(hHe, "getAssignmentIdentifiers");
  function fHe(t) {
    return mH(this.node, t);
  }
  n(fHe, "getBindingIdentifiers");
  function dHe(t) {
    return G$e(this.node, t);
  }
  n(dHe, "getOuterBindingIdentifiers");
  function mHe(t = !1, e = !1) {
    let i = [this], r = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let a = i.shift();
      if (!a || !a.node) continue;
      let o = mH.keys[a.node.type];
      if (a.isIdentifier()) {
        t ? (r[a.node.name] = r[a.node.name] || []).push(a) : r[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        l.isDeclaration() && i.push(l);
        continue;
      }
      if (e) {
        if (a.isFunctionDeclaration()) {
          i.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c);
        }
    }
    return r;
  }
  n(mHe, "getBindingIdentifierPaths");
  function yHe(t = !1) {
    return this.getBindingIdentifierPaths(t, !0);
  }
  n(yHe, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/comments.js
var xH = g((_g) => {
  "use strict";
  Object.defineProperty(_g, "__esModule", {
    value: !0
  });
  _g.addComment = SHe;
  _g.addComments = PHe;
  _g.shareCommentsWithSiblings = xHe;
  var gHe = fe(), {
    addComment: THe,
    addComments: bHe
  } = gHe;
  function xHe() {
    if (typeof this.key == "string") return;
    let t = this.node;
    if (!t) return;
    let e = t.trailingComments, s = t.leadingComments;
    if (!e && !s) return;
    let i = this.getSibling(this.key - 1), r = this.getSibling(this.key + 1), a = !!i.node, o = !!r.node;
    a && (s && i.addComments("trailing", bH(s, i.node.trailingComments)), e && !o && i.addComments("trailing", e)), o && (e && r.addComments(
    "leading", bH(e, r.node.leadingComments)), s && !a && r.addComments("leading", s));
  }
  n(xHe, "shareCommentsWithSiblings");
  function bH(t, e) {
    if (!(e != null && e.length)) return t;
    let s = new Set(e);
    return t.filter((i) => !s.has(i));
  }
  n(bH, "removeIfExisting");
  function SHe(t, e, s) {
    THe(this.node, t, e, s);
  }
  n(SHe, "addComment");
  function PHe(t, e) {
    bHe(this.node, t, e);
  }
  n(PHe, "addComments");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/index.js
var Mc = g((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", {
    value: !0
  });
  al.default = al.SHOULD_STOP = al.SHOULD_SKIP = al.REMOVED = void 0;
  var EHe = vN(), AHe = go(), vHe = zl(), CHe = jN(), EH = fe(), pS = EH, wHe = oh(), IHe = $x(), rl = DW(), Dd = GW(), Od = Pk(), SH = Z$(),
  bh = oH(), br = fH(), AH = tl(), ir = AH, _d = Xx(), nl = zx(), Pn = TH(), PD = xH(), NHe = DN(), {
    validate: kHe
  } = EH, PH = AHe("babel"), _7s = al.REMOVED = 1, L7s = al.SHOULD_STOP = 2, B7s = al.SHOULD_SKIP = 4, ou = al.default = class vH {
    static {
      n(this, "NodePath");
    }
    constructor(e, s) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = s, this.hub = e, this.data = null, this.
      context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(e) {
      e ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(e) {
      e ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(e) {
      e ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: e,
      parentPath: s,
      parent: i,
      container: r,
      listKey: a,
      key: o
    }) {
      if (!e && s && (e = s.hub), !i)
        throw new Error("To get a node path the parent needs to exist");
      let l = r[o], u = wHe.getOrCreateCachedPaths(e, i), c = u.get(l);
      return c || (c = new vH(e, i), l && u.set(l, c)), AH.setup.call(c, s, r, a, o), c;
    }
    getScope(e) {
      return this.isScope() ? new CHe.default(this) : e;
    }
    setData(e, s) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e] = s;
    }
    getData(e, s) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let i = this.data[e];
      return i === void 0 && s !== void 0 && (i = this.data[e] = s), i;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(e, s = SyntaxError) {
      return this.hub.buildError(this.node, e, s);
    }
    traverse(e, s) {
      (0, vHe.default)(this.node, e, this.scope, s, this);
    }
    set(e, s) {
      kHe(this.node, e, s), this.node[e] = s;
    }
    getPathLocation() {
      let e = [], s = this;
      do {
        let i = s.key;
        s.inList && (i = `${s.listKey}[${i}]`), e.unshift(i);
      } while (s = s.parentPath);
      return e.join(".");
    }
    debug(e) {
      PH.enabled && PH(`${this.getPathLocation()} ${this.type}: ${e}`);
    }
    toString() {
      return (0, IHe.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e) {
      e || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, DHe = {
    findParent: rl.findParent,
    find: rl.find,
    getFunctionParent: rl.getFunctionParent,
    getStatementParent: rl.getStatementParent,
    getEarliestCommonAncestorFrom: rl.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: rl.getDeepestCommonAncestorFrom,
    getAncestry: rl.getAncestry,
    isAncestor: rl.isAncestor,
    isDescendant: rl.isDescendant,
    inType: rl.inType,
    getTypeAnnotation: Dd.getTypeAnnotation,
    isBaseType: Dd.isBaseType,
    couldBeBaseType: Dd.couldBeBaseType,
    baseTypeStrictlyMatches: Dd.baseTypeStrictlyMatches,
    isGenericType: Dd.isGenericType,
    replaceWithMultiple: Od.replaceWithMultiple,
    replaceWithSourceString: Od.replaceWithSourceString,
    replaceWith: Od.replaceWith,
    replaceExpressionWithStatements: Od.replaceExpressionWithStatements,
    replaceInline: Od.replaceInline,
    evaluateTruthy: SH.evaluateTruthy,
    evaluate: SH.evaluate,
    toComputedKey: bh.toComputedKey,
    ensureBlock: bh.ensureBlock,
    unwrapFunctionEnvironment: bh.unwrapFunctionEnvironment,
    arrowFunctionToExpression: bh.arrowFunctionToExpression,
    splitExportDeclaration: bh.splitExportDeclaration,
    ensureFunctionName: bh.ensureFunctionName,
    matchesPattern: br.matchesPattern,
    isStatic: br.isStatic,
    isNodeType: br.isNodeType,
    canHaveVariableDeclarationOrExpression: br.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: br.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: br.isCompletionRecord,
    isStatementOrBlock: br.isStatementOrBlock,
    referencesImport: br.referencesImport,
    getSource: br.getSource,
    willIMaybeExecuteBefore: br.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: br._guessExecutionStatusRelativeTo,
    resolve: br.resolve,
    isConstantExpression: br.isConstantExpression,
    isInStrictMode: br.isInStrictMode,
    isDenylisted: ir.isDenylisted,
    visit: ir.visit,
    skip: ir.skip,
    skipKey: ir.skipKey,
    stop: ir.stop,
    setContext: ir.setContext,
    requeue: ir.requeue,
    requeueComputedKeyAndDecorators: ir.requeueComputedKeyAndDecorators,
    remove: _d.remove,
    insertBefore: nl.insertBefore,
    insertAfter: nl.insertAfter,
    unshiftContainer: nl.unshiftContainer,
    pushContainer: nl.pushContainer,
    getOpposite: Pn.getOpposite,
    getCompletionRecords: Pn.getCompletionRecords,
    getSibling: Pn.getSibling,
    getPrevSibling: Pn.getPrevSibling,
    getNextSibling: Pn.getNextSibling,
    getAllNextSiblings: Pn.getAllNextSiblings,
    getAllPrevSiblings: Pn.getAllPrevSiblings,
    get: Pn.get,
    getAssignmentIdentifiers: Pn.getAssignmentIdentifiers,
    getBindingIdentifiers: Pn.getBindingIdentifiers,
    getOuterBindingIdentifiers: Pn.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: Pn.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: Pn.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: PD.shareCommentsWithSiblings,
    addComment: PD.addComment,
    addComments: PD.addComments
  };
  Object.assign(ou.prototype, DHe);
  ou.prototype.arrowFunctionToShadowed = bh.arrowFunctionToShadowed, Object.assign(ou.prototype, {
    has: br.has,
    is: br.is,
    isnt: br.isnt,
    equals: br.equals,
    hoist: nl.hoist,
    updateSiblingKeys: nl.updateSiblingKeys,
    call: ir.call,
    isBlacklisted: ir.isBlacklisted,
    setScope: ir.setScope,
    resync: ir.resync,
    popContext: ir.popContext,
    pushContext: ir.pushContext,
    setup: ir.setup,
    setKey: ir.setKey
  });
  ou.prototype._guessExecutionStatusRelativeToDifferentFunctions = br._guessExecutionStatusRelativeTo, ou.prototype._guessExecutionStatusRelativeToDifferentFunctions =
  br._guessExecutionStatusRelativeTo, Object.assign(ou.prototype, {
    _getTypeAnnotation: Dd._getTypeAnnotation,
    _replaceWith: Od._replaceWith,
    _resolve: br._resolve,
    _call: ir._call,
    _resyncParent: ir._resyncParent,
    _resyncKey: ir._resyncKey,
    _resyncList: ir._resyncList,
    _resyncRemoved: ir._resyncRemoved,
    _getQueueContexts: ir._getQueueContexts,
    _removeFromScope: _d._removeFromScope,
    _callRemovalHooks: _d._callRemovalHooks,
    _remove: _d._remove,
    _markRemoved: _d._markRemoved,
    _assertUnremoved: _d._assertUnremoved,
    _containerInsert: nl._containerInsert,
    _containerInsertBefore: nl._containerInsertBefore,
    _containerInsertAfter: nl._containerInsertAfter,
    _verifyNodeList: nl._verifyNodeList,
    _getKey: Pn._getKey,
    _getPattern: Pn._getPattern
  });
  for (let t of pS.TYPES) {
    let e = `is${t}`, s = pS[e];
    ou.prototype[e] = function(i) {
      return s(this.node, i);
    }, ou.prototype[`assert${t}`] = function(i) {
      if (!s(this.node, i))
        throw new TypeError(`Expected node path of type ${t}`);
    };
  }
  Object.assign(ou.prototype, NHe);
  for (let t of Object.keys(EHe))
    t[0] !== "_" && (pS.TYPES.includes(t) || pS.TYPES.push(t));
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/context.js
var CH = g((hS) => {
  "use strict";
  Object.defineProperty(hS, "__esModule", {
    value: !0
  });
  hS.default = void 0;
  var OHe = Mc(), _He = fe(), ED = tl(), {
    VISITOR_KEYS: LHe
  } = _He, AD = class {
    static {
      n(this, "TraversalContext");
    }
    constructor(e, s, i, r) {
      this.queue = null, this.priorityQueue = null, this.parentPath = r, this.scope = e, this.state = i, this.opts = s;
    }
    shouldVisit(e) {
      let s = this.opts;
      if (s.enter || s.exit || s[e.type]) return !0;
      let i = LHe[e.type];
      if (!(i != null && i.length)) return !1;
      for (let r of i)
        if (e[r])
          return !0;
      return !1;
    }
    create(e, s, i, r) {
      return OHe.default.get({
        parentPath: this.parentPath,
        parent: e,
        container: s,
        key: i,
        listKey: r
      });
    }
    maybeQueue(e, s) {
      this.queue && (s ? this.queue.push(e) : this.priorityQueue.push(e));
    }
    visitMultiple(e, s, i) {
      if (e.length === 0) return !1;
      let r = [];
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        o && this.shouldVisit(o) && r.push(this.create(s, e, a, i));
      }
      return this.visitQueue(r);
    }
    visitSingle(e, s) {
      return this.shouldVisit(e[s]) ? this.visitQueue([this.create(e, e, s)]) : !1;
    }
    visitQueue(e) {
      this.queue = e, this.priorityQueue = [];
      let s = /* @__PURE__ */ new WeakSet(), i = !1, r = 0;
      for (; r < e.length; ) {
        let a = e[r];
        if (r++, ED.resync.call(a), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && ED.pushContext.call(a, this),
        a.key === null) continue;
        let {
          node: o
        } = a;
        if (!s.has(o)) {
          if (o && s.add(o), a.visit()) {
            i = !0;
            break;
          }
          if (this.priorityQueue.length && (i = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e, i))
            break;
        }
      }
      for (let a = 0; a < r; a++)
        ED.popContext.call(e[a]);
      return this.queue = null, i;
    }
    visit(e, s) {
      let i = e[s];
      return i ? Array.isArray(i) ? this.visitMultiple(i, e, s) : this.visitSingle(e, s) : !1;
    }
  };
  hS.default = AD;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/traverse-node.js
var Sx = g((vD) => {
  "use strict";
  Object.defineProperty(vD, "__esModule", {
    value: !0
  });
  vD.traverseNode = jHe;
  var BHe = CH(), MHe = fe(), {
    VISITOR_KEYS: FHe
  } = MHe;
  function jHe(t, e, s, i, r, a, o) {
    let l = FHe[t.type];
    if (!l) return !1;
    let u = new BHe.default(s, e, i, r);
    if (o)
      return a != null && a[r.parentKey] ? !1 : u.visitQueue([r]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(t, c))
        return !0;
    return !1;
  }
  n(jHe, "traverseNode");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/path/context.js
var tl = g((Ui) => {
  "use strict";
  Object.defineProperty(Ui, "__esModule", {
    value: !0
  });
  Ui._call = wD;
  Ui._getQueueContexts = eJe;
  Ui._resyncKey = OH;
  Ui._resyncList = _H;
  Ui._resyncParent = DH;
  Ui._resyncRemoved = YHe;
  Ui.call = CD;
  Ui.isDenylisted = NH;
  Ui.popContext = XHe;
  Ui.pushContext = zHe;
  Ui.requeue = QHe;
  Ui.requeueComputedKeyAndDecorators = ZHe;
  Ui.resync = JHe;
  Ui.setContext = HHe;
  Ui.setKey = fS;
  Ui.setScope = kH;
  Ui.setup = GHe;
  Ui.skip = VHe;
  Ui.skipKey = WHe;
  Ui.stop = $He;
  Ui.visit = KHe;
  var RHe = Sx(), wH = Mc(), qHe = Xx(), UHe = fe();
  function CD(t) {
    let e = this.opts;
    if (this.debug(t), this.node && wD.call(this, e[t]))
      return !0;
    if (this.node) {
      var s;
      return wD.call(this, (s = e[this.node.type]) == null ? void 0 : s[t]);
    }
    return !1;
  }
  n(CD, "call");
  function wD(t) {
    if (!t) return !1;
    for (let e of t) {
      if (!e) continue;
      let s = this.node;
      if (!s) return !0;
      let i = e.call(this.state, this, this.state);
      if (i && typeof i == "object" && typeof i.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (i)
        throw new Error(`Unexpected return value from visitor method ${e}`);
      if (this.node !== s || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  n(wD, "_call");
  function NH() {
    var t;
    let e = (t = this.opts.denylist) != null ? t : this.opts.blacklist;
    return e?.includes(this.node.type);
  }
  n(NH, "isDenylisted");
  Ui.isBlacklisted = NH;
  function IH(t, e) {
    t.context !== e && (t.context = e, t.state = e.state, t.opts = e.opts);
  }
  n(IH, "restoreContext");
  function KHe() {
    var t, e;
    if (!this.node || this.isDenylisted() || (t = (e = this.opts).shouldSkip) != null && t.call(e, this))
      return !1;
    let s = this.context;
    return this.shouldSkip || CD.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (IH(this, s), this.debug("Recursing into..\
."), this.shouldStop = (0, RHe.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), IH(this, s), CD.call(this, "\
exit"), this.shouldStop);
  }
  n(KHe, "visit");
  function VHe() {
    this.shouldSkip = !0;
  }
  n(VHe, "skip");
  function WHe(t) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[t] = !0;
  }
  n(WHe, "skipKey");
  function $He() {
    this._traverseFlags |= wH.SHOULD_SKIP | wH.SHOULD_STOP;
  }
  n($He, "stop");
  function kH() {
    var t, e;
    if ((t = this.opts) != null && t.noScope) return;
    let s = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && s.isMethod() || this.key === "discriminant" && s.isSwitchStatement()) && (s = s.
    parentPath);
    let i;
    for (; s && !i; ) {
      var r;
      if ((r = s.opts) != null && r.noScope) return;
      i = s.scope, s = s.parentPath;
    }
    this.scope = this.getScope(i), (e = this.scope) == null || e.init();
  }
  n(kH, "setScope");
  function HHe(t) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, t && (this.context = t, this.state = t.state, this.opts =
    t.opts), kH.call(this), this;
  }
  n(HHe, "setContext");
  function JHe() {
    this.removed || (DH.call(this), _H.call(this), OH.call(this));
  }
  n(JHe, "resync");
  function DH() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  n(DH, "_resyncParent");
  function OH() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let t = 0; t < this.container.length; t++)
          if (this.container[t] === this.node) {
            fS.call(this, t);
            return;
          }
      } else
        for (let t of Object.keys(this.container))
          if (this.container[t] === this.node) {
            fS.call(this, t);
            return;
          }
      this.key = null;
    }
  }
  n(OH, "_resyncKey");
  function _H() {
    if (!this.parent || !this.inList) return;
    let t = this.parent[this.listKey];
    this.container !== t && (this.container = t || null);
  }
  n(_H, "_resyncList");
  function YHe() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && qHe._markRemoved.call(this);
  }
  n(YHe, "_resyncRemoved");
  function XHe() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  n(XHe, "popContext");
  function zHe(t) {
    this.contexts.push(t), this.setContext(t);
  }
  n(zHe, "pushContext");
  function GHe(t, e, s, i) {
    this.listKey = s, this.container = e, this.parentPath = t || this.parentPath, fS.call(this, i);
  }
  n(GHe, "setup");
  function fS(t) {
    var e;
    this.key = t, this.node = this.container[this.key], this.type = (e = this.node) == null ? void 0 : e.type;
  }
  n(fS, "setKey");
  function QHe(t = this) {
    if (t.removed) return;
    let e = this.contexts;
    for (let s of e)
      s.maybeQueue(t);
  }
  n(QHe, "requeue");
  function ZHe() {
    let {
      context: t,
      node: e
    } = this;
    if (!UHe.isPrivate(e) && e.computed && t.maybeQueue(this.get("key")), e.decorators)
      for (let s of this.get("decorators"))
        t.maybeQueue(s);
  }
  n(ZHe, "requeueComputedKeyAndDecorators");
  function eJe() {
    let t = this, e = this.contexts;
    for (; !e.length && (t = t.parentPath, !!t); )
      e = t.contexts;
    return e;
  }
  n(eJe, "_getQueueContexts");
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/hub.js
var LH = g((dS) => {
  "use strict";
  Object.defineProperty(dS, "__esModule", {
    value: !0
  });
  dS.default = void 0;
  var ID = class {
    static {
      n(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e, s, i = TypeError) {
      return new i(s);
    }
  };
  dS.default = ID;
});

// ../node_modules/@babel/core/node_modules/@babel/traverse/lib/index.js
var zl = g((lu) => {
  "use strict";
  Object.defineProperty(lu, "__esModule", {
    value: !0
  });
  Object.defineProperty(lu, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nJe.default;
    }, "get")
  });
  Object.defineProperty(lu, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iJe.default;
    }, "get")
  });
  Object.defineProperty(lu, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rJe.default;
    }, "get")
  });
  lu.visitors = lu.default = void 0;
  tl();
  var Lg = fg();
  lu.visitors = Lg;
  var tJe = fe(), sJe = oh(), BH = Sx(), iJe = Mc(), rJe = jN(), nJe = LH(), {
    VISITOR_KEYS: aJe,
    removeProperties: oJe,
    traverseFast: MH
  } = tJe;
  function Oa(t, e = {}, s, i, r, a) {
    if (t) {
      if (!e.noScope && !s && t.type !== "Program" && t.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${t.
        type} node without passing scope and parentPath.`);
      if (!r && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      aJe[t.type] && (Lg.explode(e), (0, BH.traverseNode)(t, e, s, i, r, null, a));
    }
  }
  n(Oa, "traverse");
  var H7s = lu.default = Oa;
  Oa.visitors = Lg;
  Oa.verify = Lg.verify;
  Oa.explode = Lg.explode;
  Oa.cheap = function(t, e) {
    MH(t, e);
  };
  Oa.node = function(t, e, s, i, r, a) {
    (0, BH.traverseNode)(t, e, s, i, r, a);
  };
  Oa.clearNode = function(t, e) {
    oJe(t, e);
  };
  Oa.removeProperties = function(t, e) {
    return MH(t, Oa.clearNode, e), t;
  };
  function lJe(t, e) {
    t.node.type === e.type && (e.has = !0, t.stop());
  }
  n(lJe, "hasDenylistedType");
  Oa.hasType = function(t, e, s) {
    if (s != null && s.includes(t.type)) return !1;
    if (t.type === e) return !0;
    let i = {
      has: !1,
      type: e
    };
    return Oa(t, {
      noScope: !0,
      denylist: s,
      enter: lJe
    }, null, i), i.has;
  };
  Oa.cache = sJe;
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var RH = g((yS) => {
  "use strict";
  Object.defineProperty(yS, "__esModule", {
    value: !0
  });
  yS.default = void 0;
  var So = require("assert"), uJe = fe(), {
    callExpression: ND,
    cloneNode: mS,
    expressionStatement: FH,
    identifier: Bg,
    importDeclaration: cJe,
    importDefaultSpecifier: pJe,
    importNamespaceSpecifier: hJe,
    importSpecifier: fJe,
    memberExpression: kD,
    stringLiteral: jH,
    variableDeclaration: dJe,
    variableDeclarator: mJe
  } = uJe, DD = class {
    static {
      n(this, "ImportBuilder");
    }
    constructor(e, s, i) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = s, this._hub = i, this._importedSource = e;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(cJe([], jH(this._importedSource))), this;
    }
    require() {
      return this._statements.push(FH(ND(Bg("require"), [jH(this._importedSource)]))), this;
    }
    namespace(e = "namespace") {
      let s = this._scope.generateUidIdentifier(e), i = this._statements[this._statements.length - 1];
      return So(i.type === "ImportDeclaration"), So(i.specifiers.length === 0), i.specifiers = [hJe(s)], this._resultName = mS(s), this;
    }
    default(e) {
      let s = this._scope.generateUidIdentifier(e), i = this._statements[this._statements.length - 1];
      return So(i.type === "ImportDeclaration"), So(i.specifiers.length === 0), i.specifiers = [pJe(s)], this._resultName = mS(s), this;
    }
    named(e, s) {
      if (s === "default") return this.default(e);
      let i = this._scope.generateUidIdentifier(e), r = this._statements[this._statements.length - 1];
      return So(r.type === "ImportDeclaration"), So(r.specifiers.length === 0), r.specifiers = [fJe(i, Bg(s))], this._resultName = mS(i), this;
    }
    var(e) {
      let s = this._scope.generateUidIdentifier(e), i = this._statements[this._statements.length - 1];
      return i.type !== "ExpressionStatement" && (So(this._resultName), i = FH(this._resultName), this._statements.push(i)), this._statements[this.
      _statements.length - 1] = dJe("var", [mJe(s, i.expression)]), this._resultName = mS(s), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(e) {
      let s = this._statements[this._statements.length - 1];
      return s.type === "ExpressionStatement" ? s.expression = ND(e, [s.expression]) : s.type === "VariableDeclaration" ? (So(s.declarations.
      length === 1), s.declarations[0].init = ND(e, [s.declarations[0].init])) : So.fail("Unexpected type."), this;
    }
    prop(e) {
      let s = this._statements[this._statements.length - 1];
      return s.type === "ExpressionStatement" ? s.expression = kD(s.expression, Bg(e)) : s.type === "VariableDeclaration" ? (So(s.declarations.
      length === 1), s.declarations[0].init = kD(s.declarations[0].init, Bg(e))) : So.fail("Unexpected type:" + s.type), this;
    }
    read(e) {
      this._resultName = kD(this._resultName, Bg(e));
    }
  };
  yS.default = DD;
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var _D = g((OD) => {
  "use strict";
  Object.defineProperty(OD, "__esModule", {
    value: !0
  });
  OD.default = yJe;
  function yJe(t) {
    return t.node.sourceType === "module";
  }
  n(yJe, "isModule");
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var $H = g((TS) => {
  "use strict";
  Object.defineProperty(TS, "__esModule", {
    value: !0
  });
  TS.default = void 0;
  var qH = require("assert"), gJe = fe(), TJe = RH(), bJe = _D(), {
    identifier: xJe,
    importSpecifier: SJe,
    numericLiteral: PJe,
    sequenceExpression: EJe,
    isImportDeclaration: UH
  } = gJe, LD = class {
    static {
      n(this, "ImportInjector");
    }
    constructor(e, s, i) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1,
        importPosition: "before"
      };
      let r = e.find((a) => a.isProgram());
      this._programPath = r, this._programScope = r.scope, this._hub = r.hub, this._defaultOpts = this._applyDefaults(s, i, !0);
    }
    addDefault(e, s) {
      return this.addNamed("default", e, s);
    }
    addNamed(e, s, i) {
      return qH(typeof e == "string"), this._generateImport(this._applyDefaults(s, i), e);
    }
    addNamespace(e, s) {
      return this._generateImport(this._applyDefaults(e, s), null);
    }
    addSideEffect(e, s) {
      return this._generateImport(this._applyDefaults(e, s), void 0);
    }
    _applyDefaults(e, s, i = !1) {
      let r;
      return typeof e == "string" ? r = Object.assign({}, this._defaultOpts, {
        importedSource: e
      }, s) : (qH(!s, "Unexpected secondary arguments."), r = Object.assign({}, this._defaultOpts, e)), !i && s && (s.nameHint !== void 0 &&
      (r.nameHint = s.nameHint), s.blockHoist !== void 0 && (r.blockHoist = s.blockHoist)), r;
    }
    _generateImport(e, s) {
      let i = s === "default", r = !!s && !i, a = s === null, {
        importedSource: o,
        importedType: l,
        importedInterop: u,
        importingInterop: c,
        ensureLiveReference: p,
        ensureNoContext: h,
        nameHint: f,
        importPosition: d,
        blockHoist: y
      } = e, m = f || s, T = (0, bJe.default)(this._programPath), b = T && c === "node", E = T && c === "babel";
      if (d === "after" && !T)
        throw new Error('"importPosition": "after" is only supported in modules');
      let w = new TJe.default(o, this._programScope, this._hub);
      if (l === "es6") {
        if (!b && !E)
          throw new Error("Cannot import an ES6 module from CommonJS");
        w.import(), a ? w.namespace(f || o) : (i || r) && w.named(m, s);
      } else {
        if (l !== "commonjs")
          throw new Error(`Unexpected interopType "${l}"`);
        if (u === "babel")
          if (b) {
            m = m !== "default" ? m : o;
            let de = `${o}$es6Default`;
            w.import(), a ? w.default(de).var(m || o).wildcardInterop() : i ? p ? w.default(de).var(m || o).defaultInterop().read("default") :
            w.default(de).var(m).defaultInterop().prop(s) : r && w.default(de).read(s);
          } else E ? (w.import(), a ? w.namespace(m || o) : (i || r) && w.named(m, s)) : (w.require(), a ? w.var(m || o).wildcardInterop() :
          (i || r) && p ? i ? (m = m !== "default" ? m : o, w.var(m).read(s), w.defaultInterop()) : w.var(o).read(s) : i ? w.var(m).defaultInterop().
          prop(s) : r && w.var(m).prop(s));
        else if (u === "compiled")
          b ? (w.import(), a ? w.default(m || o) : (i || r) && w.default(o).read(m)) : E ? (w.import(), a ? w.namespace(m || o) : (i || r) &&
          w.named(m, s)) : (w.require(), a ? w.var(m || o) : (i || r) && (p ? w.var(o).read(m) : w.prop(s).var(m)));
        else if (u === "uncompiled") {
          if (i && p)
            throw new Error("No live reference for commonjs default");
          b ? (w.import(), a ? w.default(m || o) : i ? w.default(m) : r && w.default(o).read(m)) : E ? (w.import(), a ? w.default(m || o) : i ?
          w.default(m) : r && w.named(m, s)) : (w.require(), a ? w.var(m || o) : i ? w.var(m) : r && (p ? w.var(o).read(m) : w.var(m).prop(s)));
        } else
          throw new Error(`Unknown importedInterop "${u}".`);
      }
      let {
        statements: K,
        resultName: he
      } = w.done();
      return this._insertStatements(K, d, y), (i || r) && h && he.type !== "Identifier" ? EJe([PJe(0), he]) : he;
    }
    _insertStatements(e, s = "before", i = 3) {
      if (s === "after") {
        if (this._insertStatementsAfter(e)) return;
      } else if (this._insertStatementsBefore(e, i)) return;
      this._programPath.unshiftContainer("body", e);
    }
    _insertStatementsBefore(e, s) {
      if (e.length === 1 && UH(e[0]) && gS(e[0])) {
        let r = this._programPath.get("body").find((a) => a.isImportDeclaration() && gS(a.node));
        if (r?.node.source.value === e[0].source.value && WH(r.node, e[0]))
          return !0;
      }
      e.forEach((r) => {
        r._blockHoist = s;
      });
      let i = this._programPath.get("body").find((r) => {
        let a = r.node._blockHoist;
        return Number.isFinite(a) && a < 4;
      });
      return i ? (i.insertBefore(e), !0) : !1;
    }
    _insertStatementsAfter(e) {
      let s = new Set(e), i = /* @__PURE__ */ new Map();
      for (let a of e)
        if (UH(a) && gS(a)) {
          let o = a.source.value;
          i.has(o) || i.set(o, []), i.get(o).push(a);
        }
      let r = null;
      for (let a of this._programPath.get("body"))
        if (a.isImportDeclaration() && gS(a.node)) {
          r = a;
          let o = a.node.source.value, l = i.get(o);
          if (!l) continue;
          for (let u of l)
            s.has(u) && WH(a.node, u) && s.delete(u);
        }
      return s.size === 0 ? !0 : (r && r.insertAfter(Array.from(s)), !!r);
    }
  };
  TS.default = LD;
  function gS(t) {
    return t.importKind !== "type" && t.importKind !== "typeof";
  }
  n(gS, "isValueImport");
  function KH(t) {
    return t.specifiers.length === 1 && t.specifiers[0].type === "ImportNamespaceSpecifier" || t.specifiers.length === 2 && t.specifiers[1].
    type === "ImportNamespaceSpecifier";
  }
  n(KH, "hasNamespaceImport");
  function VH(t) {
    return t.specifiers.length > 0 && t.specifiers[0].type === "ImportDefaultSpecifier";
  }
  n(VH, "hasDefaultImport");
  function WH(t, e) {
    return t.specifiers.length ? e.specifiers.length ? KH(t) || KH(e) ? !1 : (VH(e) && (VH(t) ? e.specifiers[0] = SJe(e.specifiers[0].local,
    xJe("default")) : t.specifiers.unshift(e.specifiers.shift())), t.specifiers.push(...e.specifiers), !0) : !0 : (t.specifiers = e.specifiers,
    !0);
  }
  n(WH, "maybeAppendImportSpecifiers");
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var HH = g((Uc) => {
  "use strict";
  Object.defineProperty(Uc, "__esModule", {
    value: !0
  });
  Object.defineProperty(Uc, "ImportInjector", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Mg.default;
    }, "get")
  });
  Uc.addDefault = vJe;
  Uc.addNamed = CJe;
  Uc.addNamespace = wJe;
  Uc.addSideEffect = IJe;
  Object.defineProperty(Uc, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return AJe.default;
    }, "get")
  });
  var Mg = $H(), AJe = _D();
  function vJe(t, e, s) {
    return new Mg.default(t).addDefault(e, s);
  }
  n(vJe, "addDefault");
  function CJe(t, e, s, i) {
    return new Mg.default(t).addNamed(e, s, i);
  }
  n(CJe, "addNamed");
  function wJe(t, e, s) {
    return new Mg.default(t).addNamespace(e, s);
  }
  n(wJe, "addNamespace");
  function IJe(t, e, s) {
    return new Mg.default(t).addSideEffect(e, s);
  }
  n(IJe, "addSideEffect");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var BD = g((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  ms.Var = ms.User = ms.Statement = ms.SpreadProperty = ms.Scope = ms.RestProperty = ms.ReferencedMemberExpression = ms.ReferencedIdentifier =
  ms.Referenced = ms.Pure = ms.NumericLiteralTypeAnnotation = ms.Generated = ms.ForAwaitStatement = ms.Flow = ms.Expression = ms.ExistentialTypeParam =
  ms.BlockScoped = ms.BindingIdentifier = void 0;
  var iqs = ms.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], rqs = ms.ReferencedMemberExpression = ["MemberExpression"], nqs = ms.
  BindingIdentifier = ["Identifier"], aqs = ms.Statement = ["Statement"], oqs = ms.Expression = ["Expression"], lqs = ms.Scope = ["Scopable",
  "Pattern"], uqs = ms.Referenced = null, cqs = ms.BlockScoped = null, pqs = ms.Var = ["VariableDeclaration"], hqs = ms.User = null, fqs = ms.
  Generated = null, dqs = ms.Pure = null, mqs = ms.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], yqs = ms.RestProperty =
  ["RestElement"], gqs = ms.SpreadProperty = ["RestElement"], Tqs = ms.ExistentialTypeParam = ["ExistsTypeAnnotation"], bqs = ms.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], xqs = ms.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var FD = g((vr) => {
  "use strict";
  Object.defineProperty(vr, "__esModule", {
    value: !0
  });
  vr.isBindingIdentifier = GJe;
  vr.isBlockScoped = sYe;
  vr.isExpression = ZJe;
  vr.isFlow = oYe;
  vr.isForAwaitStatement = cYe;
  vr.isGenerated = nYe;
  vr.isPure = aYe;
  vr.isReferenced = tYe;
  vr.isReferencedIdentifier = XJe;
  vr.isReferencedMemberExpression = zJe;
  vr.isRestProperty = lYe;
  vr.isScope = eYe;
  vr.isSpreadProperty = uYe;
  vr.isStatement = QJe;
  vr.isUser = rYe;
  vr.isVar = iYe;
  var NJe = fe(), {
    isBinding: kJe,
    isBlockScoped: DJe,
    isExportDeclaration: OJe,
    isExpression: _Je,
    isFlow: LJe,
    isForStatement: BJe,
    isForXStatement: MJe,
    isIdentifier: JH,
    isImportDeclaration: FJe,
    isImportSpecifier: jJe,
    isJSXIdentifier: RJe,
    isJSXMemberExpression: qJe,
    isMemberExpression: UJe,
    isRestElement: YH,
    isReferenced: MD,
    isScope: KJe,
    isStatement: VJe,
    isVar: WJe,
    isVariableDeclaration: $Je,
    react: HJe,
    isForOfStatement: JJe
  } = NJe, {
    isCompatTag: YJe
  } = HJe;
  function XJe(t) {
    let {
      node: e,
      parent: s
    } = this;
    if (!JH(e, t) && !qJe(s, t))
      if (RJe(e, t)) {
        if (YJe(e.name)) return !1;
      } else
        return !1;
    return MD(e, s, this.parentPath.parent);
  }
  n(XJe, "isReferencedIdentifier");
  function zJe() {
    let {
      node: t,
      parent: e
    } = this;
    return UJe(t) && MD(t, e);
  }
  n(zJe, "isReferencedMemberExpression");
  function GJe() {
    let {
      node: t,
      parent: e
    } = this, s = this.parentPath.parent;
    return JH(t) && kJe(t, e, s);
  }
  n(GJe, "isBindingIdentifier");
  function QJe() {
    let {
      node: t,
      parent: e
    } = this;
    return VJe(t) ? !($Je(t) && (MJe(e, {
      left: t
    }) || BJe(e, {
      init: t
    }))) : !1;
  }
  n(QJe, "isStatement");
  function ZJe() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : _Je(this.node);
  }
  n(ZJe, "isExpression");
  function eYe() {
    return KJe(this.node, this.parent);
  }
  n(eYe, "isScope");
  function tYe() {
    return MD(this.node, this.parent);
  }
  n(tYe, "isReferenced");
  function sYe() {
    return DJe(this.node);
  }
  n(sYe, "isBlockScoped");
  function iYe() {
    return WJe(this.node);
  }
  n(iYe, "isVar");
  function rYe() {
    return this.node && !!this.node.loc;
  }
  n(rYe, "isUser");
  function nYe() {
    return !this.isUser();
  }
  n(nYe, "isGenerated");
  function aYe(t) {
    return this.scope.isPure(this.node, t);
  }
  n(aYe, "isPure");
  function oYe() {
    let {
      node: t
    } = this;
    return LJe(t) ? !0 : FJe(t) ? t.importKind === "type" || t.importKind === "typeof" : OJe(t) ? t.exportKind === "type" : jJe(t) ? t.importKind ===
    "type" || t.importKind === "typeof" : !1;
  }
  n(oYe, "isFlow");
  function lYe() {
    var t;
    return YH(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectPattern());
  }
  n(lYe, "isRestProperty");
  function uYe() {
    var t;
    return YH(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectExpression());
  }
  n(uYe, "isSpreadProperty");
  function cYe() {
    return JJe(this.node, {
      await: !0
    });
  }
  n(cYe, "isForAwaitStatement");
  vr.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), vr.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/visitors.js
var jg = g((Sh) => {
  "use strict";
  Object.defineProperty(Sh, "__esModule", {
    value: !0
  });
  Sh.environmentVisitor = TYe;
  Sh.explode = nJ;
  Sh.isExplodedVisitor = rJ;
  Sh.merge = oJ;
  Sh.verify = aJ;
  var iJ = BD(), pYe = FD(), hYe = fe(), XH = ol(), {
    DEPRECATED_KEYS: zH,
    DEPRECATED_ALIASES: GH,
    FLIPPED_ALIAS_KEYS: QH,
    TYPES: fYe,
    __internal__deprecationWarning: ZH
  } = hYe;
  function dYe(t) {
    return t in iJ;
  }
  n(dYe, "isVirtualType");
  function rJ(t) {
    return t?._exploded;
  }
  n(rJ, "isExplodedVisitor");
  function nJ(t) {
    if (rJ(t)) return t;
    t._exploded = !0;
    for (let e of Object.keys(t)) {
      if (xh(e)) continue;
      let s = e.split("|");
      if (s.length === 1) continue;
      let i = t[e];
      delete t[e];
      for (let r of s)
        t[r] = i;
    }
    aJ(t), delete t.__esModule, mYe(t), sJ(t);
    for (let e of Object.keys(t)) {
      if (xh(e) || !dYe(e)) continue;
      let s = t[e];
      for (let r of Object.keys(s))
        s[r] = yYe(e, s[r]);
      delete t[e];
      let i = iJ[e];
      if (i !== null)
        for (let r of i)
          t[r] ? Fg(t[r], s) : t[r] = s;
      else
        Fg(t, s);
    }
    for (let e of Object.keys(t)) {
      if (xh(e)) continue;
      let s = QH[e];
      if (e in zH) {
        let r = zH[e];
        ZH(e, r, "Visitor "), s = [r];
      } else if (e in GH) {
        let r = GH[e];
        ZH(e, r, "Visitor "), s = QH[r];
      }
      if (!s) continue;
      let i = t[e];
      delete t[e];
      for (let r of s) {
        let a = t[r];
        a ? Fg(a, i) : t[r] = Object.assign({}, i);
      }
    }
    for (let e of Object.keys(t))
      xh(e) || sJ(t[e]);
    return t;
  }
  n(nJ, "explode$1");
  function aJ(t) {
    if (!t._verified) {
      if (typeof t == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let e of Object.keys(t)) {
        if ((e === "enter" || e === "exit") && eJ(e, t[e]), xh(e)) continue;
        if (!fYe.includes(e))
          throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type in @babel/traverse 7.26.9`);
        let s = t[e];
        if (typeof s == "object")
          for (let i of Object.keys(s))
            if (i === "enter" || i === "exit")
              eJ(`${e}.${i}`, s[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${i}`);
      }
      t._verified = !0;
    }
  }
  n(aJ, "verify$1");
  function eJ(t, e) {
    let s = [].concat(e);
    for (let i of s)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${t} with type ${typeof i}`);
  }
  n(eJ, "validateVisitorMethods");
  function oJ(t, e = [], s) {
    let i = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(i, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(i, "_verified", {
      enumerable: !1
    });
    for (let r = 0; r < t.length; r++) {
      let a = nJ(t[r]), o = e[r], l = a;
      (o || s) && (l = tJ(l, o, s)), Fg(i, l);
      for (let u of Object.keys(a)) {
        if (xh(u)) continue;
        let c = a[u];
        (o || s) && (c = tJ(c, o, s));
        let p = i[u] || (i[u] = {});
        Fg(p, c);
      }
    }
    return i;
  }
  n(oJ, "merge");
  function tJ(t, e, s) {
    let i = {};
    for (let r of ["enter", "exit"]) {
      let a = t[r];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return e && (l = /* @__PURE__ */ n(function(u) {
          o.call(e, u, e);
        }, "newFn")), s && (l = s(e?.key, r, l)), l !== o && (l.toString = () => o.toString()), l;
      }), i[r] = a);
    }
    return i;
  }
  n(tJ, "wrapWithStateOrWrapper");
  function mYe(t) {
    for (let e of Object.keys(t)) {
      if (xh(e)) continue;
      let s = t[e];
      typeof s == "function" && (t[e] = {
        enter: s
      });
    }
  }
  n(mYe, "ensureEntranceObjects");
  function sJ(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit]);
  }
  n(sJ, "ensureCallbackArrays");
  function yYe(t, e) {
    let s = `is${t}`, i = pYe[s], r = /* @__PURE__ */ n(function(a) {
      if (i.call(a))
        return e.apply(this, arguments);
    }, "newFn");
    return r.toString = () => e.toString(), r;
  }
  n(yYe, "wrapCheck");
  function xh(t) {
    return t[0] === "_" || t === "enter" || t === "exit" || t === "shouldSkip" || t === "denylist" || t === "noScope" || t === "skipKeys" ||
    t === "blacklist";
  }
  n(xh, "shouldIgnoreKey");
  function Fg(t, e) {
    for (let s of ["enter", "exit"])
      e[s] && (t[s] = [].concat(t[s] || [], e[s]));
  }
  n(Fg, "mergePair");
  var gYe = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() :
      XH.requeueComputedKeyAndDecorators.call(t)));
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() : XH.requeueComputedKeyAndDecorators.
      call(t));
    }
  };
  function TYe(t) {
    return oJ([gYe, t]);
  }
  n(TYe, "environmentVisitor");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var lJ = g((xS) => {
  "use strict";
  Object.defineProperty(xS, "__esModule", {
    value: !0
  });
  xS.default = void 0;
  var bS = fe(), bYe = bS, xYe = SS(), SYe = jg(), PYe = ol(), {
    getAssignmentIdentifiers: EYe
  } = bYe, AYe = {
    ReferencedIdentifier({
      node: t
    }, e) {
      t.name === e.oldName && (t.name = e.newName);
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.
      requeueComputedKeyAndDecorators() : PYe.requeueComputedKeyAndDecorators.call(t)));
    },
    ObjectProperty({
      node: t,
      scope: e
    }, s) {
      let {
        name: i
      } = t.key;
      if (t.shorthand && (i === s.oldName || i === s.newName) && e.getBindingIdentifier(i) === s.binding.identifier) {
        t.shorthand = !1;
        {
          var r;
          (r = t.extra) != null && r.shorthand && (t.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(t, e) {
      if (t.isVariableDeclaration()) return;
      let s = t.isAssignmentExpression() ? EYe(t.node) : t.getOuterBindingIdentifiers();
      for (let i in s)
        i === e.oldName && (s[i].name = e.newName);
    }
  }, jD = class {
    static {
      n(this, "Renamer");
    }
    constructor(e, s, i) {
      this.newName = i, this.oldName = s, this.binding = e;
    }
    maybeConvertFromExportDeclaration(e) {
      let s = e.parentPath;
      if (s.isExportDeclaration()) {
        if (s.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = s.node;
          if (bS.isDeclaration(i) && !i.id)
            return;
        }
        s.isExportAllDeclaration() || s.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(e) {
      return e;
    }
    maybeConvertFromClassFunctionExpression(e) {
      return e;
    }
    rename() {
      let {
        binding: e,
        oldName: s,
        newName: i
      } = this, {
        scope: r,
        path: a
      } = e, o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression());
      o && o.getOuterBindingIdentifiers()[s] === e.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || r.block, u = {
        discriminant: !0
      };
      bS.isMethod(l) && (l.computed && (u.key = !0), bS.isObjectMethod(l) || (u.decorators = !0)), (0, xYe.traverseNode)(l, (0, SYe.explode)(
      AYe), r, this, r.path, u), arguments[0] || (r.removeOwnBinding(s), r.bindings[i] = e, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  xS.default = jD;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/scope/binding.js
var uJ = g((PS) => {
  "use strict";
  Object.defineProperty(PS, "__esModule", {
    value: !0
  });
  PS.default = void 0;
  var RD = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: e,
      scope: s,
      path: i,
      kind: r
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e, this.scope = s, this.path = i, this.kind = r,
      (r === "var" || r === "hoisted") && vYe(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(e) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = e);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(e) {
      this.constant = !1, !this.constantViolations.includes(e) && this.constantViolations.push(e);
    }
    reference(e) {
      this.referencePaths.includes(e) || (this.referenced = !0, this.references++, this.referencePaths.push(e));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  PS.default = RD;
  function vYe(t) {
    for (let {
      parentPath: e,
      key: s
    } = t; e; {
      parentPath: e,
      key: s
    } = e) {
      if (e.isFunctionParent()) return !1;
      if (e.isWhile() || e.isForXStatement() || e.isForStatement() && s === "body")
        return !0;
    }
    return !1;
  }
  n(vYe, "isDeclaredInLoop");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/cache.js
var Ph = g((ca) => {
  "use strict";
  Object.defineProperty(ca, "__esModule", {
    value: !0
  });
  ca.clear = wYe;
  ca.clearPath = cJ;
  ca.clearScope = pJ;
  ca.getCachedPaths = IYe;
  ca.getOrCreateCachedPaths = NYe;
  ca.scope = ca.path = void 0;
  var ES = ca.path = /* @__PURE__ */ new WeakMap(), CYe = ca.scope = /* @__PURE__ */ new WeakMap();
  function wYe() {
    cJ(), pJ();
  }
  n(wYe, "clear");
  function cJ() {
    ca.path = ES = /* @__PURE__ */ new WeakMap();
  }
  n(cJ, "clearPath");
  function pJ() {
    ca.scope = CYe = /* @__PURE__ */ new WeakMap();
  }
  n(pJ, "clearScope");
  var qD = Object.freeze({});
  function IYe(t, e) {
    var s, i;
    return t = null, (s = ES.get((i = t) != null ? i : qD)) == null ? void 0 : s.get(e);
  }
  n(IYe, "getCachedPaths");
  function NYe(t, e) {
    var s, i;
    t = null;
    let r = ES.get((s = t) != null ? s : qD);
    r || ES.set((i = t) != null ? i : qD, r = /* @__PURE__ */ new WeakMap());
    let a = r.get(e);
    return a || r.set(e, a = /* @__PURE__ */ new Map()), a;
  }
  n(NYe, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/scope/index.js
var WD = g((vS) => {
  "use strict";
  Object.defineProperty(vS, "__esModule", {
    value: !0
  });
  vS.default = void 0;
  var kYe = lJ(), DYe = Ld(), OYe = uJ(), _Ye = dd(), xJ = fe(), SJ = xJ, hJ = Ph(), LYe = jg(), {
    NOT_LOCAL_BINDING: fJ,
    assignmentExpression: BYe,
    callExpression: dJ,
    cloneNode: mJ,
    getBindingIdentifiers: PJ,
    identifier: Ah,
    isArrayExpression: EJ,
    isBinary: MYe,
    isCallExpression: yJ,
    isClass: FYe,
    isClassBody: jYe,
    isClassDeclaration: RYe,
    isExportAllDeclaration: AJ,
    isExportDefaultDeclaration: qYe,
    isExportNamedDeclaration: UD,
    isFunctionDeclaration: UYe,
    isIdentifier: Eh,
    isImportDeclaration: KD,
    isLiteral: KYe,
    isMemberExpression: VYe,
    isMethod: WYe,
    isModuleSpecifier: $Ye,
    isNullLiteral: HYe,
    isObjectExpression: JYe,
    isProperty: YYe,
    isPureish: XYe,
    isRegExpLiteral: zYe,
    isSuper: GYe,
    isTaggedTemplateExpression: QYe,
    isTemplateLiteral: vJ,
    isThisExpression: gJ,
    isUnaryExpression: ZYe,
    isVariableDeclaration: eXe,
    expressionStatement: tXe,
    matchesPattern: TJ,
    memberExpression: VD,
    numericLiteral: sXe,
    toIdentifier: iXe,
    variableDeclaration: rXe,
    variableDeclarator: nXe,
    isRecordExpression: aXe,
    isTupleExpression: oXe,
    isObjectProperty: lXe,
    isTopicReference: bJ,
    isMetaProperty: uXe,
    isPrivateName: cXe,
    isExportDeclaration: pXe,
    buildUndefinedNode: hXe,
    sequenceExpression: fXe
  } = xJ;
  function Ci(t, e) {
    switch (t?.type) {
      default:
        if (KD(t) || pXe(t)) {
          var s;
          if ((AJ(t) || UD(t) || KD(t)) && t.source)
            Ci(t.source, e);
          else if ((UD(t) || KD(t)) && (s = t.specifiers) != null && s.length)
            for (let i of t.specifiers) Ci(i, e);
          else (qYe(t) || UD(t)) && t.declaration && Ci(t.declaration, e);
        } else $Ye(t) ? Ci(t.local, e) : KYe(t) && !HYe(t) && !zYe(t) && !vJ(t) && e.push(t.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Ci(t.object, e), Ci(t.property, e);
        break;
      case "Identifier":
      case "JSXIdentifier":
        e.push(t.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Ci(t.callee, e);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of t.properties)
          Ci(i, e);
        break;
      case "SpreadElement":
      case "RestElement":
        Ci(t.argument, e);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Ci(t.key, e);
        break;
      case "ThisExpression":
        e.push("this");
        break;
      case "Super":
        e.push("super");
        break;
      case "Import":
        e.push("import");
        break;
      case "DoExpression":
        e.push("do");
        break;
      case "YieldExpression":
        e.push("yield"), Ci(t.argument, e);
        break;
      case "AwaitExpression":
        e.push("await"), Ci(t.argument, e);
        break;
      case "AssignmentExpression":
        Ci(t.left, e);
        break;
      case "VariableDeclarator":
        Ci(t.id, e);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Ci(t.id, e);
        break;
      case "PrivateName":
        Ci(t.id, e);
        break;
      case "ParenthesizedExpression":
        Ci(t.expression, e);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Ci(t.argument, e);
        break;
      case "MetaProperty":
        Ci(t.meta, e), Ci(t.property, e);
        break;
      case "JSXElement":
        Ci(t.openingElement, e);
        break;
      case "JSXOpeningElement":
        Ci(t.name, e);
        break;
      case "JSXFragment":
        Ci(t.openingFragment, e);
        break;
      case "JSXOpeningFragment":
        e.push("Fragment");
        break;
      case "JSXNamespacedName":
        Ci(t.namespace, e), Ci(t.name, e);
        break;
    }
  }
  n(Ci, "gatherNodeParts");
  var AS = {
    ForStatement(t) {
      let e = t.get("init");
      if (e.isVar()) {
        let {
          scope: s
        } = t;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", e);
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return;
      (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t);
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    TSImportEqualsDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    ReferencedIdentifier(t, e) {
      SJ.isTSQualifiedName(t.parent) && t.parent.right === t.node || t.parentPath.isTSImportEqualsDeclaration() || e.references.push(t);
    },
    ForXStatement(t, e) {
      let s = t.get("left");
      if (s.isPattern() || s.isIdentifier())
        e.constantViolations.push(t);
      else if (s.isVar()) {
        let {
          scope: i
        } = t;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", s);
      }
    },
    ExportDeclaration: {
      exit(t) {
        let {
          node: e,
          scope: s
        } = t;
        if (AJ(e)) return;
        let i = e.declaration;
        if (RYe(i) || UYe(i)) {
          let r = i.id;
          if (!r) return;
          let a = s.getBinding(r.name);
          a?.reference(t);
        } else if (eXe(i))
          for (let r of i.declarations)
            for (let a of Object.keys(PJ(r))) {
              let o = s.getBinding(a);
              o?.reference(t);
            }
      }
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t);
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t);
    },
    UnaryExpression(t, e) {
      t.node.operator === "delete" && e.constantViolations.push(t);
    },
    BlockScoped(t) {
      let e = t.scope;
      if (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id) {
        let r = t.node.id.name;
        t.scope.bindings[r] = t.scope.parent.getBinding(r);
      }
    },
    CatchClause(t) {
      t.scope.registerBinding("let", t);
    },
    Function(t) {
      let e = t.get("params");
      for (let s of e)
        t.scope.registerBinding("param", s);
      t.isFunctionExpression() && t.node.id && !t.node.id[fJ] && t.scope.registerBinding("local", t.get("id"), t);
    },
    ClassExpression(t) {
      t.node.id && !t.node.id[fJ] && t.scope.registerBinding("local", t.get("id"), t);
    },
    TSTypeAnnotation(t) {
      t.skip();
    }
  }, dXe = 0, Po = class t {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: s
      } = e, i = hJ.scope.get(s);
      if (i?.path === e)
        return i;
      hJ.scope.set(s, this), this.uid = dXe++, this.block = s, this.path = e, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var e;
      let s, i = this.path;
      do {
        var r;
        let a = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, a && i.isMethod() && (i = i.parentPath), (r = i) != null && r.isScope() && (s = i);
      } while (i && !s);
      return (e = s) == null ? void 0 : e.scope;
    }
    generateDeclaredUidIdentifier(e) {
      let s = this.generateUidIdentifier(e);
      return this.push({
        id: s
      }), mJ(s);
    }
    generateUidIdentifier(e) {
      return Ah(this.generateUid(e));
    }
    generateUid(e = "temp") {
      e = iXe(e).replace(/^_+/, "").replace(/\d+$/g, "");
      let s, i = 1;
      do
        s = `_${e}`, i > 1 && (s += i), i++;
      while (this.hasLabel(s) || this.hasBinding(s) || this.hasGlobal(s) || this.hasReference(s));
      let r = this.getProgramParent();
      return r.references[s] = !0, r.uids[s] = !0, s;
    }
    generateUidBasedOnNode(e, s) {
      let i = [];
      Ci(e, i);
      let r = i.join("$");
      return r = r.replace(/^_/, "") || s || "ref", this.generateUid(r.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e, s) {
      return Ah(this.generateUidBasedOnNode(e, s));
    }
    isStatic(e) {
      if (gJ(e) || GYe(e) || bJ(e))
        return !0;
      if (Eh(e)) {
        let s = this.getBinding(e.name);
        return s ? s.constant : this.hasBinding(e.name);
      }
      return !1;
    }
    maybeGenerateMemoised(e, s) {
      if (this.isStatic(e))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(e);
        return s ? i : (this.push({
          id: i
        }), mJ(i));
      }
    }
    checkBlockScopedCollisions(e, s, i, r) {
      if (s === "param" || e.kind === "local") return;
      if (s === "let" || e.kind === "let" || e.kind === "const" || e.kind === "module" || e.kind === "param" && s === "const")
        throw this.path.hub.buildError(r, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(e, s) {
      let i = this.getBinding(e);
      i && (s || (s = this.generateUidIdentifier(e).name), new kYe.default(i, e, s).rename(arguments[2]));
    }
    dump() {
      let e = "-".repeat(60);
      console.log(e);
      let s = this;
      do {
        console.log("#", s.block.type);
        for (let i of Object.keys(s.bindings)) {
          let r = s.bindings[i];
          console.log(" -", i, {
            constant: r.constant,
            references: r.references,
            violations: r.constantViolations.length,
            kind: r.kind
          });
        }
      } while (s = s.parent);
      console.log(e);
    }
    hasLabel(e) {
      return !!this.getLabel(e);
    }
    getLabel(e) {
      return this.labels.get(e);
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e);
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement())
        this.registerLabel(e);
      else if (e.isFunctionDeclaration())
        this.registerBinding("hoisted", e.get("id"), e);
      else if (e.isVariableDeclaration()) {
        let s = e.get("declarations"), {
          kind: i
        } = e.node;
        for (let r of s)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, r);
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return;
        this.registerBinding("let", e);
      } else if (e.isImportDeclaration()) {
        let s = e.node.importKind === "type" || e.node.importKind === "typeof", i = e.get("specifiers");
        for (let r of i) {
          let a = s || r.isImportSpecifier() && (r.node.importKind === "type" || r.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", r);
        }
      } else if (e.isExportDeclaration()) {
        let s = e.get("declaration");
        (s.isClassDeclaration() || s.isFunctionDeclaration() || s.isVariableDeclaration()) && this.registerDeclaration(s);
      } else
        this.registerBinding("unknown", e);
    }
    buildUndefinedNode() {
      return hXe();
    }
    registerConstantViolation(e) {
      let s = e.getAssignmentIdentifiers();
      for (let r of Object.keys(s)) {
        var i;
        (i = this.getBinding(r)) == null || i.reassign(e);
      }
    }
    registerBinding(e, s, i = s) {
      if (!e) throw new ReferenceError("no `kind`");
      if (s.isVariableDeclaration()) {
        let o = s.get("declarations");
        for (let l of o)
          this.registerBinding(e, l);
        return;
      }
      let r = this.getProgramParent(), a = s.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        r.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, e, o, l);
          }
          u ? u.reassign(i) : this.bindings[o] = new OYe.default({
            identifier: l,
            scope: this,
            path: i,
            kind: e
          });
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e;
    }
    hasUid(e) {
      let s = this;
      do
        if (s.uids[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasGlobal(e) {
      let s = this;
      do
        if (s.globals[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e];
    }
    isPure(e, s) {
      if (Eh(e)) {
        let o = this.getBinding(e.name);
        return o ? s ? o.constant : !0 : !1;
      } else {
        if (gJ(e) || uXe(e) || bJ(e) || cXe(e))
          return !0;
        if (FYe(e)) {
          var i;
          return e.superClass && !this.isPure(e.superClass, s) || ((i = e.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(e.
          body, s);
        } else if (jYe(e)) {
          for (let o of e.body)
            if (!this.isPure(o, s)) return !1;
          return !0;
        } else {
          if (MYe(e))
            return this.isPure(e.left, s) && this.isPure(e.right, s);
          if (EJ(e) || oXe(e)) {
            for (let o of e.elements)
              if (o !== null && !this.isPure(o, s)) return !1;
            return !0;
          } else if (JYe(e) || aXe(e)) {
            for (let o of e.properties)
              if (!this.isPure(o, s)) return !1;
            return !0;
          } else if (WYe(e)) {
            var r;
            return !(e.computed && !this.isPure(e.key, s) || ((r = e.decorators) == null ? void 0 : r.length) > 0);
          } else if (YYe(e)) {
            var a;
            return !(e.computed && !this.isPure(e.key, s) || ((a = e.decorators) == null ? void 0 : a.length) > 0 || (lXe(e) || e.static) &&
            e.value !== null && !this.isPure(e.value, s));
          } else {
            if (ZYe(e))
              return this.isPure(e.argument, s);
            if (vJ(e)) {
              for (let o of e.expressions)
                if (!this.isPure(o, s)) return !1;
              return !0;
            } else return QYe(e) ? TJ(e.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(e.quasi, s) : VYe(e) ? !e.computed && Eh(e.object) && e.object.name === "Symbol" && Eh(e.property) && e.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : yJ(e) ? TJ(e.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && e.arguments.length === 1 && SJ.isStringLiteral(e.arguments[0]) : XYe(e);
          }
        }
      }
    }
    setData(e, s) {
      return this.data[e] = s;
    }
    getData(e) {
      let s = this;
      do {
        let i = s.data[e];
        if (i != null) return i;
      } while (s = s.parent);
    }
    removeData(e) {
      let s = this;
      do
        s.data[e] != null && (s.data[e] = null);
      while (s = s.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let e = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let s = this;
      do {
        if (s.crawling) return;
        if (s.path.isProgram())
          break;
      } while (s = s.parent);
      let i = s, r = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, e.type !== "Program" && (0, LYe.isExplodedVisitor)(AS)) {
        for (let o of AS.enter)
          o.call(r, e, r);
        let a = AS[e.type];
        if (a)
          for (let o of a.enter)
            o.call(r, e, r);
      }
      e.traverse(AS, r), this.crawling = !1;
      for (let a of r.assignments) {
        let o = a.getAssignmentIdentifiers();
        for (let l of Object.keys(o))
          a.scope.getBinding(l) || i.addGlobal(o[l]);
        a.scope.registerConstantViolation(a);
      }
      for (let a of r.references) {
        let o = a.scope.getBinding(a.node.name);
        o ? o.reference(a) : i.addGlobal(a.node);
      }
      for (let a of r.constantViolations)
        a.scope.registerConstantViolation(a);
    }
    push(e) {
      let s = this.path;
      s.isPattern() ? s = this.getPatternParent().path : !s.isBlockStatement() && !s.isProgram() && (s = this.getBlockParent().path), s.isSwitchStatement() &&
      (s = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: r,
        kind: a = "var",
        id: o
      } = e;
      if (!i && !r && (a === "var" || a === "let") && s.isFunction() && !s.node.name && yJ(s.parent, {
        callee: s.node
      }) && s.parent.arguments.length <= s.node.params.length && Eh(o)) {
        s.pushContainer("params", o), s.scope.registerBinding("param", s.get("params")[s.node.params.length - 1]);
        return;
      }
      (s.isLoop() || s.isCatchClause() || s.isFunction()) && (s.ensureBlock(), s = s.get("body"));
      let l = e._blockHoist == null ? 2 : e._blockHoist, u = `declaration:${a}:${l}`, c = !r && s.getData(u);
      if (!c) {
        let f = rXe(a, []);
        f._blockHoist = l, [c] = s.unshiftContainer("body", [f]), r || s.setData(u, c);
      }
      let p = nXe(o, i), h = c.node.declarations.push(p);
      s.scope.registerBinding(a, c.get("declarations")[h - 1]);
    }
    getProgramParent() {
      let e = this;
      do
        if (e.path.isProgram())
          return e;
      while (e = e.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e = this;
      do
        if (e.path.isFunctionParent())
          return e;
      while (e = e.parent);
      return null;
    }
    getBlockParent() {
      let e = this;
      do
        if (e.path.isBlockParent())
          return e;
      while (e = e.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e = this;
      do
        if (!e.path.isPattern())
          return e.getBlockParent();
      while (e = e.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let e = /* @__PURE__ */ Object.create(null), s = this;
      do {
        for (let i of Object.keys(s.bindings))
          i in e || (e[i] = s.bindings[i]);
        s = s.parent;
      } while (s);
      return e;
    }
    bindingIdentifierEquals(e, s) {
      return this.getBindingIdentifier(e) === s;
    }
    getBinding(e) {
      let s = this, i;
      do {
        let a = s.getOwnBinding(e);
        if (a) {
          var r;
          if (!((r = i) != null && r.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && e === "arguments" && s.path.isFunction() && !s.path.isArrowFunctionExpression())
          break;
        i = s.path;
      } while (s = s.parent);
    }
    getOwnBinding(e) {
      return this.bindings[e];
    }
    getBindingIdentifier(e) {
      var s;
      return (s = this.getBinding(e)) == null ? void 0 : s.identifier;
    }
    getOwnBindingIdentifier(e) {
      let s = this.bindings[e];
      return s?.identifier;
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e);
    }
    hasBinding(e, s) {
      if (!e) return !1;
      let i = this;
      do
        if (i.hasOwnBinding(e))
          return !0;
      while (i = i.parent);
      let r, a;
      return typeof s == "object" ? (r = s.noGlobals, a = s.noUids) : typeof s == "boolean" && (r = s), !!(!a && this.hasUid(e) || !r && t.globals.
      includes(e) || !r && t.contextVariables.includes(e));
    }
    parentHasBinding(e, s) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(e, s);
    }
    moveBindingTo(e, s) {
      let i = this.getBinding(e);
      i && (i.scope.removeOwnBinding(e), i.scope = s, s.bindings[e] = i);
    }
    removeOwnBinding(e) {
      delete this.bindings[e];
    }
    removeBinding(e) {
      var s;
      (s = this.getBinding(e)) == null || s.scope.removeOwnBinding(e);
      let i = this;
      do
        i.uids[e] && (i.uids[e] = !1);
      while (i = i.parent);
    }
    hoistVariables(e = (s) => this.push({
      id: s
    })) {
      this.crawl();
      let s = /* @__PURE__ */ new Set();
      for (let r of Object.keys(this.bindings)) {
        let a = this.bindings[r];
        if (!a) continue;
        let {
          path: o
        } = a;
        if (!o.isVariableDeclarator()) continue;
        let {
          parent: l,
          parentPath: u
        } = o;
        if (l.kind !== "var" || s.has(l)) continue;
        s.add(o.parent);
        let c, p = [];
        for (let h of l.declarations) {
          var i;
          (i = c) != null || (c = h.id), h.init && p.push(BYe("=", h.id, h.init));
          let f = Object.keys(PJ(h, !1, !0, !0));
          for (let d of f)
            e(Ah(d), h.init != null);
        }
        if (u.parentPath.isFor({
          left: l
        }))
          u.replaceWith(c);
        else if (p.length === 0)
          u.remove();
        else {
          let h = p.length === 1 ? p[0] : fXe(p);
          u.parentPath.isForStatement({
            init: l
          }) ? u.replaceWith(h) : u.replaceWith(tXe(h));
        }
      }
    }
  };
  vS.default = Po;
  Po.globals = Object.keys(_Ye.builtin);
  Po.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  Po.prototype._renameFromMap = /* @__PURE__ */ n(function(e, s, i, r) {
    e[s] && (e[i] = r, e[s] = null);
  }, "_renameFromMap"), Po.prototype.traverse = function(t, e, s) {
    (0, DYe.default)(t, e, this, s, this.path);
  }, Po.prototype._generateUid = /* @__PURE__ */ n(function(e, s) {
    let i = e;
    return s > 1 && (i += s), `_${i}`;
  }, "_generateUid"), Po.prototype.toArray = /* @__PURE__ */ n(function(e, s, i) {
    if (Eh(e)) {
      let o = this.getBinding(e.name);
      if (o != null && o.constant && o.path.isGenericType("Array"))
        return e;
    }
    if (EJ(e))
      return e;
    if (Eh(e, {
      name: "arguments"
    }))
      return dJ(VD(VD(VD(Ah("Array"), Ah("prototype")), Ah("slice")), Ah("call")), [e]);
    let r, a = [e];
    return s === !0 ? r = "toConsumableArray" : typeof s == "number" ? (a.push(sXe(s)), r = "slicedToArray") : r = "toArray", i && (a.unshift(
    this.path.hub.addHelper(r)), r = "maybeArrayLike"), dJ(this.path.hub.addHelper(r), a);
  }, "toArray"), Po.prototype.getAllBindingsOfKind = /* @__PURE__ */ n(function(...e) {
    let s = /* @__PURE__ */ Object.create(null);
    for (let i of e) {
      let r = this;
      do {
        for (let a of Object.keys(r.bindings)) {
          let o = r.bindings[a];
          o.kind === i && (s[a] = o);
        }
        r = r.parent;
      } while (r);
    }
    return s;
  }, "getAllBindingsOfKind"), Object.defineProperties(Po.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  });
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/source-map.js
var CJ = g((CS) => {
  "use strict";
  Object.defineProperty(CS, "__esModule", {
    value: !0
  });
  CS.default = void 0;
  var Kc = ch(), $D = Nc(), HD = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, s) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let r = this._map = new Kc.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new $D.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, Kc.setSourceContent)(r, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof s == "string" && !e.inputSourceMap)
        (0, Kc.setSourceContent)(r, this._sourceFileName, s);
      else if (typeof s == "object")
        for (let o of Object.keys(s))
          (0, Kc.setSourceContent)(r, o.replace(/\\/g, "/"), s[o]);
    }
    get() {
      return (0, Kc.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, Kc.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, Kc.allMappings)(this._map));
    }
    mark(e, s, i, r, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (s != null)
        if (this._inputMap) {
          if (u = (0, $D.originalPositionFor)(this._inputMap, {
            line: s,
            column: i
          }), !u.name && a) {
            let c = (0, $D.originalPositionFor)(this._inputMap, a);
            c.name && (r = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: s,
            column: i
          };
      (0, Kc.maybeAddMapping)(this._map, {
        name: r,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  CS.default = HD;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/buffer.js
var wJ = g((wS) => {
  "use strict";
  Object.defineProperty(wS, "__esModule", {
    value: !0
  });
  wS.default = void 0;
  var JD = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, s) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = s;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(s.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let s = 0; s < 16; s++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, s, i, r, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = s, l.line = i, l.column = r, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, s = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = e ? e.get() : null;
          return s.map = i, i;
        },
        set map(i) {
          Object.defineProperty(s, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = e?.getRawMappings();
          return s.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(s, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return s;
    }
    append(e, s) {
      this._flush(), this._append(e, this._sourcePosition, s);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let s = this._sourcePosition;
      this._pushQueue(e, 1, s.line, s.column, s.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, s = this._queue;
      for (let i = 0; i < e; i++) {
        let r = s[i];
        this._appendChar(r.char, r.repeat, r);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, s, i) {
      if (this._last = e, e === -1) {
        let r = this._fastIndentations[s];
        r !== void 0 ? this._str += r : this._str += s > 1 ? this._indentChar.repeat(s) : this._indentChar;
      } else
        this._str += s > 1 ? String.fromCharCode(e).repeat(s) : String.fromCharCode(e);
      e !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += s) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(e, s, i) {
      let r = e.length, a = this._position;
      if (this._last = e.charCodeAt(r - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !i && !this._map) {
        a.column += r;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = s, p = s.line;
      (l != null || u != null) && this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
      let h = e.indexOf(`
`), f = 0;
      for (h !== 0 && this._mark(p, o, l, u, c); h !== -1; )
        a.line++, a.column = 0, f = h + 1, f < r && p !== void 0 && this._mark(++p, 0, null, null, c), h = e.indexOf(`
`, f);
      a.column += r - f;
    }
    _mark(e, s, i, r, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, s, i, r, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, s = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let i = e - 1; i >= 0 && this._queue[i].char === 10; i--)
        s++;
      return s === e && this._last === 10 ? s + 1 : s;
    }
    endsWithCharAndNewline() {
      let e = this._queue, s = this._queueCursor;
      if (s !== 0)
        return e[s - 1].char !== 10 ? void 0 : s > 1 ? e[s - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, s) {
      if (!this._map) {
        s();
        return;
      }
      this.source("start", e);
      let i = e.identifierName, r = this._sourcePosition;
      i && (this._canMarkIdName = !1, r.identifierName = i), s(), i && (this._canMarkIdName = !0, r.identifierName = void 0, r.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, s) {
      this._map && this._normalizePosition(e, s, 0);
    }
    sourceWithOffset(e, s, i) {
      this._map && this._normalizePosition(e, s, i);
    }
    _normalizePosition(e, s, i) {
      let r = s[e], a = this._sourcePosition;
      r && (a.line = r.line, a.column = Math.max(r.column + i, 0), a.filename = s.filename);
    }
    getCurrentColumn() {
      let e = this._queue, s = this._queueCursor, i = -1, r = 0;
      for (let a = 0; a < s; a++) {
        let o = e[a];
        o.char === 10 && (i = r), r += o.repeat;
      }
      return i === -1 ? this._position.column + r : r - 1 - i;
    }
    getCurrentLine() {
      let e = 0, s = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        s[i].char === 10 && e++;
      return this._position.line + e;
    }
  };
  wS.default = JD;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/node/whitespace.js
var OJ = g((NS) => {
  "use strict";
  Object.defineProperty(NS, "__esModule", {
    value: !0
  });
  NS.nodes = void 0;
  var mXe = fe(), {
    FLIPPED_ALIAS_KEYS: yXe,
    isArrayExpression: gXe,
    isAssignmentExpression: NJ,
    isBinary: kJ,
    isBlockStatement: TXe,
    isCallExpression: DJ,
    isFunction: Rg,
    isIdentifier: IS,
    isLiteral: bXe,
    isMemberExpression: YD,
    isObjectExpression: xXe,
    isOptionalCallExpression: SXe,
    isOptionalMemberExpression: PXe,
    isStringLiteral: EXe
  } = mXe;
  function Bd(t, e) {
    return t && (YD(t) || PXe(t) ? (Bd(t.object, e), t.computed && Bd(t.property, e)) : kJ(t) || NJ(t) ? (Bd(t.left, e), Bd(t.right, e)) : DJ(
    t) || SXe(t) ? (e.hasCall = !0, Bd(t.callee, e)) : Rg(t) ? e.hasFunction = !0 : IS(t) && (e.hasHelper = e.hasHelper || t.callee && uu(t.
    callee))), e;
  }
  n(Bd, "crawlInternal");
  function IJ(t) {
    return Bd(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(IJ, "crawl");
  function uu(t) {
    return t ? YD(t) ? uu(t.object) || uu(t.property) : IS(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : DJ(t) ? uu(t.callee) :
    kJ(t) || NJ(t) ? IS(t.left) && uu(t.left) || uu(t.right) : !1 : !1;
  }
  n(uu, "isHelper");
  function AXe(t) {
    return bXe(t) || xXe(t) || gXe(t) || IS(t) || YD(t);
  }
  n(AXe, "isType");
  var vh = NS.nodes = {
    AssignmentExpression(t) {
      let e = IJ(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (Rg(t.left) || Rg(t.right))
        return 2;
    },
    Literal(t) {
      if (EXe(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (Rg(t.callee) || uu(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (Rg(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let s = t.declarations[e], i = uu(s.id) && !AXe(s.init);
        if (!i && s.init) {
          let r = IJ(s.init);
          i = uu(s.init) && r.hasCall || r.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(t) {
      if (TXe(t.consequent))
        return 3;
    }
  };
  vh.ObjectProperty = vh.ObjectTypeProperty = vh.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  vh.ObjectTypeCallProperty = function(t, e) {
    var s;
    if (e.callProperties[0] === t && !((s = e.properties) != null && s.length))
      return 1;
  };
  vh.ObjectTypeIndexer = function(t, e) {
    var s, i;
    if (e.indexers[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length))
      return 1;
  };
  vh.ObjectTypeInternalSlot = function(t, e) {
    var s, i, r;
    if (e.internalSlots[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length) && !((r = e.indexers) !=
    null && r.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(yXe[t] || []).forEach(function(s) {
      let i = e ? 3 : 0;
      vh[s] = () => i;
    });
  });
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/node/parentheses.js
var qJ = g((xs) => {
  "use strict";
  Object.defineProperty(xs, "__esModule", {
    value: !0
  });
  xs.AssignmentExpression = sze;
  xs.Binary = FJ;
  xs.BinaryExpression = zXe;
  xs.ClassExpression = ZXe;
  xs.ArrowFunctionExpression = xs.ConditionalExpression = RJ;
  xs.DoExpression = RXe;
  xs.FunctionExpression = eze;
  xs.FunctionTypeAnnotation = MXe;
  xs.Identifier = rze;
  xs.LogicalExpression = ize;
  xs.NullableTypeAnnotation = BXe;
  xs.ObjectExpression = jXe;
  xs.OptionalIndexedAccessType = UXe;
  xs.OptionalCallExpression = xs.OptionalMemberExpression = tze;
  xs.SequenceExpression = GXe;
  xs.TSSatisfiesExpression = xs.TSAsExpression = KXe;
  xs.TSConditionalType = VXe;
  xs.TSConstructorType = xs.TSFunctionType = XXe;
  xs.TSInferType = HXe;
  xs.TSInstantiationExpression = YXe;
  xs.TSIntersectionType = $Xe;
  xs.UnaryLike = xs.TSTypeAssertion = jJ;
  xs.TSTypeOperator = JXe;
  xs.TSUnionType = WXe;
  xs.IntersectionTypeAnnotation = xs.UnionTypeAnnotation = qXe;
  xs.UpdateExpression = FXe;
  xs.AwaitExpression = xs.YieldExpression = QXe;
  var vXe = fe(), _a = Vc(), {
    isArrayTypeAnnotation: CXe,
    isBinaryExpression: wXe,
    isCallExpression: IXe,
    isForOfStatement: NXe,
    isIndexedAccessType: kXe,
    isMemberExpression: BJ,
    isObjectPattern: DXe,
    isOptionalMemberExpression: OXe,
    isYieldExpression: _Xe,
    isStatement: LXe
  } = vXe, _J = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["\
!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function LJ(t, e) {
    if (e === "BinaryExpression" || e === "LogicalExpression")
      return _J.get(t.operator);
    if (e === "TSAsExpression" || e === "TSSatisfiesExpression")
      return _J.get("in");
  }
  n(LJ, "getBinaryPrecedence");
  function XD(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(XD, "isTSTypeExpression");
  var kS = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "ClassDeclaration" || s === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), DS = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "MemberExpression" || s === "OptionalMemberExpression") && e.object === t || (s === "CallExpression" || s === "OptionalCal\
lExpression" || s === "NewExpression") && e.callee === t || s === "TaggedTemplateExpression" && e.tag === t || s === "TSNonNullExpression";
  }, "hasPostfixPart");
  function BXe(t, e) {
    return CXe(e);
  }
  n(BXe, "NullableTypeAnnotation");
  function MXe(t, e, s) {
    let i = e.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(s & _a.TokenContext.arrowFlowReturnType);
  }
  n(MXe, "FunctionTypeAnnotation");
  function FXe(t, e) {
    return DS(t, e) || kS(t, e);
  }
  n(FXe, "UpdateExpression");
  function MJ(t) {
    return !!(t & (_a.TokenContext.expressionStatement | _a.TokenContext.arrowBody));
  }
  n(MJ, "needsParenBeforeExpressionBrace");
  function jXe(t, e, s) {
    return MJ(s);
  }
  n(jXe, "ObjectExpression");
  function RXe(t, e, s) {
    return !t.async && !!(s & _a.TokenContext.expressionStatement);
  }
  n(RXe, "DoExpression");
  function FJ(t, e) {
    let s = e.type;
    if (t.type === "BinaryExpression" && t.operator === "**" && s === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (kS(t, e) || DS(t, e) || s === "UnaryExpression" || s === "SpreadElement" || s === "AwaitExpression")
      return !0;
    let i = LJ(e, s);
    if (i != null) {
      let r = LJ(t, t.type);
      if (i === r && s === "BinaryExpression" && e.right === t || i > r)
        return !0;
    }
  }
  n(FJ, "Binary");
  function qXe(t, e) {
    let s = e.type;
    return s === "ArrayTypeAnnotation" || s === "NullableTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "UnionTypeAnnotation";
  }
  n(qXe, "UnionTypeAnnotation");
  function UXe(t, e) {
    return kXe(e) && e.objectType === t;
  }
  n(UXe, "OptionalIndexedAccessType");
  function KXe(t, e) {
    return (e.type === "AssignmentExpression" || e.type === "AssignmentPattern") && e.left === t || e.type === "BinaryExpression" && (e.operator ===
    "|" || e.operator === "&") && t === e.left ? !0 : FJ(t, e);
  }
  n(KXe, "TSAsExpression");
  function VXe(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || s === "TSTypeOperator" || s ===
    "TSTypeParameter" || (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t || s === "TSConditionalType" && (e.checkType ===
    t || e.extendsType === t);
  }
  n(VXe, "TSConditionalType");
  function WXe(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t ||
    s === "TSOptionalType";
  }
  n(WXe, "TSUnionType");
  function $Xe(t, e) {
    let s = e.type;
    return s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n($Xe, "TSIntersectionType");
  function HXe(t, e) {
    let s = e.type;
    return !!(s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || t.typeParameter.constraint &&
    (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t);
  }
  n(HXe, "TSInferType");
  function JXe(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n(JXe, "TSTypeOperator");
  function YXe(t, e) {
    let s = e.type;
    return (s === "CallExpression" || s === "OptionalCallExpression" || s === "NewExpression" || s === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(YXe, "TSInstantiationExpression");
  function XXe(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSUnionType" || s === "TSTypeOperator" || s === "TSOptionalType" || s === "TSArrayType" || s ===
    "TSIndexedAccessType" && e.objectType === t || s === "TSConditionalType" && (e.checkType === t || e.extendsType === t);
  }
  n(XXe, "TSFunctionType");
  function zXe(t, e, s, i) {
    return t.operator === "in" && i;
  }
  n(zXe, "BinaryExpression");
  function GXe(t, e) {
    let s = e.type;
    return s === "SequenceExpression" || s === "ParenthesizedExpression" || s === "MemberExpression" && e.property === t || s === "OptionalM\
emberExpression" && e.property === t || s === "TemplateLiteral" ? !1 : s === "ClassDeclaration" ? !0 : s === "ForOfStatement" ? e.right === t :
    s === "ExportDefaultDeclaration" ? !0 : !LXe(e);
  }
  n(GXe, "SequenceExpression");
  function QXe(t, e) {
    let s = e.type;
    return s === "BinaryExpression" || s === "LogicalExpression" || s === "UnaryExpression" || s === "SpreadElement" || DS(t, e) || s === "A\
waitExpression" && _Xe(t) || s === "ConditionalExpression" && t === e.test || kS(t, e) || XD(s);
  }
  n(QXe, "YieldExpression");
  function ZXe(t, e, s) {
    return !!(s & (_a.TokenContext.expressionStatement | _a.TokenContext.exportDefault));
  }
  n(ZXe, "ClassExpression");
  function jJ(t, e) {
    return DS(t, e) || wXe(e) && e.operator === "**" && e.left === t || kS(t, e);
  }
  n(jJ, "UnaryLike");
  function eze(t, e, s) {
    return !!(s & (_a.TokenContext.expressionStatement | _a.TokenContext.exportDefault));
  }
  n(eze, "FunctionExpression");
  function RJ(t, e) {
    let s = e.type;
    return s === "UnaryExpression" || s === "SpreadElement" || s === "BinaryExpression" || s === "LogicalExpression" || s === "ConditionalEx\
pression" && e.test === t || s === "AwaitExpression" || XD(s) ? !0 : jJ(t, e);
  }
  n(RJ, "ConditionalExpression");
  function tze(t, e) {
    return IXe(e) && e.callee === t || BJ(e) && e.object === t;
  }
  n(tze, "OptionalMemberExpression");
  function sze(t, e, s) {
    return MJ(s) && DXe(t.left) ? !0 : RJ(t, e);
  }
  n(sze, "AssignmentExpression");
  function ize(t, e) {
    let s = e.type;
    if (XD(s)) return !0;
    if (s !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(ize, "LogicalExpression");
  function rze(t, e, s, i, r) {
    var a;
    let o = e.type;
    if ((a = t.extra) != null && a.parenthesized && o === "AssignmentExpression" && e.left === t) {
      let l = e.right.type;
      if ((l === "FunctionExpression" || l === "ClassExpression") && e.right.id == null)
        return !0;
    }
    return r && r(t) !== t.name ? !1 : t.name === "let" ? (BJ(e, {
      object: t,
      computed: !0
    }) || OXe(e, {
      object: t,
      computed: !0,
      optional: !1
    })) && s & (_a.TokenContext.expressionStatement | _a.TokenContext.forHead | _a.TokenContext.forInHead) ? !0 : !!(s & _a.TokenContext.forOfHead) :
    t.name === "async" && NXe(e, {
      left: t,
      await: !1
    });
  }
  n(rze, "Identifier");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/node/index.js
var Vc = g((cu) => {
  "use strict";
  Object.defineProperty(cu, "__esModule", {
    value: !0
  });
  cu.TokenContext = void 0;
  cu.isLastChild = xze;
  cu.needsParens = bze;
  cu.needsWhitespace = GD;
  cu.needsWhitespaceAfter = Tze;
  cu.needsWhitespaceBefore = gze;
  var nze = OJ(), aze = qJ(), oze = fe(), {
    FLIPPED_ALIAS_KEYS: lze,
    VISITOR_KEYS: uze,
    isCallExpression: UJ,
    isDecorator: cze,
    isExpressionStatement: pze,
    isMemberExpression: hze,
    isNewExpression: fze,
    isParenthesizedExpression: dze
  } = oze, Kqs = cu.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function KJ(t) {
    let e = /* @__PURE__ */ new Map();
    function s(i, r) {
      let a = e.get(i);
      e.set(i, a ? function(o, l, u, c, p) {
        var h;
        return (h = a(o, l, u, c, p)) != null ? h : r(o, l, u, c, p);
      } : r);
    }
    n(s, "add");
    for (let i of Object.keys(t)) {
      let r = lze[i];
      if (r)
        for (let a of r)
          s(a, t[i]);
      else
        s(i, t[i]);
    }
    return e;
  }
  n(KJ, "expandAliases");
  var mze = KJ(aze), yze = KJ(nze.nodes);
  function VJ(t) {
    return UJ(t) ? !0 : hze(t) && VJ(t.object);
  }
  n(VJ, "isOrHasCallExpression");
  function GD(t, e, s) {
    var i;
    if (!t) return !1;
    pze(t) && (t = t.expression);
    let r = (i = yze.get(t.type)) == null ? void 0 : i(t, e);
    return typeof r == "number" ? (r & s) !== 0 : !1;
  }
  n(GD, "needsWhitespace");
  function gze(t, e) {
    return GD(t, e, 1);
  }
  n(gze, "needsWhitespaceBefore");
  function Tze(t, e) {
    return GD(t, e, 2);
  }
  n(Tze, "needsWhitespaceAfter");
  function bze(t, e, s, i, r) {
    var a;
    return e ? fze(e) && e.callee === t && VJ(t) ? !0 : cze(e) ? !zD(t) && !(UJ(t) && zD(t.callee)) && !dze(t) : (a = mze.get(t.type)) == null ?
    void 0 : a(t, e, s, i, r) : !1;
  }
  n(bze, "needsParens");
  function zD(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && zD(t.object);
      default:
        return !1;
    }
  }
  n(zD, "isDecoratorMemberExpression");
  function xze(t, e) {
    let s = uze[t.type];
    for (let i = s.length - 1; i >= 0; i--) {
      let r = t[s[i]];
      if (r === e)
        return !0;
      if (Array.isArray(r)) {
        let a = r.length - 1;
        for (; a >= 0 && r[a] === null; ) a--;
        return a >= 0 && r[a] === e;
      } else if (r)
        return !1;
    }
    return !1;
  }
  n(xze, "isLastChild");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/token-map.js
var WJ = g((OS) => {
  "use strict";
  Object.defineProperty(OS, "__esModule", {
    value: !0
  });
  OS.TokenMap = void 0;
  var Sze = fe(), {
    traverseFast: Pze,
    VISITOR_KEYS: Eze
  } = Sze, QD = class {
    static {
      n(this, "TokenMap");
    }
    constructor(e, s, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = s, this._source = i, Pze(e, (r) => {
        let a = this._getTokensIndexesOfNode(r);
        a.length > 0 && this._nodesToTokenIndexes.set(r, a);
      }), this._tokensCache = null;
    }
    has(e) {
      return this._nodesToTokenIndexes.has(e);
    }
    getIndexes(e) {
      return this._nodesToTokenIndexes.get(e);
    }
    find(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = 0; r < i.length; r++) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return o;
        }
      return null;
    }
    findLastIndex(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = i.length - 1; r >= 0; r--) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return a;
        }
      return -1;
    }
    findMatching(e, s, i = 0) {
      let r = this._nodesToTokenIndexes.get(e);
      if (r) {
        let a = 0, o = i;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(e);
          l && l.test === s && l.count < o && (a = l.i + 1, i -= l.count + 1);
        }
        for (; a < r.length; a++) {
          let l = this._tokens[r[a]];
          if (this.matchesOriginal(l, s)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(e, {
                test: s,
                count: o,
                i: a
              }), l;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(e, s) {
      return e.end - e.start !== s.length ? !1 : e.value != null ? e.value === s : this._source.startsWith(s, e.start);
    }
    startMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[0]];
      return r.start !== e.start ? !1 : this.matchesOriginal(r, s);
    }
    endMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[i.length - 1]];
      return r.end !== e.end ? !1 : this.matchesOriginal(r, s);
    }
    _getTokensIndexesOfNode(e) {
      if (e.start == null || e.end == null) return [];
      let {
        first: s,
        last: i
      } = this._findTokensOfNode(e, 0, this._tokens.length - 1), r = s, a = Aze(e);
      (e.type === "ExportNamedDeclaration" || e.type === "ExportDefaultDeclaration") && e.declaration && e.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, r, i), c = u.first;
        for (let p = r; p < c; p++) o.push(p);
        r = u.last + 1;
      }
      for (let l = r; l <= i; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(e, s, i) {
      let r = this._tokensCache.get(e);
      if (r) return r;
      let a = this._findFirstTokenOfNode(e.start, s, i), o = this._findLastTokenOfNode(e.end, a, i);
      return this._tokensCache.set(e, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].start)
          i = r - 1;
        else if (e > this._tokens[r].start)
          s = r + 1;
        else
          return r;
      }
      return s;
    }
    _findLastTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].end)
          i = r - 1;
        else if (e > this._tokens[r].end)
          s = r + 1;
        else
          return r;
      }
      return i;
    }
  };
  OS.TokenMap = QD;
  function* Aze(t) {
    if (t.type === "TemplateLiteral") {
      yield t.quasis[0];
      for (let s = 1; s < t.quasis.length; s++)
        yield t.expressions[s - 1], yield t.quasis[s];
      return;
    }
    let e = Eze[t.type];
    for (let s of e) {
      let i = t[s];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  n(Aze, "childrenIterator");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/template-literals.js
var $J = g((Md) => {
  "use strict";
  Object.defineProperty(Md, "__esModule", {
    value: !0
  });
  Md.TaggedTemplateExpression = vze;
  Md.TemplateElement = Cze;
  Md.TemplateLiteral = Ize;
  Md._printTemplate = wze;
  function vze(t) {
    this.print(t.tag), this.print(t.typeParameters), this.print(t.quasi);
  }
  n(vze, "TaggedTemplateExpression");
  function Cze() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(Cze, "TemplateElement");
  function wze(t, e) {
    let s = t.quasis, i = "`";
    for (let r = 0; r < s.length - 1; r++)
      if (i += s[r].value.raw, this.token(i + "${", !0), this.print(e[r]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(t, "}", r);
        a && this._catchUpTo(a.loc.start);
      }
    i += s[s.length - 1].value.raw, this.token(i + "`", !0);
  }
  n(wze, "_printTemplate");
  function Ize(t) {
    this._printTemplate(t, t.expressions);
  }
  n(Ize, "TemplateLiteral");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/expressions.js
var JJ = g((ci) => {
  "use strict";
  Object.defineProperty(ci, "__esModule", {
    value: !0
  });
  ci.LogicalExpression = ci.BinaryExpression = ci.AssignmentExpression = eGe;
  ci.AssignmentPattern = Zze;
  ci.AwaitExpression = Xze;
  ci.BindExpression = tGe;
  ci.CallExpression = Jze;
  ci.ConditionalExpression = jze;
  ci.Decorator = Wze;
  ci.DoExpression = Bze;
  ci.EmptyStatement = Gze;
  ci.ExpressionStatement = Qze;
  ci.Import = Yze;
  ci.MemberExpression = sGe;
  ci.MetaProperty = iGe;
  ci.ModuleExpression = aGe;
  ci.NewExpression = Rze;
  ci.OptionalCallExpression = Hze;
  ci.OptionalMemberExpression = $ze;
  ci.ParenthesizedExpression = Mze;
  ci.PrivateName = rGe;
  ci.SequenceExpression = qze;
  ci.Super = Kze;
  ci.ThisExpression = Uze;
  ci.UnaryExpression = Lze;
  ci.UpdateExpression = Fze;
  ci.V8IntrinsicIdentifier = nGe;
  ci.YieldExpression = zze;
  ci._shouldPrintDecoratorsBeforeExport = Vze;
  var Nze = fe(), kze = Vc(), {
    isCallExpression: Dze,
    isLiteral: HJ,
    isMemberExpression: ZD,
    isNewExpression: Oze,
    isPattern: _ze
  } = Nze;
  function Lze(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument);
  }
  n(Lze, "UnaryExpression");
  function Bze(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body);
  }
  n(Bze, "DoExpression");
  function Mze(t) {
    this.tokenChar(40);
    let e = this.enterDelimited();
    this.print(t.expression), e(), this.rightParens(t);
  }
  n(Mze, "ParenthesizedExpression");
  function Fze(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument)) : (this.print(t.argument, !0), this.token(t.operator));
  }
  n(Fze, "UpdateExpression");
  function jze(t) {
    this.print(t.test), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(t.alternate);
  }
  n(jze, "ConditionalExpression");
  function Rze(t, e) {
    if (this.word("new"), this.space(), this.print(t.callee), this.format.minified && t.arguments.length === 0 && !t.optional && !Dze(e, {
      callee: t
    }) && !ZD(e) && !Oze(e) || (this.print(t.typeArguments), this.print(t.typeParameters), t.optional && this.token("?."), t.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(t, ")")))
      return;
    this.tokenChar(40);
    let s = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), s(), this.rightParens(t);
  }
  n(Rze, "NewExpression");
  function qze(t) {
    this.printList(t.expressions);
  }
  n(qze, "SequenceExpression");
  function Uze() {
    this.word("this");
  }
  n(Uze, "ThisExpression");
  function Kze() {
    this.word("super");
  }
  n(Kze, "Super");
  function Vze(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(Vze, "_shouldPrintDecoratorsBeforeExport");
  function Wze(t) {
    this.tokenChar(64), this.print(t.expression), this.newline();
  }
  n(Wze, "Decorator");
  function $ze(t) {
    let {
      computed: e
    } = t, {
      optional: s,
      property: i
    } = t;
    if (this.print(t.object), !e && ZD(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    HJ(i) && typeof i.value == "number" && (e = !0), s && this.token("?."), e ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (s ||
    this.tokenChar(46), this.print(i));
  }
  n($ze, "OptionalMemberExpression");
  function Hze(t) {
    this.print(t.callee), this.print(t.typeParameters), t.optional && this.token("?."), this.print(t.typeArguments), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments), e(), this.rightParens(t);
  }
  n(Hze, "OptionalCallExpression");
  function Jze(t) {
    this.print(t.callee), this.print(t.typeArguments), this.print(t.typeParameters), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), e(), this.rightParens(t);
  }
  n(Jze, "CallExpression");
  function Yze() {
    this.word("import");
  }
  n(Yze, "Import");
  function Xze(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument));
  }
  n(Xze, "AwaitExpression");
  function zze(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument))) : t.argument && (this.space(),
    this.printTerminatorless(t.argument));
  }
  n(zze, "YieldExpression");
  function Gze() {
    this.semicolon(!0);
  }
  n(Gze, "EmptyStatement");
  function Qze(t) {
    this.tokenContext |= kze.TokenContext.expressionStatement, this.print(t.expression), this.semicolon();
  }
  n(Qze, "ExpressionStatement");
  function Zze(t) {
    this.print(t.left), (t.left.type === "Identifier" || _ze(t.left)) && (t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(t.right);
  }
  n(Zze, "AssignmentPattern");
  function eGe(t) {
    this.print(t.left), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) : (this.token(t.operator), this.
    _endsWithDiv = t.operator === "/"), this.space(), this.print(t.right);
  }
  n(eGe, "AssignmentExpression");
  function tGe(t) {
    this.print(t.object), this.token("::"), this.print(t.callee);
  }
  n(tGe, "BindExpression");
  function sGe(t) {
    if (this.print(t.object), !t.computed && ZD(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    if (HJ(t.property) && typeof t.property.value == "number" && (e = !0), e) {
      let s = this.enterDelimited();
      this.tokenChar(91), this.print(t.property), this.tokenChar(93), s();
    } else
      this.tokenChar(46), this.print(t.property);
  }
  n(sGe, "MemberExpression");
  function iGe(t) {
    this.print(t.meta), this.tokenChar(46), this.print(t.property);
  }
  n(iGe, "MetaProperty");
  function rGe(t) {
    this.tokenChar(35), this.print(t.id);
  }
  n(rGe, "PrivateName");
  function nGe(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(nGe, "V8IntrinsicIdentifier");
  function aGe(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e), this.dedent(), this.rightBrace(t);
  }
  n(aGe, "ModuleExpression");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/statements.js
var GJ = g((Gi) => {
  "use strict";
  Object.defineProperty(Gi, "__esModule", {
    value: !0
  });
  Gi.BreakStatement = yGe;
  Gi.CatchClause = PGe;
  Gi.ContinueStatement = gGe;
  Gi.DebuggerStatement = vGe;
  Gi.DoWhileStatement = mGe;
  Gi.ForOfStatement = Gi.ForInStatement = void 0;
  Gi.ForStatement = fGe;
  Gi.IfStatement = hGe;
  Gi.LabeledStatement = xGe;
  Gi.ReturnStatement = TGe;
  Gi.SwitchCase = AGe;
  Gi.SwitchStatement = EGe;
  Gi.ThrowStatement = bGe;
  Gi.TryStatement = SGe;
  Gi.VariableDeclaration = CGe;
  Gi.VariableDeclarator = wGe;
  Gi.WhileStatement = dGe;
  Gi.WithStatement = pGe;
  var oGe = fe(), eO = Vc(), {
    isFor: YJ,
    isForStatement: lGe,
    isIfStatement: uGe,
    isStatement: cGe
  } = oGe;
  function pGe(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object), this.tokenChar(41), this.printBlock(t);
  }
  n(pGe, "WithStatement");
  function hGe(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.space();
    let e = t.alternate && uGe(XJ(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate));
  }
  n(hGe, "IfStatement");
  function XJ(t) {
    let {
      body: e
    } = t;
    return cGe(e) === !1 ? t : XJ(e);
  }
  n(XJ, "getLastStatement");
  function fGe(t) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let e = this.enterForStatementInit();
      this.tokenContext |= eO.TokenContext.forHead, this.print(t.init), e();
    }
    this.tokenChar(59), t.test && (this.space(), this.print(t.test)), this.token(";", !1, 1), t.update && (this.space(), this.print(t.update)),
    this.tokenChar(41), this.printBlock(t);
  }
  n(fGe, "ForStatement");
  function dGe(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.printBlock(t);
  }
  n(dGe, "WhileStatement");
  function zJ(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let s = e ? null : this.enterForStatementInit();
      this.tokenContext |= e ? eO.TokenContext.forOfHead : eO.TokenContext.forInHead, this.print(t.left), s?.();
    }
    this.space(), this.word(e ? "of" : "in"), this.space(), this.print(t.right), this.tokenChar(41), this.printBlock(t);
  }
  n(zJ, "ForXStatement");
  var Gqs = Gi.ForInStatement = zJ, Qqs = Gi.ForOfStatement = zJ;
  function mGe(t) {
    this.word("do"), this.space(), this.print(t.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test),
    this.tokenChar(41), this.semicolon();
  }
  n(mGe, "DoWhileStatement");
  function _S(t, e) {
    e && (t.space(), t.printTerminatorless(e)), t.semicolon();
  }
  n(_S, "printStatementAfterKeyword");
  function yGe(t) {
    this.word("break"), _S(this, t.label);
  }
  n(yGe, "BreakStatement");
  function gGe(t) {
    this.word("continue"), _S(this, t.label);
  }
  n(gGe, "ContinueStatement");
  function TGe(t) {
    this.word("return"), _S(this, t.argument);
  }
  n(TGe, "ReturnStatement");
  function bGe(t) {
    this.word("throw"), _S(this, t.argument);
  }
  n(bGe, "ThrowStatement");
  function xGe(t) {
    this.print(t.label), this.tokenChar(58), this.space(), this.print(t.body);
  }
  n(xGe, "LabeledStatement");
  function SGe(t) {
    this.word("try"), this.space(), this.print(t.block), this.space(), t.handlers ? this.print(t.handlers[0]) : this.print(t.handler), t.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(t.finalizer));
  }
  n(SGe, "TryStatement");
  function PGe(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param), this.print(t.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(t.body);
  }
  n(PGe, "CatchClause");
  function EGe(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, !0, void 0, /* @__PURE__ */ n(function(s, i) {
      if (!s && t.cases[t.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(t);
  }
  n(EGe, "SwitchStatement");
  function AGe(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, !0));
  }
  n(AGe, "SwitchCase");
  function vGe() {
    this.word("debugger"), this.semicolon();
  }
  n(vGe, "DebuggerStatement");
  function CGe(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: s
    } = t;
    s === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(s, s === "using"), this.space();
    let i = !1;
    if (!YJ(e))
      for (let r of t.declarations)
        r.init && (i = !0);
    if (this.printList(t.declarations, void 0, void 0, t.declarations.length > 1, i ? function(r) {
      this.token(",", !1, r), this.newline();
    } : void 0), YJ(e)) {
      if (lGe(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(CGe, "VariableDeclaration");
  function wGe(t) {
    this.print(t.id), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation), t.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(t.init));
  }
  n(wGe, "VariableDeclarator");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/classes.js
var QJ = g((La) => {
  "use strict";
  Object.defineProperty(La, "__esModule", {
    value: !0
  });
  La.ClassAccessorProperty = BGe;
  La.ClassBody = OGe;
  La.ClassExpression = La.ClassDeclaration = DGe;
  La.ClassMethod = FGe;
  La.ClassPrivateMethod = jGe;
  La.ClassPrivateProperty = MGe;
  La.ClassProperty = LGe;
  La.StaticBlock = qGe;
  La._classMethodHead = RGe;
  var IGe = fe(), {
    isExportDefaultDeclaration: NGe,
    isExportNamedDeclaration: kGe
  } = IGe;
  function DGe(t, e) {
    (!(NGe(e) || kGe(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id)), this.print(
    t.typeParameters), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass), this.print(t.superTypeParameters)),
    t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements)), this.space(), this.print(t.body);
  }
  n(DGe, "ClassDeclaration");
  function OGe(t) {
    if (this.tokenChar(123), t.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let e = _Ge(this, t);
      e?.(-1);
      let s = this.enterDelimited();
      this.printJoin(t.body, !0, !0, e, !0), s(), this.endsWith(10) || this.newline(), this.rightBrace(t);
    }
  }
  n(OGe, "ClassBody");
  function _Ge(t, e) {
    if (!t.tokenMap || e.start == null || e.end == null)
      return null;
    let s = t.tokenMap.getIndexes(e);
    if (!s) return null;
    let i = 1, r = 0, a = 0, o = /* @__PURE__ */ n(() => {
      for (; a < e.body.length && e.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === e.body.length ? e.end : e.body[a].start, c;
      for (; i < s.length && t.tokenMap.matchesOriginal(c = t._tokens[s[i]], ";") && c.start < u; )
        t.token(";", void 0, r++), i++;
    };
  }
  n(_Ge, "classBodyEmptySemicolonsPrinter");
  function LGe(t) {
    if (this.printJoin(t.decorators), !t.static && !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key), this.tokenChar(93)) : (this._variance(t), this.
    print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(LGe, "ClassProperty");
  function BGe(t) {
    var e;
    this.printJoin(t.decorators);
    let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    s && this.catchUp(s), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key), this.tokenChar(93)) : (this._variance(t), this.print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(BGe, "ClassAccessorProperty");
  function MGe(t) {
    this.printJoin(t.decorators), this.tsPrintClassMemberModifiers(t), this.print(t.key), t.optional && this.tokenChar(63), t.definite && this.
    tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(MGe, "ClassPrivateProperty");
  function FGe(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(FGe, "ClassMethod");
  function jGe(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(jGe, "ClassPrivateMethod");
  function RGe(t) {
    if (this.printJoin(t.decorators), !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(RGe, "_classMethodHead");
  function qGe(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, !0), this.rightBrace(t));
  }
  n(qGe, "StaticBlock");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/methods.js
var ZJ = g((Ba) => {
  "use strict";
  Object.defineProperty(Ba, "__esModule", {
    value: !0
  });
  Ba.ArrowFunctionExpression = GGe;
  Ba.FunctionDeclaration = Ba.FunctionExpression = zGe;
  Ba._functionHead = XGe;
  Ba._methodHead = JGe;
  Ba._param = HGe;
  Ba._parameters = $Ge;
  Ba._params = WGe;
  Ba._predicate = YGe;
  Ba._shouldPrintArrowParamsParens = QGe;
  var UGe = fe(), KGe = Vc(), {
    isIdentifier: VGe
  } = UGe;
  function WGe(t, e, s) {
    this.print(t.typeParameters);
    let i = ZGe.call(this, e, s);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(t.params, ")");
    let r = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, r), this._noLineTerminator = r;
  }
  n(WGe, "_params");
  function $Ge(t, e) {
    let s = this.enterDelimited(), i = this.shouldPrintTrailingComma(e), r = t.length;
    for (let a = 0; a < r; a++)
      this._param(t[a]), (i || a < r - 1) && (this.token(",", null, a), this.space());
    this.token(e), s();
  }
  n($Ge, "_parameters");
  function HGe(t) {
    this.printJoin(t.decorators), this.print(t), t.optional && this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(HGe, "_param");
  function JGe(t) {
    let e = t.kind, s = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(s), this.tokenChar(93)) : this.print(s), t.optional &&
    this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(JGe, "_methodHead");
  function YGe(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, e));
  }
  n(YGe, "_predicate");
  function XGe(t, e) {
    t.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), t.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), t.id && this.print(t.id), this._params(
    t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(t);
  }
  n(XGe, "_functionHead");
  function zGe(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body);
  }
  n(zGe, "FunctionExpression");
  function GGe(t, e) {
    t.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(t) ? this._params(t, void 0, e) : this.print(t.params[0],
    !0), this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= KGe.TokenContext.
    arrowBody, this.print(t.body);
  }
  n(GGe, "ArrowFunctionExpression");
  function QGe(t) {
    var e, s;
    if (t.params.length !== 1 || t.typeParameters || t.returnType || t.predicate)
      return !0;
    let i = t.params[0];
    if (!VGe(i) || i.typeAnnotation || i.optional || (e = i.leadingComments) != null && e.length || (s = i.trailingComments) != null && s.length)
      return !0;
    if (this.tokenMap) {
      if (t.loc == null || this.tokenMap.findMatching(t, "(") !== null) return !0;
      let r = this.tokenMap.findMatching(t, "=>");
      return r?.loc == null ? !0 : r.loc.start.line !== t.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  n(QGe, "_shouldPrintArrowParamsParens");
  function ZGe(t, e) {
    let s = t;
    if (!s && e) {
      let u = e.type;
      u === "VariableDeclarator" ? s = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? s = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (s = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (s = e.key);
    }
    if (!s) return;
    let i;
    if (s.type === "Identifier") {
      var r, a;
      i = {
        pos: (r = s.loc) == null ? void 0 : r.start,
        name: ((a = s.loc) == null ? void 0 : a.identifierName) || s.name
      };
    } else if (s.type === "PrivateName") {
      var o;
      i = {
        pos: (o = s.loc) == null ? void 0 : o.start,
        name: "#" + s.id.name
      };
    } else if (s.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = s.loc) == null ? void 0 : l.start,
        name: s.value
      };
    }
    return i;
  }
  n(ZGe, "_getFuncIdName");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/modules.js
var tO = g((En) => {
  "use strict";
  Object.defineProperty(En, "__esModule", {
    value: !0
  });
  En.ExportAllDeclaration = fQe;
  En.ExportDefaultDeclaration = mQe;
  En.ExportDefaultSpecifier = uQe;
  En.ExportNamedDeclaration = dQe;
  En.ExportNamespaceSpecifier = pQe;
  En.ExportSpecifier = cQe;
  En.ImportAttribute = gQe;
  En.ImportDeclaration = yQe;
  En.ImportDefaultSpecifier = lQe;
  En.ImportExpression = bQe;
  En.ImportNamespaceSpecifier = TQe;
  En.ImportSpecifier = oQe;
  En._printAttributes = hQe;
  var eQe = fe(), tQe = Vc(), {
    isClassDeclaration: sQe,
    isExportDefaultSpecifier: iQe,
    isExportNamespaceSpecifier: rQe,
    isImportDefaultSpecifier: nQe,
    isImportNamespaceSpecifier: aQe,
    isStatement: tY
  } = eQe;
  function oQe(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported), t.local && t.
    local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local));
  }
  n(oQe, "ImportSpecifier");
  function lQe(t) {
    this.print(t.local);
  }
  n(lQe, "ImportDefaultSpecifier");
  function uQe(t) {
    this.print(t.exported);
  }
  n(uQe, "ExportDefaultSpecifier");
  function cQe(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported));
  }
  n(cQe, "ExportSpecifier");
  function pQe(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported);
  }
  n(pQe, "ExportNamespaceSpecifier");
  var eY = !1;
  function hQe(t, e) {
    var s;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: r,
      assertions: a
    } = t;
    r && !i && t.extra && (t.extra.deprecatedAssertSyntax || t.extra.deprecatedWithLegacySyntax) && !eY && (eY = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (s = t.extra) != null && s.deprecatedWithLegacySyntax)) {
      this.printList(r || a);
      return;
    }
    let l = e ? 1 : 0;
    this.token("{", null, l), this.space(), this.printList(r || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, l);
  }
  n(hQe, "_printAttributes");
  function fQe(t) {
    var e, s;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0),
    this.space(), this._printAttributes(t, !1)) : this.print(t.source), this.semicolon();
  }
  n(fQe, "ExportAllDeclaration");
  function sY(t, e) {
    sQe(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators);
  }
  n(sY, "maybePrintDecoratorsBeforeExport");
  function dQe(t) {
    if (sY(this, t), this.word("export"), this.space(), t.declaration) {
      let i = t.declaration;
      this.print(i), tY(i) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let i = t.specifiers.slice(0), r = !1;
      for (; ; ) {
        let o = i[0];
        if (iQe(o) || rQe(o))
          r = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !r) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), t.source) {
        var e, s;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.
        print(t.source, !0), this.space(), this._printAttributes(t, a)) : this.print(t.source);
      }
      this.semicolon();
    }
  }
  n(dQe, "ExportNamedDeclaration");
  function mQe(t) {
    sY(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    tQe.TokenContext.exportDefault;
    let e = t.declaration;
    this.print(e), tY(e) || this.semicolon();
  }
  n(mQe, "ExportDefaultDeclaration");
  function yQe(t) {
    var e, s;
    this.word("import"), this.space();
    let i = t.importKind === "type" || t.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let r = t.specifiers.slice(0), a = !!r.length;
    for (; a; ) {
      let l = r[0];
      if (nQe(l) || aQe(l))
        this.print(r.shift()), r.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    r.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(r, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (e =
    t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0), this.space(), this._printAttributes(
    t, o)) : this.print(t.source), this.semicolon();
  }
  n(yQe, "ImportDeclaration");
  function gQe(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(gQe, "ImportAttribute");
  function TQe(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local);
  }
  n(TQe, "ImportNamespaceSpecifier");
  function bQe(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options)), this.tokenChar(41);
  }
  n(bQe, "ImportExpression");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/types.js
var iO = g((_i) => {
  "use strict";
  Object.defineProperty(_i, "__esModule", {
    value: !0
  });
  _i.ArgumentPlaceholder = AQe;
  _i.ArrayPattern = _i.ArrayExpression = NQe;
  _i.BigIntLiteral = FQe;
  _i.BooleanLiteral = _Qe;
  _i.Identifier = EQe;
  _i.NullLiteral = LQe;
  _i.NumericLiteral = BQe;
  _i.ObjectPattern = _i.ObjectExpression = CQe;
  _i.ObjectMethod = wQe;
  _i.ObjectProperty = IQe;
  _i.PipelineBareFunction = qQe;
  _i.PipelinePrimaryTopicReference = UQe;
  _i.PipelineTopicExpression = RQe;
  _i.RecordExpression = kQe;
  _i.RegExpLiteral = OQe;
  _i.SpreadElement = _i.RestElement = vQe;
  _i.StringLiteral = MQe;
  _i.TopicReference = jQe;
  _i.TupleExpression = DQe;
  _i._getRawIdentifier = PQe;
  var xQe = fe(), nY = gd(), {
    isAssignmentPattern: SQe,
    isIdentifier: sO
  } = xQe, iY = null, LS = "";
  function PQe(t) {
    if (t === iY) return LS;
    iY = t;
    let {
      name: e
    } = t, s = this.tokenMap.find(t, (i) => i.value === e);
    return s ? (LS = this._originalCode.slice(s.start, s.end), LS) : LS = t.name;
  }
  n(PQe, "_getRawIdentifier");
  function EQe(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(this.tokenMap ? this._getRawIdentifier(
    t) : t.name);
  }
  n(EQe, "Identifier");
  function AQe() {
    this.tokenChar(63);
  }
  n(AQe, "ArgumentPlaceholder");
  function vQe(t) {
    this.token("..."), this.print(t.argument);
  }
  n(vQe, "RestElement");
  function CQe(t) {
    let e = t.properties;
    if (this.tokenChar(123), e.length) {
      let s = this.enterDelimited();
      this.space(), this.printList(e, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), s();
    }
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(CQe, "ObjectExpression");
  function wQe(t) {
    this.printJoin(t.decorators), this._methodHead(t), this.space(), this.print(t.body);
  }
  n(wQe, "ObjectMethod");
  function IQe(t) {
    if (this.printJoin(t.decorators), t.computed)
      this.tokenChar(91), this.print(t.key), this.tokenChar(93);
    else {
      if (SQe(t.value) && sO(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value);
        return;
      }
      if (this.print(t.key), t.shorthand && sO(t.key) && sO(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(IQe, "ObjectProperty");
  function NQe(t) {
    let e = t.elements, s = e.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let r = 0; r < e.length; r++) {
      let a = e[r];
      a ? (r > 0 && this.space(), this.print(a), (r < s - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, r)) : this.token("\
,", !1, r);
    }
    i(), this.tokenChar(93);
  }
  n(NQe, "ArrayExpression");
  function kQe(t) {
    let e = t.properties, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      s = "#{", i = "}";
    }
    this.token(s), e.length && (this.space(), this.printList(e, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  n(kQe, "RecordExpression");
  function DQe(t) {
    let e = t.elements, s = e.length, i, r;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", r = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", r = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o), (a < s - 1 || this.shouldPrintTrailingComma(r)) && this.token(",", !1, a));
    }
    this.token(r);
  }
  n(DQe, "TupleExpression");
  function OQe(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(OQe, "RegExpLiteral");
  function _Qe(t) {
    this.word(t.value ? "true" : "false");
  }
  n(_Qe, "BooleanLiteral");
  function LQe() {
    this.word("null");
  }
  n(LQe, "NullLiteral");
  function BQe(t) {
    let e = this.getPossibleRaw(t), s = this.format.jsescOption, i = t.value, r = i + "";
    s.numbers ? this.number(nY(i, s), i) : e == null ? this.number(r, i) : this.format.minified ? this.number(e.length < r.length ? e : r, i) :
    this.number(e, i);
  }
  n(BQe, "NumericLiteral");
  function MQe(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let s = nY(t.value, this.format.jsescOption);
    this.token(s);
  }
  n(MQe, "StringLiteral");
  function FQe(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(FQe, "BigIntLiteral");
  var rY = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function jQe() {
    let {
      topicToken: t
    } = this.format;
    if (rY.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), s = Array.from(rY, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${s.join(", ")} (${e} received instead).`);
    }
  }
  n(jQe, "TopicReference");
  function RQe(t) {
    this.print(t.expression);
  }
  n(RQe, "PipelineTopicExpression");
  function qQe(t) {
    this.print(t.callee);
  }
  n(qQe, "PipelineBareFunction");
  function UQe() {
    this.tokenChar(35);
  }
  n(UQe, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/flow.js
var oY = g((it) => {
  "use strict";
  Object.defineProperty(it, "__esModule", {
    value: !0
  });
  it.AnyTypeAnnotation = HQe;
  it.ArrayTypeAnnotation = JQe;
  it.BooleanLiteralTypeAnnotation = XQe;
  it.BooleanTypeAnnotation = YQe;
  it.DeclareClass = GQe;
  it.DeclareExportAllDeclaration = lZe;
  it.DeclareExportDeclaration = oZe;
  it.DeclareFunction = QQe;
  it.DeclareInterface = tZe;
  it.DeclareModule = sZe;
  it.DeclareModuleExports = iZe;
  it.DeclareOpaqueType = nZe;
  it.DeclareTypeAlias = rZe;
  it.DeclareVariable = aZe;
  it.DeclaredPredicate = eZe;
  it.EmptyTypeAnnotation = kZe;
  it.EnumBooleanBody = cZe;
  it.EnumBooleanMember = mZe;
  it.EnumDeclaration = uZe;
  it.EnumDefaultedMember = dZe;
  it.EnumNumberBody = pZe;
  it.EnumNumberMember = yZe;
  it.EnumStringBody = hZe;
  it.EnumStringMember = gZe;
  it.EnumSymbolBody = fZe;
  it.ExistsTypeAnnotation = bZe;
  it.FunctionTypeAnnotation = xZe;
  it.FunctionTypeParam = SZe;
  it.IndexedAccessType = tet;
  it.InferredPredicate = ZQe;
  it.InterfaceDeclaration = vZe;
  it.GenericTypeAnnotation = it.ClassImplements = it.InterfaceExtends = PZe;
  it.InterfaceTypeAnnotation = wZe;
  it.IntersectionTypeAnnotation = IZe;
  it.MixedTypeAnnotation = NZe;
  it.NullLiteralTypeAnnotation = zQe;
  it.NullableTypeAnnotation = DZe;
  Object.defineProperty(it, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aY.NumericLiteral;
    }, "get")
  });
  it.NumberTypeAnnotation = OZe;
  it.ObjectTypeAnnotation = KZe;
  it.ObjectTypeCallProperty = WZe;
  it.ObjectTypeIndexer = $Ze;
  it.ObjectTypeInternalSlot = VZe;
  it.ObjectTypeProperty = HZe;
  it.ObjectTypeSpreadProperty = JZe;
  it.OpaqueType = UZe;
  it.OptionalIndexedAccessType = set;
  it.QualifiedTypeIdentifier = YZe;
  Object.defineProperty(it, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aY.StringLiteral;
    }, "get")
  });
  it.StringTypeAnnotation = _Ze;
  it.SymbolTypeAnnotation = XZe;
  it.ThisTypeAnnotation = LZe;
  it.TupleTypeAnnotation = BZe;
  it.TypeAlias = FZe;
  it.TypeAnnotation = jZe;
  it.TypeCastExpression = QZe;
  it.TypeParameter = qZe;
  it.TypeParameterDeclaration = it.TypeParameterInstantiation = RZe;
  it.TypeofTypeAnnotation = MZe;
  it.UnionTypeAnnotation = GZe;
  it.Variance = ZZe;
  it.VoidTypeAnnotation = eet;
  it._interfaceish = EZe;
  it._variance = AZe;
  var KQe = fe(), VQe = tO(), WQe = Vc(), aY = iO(), {
    isDeclareExportDeclaration: BS,
    isStatement: $Qe
  } = KQe;
  function HQe() {
    this.word("any");
  }
  n(HQe, "AnyTypeAnnotation");
  function JQe(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(JQe, "ArrayTypeAnnotation");
  function YQe() {
    this.word("boolean");
  }
  n(YQe, "BooleanTypeAnnotation");
  function XQe(t) {
    this.word(t.value ? "true" : "false");
  }
  n(XQe, "BooleanLiteralTypeAnnotation");
  function zQe() {
    this.word("null");
  }
  n(zQe, "NullLiteralTypeAnnotation");
  function GQe(t, e) {
    BS(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(GQe, "DeclareClass");
  function QQe(t, e) {
    BS(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation.typeAnnotation),
    t.predicate && (this.space(), this.print(t.predicate)), this.semicolon();
  }
  n(QQe, "DeclareFunction");
  function ZQe() {
    this.tokenChar(37), this.word("checks");
  }
  n(ZQe, "InferredPredicate");
  function eZe(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value), this.tokenChar(41);
  }
  n(eZe, "DeclaredPredicate");
  function tZe(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(tZe, "DeclareInterface");
  function sZe(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id), this.space(), this.print(t.body);
  }
  n(sZe, "DeclareModule");
  function iZe(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation);
  }
  n(iZe, "DeclareModuleExports");
  function rZe(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(rZe, "DeclareTypeAlias");
  function nZe(t, e) {
    BS(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(nZe, "DeclareOpaqueType");
  function aZe(t, e) {
    BS(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation), this.semicolon();
  }
  n(aZe, "DeclareVariable");
  function oZe(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), TZe.call(this,
    t);
  }
  n(oZe, "DeclareExportDeclaration");
  function lZe(t) {
    this.word("declare"), this.space(), VQe.ExportAllDeclaration.call(this, t);
  }
  n(lZe, "DeclareExportAllDeclaration");
  function uZe(t) {
    let {
      id: e,
      body: s
    } = t;
    this.word("enum"), this.space(), this.print(e), this.print(s);
  }
  n(uZe, "EnumDeclaration");
  function MS(t, e, s) {
    s && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(MS, "enumExplicitType");
  function FS(t, e) {
    let {
      members: s
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let i of s)
      t.print(i), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(FS, "enumBody");
  function cZe(t) {
    let {
      explicitType: e
    } = t;
    MS(this, "boolean", e), FS(this, t);
  }
  n(cZe, "EnumBooleanBody");
  function pZe(t) {
    let {
      explicitType: e
    } = t;
    MS(this, "number", e), FS(this, t);
  }
  n(pZe, "EnumNumberBody");
  function hZe(t) {
    let {
      explicitType: e
    } = t;
    MS(this, "string", e), FS(this, t);
  }
  n(hZe, "EnumStringBody");
  function fZe(t) {
    MS(this, "symbol", !0), FS(this, t);
  }
  n(fZe, "EnumSymbolBody");
  function dZe(t) {
    let {
      id: e
    } = t;
    this.print(e), this.tokenChar(44);
  }
  n(dZe, "EnumDefaultedMember");
  function rO(t, e) {
    t.print(e.id), t.space(), t.token("="), t.space(), t.print(e.init), t.token(",");
  }
  n(rO, "enumInitializedMember");
  function mZe(t) {
    rO(this, t);
  }
  n(mZe, "EnumBooleanMember");
  function yZe(t) {
    rO(this, t);
  }
  n(yZe, "EnumNumberMember");
  function gZe(t) {
    rO(this, t);
  }
  n(gZe, "EnumStringMember");
  function TZe(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e), $Qe(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source)), this.semicolon();
  }
  n(TZe, "FlowExportDeclaration");
  function bZe() {
    this.tokenChar(42);
  }
  n(bZe, "ExistsTypeAnnotation");
  function xZe(t, e) {
    this.print(t.typeParameters), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation),
    (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params), t.rest && (t.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(t.rest)), this.tokenChar(41);
    let s = e?.type;
    s != null && (s === "ObjectTypeCallProperty" || s === "ObjectTypeInternalSlot" || s === "DeclareFunction" || s === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType);
  }
  n(xZe, "FunctionTypeAnnotation");
  function SZe(t) {
    this.print(t.name), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation);
  }
  n(SZe, "FunctionTypeParam");
  function PZe(t) {
    this.print(t.id), this.print(t.typeParameters, !0);
  }
  n(PZe, "InterfaceExtends");
  function EZe(t) {
    var e;
    if (this.print(t.id), this.print(t.typeParameters), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(),
    this.printList(t.extends)), t.type === "DeclareClass") {
      var s, i;
      (s = t.mixins) != null && s.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins)), (i = t.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements));
    }
    this.space(), this.print(t.body);
  }
  n(EZe, "_interfaceish");
  function AZe(t) {
    var e;
    let s = (e = t.variance) == null ? void 0 : e.kind;
    s != null && (s === "plus" ? this.tokenChar(43) : s === "minus" && this.tokenChar(45));
  }
  n(AZe, "_variance");
  function vZe(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(vZe, "InterfaceDeclaration");
  function CZe(t) {
    this.space(), this.token("&", !1, t), this.space();
  }
  n(CZe, "andSeparator");
  function wZe(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends)),
    this.space(), this.print(t.body);
  }
  n(wZe, "InterfaceTypeAnnotation");
  function IZe(t) {
    this.printJoin(t.types, void 0, void 0, CZe);
  }
  n(IZe, "IntersectionTypeAnnotation");
  function NZe() {
    this.word("mixed");
  }
  n(NZe, "MixedTypeAnnotation");
  function kZe() {
    this.word("empty");
  }
  n(kZe, "EmptyTypeAnnotation");
  function DZe(t) {
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(DZe, "NullableTypeAnnotation");
  function OZe() {
    this.word("number");
  }
  n(OZe, "NumberTypeAnnotation");
  function _Ze() {
    this.word("string");
  }
  n(_Ze, "StringTypeAnnotation");
  function LZe() {
    this.word("this");
  }
  n(LZe, "ThisTypeAnnotation");
  function BZe(t) {
    this.tokenChar(91), this.printList(t.types), this.tokenChar(93);
  }
  n(BZe, "TupleTypeAnnotation");
  function MZe(t) {
    this.word("typeof"), this.space(), this.print(t.argument);
  }
  n(MZe, "TypeofTypeAnnotation");
  function FZe(t) {
    this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    t.right), this.semicolon();
  }
  n(FZe, "TypeAlias");
  function jZe(t, e) {
    this.tokenChar(58), this.space(), e.type === "ArrowFunctionExpression" ? this.tokenContext |= WQe.TokenContext.arrowFlowReturnType : t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(jZe, "TypeAnnotation");
  function RZe(t) {
    this.tokenChar(60), this.printList(t.params), this.tokenChar(62);
  }
  n(RZe, "TypeParameterInstantiation");
  function qZe(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default));
  }
  n(qZe, "TypeParameter");
  function UZe(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), t.supertype && (this.
    tokenChar(58), this.space(), this.print(t.supertype)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(t.impltype)),
    this.semicolon();
  }
  n(UZe, "OpaqueType");
  function KZe(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, !0, !0, void 0, void 0, /* @__PURE__ */ n(function(i) {
      if (i && !e[0]) return 1;
    }, "addNewlines"), () => {
      (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(KZe, "ObjectTypeAnnotation");
  function VZe(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value);
  }
  n(VZe, "ObjectTypeInternalSlot");
  function WZe(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value);
  }
  n(WZe, "ObjectTypeCallProperty");
  function $Ze(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id), this.tokenChar(58), this.
    space()), this.print(t.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n($Ze, "ObjectTypeIndexer");
  function HZe(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58),
    this.space()), this.print(t.value);
  }
  n(HZe, "ObjectTypeProperty");
  function JZe(t) {
    this.token("..."), this.print(t.argument);
  }
  n(JZe, "ObjectTypeSpreadProperty");
  function YZe(t) {
    this.print(t.qualification), this.tokenChar(46), this.print(t.id);
  }
  n(YZe, "QualifiedTypeIdentifier");
  function XZe() {
    this.word("symbol");
  }
  n(XZe, "SymbolTypeAnnotation");
  function zZe(t) {
    this.space(), this.token("|", !1, t), this.space();
  }
  n(zZe, "orSeparator");
  function GZe(t) {
    this.printJoin(t.types, void 0, void 0, zZe);
  }
  n(GZe, "UnionTypeAnnotation");
  function QZe(t) {
    this.tokenChar(40), this.print(t.expression), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(QZe, "TypeCastExpression");
  function ZZe(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(ZZe, "Variance");
  function eet() {
    this.word("void");
  }
  n(eet, "VoidTypeAnnotation");
  function tet(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(tet, "IndexedAccessType");
  function set(t) {
    this.print(t.objectType), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(set, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/base.js
var lY = g((pu) => {
  "use strict";
  Object.defineProperty(pu, "__esModule", {
    value: !0
  });
  pu.BlockStatement = net;
  pu.Directive = aet;
  pu.DirectiveLiteral = cet;
  pu.File = iet;
  pu.InterpreterDirective = pet;
  pu.Placeholder = het;
  pu.Program = ret;
  function iet(t) {
    t.program && this.print(t.program.interpreter), this.print(t.program);
  }
  n(iet, "File");
  function ret(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let s = (e = t.directives) == null ? void 0 : e.length;
    if (s) {
      var i;
      let r = t.body.length ? 2 : 1;
      this.printSequence(t.directives, void 0, r), (i = t.directives[s - 1].trailingComments) != null && i.length || this.newline(r);
    }
    this.printSequence(t.body);
  }
  n(ret, "Program");
  function net(t) {
    var e;
    this.tokenChar(123);
    let s = this.enterDelimited(), i = (e = t.directives) == null ? void 0 : e.length;
    if (i) {
      var r;
      let a = t.body.length ? 2 : 1;
      this.printSequence(t.directives, !0, a), (r = t.directives[i - 1].trailingComments) != null && r.length || this.newline(a);
    }
    this.printSequence(t.body, !0), s(), this.rightBrace(t);
  }
  n(net, "BlockStatement");
  function aet(t) {
    this.print(t.value), this.semicolon();
  }
  n(aet, "Directive");
  var oet = /(?:^|[^\\])(?:\\\\)*'/, uet = /(?:^|[^\\])(?:\\\\)*"/;
  function cet(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: s
    } = t;
    if (!uet.test(s))
      this.token(`"${s}"`);
    else if (!oet.test(s))
      this.token(`'${s}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(cet, "DirectiveLiteral");
  function pet(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(pet, "InterpreterDirective");
  function het(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(het, "Placeholder");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/jsx.js
var uY = g((Kr) => {
  "use strict";
  Object.defineProperty(Kr, "__esModule", {
    value: !0
  });
  Kr.JSXAttribute = fet;
  Kr.JSXClosingElement = vet;
  Kr.JSXClosingFragment = Net;
  Kr.JSXElement = Pet;
  Kr.JSXEmptyExpression = Cet;
  Kr.JSXExpressionContainer = Tet;
  Kr.JSXFragment = wet;
  Kr.JSXIdentifier = det;
  Kr.JSXMemberExpression = yet;
  Kr.JSXNamespacedName = met;
  Kr.JSXOpeningElement = Aet;
  Kr.JSXOpeningFragment = Iet;
  Kr.JSXSpreadAttribute = get;
  Kr.JSXSpreadChild = bet;
  Kr.JSXText = xet;
  function fet(t) {
    this.print(t.name), t.value && (this.tokenChar(61), this.print(t.value));
  }
  n(fet, "JSXAttribute");
  function det(t) {
    this.word(t.name);
  }
  n(det, "JSXIdentifier");
  function met(t) {
    this.print(t.namespace), this.tokenChar(58), this.print(t.name);
  }
  n(met, "JSXNamespacedName");
  function yet(t) {
    this.print(t.object), this.tokenChar(46), this.print(t.property);
  }
  n(yet, "JSXMemberExpression");
  function get(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument), this.rightBrace(t);
  }
  n(get, "JSXSpreadAttribute");
  function Tet(t) {
    this.tokenChar(123), this.print(t.expression), this.rightBrace(t);
  }
  n(Tet, "JSXExpressionContainer");
  function bet(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression), this.rightBrace(t);
  }
  n(bet, "JSXSpreadChild");
  function xet(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(xet, "JSXText");
  function Pet(t) {
    let e = t.openingElement;
    if (this.print(e), !e.selfClosing) {
      this.indent();
      for (let s of t.children)
        this.print(s);
      this.dedent(), this.print(t.closingElement);
    }
  }
  n(Pet, "JSXElement");
  function Eet() {
    this.space();
  }
  n(Eet, "spaceSeparator");
  function Aet(t) {
    this.tokenChar(60), this.print(t.name), t.typeArguments && this.print(t.typeArguments), this.print(t.typeParameters), t.attributes.length >
    0 && (this.space(), this.printJoin(t.attributes, void 0, void 0, Eet)), t.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  n(Aet, "JSXOpeningElement");
  function vet(t) {
    this.tokenChar(60), this.tokenChar(47), this.print(t.name), this.tokenChar(62);
  }
  n(vet, "JSXClosingElement");
  function Cet() {
    this.printInnerComments();
  }
  n(Cet, "JSXEmptyExpression");
  function wet(t) {
    this.print(t.openingFragment), this.indent();
    for (let e of t.children)
      this.print(e);
    this.dedent(), this.print(t.closingFragment);
  }
  n(wet, "JSXFragment");
  function Iet() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(Iet, "JSXOpeningFragment");
  function Net() {
    this.token("</"), this.tokenChar(62);
  }
  n(Net, "JSXClosingFragment");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/typescript.js
var dY = g((Xe) => {
  "use strict";
  Object.defineProperty(Xe, "__esModule", {
    value: !0
  });
  Xe.TSAnyKeyword = Vet;
  Xe.TSArrayType = ctt;
  Xe.TSSatisfiesExpression = Xe.TSAsExpression = Ntt;
  Xe.TSBigIntKeyword = Wet;
  Xe.TSBooleanKeyword = Yet;
  Xe.TSCallSignatureDeclaration = Fet;
  Xe.TSInterfaceHeritage = Xe.TSClassImplements = vtt;
  Xe.TSConditionalType = gtt;
  Xe.TSConstructSignatureDeclaration = jet;
  Xe.TSConstructorType = rtt;
  Xe.TSDeclareFunction = Let;
  Xe.TSDeclareMethod = Bet;
  Xe.TSEnumBody = fY;
  Xe.TSEnumDeclaration = Ott;
  Xe.TSEnumMember = _tt;
  Xe.TSExportAssignment = qtt;
  Xe.TSExternalModuleReference = jtt;
  Xe.TSFunctionType = itt;
  Xe.TSImportEqualsDeclaration = Ftt;
  Xe.TSImportType = Mtt;
  Xe.TSIndexSignature = Ket;
  Xe.TSIndexedAccessType = Stt;
  Xe.TSInferType = Ttt;
  Xe.TSInstantiationExpression = Dtt;
  Xe.TSInterfaceBody = wtt;
  Xe.TSInterfaceDeclaration = Ctt;
  Xe.TSIntersectionType = ytt;
  Xe.TSIntrinsicKeyword = ttt;
  Xe.TSLiteralType = Att;
  Xe.TSMappedType = Ptt;
  Xe.TSMethodSignature = Uet;
  Xe.TSModuleBlock = Btt;
  Xe.TSModuleDeclaration = Ltt;
  Xe.TSNamedTupleMember = dtt;
  Xe.TSNamespaceExportDeclaration = Utt;
  Xe.TSNeverKeyword = ett;
  Xe.TSNonNullExpression = Rtt;
  Xe.TSNullKeyword = Zet;
  Xe.TSNumberKeyword = Het;
  Xe.TSObjectKeyword = Jet;
  Xe.TSOptionalType = htt;
  Xe.TSParameterProperty = _et;
  Xe.TSParenthesizedType = btt;
  Xe.TSPropertySignature = Ret;
  Xe.TSQualifiedName = Met;
  Xe.TSRestType = ftt;
  Xe.TSStringKeyword = Xet;
  Xe.TSSymbolKeyword = zet;
  Xe.TSTemplateLiteralType = Ett;
  Xe.TSThisType = stt;
  Xe.TSTupleType = ptt;
  Xe.TSTypeAliasDeclaration = Itt;
  Xe.TSTypeAnnotation = ket;
  Xe.TSTypeAssertion = ktt;
  Xe.TSTypeLiteral = utt;
  Xe.TSTypeOperator = xtt;
  Xe.TSTypeParameter = Oet;
  Xe.TSTypeParameterDeclaration = Xe.TSTypeParameterInstantiation = Det;
  Xe.TSTypePredicate = ott;
  Xe.TSTypeQuery = ltt;
  Xe.TSTypeReference = att;
  Xe.TSUndefinedKeyword = Qet;
  Xe.TSUnionType = mtt;
  Xe.TSUnknownKeyword = $et;
  Xe.TSVoidKeyword = Get;
  Xe.tsPrintClassMemberModifiers = Vtt;
  Xe.tsPrintFunctionOrConstructorType = ntt;
  Xe.tsPrintPropertyOrMethodName = qet;
  Xe.tsPrintSignatureDeclarationBase = Ktt;
  function ket(t, e) {
    this.token((e.type === "TSFunctionType" || e.type === "TSConstructorType") && e.typeAnnotation === t ? "=>" : ":"), this.space(), t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(ket, "TSTypeAnnotation");
  function Det(t, e) {
    this.tokenChar(60);
    let s = e.type === "ArrowFunctionExpression" && t.params.length === 1;
    this.tokenMap && t.start != null && t.end != null && (s && (s = !!this.tokenMap.find(t, (i) => this.tokenMap.matchesOriginal(i, ","))), s ||
    (s = this.shouldPrintTrailingComma(">"))), this.printList(t.params, s), this.tokenChar(62);
  }
  n(Det, "TSTypeParameterInstantiation");
  function Oet(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.default));
  }
  n(Oet, "TSTypeParameter");
  function _et(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(_et, "TSParameterProperty");
  function Let(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.semicolon();
  }
  n(Let, "TSDeclareFunction");
  function Bet(t) {
    this._classMethodHead(t), this.semicolon();
  }
  n(Bet, "TSDeclareMethod");
  function Met(t) {
    this.print(t.left), this.tokenChar(46), this.print(t.right);
  }
  n(Met, "TSQualifiedName");
  function Fet(t) {
    this.tsPrintSignatureDeclarationBase(t), qg(this, t);
  }
  n(Fet, "TSCallSignatureDeclaration");
  function qg(t, e) {
    if (!t.tokenMap || !e.start || !e.end) {
      t.semicolon();
      return;
    }
    t.tokenMap.endMatches(e, ",") ? t.token(",") : t.tokenMap.endMatches(e, ";") && t.semicolon();
  }
  n(qg, "maybePrintTrailingCommaOrSemicolon");
  function jet(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), qg(this, t);
  }
  n(jet, "TSConstructSignatureDeclaration");
  function Ret(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation), qg(this, t);
  }
  n(Ret, "TSPropertySignature");
  function qet(t) {
    t.computed && this.tokenChar(91), this.print(t.key), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(qet, "tsPrintPropertyOrMethodName");
  function Uet(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), qg(this, t);
  }
  n(Uet, "TSMethodSignature");
  function Ket(t) {
    let {
      readonly: e,
      static: s
    } = t;
    s && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    "]"), this.print(t.typeAnnotation), qg(this, t);
  }
  n(Ket, "TSIndexSignature");
  function Vet() {
    this.word("any");
  }
  n(Vet, "TSAnyKeyword");
  function Wet() {
    this.word("bigint");
  }
  n(Wet, "TSBigIntKeyword");
  function $et() {
    this.word("unknown");
  }
  n($et, "TSUnknownKeyword");
  function Het() {
    this.word("number");
  }
  n(Het, "TSNumberKeyword");
  function Jet() {
    this.word("object");
  }
  n(Jet, "TSObjectKeyword");
  function Yet() {
    this.word("boolean");
  }
  n(Yet, "TSBooleanKeyword");
  function Xet() {
    this.word("string");
  }
  n(Xet, "TSStringKeyword");
  function zet() {
    this.word("symbol");
  }
  n(zet, "TSSymbolKeyword");
  function Get() {
    this.word("void");
  }
  n(Get, "TSVoidKeyword");
  function Qet() {
    this.word("undefined");
  }
  n(Qet, "TSUndefinedKeyword");
  function Zet() {
    this.word("null");
  }
  n(Zet, "TSNullKeyword");
  function ett() {
    this.word("never");
  }
  n(ett, "TSNeverKeyword");
  function ttt() {
    this.word("intrinsic");
  }
  n(ttt, "TSIntrinsicKeyword");
  function stt() {
    this.word("this");
  }
  n(stt, "TSThisType");
  function itt(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(itt, "TSFunctionType");
  function rtt(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(rtt, "TSConstructorType");
  function ntt(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")"), this.space();
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(ntt, "tsPrintFunctionOrConstructorType");
  function att(t) {
    let e = t.typeParameters;
    this.print(t.typeName, !!e), this.print(e);
  }
  n(att, "TSTypeReference");
  function ott(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(ott, "TSTypePredicate");
  function ltt(t) {
    this.word("typeof"), this.space(), this.print(t.exprName);
    let e = t.typeParameters;
    e && this.print(e);
  }
  n(ltt, "TSTypeQuery");
  function utt(t) {
    jS(this, t, () => this.printJoin(t.members, !0, !0));
  }
  n(utt, "TSTypeLiteral");
  function ctt(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(ctt, "TSArrayType");
  function ptt(t) {
    this.tokenChar(91), this.printList(t.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  n(ptt, "TSTupleType");
  function htt(t) {
    this.print(t.typeAnnotation), this.tokenChar(63);
  }
  n(htt, "TSOptionalType");
  function ftt(t) {
    this.token("..."), this.print(t.typeAnnotation);
  }
  n(ftt, "TSRestType");
  function dtt(t) {
    this.print(t.label), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType);
  }
  n(dtt, "TSNamedTupleMember");
  function mtt(t) {
    hY(this, t, "|");
  }
  n(mtt, "TSUnionType");
  function ytt(t) {
    hY(this, t, "&");
  }
  n(ytt, "TSIntersectionType");
  function hY(t, e, s) {
    var i;
    let r = 0;
    (i = t.tokenMap) != null && i.startMatches(e, s) && (r = 1, t.token(s)), t.printJoin(e.types, void 0, void 0, function(a) {
      this.space(), this.token(s, null, a + r), this.space();
    });
  }
  n(hY, "tsPrintUnionOrIntersectionType");
  function gtt(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(gtt, "TSConditionalType");
  function Ttt(t) {
    this.word("infer"), this.print(t.typeParameter);
  }
  n(Ttt, "TSInferType");
  function btt(t) {
    this.tokenChar(40), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(btt, "TSParenthesizedType");
  function xtt(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation);
  }
  n(xtt, "TSTypeOperator");
  function Stt(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(Stt, "TSIndexedAccessType");
  function Ptt(t) {
    let {
      nameType: e,
      optional: s,
      readonly: i,
      typeAnnotation: r
    } = t;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (cY(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(t.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(t.typeParameter.constraint), e && (this.space(), this.word("as"), this.space(), this.print(e)),
    this.tokenChar(93), s && (cY(this, s), this.tokenChar(63)), r && (this.tokenChar(58), this.space(), this.print(r)), this.space(), a(), this.
    tokenChar(125);
  }
  n(Ptt, "TSMappedType");
  function cY(t, e) {
    e !== !0 && t.token(e);
  }
  n(cY, "tokenIfPlusMinus");
  function Ett(t) {
    this._printTemplate(t, t.types);
  }
  n(Ett, "TSTemplateLiteralType");
  function Att(t) {
    this.print(t.literal);
  }
  n(Att, "TSLiteralType");
  function vtt(t) {
    this.print(t.expression), this.print(t.typeArguments);
  }
  n(vtt, "TSClassImplements");
  function Ctt(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      extends: r,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(s), this.print(i), r != null && r.length && (this.
    space(), this.word("extends"), this.space(), this.printList(r)), this.space(), this.print(a);
  }
  n(Ctt, "TSInterfaceDeclaration");
  function wtt(t) {
    jS(this, t, () => this.printJoin(t.body, !0, !0));
  }
  n(wtt, "TSInterfaceBody");
  function Itt(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      typeAnnotation: r
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(s), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(r), this.semicolon();
  }
  n(Itt, "TSTypeAliasDeclaration");
  function Ntt(t) {
    let {
      type: e,
      expression: s,
      typeAnnotation: i
    } = t;
    this.print(s, !0), this.space(), this.word(e === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  n(Ntt, "TSTypeExpression");
  function ktt(t) {
    let {
      typeAnnotation: e,
      expression: s
    } = t;
    this.tokenChar(60), this.print(e), this.tokenChar(62), this.space(), this.print(s);
  }
  n(ktt, "TSTypeAssertion");
  function Dtt(t) {
    this.print(t.expression), this.print(t.typeParameters);
  }
  n(Dtt, "TSInstantiationExpression");
  function Ott(t) {
    let {
      declare: e,
      const: s,
      id: i
    } = t;
    e && (this.word("declare"), this.space()), s && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), fY.call(this, t);
  }
  n(Ott, "TSEnumDeclaration");
  function fY(t) {
    jS(this, t, () => {
      var e;
      return this.printList(t.members, (e = this.shouldPrintTrailingComma("}")) != null ? e : !0, !0, !0);
    });
  }
  n(fY, "TSEnumBody");
  function _tt(t) {
    let {
      id: e,
      initializer: s
    } = t;
    this.print(e), s && (this.space(), this.tokenChar(61), this.space(), this.print(s));
  }
  n(_tt, "TSEnumMember");
  function Ltt(t) {
    let {
      declare: e,
      id: s,
      kind: i
    } = t;
    e && (this.word("declare"), this.space());
    {
      if (t.global || (this.word(i ?? (s.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(s), !t.body) {
        this.semicolon();
        return;
      }
      let r = t.body;
      for (; r.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(r.id), r = r.body;
      this.space(), this.print(r);
    }
  }
  n(Ltt, "TSModuleDeclaration");
  function Btt(t) {
    jS(this, t, () => this.printSequence(t.body, !0));
  }
  n(Btt, "TSModuleBlock");
  function Mtt(t) {
    let {
      argument: e,
      qualifier: s,
      options: i
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), s && (this.tokenChar(
    46), this.print(s));
    let r = t.typeParameters;
    r && this.print(r);
  }
  n(Mtt, "TSImportType");
  function Ftt(t) {
    let {
      id: e,
      moduleReference: s
    } = t;
    t.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(e), this.space(), this.tokenChar(61), this.
    space(), this.print(s), this.semicolon();
  }
  n(Ftt, "TSImportEqualsDeclaration");
  function jtt(t) {
    this.token("require("), this.print(t.expression), this.tokenChar(41);
  }
  n(jtt, "TSExternalModuleReference");
  function Rtt(t) {
    this.print(t.expression), this.tokenChar(33);
  }
  n(Rtt, "TSNonNullExpression");
  function qtt(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression), this.semicolon();
  }
  n(qtt, "TSExportAssignment");
  function Utt(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id), this.semicolon();
  }
  n(Utt, "TSNamespaceExportDeclaration");
  function Ktt(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")");
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(Ktt, "tsPrintSignatureDeclarationBase");
  function Vtt(t) {
    let e = t.type === "ClassPrivateProperty", s = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    pY(this, t, [s && t.declare && "declare", !e && t.accessibility]), t.static && (this.word("static"), this.space()), pY(this, t, [!e && t.
    abstract && "abstract", !e && t.override && "override", (s || e) && t.readonly && "readonly"]);
  }
  n(Vtt, "tsPrintClassMemberModifiers");
  function jS(t, e, s) {
    t.token("{");
    let i = t.enterDelimited();
    s(), i(), t.rightBrace(e);
  }
  n(jS, "printBraced");
  function pY(t, e, s) {
    var i;
    let r = /* @__PURE__ */ new Set();
    for (let a of s)
      a && r.add(a);
    (i = t.tokenMap) == null || i.find(e, (a) => {
      if (r.has(a.value))
        return t.token(a.value), t.space(), r.delete(a.value), r.size === 0;
    });
    for (let a of r)
      t.word(a), t.space();
  }
  n(pY, "printModifiersList");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/index.js
var mY = g((ks) => {
  "use strict";
  Object.defineProperty(ks, "__esModule", {
    value: !0
  });
  var nO = $J();
  Object.keys(nO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === nO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return nO[t];
      }, "get")
    });
  });
  var aO = JJ();
  Object.keys(aO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === aO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return aO[t];
      }, "get")
    });
  });
  var oO = GJ();
  Object.keys(oO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === oO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return oO[t];
      }, "get")
    });
  });
  var lO = QJ();
  Object.keys(lO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === lO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return lO[t];
      }, "get")
    });
  });
  var uO = ZJ();
  Object.keys(uO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === uO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return uO[t];
      }, "get")
    });
  });
  var cO = tO();
  Object.keys(cO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === cO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return cO[t];
      }, "get")
    });
  });
  var pO = iO();
  Object.keys(pO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === pO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return pO[t];
      }, "get")
    });
  });
  var hO = oY();
  Object.keys(hO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === hO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return hO[t];
      }, "get")
    });
  });
  var fO = lY();
  Object.keys(fO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === fO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return fO[t];
      }, "get")
    });
  });
  var dO = uY();
  Object.keys(dO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === dO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return dO[t];
      }, "get")
    });
  });
  var mO = dY();
  Object.keys(mO).forEach(function(t) {
    t === "default" || t === "__esModule" || t in ks && ks[t] === mO[t] || Object.defineProperty(ks, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return mO[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/generators/deprecated.js
var yY = g((yO) => {
  "use strict";
  Object.defineProperty(yO, "__esModule", {
    value: !0
  });
  yO.addDeprecatedGenerators = Wtt;
  function Wtt(t) {
    {
      let e = {
        Noop() {
        },
        TSExpressionWithTypeArguments(s) {
          this.print(s.expression), this.print(s.typeParameters);
        },
        DecimalLiteral(s) {
          let i = this.getPossibleRaw(s);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(s.value + "m");
        }
      };
      Object.assign(t.prototype, e);
    }
  }
  n(Wtt, "addDeprecatedGenerators");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/printer.js
var xY = g((RS) => {
  "use strict";
  Object.defineProperty(RS, "__esModule", {
    value: !0
  });
  RS.default = void 0;
  var $tt = wJ(), TY = Vc(), Htt = fe(), Jtt = WJ(), Ytt = mY(), Xtt = yY(), {
    isExpression: ztt,
    isFunction: Gtt,
    isStatement: Qtt,
    isClassBody: Ztt,
    isTSInterfaceBody: est,
    isTSEnumMember: tst
  } = Htt, sst = /e/i, ist = /\.0+$/, bY = /[\n\r\u2028\u2029]/, rst = /[\n\r\u2028\u2029]|\*\//;
  function gY(t) {
    return t.type === "CommentLine" || bY.test(t.value);
  }
  n(gY, "commentIsNewline");
  var {
    needsParens: nst
  } = TY, Ug = class {
    static {
      n(this, "Printer");
    }
    constructor(e, s, i, r) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e,
      this._tokens = i, this._originalCode = r, this._indentRepeat = e.indent.style.length, this._inputMap = s?._inputMap, this._buf = new $tt.
      default(s, e.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let e = this.inForStatementInit, s = this._noLineTerminatorAfterNode;
      return e === !1 && s === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = e, this._noLineTerminatorAfterNode = s;
      });
    }
    generate(e) {
      return this.format.preserveFormat && (this.tokenMap = new Jtt.TokenMap(e, this._tokens, this._originalCode)), this.print(e), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent++;
    }
    dedent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent--;
    }
    semicolon(e = !1) {
      if (this._maybeAddAuxComment(), e) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let s = this._currentNode;
        if (s.start != null && s.end != null) {
          if (!this.tokenMap.endMatches(s, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      let {
        format: s
      } = this;
      if (!(s.compact || s.preserveFormat)) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(e, s = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(e), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e), (this.
      _endsWithWord || this._endsWithDiv && e.charCodeAt(0) === 47) && this._space(), this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator =
      s;
    }
    number(e, s) {
      function i(r) {
        if (r.length > 2 && r.charCodeAt(0) === 48) {
          let a = r.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(i, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(s) && !i(e) && !sst.test(e) && !ist.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, s = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(e, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e,
      i);
      let r = this.getLastChar(), a = e.charCodeAt(0);
      (r === 33 && (e === "--" || a === 61) || a === 43 && r === 43 || a === 45 && r === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(e, s), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this.tokenContext = 0;
      let s = String.fromCharCode(e);
      this._maybePrintInnerComments(s), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(s);
      let i = this.getLastChar();
      (e === 43 && i === 43 || e === 45 && i === 45 || e === 46 && this._endsWithInteger) && this._space(), this._appendChar(e), this._noLineTerminator =
      !1;
    }
    newline(e = 1, s) {
      if (!(e <= 0)) {
        if (!s) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let i = 0; i < e; i++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, s) {
      if (!e) {
        s();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, s);
    }
    source(e, s) {
      s && (this._catchUp(e, s), this._buf.source(e, s));
    }
    sourceWithOffset(e, s, i) {
      !s || this.format.preserveFormat || (this._catchUp(e, s), this._buf.sourceWithOffset(e, s, i));
    }
    sourceIdentifierName(e, s) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = s, i.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(e, s = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, e, s);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(e, s) {
      this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, s), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(e) {
      this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(e) {
      this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let s = e - this._buf.getCurrentLine();
      for (let i = 0; i < s; i++)
        this._newline();
    }
    _catchUp(e, s) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && s != null && s[e] && this.catchUp(s[e].line);
        return;
      }
      let r = s?.[e];
      r != null && this._catchUpTo(r);
    }
    _catchUpTo({
      line: e,
      column: s,
      index: i
    }) {
      let r = e - this._buf.getCurrentLine();
      if (r > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < r; o++)
        this._newline();
      let a = r > 0 ? s : s - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e) {
      this._noLineTerminator = !0, this.print(e);
    }
    print(e, s, i) {
      var r, a, o;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let l = e.type, u = this.format, c = u.concise;
      e._compact && (u.concise = !0);
      let p = this[l];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(e.constructor.name)}`);
      let h = this._currentNode;
      this._currentNode = e, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let f = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !f);
      let d = (r = e.extra) == null ? void 0 : r.parenthesized, y = d && u.preserveFormat || d && u.retainFunctionParens && l === "FunctionE\
xpression" || nst(e, h, this.tokenContext, this.inForStatementInit, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!y && d && (a = e.leadingComments) != null && a.length && e.leadingComments[0].type === "CommentBlock")
        switch (h?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (h.callee !== e) break;
          default:
            y = !0;
        }
      let m = !1;
      !y && this._noLineTerminator && ((o = e.leadingComments) != null && o.some(gY) || this.format.retainLines && e.loc && e.loc.start.line >
      this._buf.getCurrentLine()) && (y = !0, m = !0);
      let T, b;
      if (!y && (s || (s = h && this._noLineTerminatorAfterNode === h && TY.isLastChild(h, e)), s)) {
        var E;
        (E = e.trailingComments) != null && E.some(gY) ? ztt(e) && (y = !0) : (T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        e);
      }
      y && (this.tokenChar(40), m && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (b = !0, this.inForStatementInit =
      !1), T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      e, h);
      let w = l === "Program" || l === "File" ? null : e.loc;
      this.exactSource(w, p.bind(this, e, h)), y ? (this._printTrailingComments(e, h), m && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = s, b && (this.inForStatementInit = !0)) : s && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(e, h)) : this._printTrailingComments(e, h, i), this._currentNode = h, u.concise = c, this._insideAux = f, T !==
      void 0 && (this._noLineTerminatorAfterNode = T), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let s = e.extra;
      if (s?.raw != null && s.rawValue != null && e.value === s.rawValue)
        return s.raw;
    }
    printJoin(e, s, i, r, a, o, l, u) {
      if (!(e != null && e.length)) return;
      if (i == null && this.format.retainLines) {
        var c;
        let m = (c = e[0].loc) == null ? void 0 : c.start.line;
        m != null && m !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let p = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, h = r?.bind(this), f = e.length;
      for (let m = 0; m < f; m++) {
        let T = e[m];
        if (T && (s && this._printNewline(m === 0, p), this.print(T, void 0, u || 0), l?.(T, m), h != null && (m < f - 1 ? h(m, !1) : a && h(
        m, !0)), s)) {
          var d;
          if ((d = T.trailingComments) != null && d.length || (this._lastCommentLine = 0), m + 1 === f)
            this.newline(1);
          else {
            var y;
            let b = e[m + 1];
            p.nextNodeStartLine = ((y = b.loc) == null ? void 0 : y.start.line) || 0, this._printNewline(!0, p);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e), s && this.dedent();
    }
    printBlock(e) {
      let s = e.body;
      s.type !== "EmptyStatement" && this.space(), this.print(s);
    }
    _printTrailingComments(e, s, i) {
      let {
        innerComments: r,
        trailingComments: a
      } = e;
      r != null && r.length && this._printComments(2, r, e, s, i), a != null && a.length && this._printComments(2, a, e, s, i);
    }
    _printLeadingComments(e, s) {
      let i = e.leadingComments;
      i != null && i.length && this._printComments(0, i, e, s);
    }
    _maybePrintInnerComments(e, s) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, e, s));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(e) {
      let s = this._currentNode, i = s.innerComments;
      if (!(i != null && i.length)) return;
      let r = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, s, void 0, void 0, e), r && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, s, i, r) {
      this.printJoin(e, !0, s ?? !1, void 0, void 0, r, void 0, i);
    }
    printList(e, s, i, r, a, o) {
      this.printJoin(e, i, r, a ?? ast, s, void 0, o);
    }
    shouldPrintTrailingComma(e) {
      if (!this.tokenMap) return null;
      let s = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, e));
      return s <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[s - 1], ",");
    }
    _printNewline(e, s) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let r = s.nextNodeStartLine, a = this._lastCommentLine;
      if (r > 0 && a > 0) {
        let o = r - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e, s) {
      if (e.ignore || this._printedComments.has(e)) return 0;
      if (this._noLineTerminator && rst.test(e.value))
        return 2;
      if (s && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (r) => r.value === e.value);
        if (i && i.start > s.start)
          return 2;
      }
      return this._printedComments.add(e), this.format.shouldPrintComment(e.value) ? 1 : 0;
    }
    _printComment(e, s) {
      let i = this._noLineTerminator, r = e.type === "CommentBlock", a = r && s !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && s !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (r) {
        if (l = `/*${e.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let c = (u = e.loc) == null ? void 0 : u.start.column;
          if (c) {
            let p = new RegExp("\\n\\s{1," + c + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else i ? l = `/*${e.value}*/` : l = `//${e.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: p
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e.loc), this._append(l, r), this.
        _printSemicolonBeforeNextNode = p, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", e.loc), this._append(l, r);
      !r && !i && this.newline(1, !0), a && s !== 3 && this.newline(1);
    }
    _printComments(e, s, i, r, a = 0, o) {
      let l = i.loc, u = s.length, c = !!l, p = c ? l.start.line : 0, h = c ? l.end.line : 0, f = 0, d = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let m = 0; m < u; m++) {
        let T = s[m], b = this._shouldPrintComment(T, o);
        if (b === 2) {
          c = !1;
          break;
        }
        if (c && T.loc && b === 1) {
          let E = T.loc.start.line, w = T.loc.end.line;
          if (e === 0) {
            let K = 0;
            m === 0 ? this._buf.hasContent() && (T.type === "CommentLine" || E !== w) && (K = d = 1) : K = E - f, f = w, y(K), this._printComment(
            T, 1), m + 1 === u && (y(Math.max(p - f, d)), f = p);
          } else if (e === 1) {
            let K = E - (m === 0 ? p : f);
            f = w, y(K), this._printComment(T, 1), m + 1 === u && (y(Math.min(1, h - f)), f = h);
          } else {
            let K = E - (m === 0 ? h - a : f);
            f = w, y(K), this._printComment(T, 1);
          }
        } else {
          if (c = !1, b !== 1)
            continue;
          if (u === 1) {
            let E = T.loc ? T.loc.start.line === T.loc.end.line : !bY.test(T.value), w = E && !Qtt(i) && !Ztt(r) && !est(r) && !tst(i);
            e === 0 ? this._printComment(T, w && i.type !== "ObjectExpression" || E && Gtt(r, {
              body: i
            }) ? 1 : 0) : w && e === 2 ? this._printComment(T, 1) : this._printComment(T, 0);
          } else e === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(T, m === 0 ? 2 : m === u - 1 ? 3 : 0) : this._printComment(T, 0);
        }
      }
      e === 2 && c && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(Ug.prototype, Ytt);
  (0, Xtt.addDeprecatedGenerators)(Ug);
  var SUs = RS.default = Ug;
  function ast(t, e) {
    this.token(",", !1, t), e || this.space();
  }
  n(ast, "commaSeparator");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/generator/lib/index.js
var vY = g((Fd) => {
  "use strict";
  Object.defineProperty(Fd, "__esModule", {
    value: !0
  });
  Fd.default = void 0;
  Fd.generate = AY;
  var SY = CJ(), PY = xY();
  function EY(t, e, s) {
    if (e.experimental_preserveFormat) {
      if (typeof t != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!e.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (e.compact && e.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (e.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (e.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(s.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      preserveFormat: e.experimental_preserveFormat,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var r;
      i.decoratorsBeforeExport = e.decoratorsBeforeExport, i.jsescOption.json = e.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (r = e.
      recordAndTupleSyntaxType) != null ? r : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((u) => i.comments || u.includes("@license") || u.includes("@preserve")), i.compact === "auto" && (i.compact = typeof t == "string" && t.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = i;
    return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  n(EY, "normalizeOptions");
  Fd.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, s = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = EY(i, s, e), this._map = s.sourceMaps ? new SY.
      default(s, i) : null;
    }
    generate() {
      return new PY.default(this._format, this._map).generate(this._ast);
    }
  };
  function AY(t, e = {}, s) {
    let i = EY(s, e, t), r = e.sourceMaps ? new SY.default(e, s) : null;
    return new PY.default(i, r, t.tokens, typeof s == "string" ? s : null).generate(t);
  }
  n(AY, "generate");
  var vUs = Fd.default = AY;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/ancestry.js
var CY = g((Ma) => {
  "use strict";
  Object.defineProperty(Ma, "__esModule", {
    value: !0
  });
  Ma.find = cst;
  Ma.findParent = ust;
  Ma.getAncestry = mst;
  Ma.getDeepestCommonAncestorFrom = dst;
  Ma.getEarliestCommonAncestorFrom = fst;
  Ma.getFunctionParent = pst;
  Ma.getStatementParent = hst;
  Ma.inType = Tst;
  Ma.isAncestor = yst;
  Ma.isDescendant = gst;
  var ost = fe(), {
    VISITOR_KEYS: lst
  } = ost;
  function ust(t) {
    let e = this;
    for (; e = e.parentPath; )
      if (t(e)) return e;
    return null;
  }
  n(ust, "findParent");
  function cst(t) {
    let e = this;
    do
      if (t(e)) return e;
    while (e = e.parentPath);
    return null;
  }
  n(cst, "find");
  function pst() {
    return this.findParent((t) => t.isFunction());
  }
  n(pst, "getFunctionParent");
  function hst() {
    let t = this;
    do {
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        break;
      t = t.parentPath;
    } while (t);
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return t;
  }
  n(hst, "getStatementParent");
  function fst(t) {
    return this.getDeepestCommonAncestorFrom(t, function(e, s, i) {
      let r, a = lst[e.type];
      for (let o of i) {
        let l = o[s + 1];
        if (!r) {
          r = l;
          continue;
        }
        if (l.listKey && r.listKey === l.listKey && l.key < r.key) {
          r = l;
          continue;
        }
        let u = a.indexOf(r.parentKey), c = a.indexOf(l.parentKey);
        u > c && (r = l);
      }
      return r;
    });
  }
  n(fst, "getEarliestCommonAncestorFrom");
  function dst(t, e) {
    if (!t.length)
      return this;
    if (t.length === 1)
      return t[0];
    let s = 1 / 0, i, r, a = t.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < s && (s = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < s; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      i = l, r = u;
    }
    if (r)
      return e ? e(r, i, a) : r;
    throw new Error("Couldn't find intersection");
  }
  n(dst, "getDeepestCommonAncestorFrom");
  function mst() {
    let t = this, e = [];
    do
      e.push(t);
    while (t = t.parentPath);
    return e;
  }
  n(mst, "getAncestry");
  function yst(t) {
    return t.isDescendant(this);
  }
  n(yst, "isAncestor");
  function gst(t) {
    return !!this.findParent((e) => e === t);
  }
  n(gst, "isDescendant");
  function Tst(...t) {
    let e = this;
    for (; e; ) {
      for (let s of t)
        if (e.node.type === s) return !0;
      e = e.parentPath;
    }
    return !1;
  }
  n(Tst, "inType");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/inference/util.js
var TO = g((gO) => {
  "use strict";
  Object.defineProperty(gO, "__esModule", {
    value: !0
  });
  gO.createUnionType = Est;
  var bst = fe(), {
    createFlowUnionType: wY,
    createTSUnionType: IY,
    createUnionTypeAnnotation: xst,
    isFlowType: Sst,
    isTSType: Pst
  } = bst;
  function Est(t) {
    {
      if (t.every((e) => Sst(e)))
        return wY ? wY(t) : xst(t);
      if (t.every((e) => Pst(e)) && IY)
        return IY(t);
    }
  }
  n(Est, "createUnionType");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var _Y = g((bO) => {
  "use strict";
  Object.defineProperty(bO, "__esModule", {
    value: !0
  });
  bO.default = Ist;
  var Ast = fe(), kY = TO(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: vst,
    createTypeAnnotationBasedOnTypeof: Cst,
    numberTypeAnnotation: DY,
    voidTypeAnnotation: wst
  } = Ast;
  function Ist(t) {
    if (!this.isReferenced()) return;
    let e = this.scope.getBinding(t.name);
    if (e)
      return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : Nst(e, this, t.name);
    if (t.name === "undefined")
      return wst();
    if (t.name === "NaN" || t.name === "Infinity")
      return DY();
    t.name;
  }
  n(Ist, "_default");
  function Nst(t, e, s) {
    let i = [], r = [], a = NY(t, e, r), o = OY(t, e, s);
    if (o) {
      let l = NY(t, o.ifStatement);
      a = a.filter((u) => !l.includes(u)), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...r);
      for (let l of a)
        i.push(l.getTypeAnnotation());
    }
    if (i.length)
      return (0, kY.createUnionType)(i);
  }
  n(Nst, "getTypeAnnotationBindingConstantViolations");
  function NY(t, e, s) {
    let i = t.constantViolations.slice();
    return i.unshift(t.path), i.filter((r) => {
      r = r.resolve();
      let a = r._guessExecutionStatusRelativeTo(e);
      return s && a === "unknown" && s.push(r), a === "before";
    });
  }
  n(NY, "getConstantViolationsBefore");
  function kst(t, e) {
    let s = e.node.operator, i = e.get("right").resolve(), r = e.get("left").resolve(), a;
    if (r.isIdentifier({
      name: t
    }) ? a = i : i.isIdentifier({
      name: t
    }) && (a = r), a)
      return s === "===" ? a.getTypeAnnotation() : vst.includes(s) ? DY() : void 0;
    if (s !== "===" && s !== "==") return;
    let o, l;
    if (r.isUnaryExpression({
      operator: "typeof"
    }) ? (o = r, l = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, l = r), !o || !o.get("argument").isIdentifier({
      name: t
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return Cst(u);
  }
  n(kst, "inferAnnotationFromBinaryExpression");
  function Dst(t, e, s) {
    let i;
    for (; i = e.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return e.key === "test" ? void 0 : i;
      if (i.isFunction() && i.parentPath.scope.getBinding(s) !== t)
        return;
      e = i;
    }
  }
  n(Dst, "getParentConditionalPath");
  function OY(t, e, s) {
    let i = Dst(t, e, s);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = kst(s, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, kY.createUnionType)(o),
      ifStatement: i
    } : OY(t, i, s);
  }
  n(OY, "getConditionalAnnotation");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/inference/inferers.js
var UY = g((Ys) => {
  "use strict";
  Object.defineProperty(Ys, "__esModule", {
    value: !0
  });
  Ys.ArrayExpression = jY;
  Ys.AssignmentExpression = eit;
  Ys.BinaryExpression = Xst;
  Ys.BooleanLiteral = rit;
  Ys.CallExpression = fit;
  Ys.ConditionalExpression = Gst;
  Ys.ClassDeclaration = Ys.ClassExpression = Ys.FunctionDeclaration = Ys.ArrowFunctionExpression = Ys.FunctionExpression = lit;
  Object.defineProperty(Ys, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _st.default;
    }, "get")
  });
  Ys.LogicalExpression = zst;
  Ys.NewExpression = Hst;
  Ys.NullLiteral = nit;
  Ys.NumericLiteral = iit;
  Ys.ObjectExpression = oit;
  Ys.ParenthesizedExpression = Zst;
  Ys.RegExpLiteral = ait;
  Ys.RestElement = RY;
  Ys.SequenceExpression = Qst;
  Ys.StringLiteral = sit;
  Ys.TSAsExpression = FY;
  Ys.TSNonNullExpression = $st;
  Ys.TaggedTemplateExpression = dit;
  Ys.TemplateLiteral = Jst;
  Ys.TypeCastExpression = MY;
  Ys.UnaryExpression = Yst;
  Ys.UpdateExpression = tit;
  Ys.VariableDeclarator = Wst;
  var Ost = fe(), _st = _Y(), BY = TO(), {
    BOOLEAN_BINARY_OPERATORS: Lst,
    BOOLEAN_UNARY_OPERATORS: Bst,
    NUMBER_BINARY_OPERATORS: Mst,
    NUMBER_UNARY_OPERATORS: Fst,
    STRING_UNARY_OPERATORS: jst,
    anyTypeAnnotation: LY,
    arrayTypeAnnotation: xO,
    booleanTypeAnnotation: SO,
    buildMatchMemberExpression: qS,
    genericTypeAnnotation: Wc,
    identifier: Ch,
    nullLiteralTypeAnnotation: Rst,
    numberTypeAnnotation: jd,
    stringTypeAnnotation: wh,
    tupleTypeAnnotation: qst,
    unionTypeAnnotation: Ust,
    voidTypeAnnotation: Kst,
    isIdentifier: Vst
  } = Ost;
  function Wst() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(Wst, "VariableDeclarator");
  function MY(t) {
    return t.typeAnnotation;
  }
  n(MY, "TypeCastExpression");
  MY.validParent = !0;
  function FY(t) {
    return t.typeAnnotation;
  }
  n(FY, "TSAsExpression");
  FY.validParent = !0;
  function $st() {
    return this.get("expression").getTypeAnnotation();
  }
  n($st, "TSNonNullExpression");
  function Hst(t) {
    if (t.callee.type === "Identifier")
      return Wc(t.callee);
  }
  n(Hst, "NewExpression");
  function Jst() {
    return wh();
  }
  n(Jst, "TemplateLiteral");
  function Yst(t) {
    let e = t.operator;
    if (e === "void")
      return Kst();
    if (Fst.includes(e))
      return jd();
    if (jst.includes(e))
      return wh();
    if (Bst.includes(e))
      return SO();
  }
  n(Yst, "UnaryExpression");
  function Xst(t) {
    let e = t.operator;
    if (Mst.includes(e))
      return jd();
    if (Lst.includes(e))
      return SO();
    if (e === "+") {
      let s = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && s.isBaseType("number") ? jd() : i.isBaseType("string") || s.isBaseType("string") ? wh() : Ust([wh(), jd()]);
    }
  }
  n(Xst, "BinaryExpression");
  function zst() {
    let t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, BY.createUnionType)(t);
  }
  n(zst, "LogicalExpression");
  function Gst() {
    let t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, BY.createUnionType)(t);
  }
  n(Gst, "ConditionalExpression");
  function Qst() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(Qst, "SequenceExpression");
  function Zst() {
    return this.get("expression").getTypeAnnotation();
  }
  n(Zst, "ParenthesizedExpression");
  function eit() {
    return this.get("right").getTypeAnnotation();
  }
  n(eit, "AssignmentExpression");
  function tit(t) {
    let e = t.operator;
    if (e === "++" || e === "--")
      return jd();
  }
  n(tit, "UpdateExpression");
  function sit() {
    return wh();
  }
  n(sit, "StringLiteral");
  function iit() {
    return jd();
  }
  n(iit, "NumericLiteral");
  function rit() {
    return SO();
  }
  n(rit, "BooleanLiteral");
  function nit() {
    return Rst();
  }
  n(nit, "NullLiteral");
  function ait() {
    return Wc(Ch("RegExp"));
  }
  n(ait, "RegExpLiteral");
  function oit() {
    return Wc(Ch("Object"));
  }
  n(oit, "ObjectExpression");
  function jY() {
    return Wc(Ch("Array"));
  }
  n(jY, "ArrayExpression");
  function RY() {
    return jY();
  }
  n(RY, "RestElement");
  RY.validParent = !0;
  function lit() {
    return Wc(Ch("Function"));
  }
  n(lit, "Func");
  var uit = qS("Array.from"), cit = qS("Object.keys"), pit = qS("Object.values"), hit = qS("Object.entries");
  function fit() {
    let {
      callee: t
    } = this.node;
    return cit(t) ? xO(wh()) : uit(t) || pit(t) || Vst(t, {
      name: "Array"
    }) ? xO(LY()) : hit(t) ? xO(qst([wh(), LY()])) : qY(this.get("callee"));
  }
  n(fit, "CallExpression");
  function dit() {
    return qY(this.get("tag"));
  }
  n(dit, "TaggedTemplateExpression");
  function qY(t) {
    if (t = t.resolve(), t.isFunction()) {
      let {
        node: e
      } = t;
      if (e.async)
        return e.generator ? Wc(Ch("AsyncIterator")) : Wc(Ch("Promise"));
      if (e.generator)
        return Wc(Ch("Iterator"));
      if (t.node.returnType)
        return t.node.returnType;
    }
  }
  n(qY, "resolveCall");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/inference/index.js
var HY = g(($c) => {
  "use strict";
  Object.defineProperty($c, "__esModule", {
    value: !0
  });
  $c._getTypeAnnotation = $Y;
  $c.baseTypeStrictlyMatches = Mit;
  $c.couldBeBaseType = Bit;
  $c.getTypeAnnotation = _it;
  $c.isBaseType = Lit;
  $c.isGenericType = Fit;
  var KY = UY(), mit = fe(), {
    anyTypeAnnotation: WY,
    isAnyTypeAnnotation: US,
    isArrayTypeAnnotation: yit,
    isBooleanTypeAnnotation: git,
    isEmptyTypeAnnotation: Tit,
    isFlowBaseAnnotation: bit,
    isGenericTypeAnnotation: xit,
    isIdentifier: VY,
    isMixedTypeAnnotation: Sit,
    isNumberTypeAnnotation: Pit,
    isStringTypeAnnotation: Eit,
    isTSArrayType: Ait,
    isTSTypeAnnotation: vit,
    isTSTypeReference: Cit,
    isTupleTypeAnnotation: wit,
    isTypeAnnotation: Iit,
    isUnionTypeAnnotation: Nit,
    isVoidTypeAnnotation: kit,
    stringTypeAnnotation: Dit,
    voidTypeAnnotation: Oit
  } = mit;
  function _it() {
    let t = this.getData("typeAnnotation");
    return t != null || (t = $Y.call(this) || WY(), (Iit(t) || vit(t)) && (t = t.typeAnnotation), this.setData("typeAnnotation", t)), t;
  }
  n(_it, "getTypeAnnotation");
  var PO = /* @__PURE__ */ new WeakSet();
  function $Y() {
    let t = this.node;
    if (!t)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let s = this.parentPath.parentPath, i = s.parentPath;
        return s.key === "left" && i.isForInStatement() ? Dit() : s.key === "left" && i.isForOfStatement() ? WY() : Oit();
      } else
        return;
    if (t.typeAnnotation)
      return t.typeAnnotation;
    if (!PO.has(t)) {
      PO.add(t);
      try {
        var e;
        let s = KY[t.type];
        if (s)
          return s.call(this, t);
        if (s = KY[this.parentPath.type], (e = s) != null && e.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        PO.delete(t);
      }
    }
  }
  n($Y, "_getTypeAnnotation");
  function Lit(t, e) {
    return EO(t, this.getTypeAnnotation(), e);
  }
  n(Lit, "isBaseType");
  function EO(t, e, s) {
    if (t === "string")
      return Eit(e);
    if (t === "number")
      return Pit(e);
    if (t === "boolean")
      return git(e);
    if (t === "any")
      return US(e);
    if (t === "mixed")
      return Sit(e);
    if (t === "empty")
      return Tit(e);
    if (t === "void")
      return kit(e);
    if (s)
      return !1;
    throw new Error(`Unknown base type ${t}`);
  }
  n(EO, "_isBaseType");
  function Bit(t) {
    let e = this.getTypeAnnotation();
    if (US(e)) return !0;
    if (Nit(e)) {
      for (let s of e.types)
        if (US(s) || EO(t, s, !0))
          return !0;
      return !1;
    } else
      return EO(t, e, !0);
  }
  n(Bit, "couldBeBaseType");
  function Mit(t) {
    let e = this.getTypeAnnotation(), s = t.getTypeAnnotation();
    return !US(e) && bit(e) ? s.type === e.type : !1;
  }
  n(Mit, "baseTypeStrictlyMatches");
  function Fit(t) {
    let e = this.getTypeAnnotation();
    return t === "Array" && (Ait(e) || yit(e) || wit(e)) ? !0 : xit(e) && VY(e.id, {
      name: t
    }) || Cit(e) && VY(e.typeName, {
      name: t
    });
  }
  n(Fit, "isGenericType");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var JY = g((KS) => {
  "use strict";
  Object.defineProperty(KS, "__esModule", {
    value: !0
  });
  KS.hooks = void 0;
  var jUs = KS.hooks = [function(t, e) {
    if (t.key === "test" && (e.isWhile() || e.isSwitchCase()) || t.key === "declaration" && e.isExportDeclaration() || t.key === "body" && e.
    isLabeledStatement() || t.listKey === "declarations" && e.isVariableDeclaration() && e.node.declarations.length === 1 || t.key === "expr\
ession" && e.isExpressionStatement())
      return e.remove(), !0;
  }, function(t, e) {
    if (e.isSequenceExpression() && e.node.expressions.length === 1)
      return e.replaceWith(e.node.expressions[0]), !0;
  }, function(t, e) {
    if (e.isBinary())
      return t.key === "left" ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0;
  }, function(t, e) {
    if (e.isIfStatement() && t.key === "consequent" || t.key === "body" && (e.isLoop() || e.isArrowFunctionExpression()))
      return t.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/removal.js
var VS = g((Hc) => {
  "use strict";
  Object.defineProperty(Hc, "__esModule", {
    value: !0
  });
  Hc._assertUnremoved = QY;
  Hc._callRemovalHooks = zY;
  Hc._markRemoved = AO;
  Hc._remove = GY;
  Hc._removeFromScope = XY;
  Hc.remove = $it;
  var jit = JY(), Rit = Ph(), qit = vO(), YY = Jc(), Uit = fe(), Kit = WS(), Vit = ol(), {
    getBindingIdentifiers: Wit
  } = Uit;
  function $it() {
    var t;
    if (QY.call(this), Vit.resync.call(this), zY.call(this)) {
      AO.call(this);
      return;
    }
    (t = this.opts) != null && t.noScope || XY.call(this), this.shareCommentsWithSiblings(), GY.call(this), AO.call(this);
  }
  n($it, "remove");
  function XY() {
    let t = Wit(this.node, !1, !1, !0);
    Object.keys(t).forEach((e) => this.scope.removeBinding(e));
  }
  n(XY, "_removeFromScope");
  function zY() {
    if (this.parentPath) {
      for (let t of jit.hooks)
        if (t(this, this.parentPath)) return !0;
    }
  }
  n(zY, "_callRemovalHooks");
  function GY() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), Kit.updateSiblingKeys.call(this, this.key, -1)) : qit._replaceWith.
    call(this, null);
  }
  n(GY, "_remove");
  function AO() {
    this._traverseFlags |= YY.SHOULD_SKIP | YY.REMOVED, this.parent && (0, Rit.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  n(AO, "_markRemoved");
  function QY() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(QY, "_assertUnremoved");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/lib/hoister.js
var eX = g(($S) => {
  "use strict";
  Object.defineProperty($S, "__esModule", {
    value: !0
  });
  $S.default = void 0;
  var ZY = fe(), Hit = ZY, {
    react: Jit
  } = ZY, {
    cloneNode: Yit,
    jsxExpressionContainer: Xit,
    variableDeclaration: zit,
    variableDeclarator: Git
  } = Hit, Qit = {
    ReferencedIdentifier(t, e) {
      if (t.isJSXIdentifier() && Jit.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression())
        return;
      if (t.node.name === "this") {
        let i = t.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && e.breakOnScopePaths.push(i.path);
      }
      let s = t.scope.getBinding(t.node.name);
      if (s) {
        for (let i of s.constantViolations)
          if (i.scope !== s.path.scope) {
            e.mutableBinding = !0, t.stop();
            return;
          }
        s === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = s);
      }
    }
  }, CO = class {
    static {
      n(this, "PathHoister");
    }
    constructor(e, s) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = s, this.path = e, this.attachAfter = !1;
    }
    isCompatibleScope(e) {
      for (let s of Object.keys(this.bindings)) {
        let i = this.bindings[s];
        if (!e.bindingIdentifierEquals(s, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let e = this.path.scope;
      do {
        if (this.isCompatibleScope(e))
          this.scopes.push(e);
        else
          break;
        if (this.breakOnScopePaths.includes(e.path))
          break;
      } while (e = e.parent);
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath();
      if (!e) return;
      let s = e.scope;
      if (s.path === e && (s = e.scope.parent), s.path.isProgram() || s.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!s.hasOwnBinding(i)) continue;
          let r = this.bindings[i];
          if (r.kind === "param" || r.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(r.path).key >= e.key) {
            this.attachAfter = !0, e = r.path;
            for (let o of r.constantViolations)
              this.getAttachmentParentForPath(o).key > e.key && (e = o);
          }
        }
      return e;
    }
    _getAttachmentPath() {
      let s = this.scopes.pop();
      if (s) {
        if (s.path.isFunction())
          if (this.hasOwnParamBindings(s)) {
            if (this.scope === s) return;
            let i = s.path.get("body").get("body");
            for (let r = 0; r < i.length; r++)
              if (!i[r].node._blockHoist)
                return i[r];
          } else
            return this.getNextScopeAttachmentParent();
        else if (s.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let e = this.scopes.pop();
      if (e) return this.getAttachmentParentForPath(e.path);
    }
    getAttachmentParentForPath(e) {
      do
        if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
          return e;
      while (e = e.parentPath);
    }
    hasOwnParamBindings(e) {
      for (let s of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(s)) continue;
        let i = this.bindings[s];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(Qit, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let e = this.getAttachmentPath();
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return;
      let s = e.scope.generateUidIdentifier("ref"), i = Git(s, this.path.node), r = this.attachAfter ? "insertAfter" : "insertBefore", [a] = e[r](
      [e.isVariableDeclarator() ? i : zit("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (s = Xit(s)), this.path.replaceWith(Yit(s)), e.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  $S.default = CO;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/modification.js
var WS = g((Fa) => {
  "use strict";
  Object.defineProperty(Fa, "__esModule", {
    value: !0
  });
  Fa._containerInsert = DO;
  Fa._containerInsertAfter = iX;
  Fa._containerInsertBefore = OO;
  Fa._verifyNodeList = Kg;
  Fa.insertAfter = mrt;
  Fa.insertBefore = frt;
  Fa.pushContainer = grt;
  Fa.unshiftContainer = yrt;
  Fa.updateSiblingKeys = aX;
  var Zit = Ph(), kO = Jc(), wO = ol(), HS = VS(), ert = fe(), trt = eX(), {
    arrowFunctionExpression: srt,
    assertExpression: irt,
    assignmentExpression: rrt,
    blockStatement: tX,
    callExpression: nrt,
    cloneNode: IO,
    expressionStatement: NO,
    isAssignmentExpression: art,
    isCallExpression: ort,
    isExportNamedDeclaration: sX,
    isExpression: lrt,
    isIdentifier: urt,
    isSequenceExpression: crt,
    isSuper: prt,
    thisExpression: hrt
  } = ert;
  function frt(t) {
    HS._assertUnremoved.call(this);
    let e = Kg.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || sX(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertBefore(e);
    if (this.isNodeType("Expression") && !this.isJSXElement() || s.isForStatement() && this.key === "init")
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e);
    if (Array.isArray(this.container))
      return OO.call(this, e);
    if (this.isStatementOrBlock()) {
      let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
      return this.replaceWith(tX(a ? [r] : [])), this.unshiftContainer("body", e);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(frt, "insertBefore");
  function DO(t, e) {
    aX.call(this, t, e.length);
    let s = [];
    this.container.splice(t, 0, ...e);
    for (let a = 0; a < e.length; a++) {
      var i;
      let o = t + a, l = this.getSibling(o);
      s.push(l), (i = this.context) != null && i.queue && wO.pushContext.call(l, this.context);
    }
    let r = wO._getQueueContexts.call(this);
    for (let a of s) {
      wO.setScope.call(a), a.debug("Inserted.");
      for (let o of r)
        o.maybeQueue(a, !0);
    }
    return s;
  }
  n(DO, "_containerInsert");
  function OO(t) {
    return DO.call(this, this.key, t);
  }
  n(OO, "_containerInsertBefore");
  function iX(t) {
    return DO.call(this, this.key + 1, t);
  }
  n(iX, "_containerInsertAfter");
  var rX = /* @__PURE__ */ n((t) => t[t.length - 1], "last");
  function nX(t) {
    return crt(t.parent) && (rX(t.parent.expressions) !== t.node || nX(t.parentPath));
  }
  n(nX, "isHiddenInSequenceExpression");
  function drt(t, e) {
    if (!art(t) || !urt(t.left))
      return !1;
    let s = e.getBlockParent();
    return s.hasOwnBinding(t.left.name) && s.getOwnBinding(t.left.name).constantViolations.length <= 1;
  }
  n(drt, "isAlmostConstantAssignment");
  function mrt(t) {
    if (HS._assertUnremoved.call(this), this.isSequenceExpression())
      return rX(this.get("expressions")).insertAfter(t);
    let e = Kg.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || sX(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertAfter(e.map((r) => lrt(r) ? NO(r) : r));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !s.isJSXElement() || s.isForStatement() && this.key === "init") {
      let r = this;
      if (r.node) {
        let a = r.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return irt(a), r.replaceWith(nrt(srt([], a), [])), r.get("callee.body").insertAfter(e), [r];
        if (nX(r))
          e.unshift(a);
        else if (ort(a) && prt(a.callee))
          e.unshift(a), e.push(hrt());
        else if (drt(a, o))
          e.unshift(a), e.push(IO(a.left));
        else if (o.isPure(a, !0))
          e.push(a);
        else {
          s.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let l = o.generateDeclaredUidIdentifier();
          e.unshift(NO(rrt("=", IO(l), a))), e.push(NO(IO(l)));
        }
      }
      return this.replaceExpressionWithStatements(e);
    } else {
      if (Array.isArray(this.container))
        return iX.call(this, e);
      if (this.isStatementOrBlock()) {
        let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
        return this.replaceWith(tX(a ? [r] : [])), this.pushContainer("body", e);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(mrt, "insertAfter");
  function aX(t, e) {
    if (!this.parent) return;
    let s = (0, Zit.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, i] of s)
      typeof i.key == "number" && i.container === this.container && i.key >= t && (i.key += e);
  }
  n(aX, "updateSiblingKeys");
  function Kg(t) {
    if (!t)
      return [];
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++) {
      let s = t[e], i;
      if (s ? typeof s != "object" ? i = "contains a non-object node" : s.type ? s instanceof kO.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let r = Array.isArray(s) ? "array" : typeof s;
        throw new Error(`Node list ${i} with the index of ${e} and type of ${r}`);
      }
    }
    return t;
  }
  n(Kg, "_verifyNodeList");
  function yrt(t, e) {
    HS._assertUnremoved.call(this), e = Kg.call(this, e);
    let s = kO.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[t],
      listKey: t,
      key: 0
    }).setContext(this.context);
    return OO.call(s, e);
  }
  n(yrt, "unshiftContainer");
  function grt(t, e) {
    HS._assertUnremoved.call(this);
    let s = Kg.call(this, e), i = this.node[t];
    return kO.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: t,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(s);
  }
  n(grt, "pushContainer");
  Fa.hoist = /* @__PURE__ */ n(function(e = this.scope) {
    return new trt.default(this, e).run();
  }, "hoist");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/parser/lib/index.js
var FX = g((Qg) => {
  "use strict";
  Object.defineProperty(Qg, "__esModule", {
    value: !0
  });
  function Trt(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(Trt, "_objectWithoutPropertiesLoose");
  var ul = class {
    static {
      n(this, "Position");
    }
    constructor(e, s, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = s, this.index = i;
    }
  }, Vd = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, s) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = s;
    }
  };
  function vn(t, e) {
    let {
      line: s,
      column: i,
      index: r
    } = t;
    return new ul(s, i + e, r + e);
  }
  n(vn, "createPositionWithColumnOffset");
  var oX = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", brt = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: oX
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: oX
    }
  }, lX = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, XS = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? lX.UpdateExpression[`${t.prefix}`] : lX[t.type], "toNodeDescription"), xrt = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${XS(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${XS(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${XS(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, Srt = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, Prt = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Ert = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${XS({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), Art = ["message"];
  function uX(t, e, s) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: s
    });
  }
  n(uX, "defineHidden");
  function vrt({
    toMessage: t,
    code: e,
    reasonCode: s,
    syntaxPlugin: i
  }) {
    let r = s === "MissingPlugin" || s === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[s] && (s = a[s]);
    }
    return /* @__PURE__ */ n(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = s, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, r && (u.missingPlugin = l.missingPlugin), uX(u, "\
clone", /* @__PURE__ */ n(function(p = {}) {
        var h;
        let {
          line: f,
          column: d,
          index: y
        } = (h = p.loc) != null ? h : o;
        return a(new ul(f, d, y), Object.assign({}, l, p.details));
      }, "clone")), uX(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${t(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  n(vrt, "toParseErrorConstructor");
  function mu(t, e) {
    if (Array.isArray(t))
      return (i) => mu(i, t[0]);
    let s = {};
    for (let i of Object.keys(t)) {
      let r = t[i], a = typeof r == "string" ? {
        message: /* @__PURE__ */ n(() => r, "message")
      } : typeof r == "function" ? {
        message: r
      } : r, {
        message: o
      } = a, l = Trt(a, Art), u = typeof o == "string" ? () => o : o;
      s[i] = vrt(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return s;
  }
  n(mu, "ParseErrorEnum");
  var Z = Object.assign({}, mu(brt), mu(xrt), mu(Srt), mu`pipelineOperator`(Ert));
  function Crt() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  n(Crt, "createDefaultOptions");
  function wrt(t) {
    let e = Crt();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let s of Object.keys(e))
      t[s] != null && (e[s] = t[s]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  n(wrt, "getOptions");
  var {
    defineProperty: Irt
  } = Object, cX = /* @__PURE__ */ n((t, e) => {
    t && Irt(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function Vg(t) {
    return cX(t.loc.start, "index"), cX(t.loc.end, "index"), t;
  }
  n(Vg, "toESTreeLocation");
  var Nrt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let s = Vg(super.parse());
      return this.optionFlags & 256 && (s.tokens = s.tokens.map(Vg)), s;
    }
    parseRegExpLiteral({
      pattern: s,
      flags: i
    }) {
      let r = null;
      try {
        r = new RegExp(s, i);
      } catch {
      }
      let a = this.estreeParseLiteral(r);
      return a.regex = {
        pattern: s,
        flags: i
      }, a;
    }
    parseBigIntLiteral(s) {
      let i;
      try {
        i = BigInt(s);
      } catch {
        i = null;
      }
      let r = this.estreeParseLiteral(i);
      return r.bigint = String(r.value || s), r;
    }
    parseDecimalLiteral(s) {
      let r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || s), r;
    }
    estreeParseLiteral(s) {
      return this.parseLiteral(s, "Literal");
    }
    parseStringLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNumericLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    directiveToStmt(s) {
      let i = s.value;
      delete s.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let r = s;
      return r.type = "ExpressionStatement", r.expression = i, r.directive = i.extra.rawValue, delete i.extra, r;
    }
    initFunction(s, i) {
      super.initFunction(s, i), s.expression = !1;
    }
    checkDeclaration(s) {
      s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
    }
    getObjectOrClassMethodParams(s) {
      return s.value.params;
    }
    isValidDirective(s) {
      var i;
      return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((i = s.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(s, i, r, a, o) {
      super.parseBlockBody(s, i, r, a, o);
      let l = s.directives.map((u) => this.directiveToStmt(u));
      s.body = l.concat(s.body), delete s.directives;
    }
    parsePrivateName() {
      let s = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
    }
    convertPrivateNameToPrivateIdentifier(s) {
      let i = super.getPrivateNameSV(s);
      return s = s, delete s.id, s.name = i, s.type = "PrivateIdentifier", s;
    }
    isPrivateName(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
    }
    getPrivateNameSV(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
    }
    parseLiteral(s, i) {
      let r = super.parseLiteral(s, i);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(s, i, r = !1) {
      super.parseFunctionBody(s, i, r), s.expression = s.body.type !== "BlockStatement";
    }
    parseMethod(s, i, r, a, o, l, u = !1) {
      let c = this.startNode();
      c.kind = s.kind, c = super.parseMethod(c, i, r, a, o, l, u), c.type = "FunctionExpression", delete c.kind, s.value = c;
      let {
        typeParameters: p
      } = s;
      return p && (delete s.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p)), l === "ClassPrivateMethod" && (s.computed =
      !1), this.finishNode(s, "MethodDefinition");
    }
    nameIsConstructor(s) {
      return s.type === "Literal" ? s.value === "constructor" : super.nameIsConstructor(s);
    }
    parseClassProperty(...s) {
      let i = super.parseClassProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...s) {
      let i = super.parseClassPrivateProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(s) {
      let i = super.parseClassAccessorProperty(s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(s, i, r, a, o) {
      let l = super.parseObjectMethod(s, i, r, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(s, i, r, a) {
      let o = super.parseObjectProperty(s, i, r, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(s, i, r) {
      return s === "Property" ? "value" : super.isValidLVal(s, i, r);
    }
    isAssignable(s, i) {
      return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      if (s != null && this.isObjectProperty(s)) {
        let {
          key: r,
          value: a
        } = s;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(s, i);
    }
    toAssignableObjectExpressionProp(s, i, r) {
      s.type === "Property" && (s.kind === "get" || s.kind === "set") ? this.raise(Z.PatternHasAccessor, s.key) : s.type === "Property" && s.
      method ? this.raise(Z.PatternHasMethod, s.key) : super.toAssignableObjectExpressionProp(s, i, r);
    }
    finishCallExpression(s, i) {
      let r = super.finishCallExpression(s, i);
      if (r.callee.type === "Import") {
        var a, o;
        r.type = "ImportExpression", r.source = r.arguments[0], r.options = (a = r.arguments[1]) != null ? a : null, r.attributes = (o = r.arguments[1]) !=
        null ? o : null, delete r.arguments, delete r.callee;
      }
      return r;
    }
    toReferencedArguments(s) {
      s.type !== "ImportExpression" && super.toReferencedArguments(s);
    }
    parseExport(s, i) {
      let r = this.state.lastTokStartLoc, a = super.parseExport(s, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, r);
          }
          break;
      }
      return a;
    }
    parseSubscript(s, i, r, a) {
      let o = super.parseSubscript(s, i, r, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(s) {
      return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
    }
    hasPropertyAsPrivateName(s) {
      return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
    }
    isObjectProperty(s) {
      return s.type === "Property" && s.kind === "init" && !s.method;
    }
    isObjectMethod(s) {
      return s.type === "Property" && (s.method || s.kind === "get" || s.kind === "set");
    }
    finishNodeAt(s, i, r) {
      return Vg(super.finishNodeAt(s, i, r));
    }
    resetStartLocation(s, i) {
      super.resetStartLocation(s, i), Vg(s);
    }
    resetEndLocation(s, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(s, i), Vg(s);
    }
  }, "estree"), kh = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, s) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!s;
    }
  }, Xs = {
    brace: new kh("{"),
    j_oTag: new kh("<tag"),
    j_cTag: new kh("</tag"),
    j_expr: new kh("<tag>...</tag>", !0)
  };
  Xs.template = new kh("`", !0);
  var os = !0, Ve = !0, _O = !0, Wg = !0, Yc = !0, krt = !0, QS = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, s = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = s.keyword,
      this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop,
      this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.
      updateContext = null;
    }
  }, i2 = /* @__PURE__ */ new Map();
  function Ds(t, e = {}) {
    e.keyword = t;
    let s = vt(t, e);
    return i2.set(t, s), s;
  }
  n(Ds, "createKeyword");
  function An(t, e) {
    return vt(t, {
      beforeExpr: os,
      binop: e
    });
  }
  n(An, "createBinop");
  var Yg = -1, fu = [], r2 = [], n2 = [], a2 = [], o2 = [], l2 = [];
  function vt(t, e = {}) {
    var s, i, r, a;
    return ++Yg, r2.push(t), n2.push((s = e.binop) != null ? s : -1), a2.push((i = e.beforeExpr) != null ? i : !1), o2.push((r = e.startsExpr) !=
    null ? r : !1), l2.push((a = e.prefix) != null ? a : !1), fu.push(new QS(t, e)), Yg;
  }
  n(vt, "createToken");
  function as(t, e = {}) {
    var s, i, r, a;
    return ++Yg, i2.set(t, Yg), r2.push(t), n2.push((s = e.binop) != null ? s : -1), a2.push((i = e.beforeExpr) != null ? i : !1), o2.push((r =
    e.startsExpr) != null ? r : !1), l2.push((a = e.prefix) != null ? a : !1), fu.push(new QS("name", e)), Yg;
  }
  n(as, "createKeywordLike");
  var Drt = {
    bracketL: vt("[", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    bracketHashL: vt("#[", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    bracketBarL: vt("[|", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    bracketR: vt("]"),
    bracketBarR: vt("|]"),
    braceL: vt("{", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    braceBarL: vt("{|", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    braceHashL: vt("#{", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    braceR: vt("}"),
    braceBarR: vt("|}"),
    parenL: vt("(", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    parenR: vt(")"),
    comma: vt(",", {
      beforeExpr: os
    }),
    semi: vt(";", {
      beforeExpr: os
    }),
    colon: vt(":", {
      beforeExpr: os
    }),
    doubleColon: vt("::", {
      beforeExpr: os
    }),
    dot: vt("."),
    question: vt("?", {
      beforeExpr: os
    }),
    questionDot: vt("?."),
    arrow: vt("=>", {
      beforeExpr: os
    }),
    template: vt("template"),
    ellipsis: vt("...", {
      beforeExpr: os
    }),
    backQuote: vt("`", {
      startsExpr: Ve
    }),
    dollarBraceL: vt("${", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    templateTail: vt("...`", {
      startsExpr: Ve
    }),
    templateNonTail: vt("...${", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    at: vt("@"),
    hash: vt("#", {
      startsExpr: Ve
    }),
    interpreterDirective: vt("#!..."),
    eq: vt("=", {
      beforeExpr: os,
      isAssign: Wg
    }),
    assign: vt("_=", {
      beforeExpr: os,
      isAssign: Wg
    }),
    slashAssign: vt("_=", {
      beforeExpr: os,
      isAssign: Wg
    }),
    xorAssign: vt("_=", {
      beforeExpr: os,
      isAssign: Wg
    }),
    moduloAssign: vt("_=", {
      beforeExpr: os,
      isAssign: Wg
    }),
    incDec: vt("++/--", {
      prefix: Yc,
      postfix: krt,
      startsExpr: Ve
    }),
    bang: vt("!", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    tilde: vt("~", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    doubleCaret: vt("^^", {
      startsExpr: Ve
    }),
    doubleAt: vt("@@", {
      startsExpr: Ve
    }),
    pipeline: An("|>", 0),
    nullishCoalescing: An("??", 1),
    logicalOR: An("||", 1),
    logicalAND: An("&&", 2),
    bitwiseOR: An("|", 3),
    bitwiseXOR: An("^", 4),
    bitwiseAND: An("&", 5),
    equality: An("==/!=/===/!==", 6),
    lt: An("</>/<=/>=", 7),
    gt: An("</>/<=/>=", 7),
    relational: An("</>/<=/>=", 7),
    bitShift: An("<</>>/>>>", 8),
    bitShiftL: An("<</>>/>>>", 8),
    bitShiftR: An("<</>>/>>>", 8),
    plusMin: vt("+/-", {
      beforeExpr: os,
      binop: 9,
      prefix: Yc,
      startsExpr: Ve
    }),
    modulo: vt("%", {
      binop: 10,
      startsExpr: Ve
    }),
    star: vt("*", {
      binop: 10
    }),
    slash: An("/", 10),
    exponent: vt("**", {
      beforeExpr: os,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ds("in", {
      beforeExpr: os,
      binop: 7
    }),
    _instanceof: Ds("instanceof", {
      beforeExpr: os,
      binop: 7
    }),
    _break: Ds("break"),
    _case: Ds("case", {
      beforeExpr: os
    }),
    _catch: Ds("catch"),
    _continue: Ds("continue"),
    _debugger: Ds("debugger"),
    _default: Ds("default", {
      beforeExpr: os
    }),
    _else: Ds("else", {
      beforeExpr: os
    }),
    _finally: Ds("finally"),
    _function: Ds("function", {
      startsExpr: Ve
    }),
    _if: Ds("if"),
    _return: Ds("return", {
      beforeExpr: os
    }),
    _switch: Ds("switch"),
    _throw: Ds("throw", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    _try: Ds("try"),
    _var: Ds("var"),
    _const: Ds("const"),
    _with: Ds("with"),
    _new: Ds("new", {
      beforeExpr: os,
      startsExpr: Ve
    }),
    _this: Ds("this", {
      startsExpr: Ve
    }),
    _super: Ds("super", {
      startsExpr: Ve
    }),
    _class: Ds("class", {
      startsExpr: Ve
    }),
    _extends: Ds("extends", {
      beforeExpr: os
    }),
    _export: Ds("export"),
    _import: Ds("import", {
      startsExpr: Ve
    }),
    _null: Ds("null", {
      startsExpr: Ve
    }),
    _true: Ds("true", {
      startsExpr: Ve
    }),
    _false: Ds("false", {
      startsExpr: Ve
    }),
    _typeof: Ds("typeof", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    _void: Ds("void", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    _delete: Ds("delete", {
      beforeExpr: os,
      prefix: Yc,
      startsExpr: Ve
    }),
    _do: Ds("do", {
      isLoop: _O,
      beforeExpr: os
    }),
    _for: Ds("for", {
      isLoop: _O
    }),
    _while: Ds("while", {
      isLoop: _O
    }),
    _as: as("as", {
      startsExpr: Ve
    }),
    _assert: as("assert", {
      startsExpr: Ve
    }),
    _async: as("async", {
      startsExpr: Ve
    }),
    _await: as("await", {
      startsExpr: Ve
    }),
    _defer: as("defer", {
      startsExpr: Ve
    }),
    _from: as("from", {
      startsExpr: Ve
    }),
    _get: as("get", {
      startsExpr: Ve
    }),
    _let: as("let", {
      startsExpr: Ve
    }),
    _meta: as("meta", {
      startsExpr: Ve
    }),
    _of: as("of", {
      startsExpr: Ve
    }),
    _sent: as("sent", {
      startsExpr: Ve
    }),
    _set: as("set", {
      startsExpr: Ve
    }),
    _source: as("source", {
      startsExpr: Ve
    }),
    _static: as("static", {
      startsExpr: Ve
    }),
    _using: as("using", {
      startsExpr: Ve
    }),
    _yield: as("yield", {
      startsExpr: Ve
    }),
    _asserts: as("asserts", {
      startsExpr: Ve
    }),
    _checks: as("checks", {
      startsExpr: Ve
    }),
    _exports: as("exports", {
      startsExpr: Ve
    }),
    _global: as("global", {
      startsExpr: Ve
    }),
    _implements: as("implements", {
      startsExpr: Ve
    }),
    _intrinsic: as("intrinsic", {
      startsExpr: Ve
    }),
    _infer: as("infer", {
      startsExpr: Ve
    }),
    _is: as("is", {
      startsExpr: Ve
    }),
    _mixins: as("mixins", {
      startsExpr: Ve
    }),
    _proto: as("proto", {
      startsExpr: Ve
    }),
    _require: as("require", {
      startsExpr: Ve
    }),
    _satisfies: as("satisfies", {
      startsExpr: Ve
    }),
    _keyof: as("keyof", {
      startsExpr: Ve
    }),
    _readonly: as("readonly", {
      startsExpr: Ve
    }),
    _unique: as("unique", {
      startsExpr: Ve
    }),
    _abstract: as("abstract", {
      startsExpr: Ve
    }),
    _declare: as("declare", {
      startsExpr: Ve
    }),
    _enum: as("enum", {
      startsExpr: Ve
    }),
    _module: as("module", {
      startsExpr: Ve
    }),
    _namespace: as("namespace", {
      startsExpr: Ve
    }),
    _interface: as("interface", {
      startsExpr: Ve
    }),
    _type: as("type", {
      startsExpr: Ve
    }),
    _opaque: as("opaque", {
      startsExpr: Ve
    }),
    name: vt("name", {
      startsExpr: Ve
    }),
    placeholder: vt("%%", {
      startsExpr: !0
    }),
    string: vt("string", {
      startsExpr: Ve
    }),
    num: vt("num", {
      startsExpr: Ve
    }),
    bigint: vt("bigint", {
      startsExpr: Ve
    }),
    decimal: vt("decimal", {
      startsExpr: Ve
    }),
    regexp: vt("regexp", {
      startsExpr: Ve
    }),
    privateName: vt("#name", {
      startsExpr: Ve
    }),
    eof: vt("eof"),
    jsxName: vt("jsxName"),
    jsxText: vt("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: vt("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: vt("jsxTagEnd")
  };
  function zs(t) {
    return t >= 93 && t <= 133;
  }
  n(zs, "tokenIsIdentifier");
  function Ort(t) {
    return t <= 92;
  }
  n(Ort, "tokenKeywordOrIdentifierIsKeyword");
  function Eo(t) {
    return t >= 58 && t <= 133;
  }
  n(Eo, "tokenIsKeywordOrIdentifier");
  function PX(t) {
    return t >= 58 && t <= 137;
  }
  n(PX, "tokenIsLiteralPropertyName");
  function _rt(t) {
    return a2[t];
  }
  n(_rt, "tokenComesBeforeExpression");
  function Hg(t) {
    return o2[t];
  }
  n(Hg, "tokenCanStartExpression");
  function Lrt(t) {
    return t >= 29 && t <= 33;
  }
  n(Lrt, "tokenIsAssignment");
  function pX(t) {
    return t >= 129 && t <= 131;
  }
  n(pX, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function Brt(t) {
    return t >= 90 && t <= 92;
  }
  n(Brt, "tokenIsLoop");
  function u2(t) {
    return t >= 58 && t <= 92;
  }
  n(u2, "tokenIsKeyword");
  function Mrt(t) {
    return t >= 39 && t <= 59;
  }
  n(Mrt, "tokenIsOperator");
  function Frt(t) {
    return t === 34;
  }
  n(Frt, "tokenIsPostfix");
  function jrt(t) {
    return l2[t];
  }
  n(jrt, "tokenIsPrefix");
  function Rrt(t) {
    return t >= 121 && t <= 123;
  }
  n(Rrt, "tokenIsTSTypeOperator");
  function qrt(t) {
    return t >= 124 && t <= 130;
  }
  n(qrt, "tokenIsTSDeclarationStart");
  function zc(t) {
    return r2[t];
  }
  n(zc, "tokenLabelName");
  function zS(t) {
    return n2[t];
  }
  n(zS, "tokenOperatorPrecedence");
  function Urt(t) {
    return t === 57;
  }
  n(Urt, "tokenIsRightAssociative");
  function ZS(t) {
    return t >= 24 && t <= 25;
  }
  n(ZS, "tokenIsTemplate");
  function hu(t) {
    return fu[t];
  }
  n(hu, "getExportedToken");
  fu[8].updateContext = (t) => {
    t.pop();
  }, fu[5].updateContext = fu[7].updateContext = fu[23].updateContext = (t) => {
    t.push(Xs.brace);
  }, fu[22].updateContext = (t) => {
    t[t.length - 1] === Xs.template ? t.pop() : t.push(Xs.template);
  }, fu[143].updateContext = (t) => {
    t.push(Xs.j_expr, Xs.j_oTag);
  };
  var c2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  EX = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6\
-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20\
-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Krt = new RegExp("[" + c2 + "]"), Vrt = new RegExp("[" + c2 + EX + "]");
  c2 = EX = null;
  var AX = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7,
  2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17,
  47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64,
  6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
  52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2,
  1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29,
  113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
  18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12,
  65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Wrt = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function jO(t, e) {
    let s = 65536;
    for (let i = 0, r = e.length; i < r; i += 2) {
      if (s += e[i], s > t) return !1;
      if (s += e[i + 1], s >= t) return !0;
    }
    return !1;
  }
  n(jO, "isInAstralSet");
  function du(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Krt.test(String.fromCharCode(t)) :
    jO(t, AX);
  }
  n(du, "isIdentifierStart");
  function qd(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Vrt.test(
    String.fromCharCode(t)) : jO(t, AX) || jO(t, Wrt);
  }
  n(qd, "isIdentifierChar");
  var p2 = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, $rt = new Set(p2.keyword), Hrt = new Set(p2.strict), Jrt = new Set(p2.strictBind);
  function vX(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(vX, "isReservedWord");
  function CX(t, e) {
    return vX(t, e) || Hrt.has(t);
  }
  n(CX, "isStrictReservedWord");
  function wX(t) {
    return Jrt.has(t);
  }
  n(wX, "isStrictBindOnlyReservedWord");
  function IX(t, e) {
    return CX(t, e) || wX(t);
  }
  n(IX, "isStrictBindReservedWord");
  function Yrt(t) {
    return $rt.has(t);
  }
  n(Yrt, "isKeyword");
  function Xrt(t, e, s) {
    return t === 64 && e === 64 && du(s);
  }
  n(Xrt, "isIteratorStart");
  var zrt = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Grt(t) {
    return zrt.has(t);
  }
  n(Grt, "canBeReservedWord");
  var Xg = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, zg = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, s) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = s;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 128)
          return !0;
        if (s & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new Xg(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 8 || s & 16) {
        this.checkRedeclarationInScope(r, e, s, i);
        let a = r.names.get(e) || 0;
        s & 16 ? a = a | 4 : (r.firstLexicalName || (r.firstLexicalName = e), a = a | 2), r.names.set(e, a), s & 8 && this.maybeExportDefined(
        r, e);
      } else if (s & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (r = this.scopeStack[a], this.checkRedeclarationInScope(r, e, s, i), r.names.set(
        e, (r.names.get(e) || 0) | 1), this.maybeExportDefined(r, e), !(r.flags & 387)); --a)
          ;
      this.parser.inModule && r.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, s) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(s);
    }
    checkRedeclarationInScope(e, s, i, r) {
      this.isRedeclaredInScope(e, s, i) && this.parser.raise(Z.VarRedeclaration, r, {
        identifierName: s
      });
    }
    isRedeclaredInScope(e, s, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(s);
      let r = e.names.get(s);
      return i & 16 ? (r & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (r & 1) > 0 : (r & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      s) || !this.treatFunctionsAsVarInScope(e) && (r & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      this.scopeStack[0].names.has(s) || this.undefinedExports.set(s, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 387)
          return s;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 451 && !(s & 4))
          return s;
      }
    }
  }, RO = class extends Xg {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, qO = class extends zg {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new RO(e);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 2048) {
        this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e), r.declareFunctions.add(e);
        return;
      }
      super.declareName(e, s, i);
    }
    isRedeclaredInScope(e, s, i) {
      if (super.isRedeclaredInScope(e, s, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(s)) {
        let r = e.names.get(s);
        return (r & 4) > 0 || (r & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, UO = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [s, i] = e;
        if (!this.hasPlugin(s))
          return !1;
        let r = this.plugins.get(s);
        for (let a of Object.keys(i))
          if (r?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, s) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[s];
    }
  };
  function NX(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(NX, "setTrailingComments");
  function Qrt(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(Qrt, "setLeadingComments");
  function Gg(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(Gg, "setInnerComments");
  function Ih(t, e, s) {
    let i = null, r = e.length;
    for (; i === null && r > 0; )
      i = e[--r];
    i === null || i.start > s.start ? Gg(t, s.comments) : NX(i, s.comments);
  }
  n(Ih, "adjustInnerComments");
  var KO = class extends UO {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: s
      } = this.state;
      this.comments.length !== s && (this.comments.length = s), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: s
      } = this.state, i = s.length;
      if (i === 0) return;
      let r = i - 1, a = s[r];
      a.start === e.end && (a.leadingNode = e, r--);
      let {
        start: o
      } = e;
      for (; r >= 0; r--) {
        let l = s[r], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), s.splice(r, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: s
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && NX(e.leadingNode, s), e.trailingNode !== null && Qrt(e.trailingNode, s);
      else {
        let {
          containingNode: i,
          start: r
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(r) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Ih(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Ih(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Ih(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Ih(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Ih(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              Ih(i, i.members, e);
              break;
            case "TSEnumBody":
              Ih(i, i.members, e);
              break;
            default:
              Gg(i, s);
          }
        else
          Gg(i, s);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let s = e.length - 1; s >= 0; s--)
        this.finalizeComment(e[s]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      if (i === 0) return;
      let r = s[i - 1];
      r.leadingNode === e && (r.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      i !== 0 && (s[i - 1].trailingNode === e ? s[i - 1].trailingNode = null : i >= 2 && s[i - 2].trailingNode === e && (s[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, s, i) {
      let {
        commentStack: r
      } = this.state, a = r.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = r[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === s)
          l.trailingNode = e;
        else if (u < s)
          break;
      }
    }
  }, Zrt = /\r\n|[\r\n\u2028\u2029]/, JS = new RegExp(Zrt.source, "g");
  function Ud(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(Ud, "isNewLine");
  function hX(t, e, s) {
    for (let i = e; i < s; i++)
      if (Ud(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  n(hX, "hasNewLine");
  var LO = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, BO = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function ent(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(ent, "isWhitespace");
  var VO = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Xs.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: s,
      startIndex: i,
      startLine: r,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : s === "module", this.startIndex = i, this.curLine = r, this.lineStart = -a, this.startLoc =
      this.endLoc = new ul(r, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new ul(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, tnt = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), fX = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, YS = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function dX(t, e, s, i, r, a) {
    let o = s, l = i, u = r, c = "", p = null, h = s, {
      length: f
    } = e;
    for (; ; ) {
      if (s >= f) {
        a.unterminated(o, l, u), c += e.slice(h, s);
        break;
      }
      let d = e.charCodeAt(s);
      if (snt(t, d, e, s)) {
        c += e.slice(h, s);
        break;
      }
      if (d === 92) {
        c += e.slice(h, s);
        let y = int(e, s, i, r, t === "template", a);
        y.ch === null && !p ? p = {
          pos: s,
          lineStart: i,
          curLine: r
        } : c += y.ch, {
          pos: s,
          lineStart: i,
          curLine: r
        } = y, h = s;
      } else d === 8232 || d === 8233 ? (++s, ++r, i = s) : d === 10 || d === 13 ? t === "template" ? (c += e.slice(h, s) + `
`, ++s, d === 13 && e.charCodeAt(s) === 10 && ++s, ++r, h = i = s) : a.unterminated(o, l, u) : ++s;
    }
    return {
      pos: s,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: r,
      containsInvalid: !!p
    };
  }
  n(dX, "readStringContents");
  function snt(t, e, s, i) {
    return t === "template" ? e === 96 || e === 36 && s.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(snt, "isStringEnd");
  function int(t, e, s, i, r, a) {
    let o = !r;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: s,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = WO(t, e, s, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = DX(t, e, s, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        s = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (r)
          return l(null);
        a.strictNumericEscape(e - 1, s, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, h = /^[0-7]+/.exec(t.slice(c, e + 2))[0], f = parseInt(h, 8);
          f > 255 && (h = h.slice(0, -1), f = parseInt(h, 8)), e += h.length - 1;
          let d = t.charCodeAt(e);
          if (h !== "0" || d === 56 || d === 57) {
            if (r)
              return l(null);
            a.strictNumericEscape(c, s, i);
          }
          return l(String.fromCharCode(f));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(int, "readEscapedChar");
  function WO(t, e, s, i, r, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = kX(t, e, s, i, 16, r, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, s, i) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(WO, "readHexChar");
  function kX(t, e, s, i, r, a, o, l, u, c) {
    let p = e, h = r === 16 ? fX.hex : fX.decBinOct, f = r === 16 ? YS.hex : r === 10 ? YS.dec : r === 8 ? YS.oct : YS.bin, d = !1, y = 0;
    for (let m = 0, T = a ?? 1 / 0; m < T; ++m) {
      let b = t.charCodeAt(e), E;
      if (b === 95 && l !== "bail") {
        let w = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !f(K) || h.has(w) || h.has(K)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, s, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, s, i);
        }
        ++e;
        continue;
      }
      if (b >= 97 ? E = b - 97 + 10 : b >= 65 ? E = b - 65 + 10 : tnt(b) ? E = b - 48 : E = 1 / 0, E >= r) {
        if (E <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (E <= 9 && u.invalidDigit(e, s, i, r))
          E = 0;
        else if (o)
          E = 0, d = !0;
        else
          break;
      }
      ++e, y = y * r + E;
    }
    return e === p || a != null && e - p !== a || d ? {
      n: null,
      pos: e
    } : {
      n: y,
      pos: e
    };
  }
  n(kX, "readInt");
  function DX(t, e, s, i, r, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = WO(t, e, s, i, t.indexOf("}", e) - e, !0, r, a), ++e, l !== null && l > 1114111)
        if (r)
          a.invalidCodePoint(e, s, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = WO(t, e, s, i, 4, !1, r, a));
    return {
      code: l,
      pos: e
    };
  }
  n(DX, "readCodePoint");
  function $g(t, e, s) {
    return new ul(s, t - e, t);
  }
  n($g, "buildPosition");
  var rnt = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ll = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      let s = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = s + e.start, this.end = s + e.end, this.loc = new Vd(e.startLoc, e.endLoc);
    }
  }, $O = class extends KO {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, s) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((i, r, a, o) => this.optionFlags & 2048 ? (this.raise(Z.InvalidDigit, $g(i, r, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(Z.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Z.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Z.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Z.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((i, r, a) => {
          this.recordStrictModeErrors(Z.StrictNumericEscape, $g(i, r, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(Z.UnterminatedString, $g(i - 1, r, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Z.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(Z.UnterminatedTemplate, $g(i, r, a));
        }, "unterminated")
      }), this.state = new VO(), this.state.init(e), this.input = s, this.length = s.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new ll(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let s = this.state;
      return this.state = e, s;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return LO.lastIndex = e, LO.test(this.input) ? LO.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return BO.lastIndex = e, BO.test(this.input) ? BO.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let s = this.input.charCodeAt(e);
      if ((s & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      return s;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([s, i]) => this.raise(s, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.state.pos, r = this.input.indexOf(e, i + 2);
      if (r === -1)
        throw this.raise(Z.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = r + e.length, JS.lastIndex = i + 2; JS.test(this.input) && JS.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = JS.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, r),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(r + e.length),
        loc: new Vd(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let s = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let r = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !Ud(r) && ++this.state.pos < this.length; )
          r = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(s + e, a),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(a),
        loc: new Vd(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, s = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let r = this.skipBlockComment("*/");
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              case 47: {
                let r = this.skipLineComment(2);
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (ent(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (s?.length > 0) {
        let i = this.state.pos, r = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: s,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(r);
      }
    }
    finishToken(e, s) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = s, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, s = this.codePointAtPos(e);
      if (s >= 48 && s <= 57)
        throw this.raise(Z.UnexpectedDigitAfterHash, this.state.curPosition());
      if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(s === 123 ? Z.RecordExpressionHashIncorrectStartSyntaxType : Z.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
      } else du(s) ? (++this.state.pos, this.finishToken(139, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let s = this.state.pos;
      for (this.state.pos += 1; !Ud(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(s + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let s = e === 42 ? 55 : 54, i = 1, r = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && r === 42 && (i++, r = this.input.charCodeAt(this.state.pos + 2), s = 57), r === 61 && !this.state.inType && (i++, s = e ===
      37 ? 33 : 30), this.finishOp(s, i);
    }
    readToken_pipe_amp(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (s === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Z.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Z.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (s === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.finishOp(34, 2);
        return;
      }
      s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && s === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Z.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Z.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let s = this.input.charCodeAt(this.state.pos + 1);
          if (s === 120 || s === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (s === 111 || s === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (s === 98 || s === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (du(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(Z.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, s) {
      let i = this.input.slice(this.state.pos, this.state.pos + s);
      this.state.pos += s, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, s = this.state.start + 1, i, r, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(Z.UnterminatedRegExp, vn(e, 1));
        let c = this.input.charCodeAt(a);
        if (Ud(c))
          throw this.raise(Z.UnterminatedRegExp, vn(e, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            r = !0;
          else if (c === 93 && r)
            r = !1;
          else if (c === 47 && !r)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(s, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => vn(e, a + 2 - s), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (rnt.has(c))
          c === 118 ? l.includes("u") && this.raise(Z.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(Z.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(Z.DuplicateRegExpFlags, u());
        else if (qd(c) || c === 92)
          this.raise(Z.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, s, i = !1, r = !0) {
      let {
        n: a,
        pos: o
      } = kX(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, s, i, r, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(Z.InvalidDigit, vn(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = !0;
      else if (o === 109)
        throw this.raise(Z.InvalidDecimal, i);
      if (du(this.codePointAtPos(this.state.pos)))
        throw this.raise(Z.NumberIdentifier, this.state.curPosition());
      if (r) {
        let l = this.input.slice(s, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(Z.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
      if (u) {
        let d = this.input.slice(s, this.state.pos);
        if (this.recordStrictModeErrors(Z.StrictOctalLiteral, i), !this.state.strict) {
          let y = d.indexOf("_");
          y > 0 && this.raise(Z.ZeroDigitNumericSeparator, vn(i, y));
        }
        l = u && !/[89]/.test(d);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !l && (++this.state.pos, this.readInt(10), r = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      Z.InvalidOrMissingExponent, i), r = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((r || u) && this.raise(Z.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(Z.InvalidDecimal, i), ++this.state.pos;
        var p = !0;
      }
      if (du(this.codePointAtPos(this.state.pos)))
        throw this.raise(Z.NumberIdentifier, this.state.curPosition());
      let h = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, h);
        return;
      }
      if (p) {
        this.finishToken(137, h);
        return;
      }
      let f = l ? parseInt(h, 8) : parseFloat(h);
      this.finishToken(135, f);
    }
    readCodePoint(e) {
      let {
        code: s,
        pos: i
      } = DX(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, s;
    }
    readString(e) {
      let {
        str: s,
        pos: i,
        curLine: r,
        lineStart: a
      } = dX(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = r, this.finishToken(134, s);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: s,
        firstInvalidLoc: i,
        pos: r,
        curLine: a,
        lineStart: o
      } = dX("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = r + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new ul(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(r) === 96 ? this.finishToken(24, i ? null : e + s + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + s + "${"));
    }
    recordStrictModeErrors(e, s) {
      let i = s.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, s) : this.state.strictErrors.set(i, [e, s]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let s = "", i = this.state.pos, r = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (qd(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, s += this.input.slice(r, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? du : qd;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Z.MissingUnicodeEscape, this.state.curPosition()), r = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(Z.EscapedCharNotAnIdentifier, o), s += String.fromCodePoint(u)), r = this.state.pos;
        } else
          break;
      }
      return s + this.input.slice(r, this.state.pos);
    }
    readWord(e) {
      let s = this.readWord1(e), i = i2.get(s);
      i !== void 0 ? this.finishToken(i, zc(i)) : this.finishToken(132, s);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      u2(e) && this.state.containsEsc && this.raise(Z.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: zc(e)
      });
    }
    raise(e, s, i = {}) {
      let r = s instanceof ul ? s : s.loc.start, a = e(r, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, s, i = {}) {
      let r = s instanceof ul ? s : s.loc.start, a = r.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(r, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, s, i);
    }
    updateContext(e) {
    }
    unexpected(e, s) {
      throw this.raise(Z.UnexpectedToken, e ?? this.state.startLoc, {
        expected: s ? zc(s) : null
      });
    }
    expectPlugin(e, s) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(Z.MissingPlugin, s ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((s) => this.hasPlugin(s)))
        throw this.raise(Z.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (s, i, r) => {
        this.raise(e, $g(s, i, r));
      };
    }
  }, HO = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, JO = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new HO());
    }
    exit() {
      let e = this.stack.pop(), s = this.current();
      for (let [i, r] of Array.from(e.undefinedPrivateNames))
        s ? s.undefinedPrivateNames.has(i) || s.undefinedPrivateNames.set(i, r) : this.parser.raise(Z.InvalidPrivateFieldResolution, r, {
          identifierName: i
        });
    }
    declarePrivateName(e, s, i) {
      let {
        privateNames: r,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = r.has(e);
      if (s & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = s & 4, h = u & 3, f = s & 3;
          l = h === f || c !== p, l || a.delete(e);
        } else l || a.set(e, s);
      }
      l && this.parser.raise(Z.PrivateNameRedeclaration, i, {
        identifierName: e
      }), r.add(e), o.delete(e);
    }
    usePrivateName(e, s) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, s) : this.parser.raise(Z.InvalidPrivateFieldResolution, s, {
        identifierName: e
      });
    }
  }, Wd = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, eP = class extends Wd {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, s) {
      let i = s.index;
      this.declarationErrors.set(i, [e, s]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, YO = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new Wd()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, s) {
      let i = s.loc.start, {
        stack: r
      } = this, a = r.length - 1, o = r[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = r[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, s) {
      let {
        stack: i
      } = this, r = i[i.length - 1], a = s.loc.start;
      if (r.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (r.canBeArrowParameterDeclaration())
        r.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: s
      } = this, i = s.length - 1, r = s[i];
      for (; r.canBeArrowParameterDeclaration(); )
        r.type === 2 && r.recordDeclarationError(Z.AwaitBindingIdentifier, e), r = s[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, s = e[e.length - 1];
      s.canBeArrowParameterDeclaration() && s.iterateErrors(([i, r]) => {
        this.parser.raise(i, r);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(r.index), o = e[--a];
      });
    }
  };
  function nnt() {
    return new Wd(3);
  }
  n(nnt, "newParameterDeclarationScope");
  function ant() {
    return new eP(1);
  }
  n(ant, "newArrowHeadScope");
  function ont() {
    return new eP(2);
  }
  n(ont, "newAsyncArrowScope");
  function OX() {
    return new Wd();
  }
  n(OX, "newExpressionScope");
  var XO = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function GS(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(GS, "functionFlags");
  var zO = class extends $O {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, s, i, r = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), r ? a[s] = i : Object.defineProperty(a, s, {
        enumerable: r,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, s) {
      let i = e + s.length;
      if (this.input.slice(e, i) === s) {
        let r = this.input.charCodeAt(i);
        return !(qd(r) || (r & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let s = this.nextTokenStart();
      return this.isUnparsedContextual(s, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, s) {
      if (!this.eatContextual(e)) {
        if (s != null)
          throw this.raise(s, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return hX(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return hX(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(Z.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, s) {
      this.eat(e) || this.unexpected(s, e);
    }
    tryParse(e, s = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let r = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > s.errors.length) {
          let a = this.state;
          return this.state = s, this.state.tokensLength = a.tokensLength, {
            node: r,
            error: a.errors[s.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: r,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (r) {
        let a = this.state;
        if (this.state = s, r instanceof SyntaxError)
          return {
            node: null,
            error: r,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (r === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw r;
      }
    }
    checkExpressionErrors(e, s) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: r,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!r || !!o || !!a;
      if (!s)
        return l;
      i != null && this.raise(Z.InvalidCoverInitializedName, i), r != null && this.raise(Z.DuplicateProto, r), a != null && this.raise(Z.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return PX(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let s = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let r = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new XO();
      let u = this.classScope;
      this.classScope = new JO(this);
      let c = this.expressionScope;
      return this.expressionScope = new YO(this), () => {
        this.state.labels = s, this.exportedIdentifiers = i, this.inModule = r, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: s
      } = e;
      s !== null && this.expectPlugin("destructuringPrivate", s);
    }
  }, Kd = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, $d = class {
    static {
      n(this, "Node");
    }
    constructor(e, s, i) {
      this.type = "", this.start = s, this.end = 0, this.loc = new Vd(i), e?.optionFlags & 128 && (this.range = [s, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, h2 = $d.prototype;
  h2.__clone = function() {
    let t = new $d(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let s = 0, i = e.length; s < i; s++) {
      let r = e[s];
      r !== "leadingComments" && r !== "trailingComments" && r !== "innerComments" && (t[r] = this[r]);
    }
    return t;
  };
  function lnt(t) {
    return yu(t);
  }
  n(lnt, "clonePlaceholder");
  function yu(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(h2);
    return u.type = e, u.start = s, u.end = i, u.loc = r, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(yu, "cloneIdentifier");
  function unt(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return lnt(t);
    let l = Object.create(h2);
    return l.type = e, l.start = s, l.end = i, l.loc = r, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(unt, "cloneStringLiteral");
  var GO = class extends zO {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new $d(this, e.index, e);
    }
    startNodeAt(e) {
      return new $d(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, s) {
      return this.finishNodeAt(e, s, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, s, i) {
      return e.type = s, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, s) {
      e.start = s.index, e.loc.start = s, this.optionFlags & 128 && (e.range[0] = s.index);
    }
    resetEndLocation(e, s = this.state.lastTokEndLoc) {
      e.end = s.index, e.loc.end = s, this.optionFlags & 128 && (e.range[1] = s.index);
    }
    resetStartLocationFromNode(e, s) {
      this.resetStartLocation(e, s.loc.start);
    }
  }, cnt = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Lt = mu`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: s
    }) => `Enum \`${t}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: s
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function pnt(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(pnt, "isEsModuleType");
  function mX(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(mX, "hasTypeImportKind");
  var hnt = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function fnt(t, e) {
    let s = [], i = [];
    for (let r = 0; r < t.length; r++)
      (e(t[r], r, t) ? s : i).push(t[r]);
    return [s, i];
  }
  n(fnt, "partition");
  var dnt = /\*?\s*@((?:no)?flow)\b/, mnt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...s) {
      super(...s), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return qO;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(s, i) {
      s !== 134 && s !== 13 && s !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(s, i);
    }
    addComment(s) {
      if (this.flowPragma === void 0) {
        let i = dnt.exec(s.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(s);
    }
    flowParseTypeInitialiser(s) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(s || 14);
      let r = this.flowParseType();
      return this.state.inType = i, r;
    }
    flowParsePredicate() {
      let s = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(Lt.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (s.value = super.parseExpression(), this.expect(11), this.finishNode(s, "DeclaredPredicate")) : this.finishNode(s, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, r = null;
      return this.match(54) ? (this.state.inType = s, r = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = s, this.
      match(54) && (r = this.flowParsePredicate())), [i, r];
    }
    flowParseDeclareClass(s) {
      return this.next(), this.flowParseInterfaceish(s, !0), this.finishNode(s, "DeclareClass");
    }
    flowParseDeclareFunction(s) {
      this.next();
      let i = s.id = this.parseIdentifier(), r = this.startNode(), a = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return r.params = o.params, r.rest = o.rest, r.this = o._this, this.expect(11), [r.returnType, s.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(s.id.name, 2048, s.id.loc.start), this.finishNode(s, "DeclareFunction");
    }
    flowParseDeclare(s, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(s);
      if (this.match(68))
        return this.flowParseDeclareFunction(s);
      if (this.match(74))
        return this.flowParseDeclareVariable(s);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(s) : (i && this.raise(Lt.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(s));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(s);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(s);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(s);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(s, i);
      this.unexpected();
    }
    flowParseDeclareVariable(s) {
      return this.next(), s.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(s.id.name, 5, s.id.loc.start), this.semicolon(),
      this.finishNode(s, "DeclareVariable");
    }
    flowParseDeclareModule(s) {
      this.scope.enter(0), this.match(134) ? s.id = super.parseExprAtom() : s.id = this.parseIdentifier();
      let i = s.body = this.startNode(), r = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Lt.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Lt.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), r.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return r.forEach((l) => {
        pnt(l) ? (a === "CommonJS" && this.raise(Lt.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Lt.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Lt.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), s.kind = a || "CommonJS", this.finishNode(s, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(s, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? s.declaration = this.flowParseDeclare(this.startNode()) : (s.declaration = this.flowParseType(),
        this.semicolon()), s.default = !0, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let r = this.state.value;
        throw this.raise(Lt.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: r,
          suggestion: hnt[r]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return s.declaration = this.flowParseDeclare(this.startNode()), s.default = !1, this.finishNode(s, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return s = this.parseExport(s, null), s.type === "ExportNamedDeclaration" && (s.type = "ExportDeclaration", s.default = !1, delete s.
        exportKind), s.type = "Declare" + s.type, s;
      this.unexpected();
    }
    flowParseDeclareModuleExports(s) {
      return this.next(), this.expectContextual(111), s.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(s,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(s) {
      this.next();
      let i = this.flowParseTypeAlias(s);
      return i.type = "DeclareTypeAlias", i;
    }
    flowParseDeclareOpaqueType(s) {
      this.next();
      let i = this.flowParseOpaqueType(s, !0);
      return i.type = "DeclareOpaqueType", i;
    }
    flowParseDeclareInterface(s) {
      return this.next(), this.flowParseInterfaceish(s, !1), this.finishNode(s, "DeclareInterface");
    }
    flowParseInterfaceish(s, i) {
      if (s.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(s.id.name, i ? 17 : 8201, s.id.loc.start), this.match(47) ?
      s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (s.implements = [], s.mixins = [], this.eatContextual(117))
          do
            s.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            s.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      s.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let s = this.startNode();
      return s.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() :
      s.typeParameters = null, this.finishNode(s, "InterfaceExtends");
    }
    flowParseInterface(s) {
      return this.flowParseInterfaceish(s, !1), this.finishNode(s, "InterfaceDeclaration");
    }
    checkNotUnderscore(s) {
      s === "_" && this.raise(Lt.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(s, i, r) {
      cnt.has(s) && this.raise(r ? Lt.AssignReservedType : Lt.UnexpectedReservedType, i, {
        reservedType: s
      });
    }
    flowParseRestrictedIdentifier(s, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(s);
    }
    flowParseTypeAlias(s) {
      return s.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.
      typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(s, "TypeAlias");
    }
    flowParseOpaqueType(s, i) {
      return this.expectContextual(130), s.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.
      start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.supertype = null, this.
      match(14) && (s.supertype = this.flowParseTypeInitialiser(14)), s.impltype = null, i || (s.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(s, "OpaqueType");
    }
    flowParseTypeParameter(s = !1) {
      let i = this.state.startLoc, r = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return r.name = o.name, r.variance = a, r.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) :
      s && this.raise(Lt.MissingTypeParamDefault, i), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let s = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = !1;
      do {
        let a = this.flowParseTypeParameter(r);
        i.params.push(a), a.default && (r = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = s, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(s) {
      if (this.curContext() !== Xs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let s = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, s.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let r = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          s.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = r;
      }), this.state.inType = i, !this.state.inType && this.curContext() === Xs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      s, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let s = this.startNode(), i = this.state.inType;
      for (s.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        s.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(s, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let s = this.startNode();
      if (this.expectContextual(129), s.extends = [], this.eat(81))
        do
          s.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return s.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(s, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(s, i, r) {
      return s.static = i, this.lookahead().type === 14 ? (s.id = this.flowParseObjectPropertyKey(), s.key = this.flowParseTypeInitialiser()) :
      (s.id = null, s.key = this.flowParseType()), this.expect(3), s.value = this.flowParseTypeInitialiser(), s.variance = r, this.finishNode(
      s, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(s, i) {
      return s.static = i, s.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (s.method =
      !0, s.optional = !1, s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start))) : (s.method = !1, this.eat(17) && (s.
      optional = !0), s.value = this.flowParseTypeInitialiser()), this.finishNode(s, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(s) {
      for (s.params = [], s.rest = null, s.typeParameters = null, s.this = null, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (s.this = this.flowParseFunctionTypeParam(!0), s.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        s.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), s.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(s, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(s, i) {
      let r = this.startNode();
      return s.static = i, s.value = this.flowParseObjectTypeMethodish(r), this.finishNode(s, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: s,
      allowExact: i,
      allowSpread: r,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, h = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let d = !1, y = null, m = null, T = this.startNode();
        if (a && this.isContextual(118)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), y = this.state.startLoc, s = !1);
        }
        if (s && this.isContextual(106)) {
          let E = this.lookahead();
          E.type !== 14 && E.type !== 17 && (this.next(), d = !0);
        }
        let b = this.flowParseVariance();
        if (this.eat(0))
          y != null && this.unexpected(y), this.eat(0) ? (b && this.unexpected(b.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          T, d))) : u.indexers.push(this.flowParseObjectTypeIndexer(T, d, b));
        else if (this.match(10) || this.match(47))
          y != null && this.unexpected(y), b && this.unexpected(b.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(T, d));
        else {
          let E = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let K = this.lookahead();
            PX(K.type) && (E = this.state.value, this.next());
          }
          let w = this.flowParseObjectTypeProperty(T, d, y, b, E, r, o ?? !p);
          w === null ? (h = !0, m = this.state.lastTokStartLoc) : u.properties.push(w);
        }
        this.flowObjectTypeSemicolon(), m && !this.match(8) && !this.match(9) && this.raise(Lt.UnexpectedExplicitInexactInObject, m);
      }
      this.expect(c), r && (u.inexact = h);
      let f = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, f;
    }
    flowParseObjectTypeProperty(s, i, r, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Lt.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Lt.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Lt.InexactVariance, a), null) : (l || this.raise(
        Lt.UnexpectedSpreadType, this.state.lastTokStartLoc), r != null && this.unexpected(r), a && this.raise(Lt.SpreadVariance, a), s.argument =
        this.flowParseType(), this.finishNode(s, "ObjectTypeSpreadProperty"));
      {
        s.key = this.flowParseObjectPropertyKey(), s.static = i, s.proto = r != null, s.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (s.method = !0, r != null && this.unexpected(r), a && this.unexpected(a.loc.start), s.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(s),
        !l && s.key.name === "constructor" && s.value.this && this.raise(Lt.ThisParamBannedInConstructor, s.value.this)) : (o !== "init" && this.
        unexpected(), s.method = !1, this.eat(17) && (c = !0), s.value = this.flowParseTypeInitialiser(), s.variance = a), s.optional = c, this.
        finishNode(s, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(s) {
      let i = s.kind === "get" ? 0 : 1, r = s.value.params.length + (s.value.rest ? 1 : 0);
      s.value.this && this.raise(s.kind === "get" ? Lt.GetterMayNotHaveThisParam : Lt.SetterMayNotHaveThisParam, s.value.this), r !== i && this.
      raise(s.kind === "get" ? Z.BadGetterArity : Z.BadSetterArity, s), s.kind === "set" && s.value.rest && this.raise(Z.BadSetterRestParameter,
      s);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(s, i) {
      s ?? (s = this.state.startLoc);
      let r = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(s);
        a.qualification = r, a.id = this.flowParseRestrictedIdentifier(!0), r = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return r;
    }
    flowParseGenericType(s, i) {
      let r = this.startNodeAt(s);
      return r.typeParameters = null, r.id = this.flowParseQualifiedTypeIdentifier(s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(r, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let s = this.startNode();
      return this.expect(87), s.argument = this.flowParsePrimaryType(), this.finishNode(s, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let s = this.startNode();
      for (s.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (s.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(s, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(s) {
      let i = null, r = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !s && this.raise(Lt.ThisParamMustBeFirst, o), i = this.parseIdentifier(u), this.eat(17) &&
      (r = !0, u && this.raise(Lt.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = r, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(s) {
      let i = this.startNodeAt(s.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = s, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(s = []) {
      let i = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(!0), r.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        s.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: s,
        rest: i,
        _this: r
      };
    }
    flowIdentToTypeAnnotation(s, i, r) {
      switch (r.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r.name), this.flowParseGenericType(s, r);
      }
    }
    flowParsePrimaryType() {
      let s = this.state.startLoc, i = this.startNode(), r, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r = this.flowParseFunctionTypeParams(), u.params =
          r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (zs(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? r = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : r = this.flowParseFunctionTypeParams(),
          u.params = r.params, u.rest = r.rest, u.this = r._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(Lt.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (u2(this.state.type)) {
            let u = zc(this.state.type);
            return this.next(), super.createIdentifier(i, u);
          } else if (zs(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let s = this.state.startLoc, i = this.flowParsePrimaryType(), r = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(s), o = this.eat(18);
        r = r || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), r ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let s = this.startNode();
      return this.eat(17) ? (s.typeAnnotation = this.flowParsePrefixType(), this.finishNode(s, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let s = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(s.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(s)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return s;
    }
    flowParseIntersectionType() {
      let s = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (s.types = [i]; this.eat(45); )
        s.types.push(this.flowParseAnonFunctionWithoutParens());
      return s.types.length === 1 ? i : this.finishNode(s, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let s = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (s.types = [i]; this.eat(43); )
        s.types.push(this.flowParseIntersectionType());
      return s.types.length === 1 ? i : this.finishNode(s, "UnionTypeAnnotation");
    }
    flowParseType() {
      let s = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = s, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let s = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(s, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let s = this.startNode();
      return s.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(s, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(s) {
      let i = s ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    flowParseVariance() {
      let s = null;
      return this.match(53) ? (s = this.startNode(), this.state.value === "+" ? s.kind = "plus" : s.kind = "minus", this.next(), this.finishNode(
      s, "Variance")) : s;
    }
    parseFunctionBody(s, i, r = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(s, () => super.parseFunctionBody(s, !0, r));
        return;
      }
      super.parseFunctionBody(s, !1, r);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), s.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(s, i, r);
    }
    parseStatementLike(s) {
      if (this.state.strict && this.isContextual(129)) {
        let r = this.lookahead();
        if (Eo(r.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      let i = super.parseStatementLike(s);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(s, i, r) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || zs(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(s);
        } else if (zs(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(s);
          if (i.name === "type")
            return this.flowParseTypeAlias(s);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(s, !1);
        }
      }
      return super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      let {
        type: s
      } = this.state;
      return s === 126 || pX(s) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: s
      } = this.state;
      return s === 126 || pX(s) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let f = this.lookaheadCharCode();
        if (f === 44 || f === 61 || f === 58 || f === 41)
          return this.setOptionalParametersError(r), s;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(i), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, h] = this.getArrowLikeExpressions(u);
      if (c || h.length > 0) {
        let f = [...o];
        if (h.length > 0) {
          this.state = a, this.state.noArrowAt = f;
          for (let d = 0; d < h.length; d++)
            f.push(h[d].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, h] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Lt.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, f.push(p[0].start),
        this.state.noArrowAt = f, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = s, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let s = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: s,
        failed: i
      };
    }
    getArrowLikeExpressions(s, i) {
      let r = [s], a = [];
      for (; r.length !== 0; ) {
        let o = r.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), r.push(o.body)) : o.type === "ConditionalExpression" && (r.push(o.consequent), r.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : fnt(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(s) {
      var i;
      this.toAssignableList(s.params, (i = s.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(s, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(s, i) {
      let r;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), r = i(), this.state.noArrowParamsConversionAt.pop()) : r = i(), r;
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(s) {
      s.type === "ImportDeclaration" && (s.importKind === "type" || s.importKind === "typeof") || s.type === "ExportNamedDeclaration" && s.exportKind ===
      "type" || s.type === "ExportAllDeclaration" && s.exportKind === "type" || super.assertModuleNodeAllowed(s);
    }
    parseExportDeclaration(s) {
      if (this.isContextual(130)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (s.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(s), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        s.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        s.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(s);
    }
    eatExportStar(s) {
      return super.eatExportStar(s) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (s.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(s) {
      let {
        startLoc: i
      } = this.state, r = super.maybeParseExportNamespaceSpecifier(s);
      return r && s.exportKind === "type" && this.unexpected(i), r;
    }
    parseClassId(s, i, r) {
      super.parseClassId(s, i, r), this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(s, i, r) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(s, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(s, i, r), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(Lt.DeclareClassElement, a) : i.value && this.raise(Lt.DeclareClassFieldInitializer, i.value));
    }
    isIterator(s) {
      return s === "iterator" || s === "asyncIterator";
    }
    readIterator() {
      let s = super.readWord1(), i = "@@" + s;
      (!this.isIterator(s) || !this.state.inType) && this.raise(Z.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      s === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (s === 62 || s === 60) ? this.finishOp(s === 62 ? 48 : 47, 1) : this.
      state.inType && s === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Xrt(s, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(s);
    }
    isAssignable(s, i) {
      return s.type === "TypeCastExpression" ? this.isAssignable(s.expression, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      !i && s.type === "AssignmentExpression" && s.left.type === "TypeCastExpression" && (s.left = this.typeCastToParameter(s.left)), super.
      toAssignable(s, i);
    }
    toAssignableList(s, i, r) {
      for (let a = 0; a < s.length; a++) {
        let o = s[a];
        o?.type === "TypeCastExpression" && (s[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(s, i, r);
    }
    toReferencedList(s, i) {
      for (let a = 0; a < s.length; a++) {
        var r;
        let o = s[a];
        o && o.type === "TypeCastExpression" && !((r = o.extra) != null && r.parenthesized) && (s.length > 1 || !i) && this.raise(Lt.TypeCastInPattern,
        o.typeAnnotation);
      }
      return s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return i && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(s, i, r) {
      return s === "TypeCastExpression" || super.isValidLVal(s, i, r);
    }
    parseClassProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(s) {
      return !this.match(14) && super.isNonstaticConstructor(s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(s, i, r, a, o, l), i.params && o) {
        let u = i.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Lt.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let u = i.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Lt.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(s, i, r, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(s, i, r, a);
    }
    parseClassSuper(s) {
      if (super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = s.implements = [];
        do {
          let r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.
          typeParameters = null, i.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(s) {
      super.checkGetterSetterParams(s);
      let i = this.getObjectOrClassMethodParams(s);
      if (i.length > 0) {
        let r = i[0];
        this.isThisParam(r) && s.kind === "get" ? this.raise(Lt.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(Lt.SetterMayNotHaveThisParam,
        r);
      }
    }
    parsePropertyNamePrefixOperator(s) {
      s.variance = this.flowParseVariance();
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(s, i, r, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseFunctionParamType(s) {
      return this.eat(17) && (s.type !== "Identifier" && this.raise(Lt.PatternIsOptional, s), this.isThisParam(s) && this.raise(Lt.ThisParamMayNotBeOptional,
      s), s.optional = !0), this.match(14) ? s.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(s) && this.raise(Lt.ThisParamAnnotationRequired,
      s), this.match(29) && this.isThisParam(s) && this.raise(Lt.ThisParamNoDefault, s), this.resetEndLocation(s), s;
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(Lt.TypeBeforeInitializer,
      r.typeAnnotation), r;
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(Lt.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(s, i, r) {
      i.local = mX(s) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), s.specifiers.push(this.finishImportSpecifier(i,
      r));
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        if (!s) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      if (super.applyImportPhase(s, i, r, a), i) {
        if (!r && this.match(65))
          return;
        s.exportKind = r === "type" ? r : "value";
      } else
        r === "type" && this.match(55) && this.unexpected(), s.importKind = r === "type" || r === "typeof" ? r : "value";
    }
    parseImportSpecifier(s, i, r, a, o) {
      let l = s.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let h = this.parseIdentifier(!0);
        u !== null && !Eo(this.state.type) ? (s.imported = h, s.importKind = u, s.local = yu(h)) : (s.imported = l, s.importKind = null, s.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Eo(this.state.type))
          s.imported = this.parseIdentifier(!0), s.importKind = u;
        else {
          if (i)
            throw this.raise(Z.ImportBindingIsString, s, {
              importName: l.value
            });
          s.imported = l, s.importKind = null;
        }
        this.eatContextual(93) ? s.local = this.parseIdentifier() : (c = !0, s.local = yu(s.imported));
      }
      let p = mX(s);
      return r && p && this.raise(Lt.ImportTypeShorthandOnlyInPureImport, s), (r || p) && this.checkReservedType(s.local.name, s.local.loc.start,
      !0), c && !r && !p && this.checkReservedWord(s.local.name, s.loc.start, !0, !0), this.finishImportSpecifier(s, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(s, i) {
      let r = s.kind;
      r !== "get" && r !== "set" && this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), this.match(14) && (s.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      if (this.match(14)) {
        let r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, s.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(s, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(s, i) {
      var r;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(s, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Xs.j_oTag || p === Xs.j_expr) && c.pop();
      }
      if ((r = o) != null && r.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((f) => {
          var d;
          c = this.flowParseTypeParameterDeclaration();
          let y = this.forwardNoArrowParamsConversionAt(c, () => {
            let T = super.parseMaybeAssign(s, i);
            return this.resetStartLocationFromNode(T, c), T;
          });
          (d = y.extra) != null && d.parenthesized && f();
          let m = this.maybeUnwrapTypeCastExpression(y);
          return m.type !== "ArrowFunctionExpression" && f(), m.typeParameters = c, this.resetStartLocationFromNode(m, c), y;
        }, a), h = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Lt.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          h = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (h)
          return this.state = p.failState, h;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Lt.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), s.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(s);
    }
    shouldParseArrow(s) {
      return this.match(14) || super.shouldParseArrow(s);
    }
    setArrowFunctionParameters(s, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)) ? s.params = i : super.setArrowFunctionParameters(s, i);
    }
    checkParams(s, i, r, a = !0) {
      if (!(r && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(s.start)))) {
        for (let o = 0; o < s.params.length; o++)
          this.isThisParam(s.params[o]) && o > 0 && this.raise(Lt.ThisParamMustBeFirst, s.params[o]);
        super.checkParams(s, i, r, a);
      }
    }
    parseParenAndDistinguishExpression(s) {
      return super.parseParenAndDistinguishExpression(s && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(s, i, r) {
      if (s.type === "Identifier" && s.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = s, a.arguments = super.parseCallExpressionArguments(11), s = this.finishNode(a, "CallExpression");
      } else if (s.type === "Identifier" && s.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(i) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(s, i, r), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(s, i, r);
    }
    parseSubscript(s, i, r, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, r)
          return a.stop = !0, s;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = s, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = s;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      super.parseNewCallee(s);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), s.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(s) {
      let i = this.startNodeAt(s);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(s);
    }
    readToken_pipe_amp(s) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (s === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(s);
    }
    parseTopLevel(s, i) {
      let r = super.parseTopLevel(s, i);
      return this.state.hasFlowComment && this.raise(Lt.UnterminatedFlowComment, this.state.curPosition()), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Lt.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let s = this.skipFlowComment();
        s && (this.state.pos += s, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: s
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(s + i)); )
        i++;
      let r = this.input.charCodeAt(i + s), a = this.input.charCodeAt(i + s + 1);
      return r === 58 && a === 58 ? i + 2 : this.input.slice(i + s, i + s + 12) === "flow-include" ? i + 12 : r === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(Z.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(s, {
      enumName: i,
      memberName: r
    }) {
      this.raise(Lt.EnumBooleanMemberNotInitialized, s, {
        memberName: r,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(s, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? Lt.EnumInvalidMemberInitializerSymbolType : Lt.EnumInvalidMemberInitializerPrimaryType :
      Lt.EnumInvalidMemberInitializerUnknownType, s, i);
    }
    flowEnumErrorNumberMemberNotInitialized(s, i) {
      this.raise(Lt.EnumNumberMemberNotInitialized, s, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(s, i) {
      this.raise(Lt.EnumStringMemberInconsistentlyInitialized, s, i);
    }
    flowEnumMemberInit() {
      let s = this.state.startLoc, i = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let r = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 134: {
          let r = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        case 85:
        case 86: {
          let r = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: r.loc.start,
            value: r
          } : {
            type: "invalid",
            loc: s
          };
        }
        default:
          return {
            type: "invalid",
            loc: s
          };
      }
    }
    flowEnumMemberRaw() {
      let s = this.state.startLoc, i = this.parseIdentifier(!0), r = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: s
      };
      return {
        id: i,
        init: r
      };
    }
    flowEnumCheckExplicitTypeMismatch(s, i, r) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== r && this.flowEnumErrorInvalidMemberInitializer(s, i);
    }
    flowEnumMembers({
      enumName: s,
      explicitType: i
    }) {
      let r = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Lt.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: s
        }), r.has(p) && this.raise(Lt.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: s
        }), r.add(p);
        let h = {
          enumName: s,
          explicitType: i,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, h, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, h);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, h);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, h);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(s, i, {
      enumName: r
    }) {
      if (s.length === 0)
        return i;
      if (i.length === 0)
        return s;
      if (i.length > s.length) {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: r
          });
        return s;
      }
    }
    flowEnumParseExplicitType({
      enumName: s
    }) {
      if (!this.eatContextual(102)) return null;
      if (!zs(this.state.type))
        throw this.raise(Lt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: s
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(Lt.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: s,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(s, i) {
      let r = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: r
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: r,
        explicitType: o
      });
      switch (s.hasUnknownMembers = u, o) {
        case "boolean":
          return s.explicitType = !0, s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
        case "number":
          return s.explicitType = !0, s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
        case "string":
          return s.explicitType = !0, s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: r
          }), this.expect(8), this.finishNode(s, "EnumStringBody");
        case "symbol":
          return s.members = l.defaultedMembers, this.expect(8), this.finishNode(s, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (s.members = [], this.expect(8), this.finishNode(s, "EnumStringBody")), "empty");
          s.explicitType = !1;
          let p = l.booleanMembers.length, h = l.numberMembers.length, f = l.stringMembers.length, d = l.defaultedMembers.length;
          if (!p && !h && !f && !d)
            return c();
          if (!p && !h)
            return s.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: r
            }), this.expect(8), this.finishNode(s, "EnumStringBody");
          if (!h && !f && p >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
          } else if (!p && !f && h >= d) {
            for (let y of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
                enumName: r,
                memberName: y.id.name
              });
            return s.members = l.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
          } else
            return this.raise(Lt.EnumInconsistentMemberValues, a, {
              enumName: r
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(s) {
      let i = this.parseIdentifier();
      return s.id = i, s.body = this.flowEnumBody(this.startNode(), i), this.finishNode(s, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(s) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (s.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(s);
    }
    isLookaheadToken_lt() {
      let s = this.nextTokenStart();
      if (this.input.charCodeAt(s) === 60) {
        let i = this.input.charCodeAt(s + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    maybeUnwrapTypeCastExpression(s) {
      return s.type === "TypeCastExpression" ? s.expression : s;
    }
  }, "flow"), ynt = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Nh = mu`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Xc(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(Xc, "isFragment");
  function Rd(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Rd(t.object) + "." + Rd(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Rd, "getQualifiedJSXName");
  var gnt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let s = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Nh.UnterminatedJsxContent, this.state.startLoc);
        let r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r);
              return;
            }
            s += this.input.slice(i, this.state.pos), this.finishToken(142, s);
            return;
          case 38:
            s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Ud(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(s) {
      let i = this.input.charCodeAt(this.state.pos), r;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = s ? `
` : `\r
`) : r = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(s) {
      let i = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Z.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === s) break;
        a === 38 ? (i += this.input.slice(r, this.state.pos), i += this.jsxReadEntity(), r = this.state.pos) : Ud(a) ? (i += this.input.slice(
        r, this.state.pos), i += this.jsxReadNewLine(!1), r = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(r, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let s = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let r = this.readInt(i, void 0, !1, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let i = 0, r = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (r) {
          let a = this.input.slice(s, this.state.pos), o = ynt[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = s, "&";
    }
    jsxReadWord() {
      let s, i = this.state.pos;
      do
        s = this.input.charCodeAt(++this.state.pos);
      while (qd(s) || s === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let s = this.startNode();
      return this.match(141) ? s.name = this.state.value : u2(this.state.type) ? s.name = zc(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(s, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let s = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let r = this.startNodeAt(s);
      return r.namespace = i, r.name = this.jsxParseIdentifier(), this.finishNode(r, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let s = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let r = this.startNodeAt(s);
        r.object = i, r.property = this.jsxParseIdentifier(), i = this.finishNode(r, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let s;
      switch (this.state.type) {
        case 5:
          return s = this.startNode(), this.setContext(Xs.brace), this.next(), s = this.jsxParseExpressionContainer(s, Xs.j_oTag), s.expression.
          type === "JSXEmptyExpression" && this.raise(Nh.AttributeIsEmpty, s), s;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(Nh.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let s = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(s, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(s) {
      return this.next(), s.expression = this.parseExpression(), this.setContext(Xs.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(s, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(s, i) {
      if (this.match(8))
        s.expression = this.jsxParseEmptyExpression();
      else {
        let r = this.parseExpression();
        s.expression = r;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let s = this.startNode();
      return this.match(5) ? (this.setContext(Xs.brace), this.next(), this.expect(21), s.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Xs.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadAttribute")) : (s.name = this.jsxParseNamespacedName(),
      s.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(s, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(s) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return s.attributes = i, s.selfClosing = this.eat(56), this.expect(144), this.finishNode(s, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(s) {
      let i = this.startNodeAt(s);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(s) {
      let i = this.startNodeAt(s), r = [], a = this.jsxParseOpeningElementAt(s), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (s = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(s);
                break e;
              }
              r.push(this.jsxParseElementAt(s));
              break;
            case 142:
              r.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Xs.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(l)) : r.push(this.jsxParseExpressionContainer(
              l, Xs.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Xc(a) && !Xc(o) && o !== null ? this.raise(Nh.MissingClosingTagFragment, o) : !Xc(a) && Xc(o) ? this.raise(Nh.MissingClosingTagElement,
        o, {
          openingTagName: Rd(a.name)
        }) : !Xc(a) && !Xc(o) && Rd(o.name) !== Rd(a.name) && this.raise(Nh.MissingClosingTagElement, o, {
          openingTagName: Rd(a.name)
        });
      }
      if (Xc(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = r, this.match(
      47))
        throw this.raise(Nh.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Xc(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let s = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(s);
    }
    setContext(s) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = s;
    }
    parseExprAtom(s) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(s);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(s) {
      let i = this.curContext();
      if (i === Xs.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === Xs.j_oTag || i === Xs.j_cTag) {
        if (du(s)) {
          this.jsxReadWord();
          return;
        }
        if (s === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((s === 34 || s === 39) && i === Xs.j_oTag) {
          this.jsxReadString(s);
          return;
        }
      }
      if (s === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(s);
    }
    updateContext(s) {
      let {
        context: i,
        type: r
      } = this.state;
      if (r === 56 && s === 143)
        i.splice(-2, 2, Xs.j_cTag), this.state.canStartJSXElement = !1;
      else if (r === 143)
        i.push(Xs.j_oTag);
      else if (r === 144) {
        let a = i[i.length - 1];
        a === Xs.j_oTag && s === 56 || a === Xs.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Xs.j_expr) : (this.setContext(
        Xs.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = _rt(r);
    }
  }, "jsx"), QO = class extends Xg {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, ZO = class extends zg {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new QO(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, s) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(e))
        return !0;
      if (!s && i > 1) {
        for (let r = 0; r < i - 1; r++)
          if (this.importsStack[r].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, s, i) {
      if (s & 4096) {
        this.hasImport(e, !0) && this.parser.raise(Z.VarRedeclaration, i, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let r = this.currentScope(), a = r.tsNames.get(e) || 0;
      if (s & 1024) {
        this.maybeExportDefined(r, e), r.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, s, i), s & 2 && (s & 1 || (this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e)), a = a | 1),
      s & 256 && (a = a | 2), s & 512 && (a = a | 4), s & 128 && (a = a | 8), a && r.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, s, i) {
      let r = e.tsNames.get(s);
      if ((r & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (r & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (r & 8) > 0 ? e.names.get(s) & 2 ? !!(i & 1) : !1 : i & 2 && (r & 1) > 0 ? !0 : super.isRedeclaredInScope(e, s, i);
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      if (this.hasImport(s)) return;
      let i = this.scopeStack.length;
      for (let r = i - 1; r >= 0; r--) {
        let o = this.scopeStack[r].tsNames.get(s);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, _X = /* @__PURE__ */ n((t) => t.type === "ParenthesizedExpression" ? _X(t.expression) : t, "unwrapParenthesizedExpression"), e2 = class extends GO {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, s = !1) {
      var i, r;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (i = e.extra) != null && i.parenthesized) && (a = _X(e), s ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(Z.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(Z.InvalidParenthesizedAssignment, e) : this.raise(Z.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], h = l === c;
            this.toAssignableObjectExpressionProp(p, h, s), h && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(Z.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, s);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (r = e.extra) == null ? void 0 : r.trailingCommaLoc, s);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(Z.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, s);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, s);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, s, i) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? Z.PatternHasAccessor : Z.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let r = e.argument;
        this.checkToRestConversion(r, !1), this.toAssignable(r, i), s || this.raise(Z.RestTrailingComma, e);
      } else
        this.toAssignable(e, i);
    }
    toAssignableList(e, s, i) {
      let r = e.length - 1;
      for (let a = 0; a <= r; a++) {
        let o = e[a];
        o && (this.toAssignableListItem(e, a, i), o.type === "RestElement" && (a < r ? this.raise(Z.RestTrailingComma, o) : s && this.raise(
        Z.RestTrailingComma, s)));
      }
    }
    toAssignableListItem(e, s, i) {
      let r = e[s];
      if (r.type === "SpreadElement") {
        r.type = "RestElement";
        let a = r.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(r, i);
    }
    isAssignable(e, s) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let i = e.properties.length - 1;
          return e.properties.every((r, a) => r.type !== "ObjectMethod" && (a === i || r.type !== "SpreadElement") && this.isAssignable(r));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !s;
        default:
          return !1;
      }
    }
    toReferencedList(e, s) {
      return e;
    }
    toReferencedListDeep(e, s) {
      this.toReferencedList(e, s);
      for (let i of e)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(e) {
      let s = this.startNode();
      return this.next(), s.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(s, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, s, i) {
      let r = i & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), r && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(s)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(Z.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: s
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return e === 139 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(this.state.value, s), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, s, !1, !1, !0, !1);
    }
    parseBindingElement(e, s) {
      let i = this.parseMaybeDefault();
      (this.hasPlugin("flow") || e & 2) && this.parseFunctionParamType(i);
      let r = this.parseMaybeDefault(i.loc.start, i);
      return s.length && (i.decorators = s), r;
    }
    parseFunctionParamType(e) {
      return e;
    }
    parseMaybeDefault(e, s) {
      if (e ?? (e = this.state.startLoc), s = s ?? this.parseBindingAtom(), !this.eat(29)) return s;
      let i = this.startNodeAt(e);
      return i.left = s, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(e, s, i) {
      switch (e) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, s, i = 64, r = !1, a = !1, o = !1) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), s.type !== "AssignmentExpression" && this.raise(Z.InvalidLhsOptionalChaining,
        e, {
          ancestor: s
        })), i !== 64 && this.raise(Z.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, i, a);
        let {
          name: m
        } = e;
        r && (r.has(m) ? this.raise(Z.ParamDupe, e) : r.add(m));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && s.type === "AssignmentExpression", i);
      if (p === !0) return;
      if (p === !1) {
        let m = i === 64 ? Z.InvalidLhs : Z.InvalidLhsBinding;
        this.raise(m, e, {
          ancestor: s
        });
        return;
      }
      let h, f;
      typeof p == "string" ? (h = p, f = u === "ParenthesizedExpression") : [h, f] = p;
      let d = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : s, y = e[h];
      if (Array.isArray(y))
        for (let m of y)
          m && this.checkLVal(m, d, i, r, a, f);
      else y && this.checkLVal(y, d, i, r, a, f);
    }
    checkIdentifier(e, s, i = !1) {
      this.state.strict && (i ? IX(e.name, this.inModule) : wX(e.name)) && (s === 64 ? this.raise(Z.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(Z.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), s & 8192 && e.name === "let" && this.raise(Z.LetInLexicalBinding, e), s & 64 || this.declareNameFromIdentifier(e, s);
    }
    declareNameFromIdentifier(e, s) {
      this.scope.declareName(e.name, s, e.loc.start);
    }
    checkToRestConversion(e, s) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, s);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (s) break;
        default:
          this.raise(Z.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? Z.RestTrailingComma : Z.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  };
  function Tnt(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(Tnt, "nonNull");
  function yX(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(yX, "assert");
  var ut = mu`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function bnt(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(bnt, "keywordTypeFromName");
  function gX(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(gX, "tsIsAccessModifier");
  function xnt(t) {
    return t === "in" || t === "out";
  }
  n(xnt, "tsIsVarianceAnnotations");
  var Snt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...s) {
      super(...s), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ut.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ut.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ut.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return ZO;
    }
    tsIsIdentifier() {
      return zs(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(s, i) {
      if (!zs(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let r = this.state.value;
      if (s.includes(r)) {
        if (i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers({
      allowedModifiers: s,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: r,
      errorTemplate: a = ut.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, h, f) => {
        p === h && o[f] && this.raise(ut.InvalidModifiersOrder, c, {
          orderedModifiers: [h, f]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, h, f) => {
        (o[h] && p === f || o[f] && p === h) && this.raise(ut.IncompatibleModifiers, c, {
          modifiers: [h, f]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(s.concat(i ?? []), r);
        if (!p) break;
        gX(p) ? o.accessibility ? this.raise(ut.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : xnt(p) ? (o[p] && this.raise(ut.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(ut.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), i != null && i.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(s) {
      switch (s) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(s, i) {
      let r = [];
      for (; !this.tsIsListTerminator(s); )
        r.push(i());
      return r;
    }
    tsParseDelimitedList(s, i, r) {
      return Tnt(this.tsParseDelimitedListWorker(s, i, !0, r));
    }
    tsParseDelimitedListWorker(s, i, r, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(s); ) {
        l = -1;
        let u = i();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(s))
          break;
        r && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(s, i, r, a, o) {
      a || (r ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(s, i, o);
      return r ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let s = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? s.argument = this.parseStringLiteral(this.state.value) : (this.raise(ut.UnsupportedImportTypeArgument,
      this.state.startLoc), s.argument = super.parseExprAtom()), this.eat(12) && !this.match(11) ? (s.options = super.parseMaybeAssignAllowIn(),
      this.eat(12)) : s.options = null, this.expect(11), this.eat(16) && (s.qualifier = this.tsParseEntityName(3)), this.match(47) && (s.typeParameters =
      this.tsParseTypeArguments()), this.finishNode(s, "TSImportType");
    }
    tsParseEntityName(s) {
      let i;
      if (s & 1 && this.match(78))
        if (s & 2)
          i = this.parseIdentifier(!0);
        else {
          let r = this.startNode();
          this.next(), i = this.finishNode(r, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(s & 1));
      for (; this.eat(16); ) {
        let r = this.startNodeAtNode(i);
        r.left = i, r.right = this.parseIdentifier(!!(s & 1)), i = this.finishNode(r, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let s = this.startNode();
      return s.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(s, "TSTypeReference");
    }
    tsParseThisTypePredicate(s) {
      this.next();
      let i = this.startNodeAtNode(s);
      return i.parameterName = s, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let s = this.startNode();
      return this.next(), this.finishNode(s, "TSThisType");
    }
    tsParseTypeQuery() {
      let s = this.startNode();
      return this.expect(87), this.match(83) ? s.exprName = this.tsParseImportType() : s.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeQuery");
    }
    tsParseTypeParameter(s) {
      let i = this.startNode();
      return s(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(s) {
      if (this.match(47))
        return this.tsParseTypeParameters(s);
    }
    tsParseTypeParameters(s) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let r = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, s), !1, !0, r), i.params.
      length === 0 && this.raise(ut.EmptyTypeParameters, i), r.value !== -1 && this.addExtra(i, "trailingComma", r.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(s, i) {
      let r = s === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      r ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(s) : this.match(s) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(s));
    }
    tsParseBindingListForSignature() {
      let s = super.parseBindingList(11, 41, 2);
      for (let i of s) {
        let {
          type: r
        } = i;
        (r === "AssignmentPattern" || r === "TSParameterProperty") && this.raise(ut.UnsupportedSignatureParameterKind, i, {
          type: r
        });
      }
      return s;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(s, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, s);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), zs(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(s) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), s.parameters = [i];
      let r = this.tsTryParseTypeAnnotation();
      return r && (s.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(s, i) {
      this.eat(17) && (s.optional = !0);
      let r = s;
      if (this.match(10) || this.match(47)) {
        i && this.raise(ut.ReadonlyForMethodSignature, s);
        let a = r;
        a.kind && this.match(47) && this.raise(ut.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(Z.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(ut.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(Z.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(ut.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(ut.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            ut.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(ut.SetAccessorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = r;
        i && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let s = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", s);
      if (this.match(77)) {
        let r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", s) : (s.key = this.
        createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(s, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, s);
      let i = this.tsTryParseIndexSignature(s);
      return i || (super.parsePropertyName(s), !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (s.kind = s.key.name, super.parsePropertyName(s)), this.tsParsePropertyOrMethodSignature(s, !!s.readonly));
    }
    tsParseTypeLiteral() {
      let s = this.startNode();
      return s.members = this.tsParseObjectTypeMembers(), this.finishNode(s, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let s = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), s;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let s = this.startNode();
      this.expect(5), this.match(53) ? (s.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (s.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), s.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return s.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (s.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (s.optional = !0), s.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(s, "TSMappedType");
    }
    tsParseTupleType() {
      let s = this.startNode();
      s.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return s.elementTypes.forEach((r) => {
        let {
          type: a
        } = r;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && r.optional) && this.raise(ut.OptionalTypeBeforeRequired,
        r), i || (i = a === "TSNamedTupleMember" && r.optional || a === "TSOptionalType");
      }), this.finishNode(s, "TSTupleType");
    }
    tsParseTupleElementType() {
      let s = this.state.startLoc, i = this.eat(21), {
        startLoc: r
      } = this.state, a, o, l, u, p = Eo(this.state.type) ? this.lookaheadCharCode() : null;
      if (p === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (p === 63) {
        l = !0;
        let h = this.state.value, f = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(r), h), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = f, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let h;
        o ? (h = this.startNodeAt(r), h.optional = l, h.label = o, h.elementType = u, this.eat(17) && (h.optional = !0, this.raise(ut.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (h = this.startNodeAt(r), h.optional = l, this.raise(ut.InvalidTupleMemberLabel, u), h.label = u, h.
        elementType = this.tsParseType()), u = this.finishNode(h, "TSNamedTupleMember");
      } else if (l) {
        let h = this.startNodeAt(r);
        h.typeAnnotation = u, u = this.finishNode(h, "TSOptionalType");
      }
      if (i) {
        let h = this.startNodeAt(s);
        h.typeAnnotation = u, u = this.finishNode(h, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let s = this.startNode();
      return this.expect(10), s.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(s, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(s, i) {
      let r = this.startNode();
      return s === "TSConstructorType" && (r.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, r)), this.finishNode(r, s);
    }
    tsParseLiteralTypeNode() {
      let s = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          s.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(s, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let s = this.startNode();
        return s.literal = super.parseTemplate(!1), this.finishNode(s, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let s = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(s) : s;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let s = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: s
          } = this.state;
          if (zs(s) || s === 88 || s === 84) {
            let i = s === 88 ? "TSVoidKeyword" : s === 84 ? "TSNullKeyword" : bnt(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let r = this.startNode();
              return this.next(), this.finishNode(r, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: s
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let r = this.startNodeAt(s);
          r.elementType = i, this.expect(3), i = this.finishNode(r, "TSArrayType");
        } else {
          let r = this.startNodeAt(s);
          r.objectType = i, r.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(r, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let s = this.startNode(), i = this.state.value;
      return this.next(), s.operator = i, s.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      s), this.finishNode(s, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(s) {
      switch (s.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ut.UnexpectedReadonly, s);
      }
    }
    tsParseInferType() {
      let s = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), s.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(s, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let s = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return s;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Rrt(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(s, i, r) {
      let a = this.startNode(), o = this.eat(r), l = [];
      do
        l.push(i());
      while (this.eat(r));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, s));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (zs(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return this.parseObjectLike(8, !0), s.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: s
        } = this.state, i = s.length;
        try {
          return super.parseBindingList(3, 93, 1), s.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(s) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(s);
        let r = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (r.parameterName = u, r.asserts = !0, r.typeAnnotation = null, u = this.finishNode(r, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, r), u.asserts = !0), i.typeAnnotation = u, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (r.parameterName = this.parseIdentifier(), r.asserts = a, r.typeAnnotation = null, i.typeAnnotation = this.finishNode(r,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let l = this.tsParseTypeAnnotation(!1);
        return r.parameterName = o, r.typeAnnotation = l, r.asserts = a, i.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let s = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), s;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let s = this.state.containsEsc;
      return this.next(), !zs(this.state.type) && !this.match(78) ? !1 : (s && this.raise(Z.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(s = !0, i = this.startNode()) {
      return this.tsInType(() => {
        s && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      yX(this.state.inType);
      let s = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return s;
      let i = this.startNodeAtNode(s);
      return i.checkType = s, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ut.ReservedTypeAssertion, this.state.startLoc);
      let s = this.startNode();
      return s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), s.expression = this.parseMaybeUnary(), this.finishNode(s, "TSTypeAssertion");
    }
    tsParseHeritageClause(s) {
      let i = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return r.length || this.raise(ut.EmptyHeritageClauseType, i, {
        token: s
      }), r;
    }
    tsParseInterfaceDeclaration(s, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (s.declare = !0), zs(this.state.type) ? (s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, 130)) : (s.id = null, this.raise(ut.MissingInterfaceName, this.state.startLoc)), s.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (s.extends = this.tsParseHeritageClause("extends"));
      let r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), s.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(
      s, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(s) {
      return s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 2), s.typeAnnotation = this.tsInType(() => {
        if (s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(s, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(s) {
      if (this.curContext() !== Xs.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return s();
        } finally {
          this.state.context = i;
        }
      } else
        return s();
    }
    tsInType(s) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return s();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(s) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return s();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(s) {
      if (this.match(s))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(s) {
      return this.tsInType(() => (this.expect(s), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let s = this.startNode();
      return s.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (s.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(s, "TSEnumMember");
    }
    tsParseEnumDeclaration(s, i = {}) {
      return i.const && (s.const = !0), i.declare && (s.declare = !0), this.expectContextual(126), s.id = this.parseIdentifier(), this.checkIdentifier(
      s.id, s.const ? 8971 : 8459), this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(s, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let s = this.startNode();
      return this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      s, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let s = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(s.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      s, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(s, i = !1) {
      if (s.id = this.parseIdentifier(), i || this.checkIdentifier(s.id, 1024), this.eat(16)) {
        let r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, !0), s.body = r;
      } else
        this.scope.enter(256), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(s, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(s) {
      return this.isContextual(112) ? (s.kind = "global", s.global = !0, s.id = this.parseIdentifier()) : this.match(134) ? (s.kind = "modul\
e", s.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0),
      s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(s, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(s, i, r) {
      s.isExport = r || !1, s.id = i || this.parseIdentifier(), this.checkIdentifier(s.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return s.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(ut.ImportAliasHasImportType, a), s.moduleReference =
      a, this.semicolon(), this.finishNode(s, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let s = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), s.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExternalModuleReference");
    }
    tsLookAhead(s) {
      let i = this.state.clone(), r = s();
      return this.state = i, r;
    }
    tsTryParseAndCatch(s) {
      let i = this.tryParse((r) => s() || r());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(s) {
      let i = this.state.clone(), r = s();
      if (r !== void 0 && r !== !1)
        return r;
      this.state = i;
    }
    tsTryParseDeclare(s) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type, r;
      return this.isContextual(100) && (i = 74, r = "let"), this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return s.declare = !0, super.parseFunctionStatement(s, !1, !1);
          case 80:
            return s.declare = !0, this.parseClass(s, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(s, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(s);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (s.declare = !0, this.parseVarStatement(s, r || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(s, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(s, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (zs(i))
              return this.tsParseDeclaration(s, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(s, i, r) {
      switch (i.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(s);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = s;
            return a.kind = "global", s.global = !0, a.id = i, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(),
            this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(s, i.name, !1, r);
      }
    }
    tsParseDeclaration(s, i, r, a) {
      switch (i) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || zs(this.state.type)))
            return this.tsParseAbstractDeclaration(s, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(s);
            if (zs(this.state.type))
              return s.kind = "module", this.tsParseModuleOrNamespaceDeclaration(s);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && zs(this.state.type))
            return s.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(s);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && zs(this.state.type))
            return this.tsParseTypeAliasDeclaration(s);
          break;
      }
    }
    tsCheckLineTerminator(s) {
      return s ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(s) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let r = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(s);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!r)
        return super.parseArrowExpression(r, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let s = this.startNode();
      return s.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), s.params.length === 0 ? this.raise(ut.EmptyTypeArguments, s) : !this.state.inType && this.curContext() ===
      Xs.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return qrt(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(s, i) {
      let r = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(s & 4) && (o || u || l) && this.raise(ut.UnexpectedParameterModifier, r);
      let c = this.parseMaybeDefault();
      s & 2 && this.parseFunctionParamType(c);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let h = this.startNodeAt(r);
        return i.length && (h.decorators = i), o && (h.accessibility = o), u && (h.readonly = u), l && (h.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(ut.UnsupportedParameterPropertyKind, h), h.parameter = p, this.finishNode(h, "TSParamet\
erProperty");
      }
      return i.length && (c.decorators = i), p;
    }
    isSimpleParameter(s) {
      return s.type === "TSParameterProperty" && super.isSimpleParameter(s.parameter) || super.isSimpleParameter(s);
    }
    tsDisallowOptionalPattern(s) {
      for (let i of s.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(ut.PatternIsOptional, i);
    }
    setArrowFunctionParameters(s, i, r) {
      super.setArrowFunctionParameters(s, i, r), this.tsDisallowOptionalPattern(s);
    }
    parseFunctionBodyAndFinish(s, i, r = !1) {
      this.match(14) && (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(s, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(ut.DeclareFunctionHasImplementation, s), s.declare) ? super.parseFunctionBodyAndFinish(s, a, r) : (this.tsDisallowOptionalPattern(
      s), super.parseFunctionBodyAndFinish(s, i, r));
    }
    registerFunctionStatementId(s) {
      !s.body && s.id ? this.checkIdentifier(s.id, 1024) : super.registerFunctionStatementId(s);
    }
    tsCheckForInvalidTypeCasts(s) {
      s.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(ut.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(s, i) {
      return this.tsCheckForInvalidTypeCasts(s), s;
    }
    parseArrayLike(s, i, r, a) {
      let o = super.parseArrayLike(s, i, r, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(s, i, r, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(i);
        return l.expression = s, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (r)
          return a.stop = !0, s;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!r && this.atPossibleAsyncArrow(s)) {
            let f = this.tsTryParseGenericAsyncArrowFunction(i);
            if (f)
              return f;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (ZS(this.state.type)) {
            let f = super.parseTaggedTemplateExpression(s, i, a);
            return f.typeParameters = c, f;
          }
          if (!r && this.eat(10)) {
            let f = this.startNodeAt(i);
            return f.callee = s, f.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters =
            c, a.optionalChainMember && (f.optional = o), this.finishCallExpression(f, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Hg(p) && !this.hasPrecedingLineBreak())
            return;
          let h = this.startNodeAt(i);
          return h.expression = s, h.typeParameters = c, this.finishNode(h, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          ut.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(s, i, r, a);
    }
    parseNewCallee(s) {
      var i;
      super.parseNewCallee(s);
      let {
        callee: r
      } = s;
      r.type === "TSInstantiationExpression" && !((i = r.extra) != null && i.parenthesized) && (s.typeParameters = r.typeParameters, s.callee =
      r.expression);
    }
    parseExprOp(s, i, r) {
      let a;
      if (zS(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = s, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(Z.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, r);
      }
      return super.parseExprOp(s, i, r);
    }
    checkReservedWord(s, i, r, a) {
      this.state.isAmbientContext || super.checkReservedWord(s, i, r, a);
    }
    checkImportReflection(s) {
      super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(ut.ImportReflectionHasImportType, s.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(s) {
      if (super.isPotentialImportPhase(s)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return s ? i === 123 || i === 42 : i !== 61;
      }
      return !s && this.isContextual(87);
    }
    applyImportPhase(s, i, r, a) {
      super.applyImportPhase(s, i, r, a), i ? s.exportKind = r === "type" ? "type" : "value" : s.importKind = r === "type" || r === "typeof" ?
      r : "value";
    }
    parseImport(s) {
      if (this.match(134))
        return s.importKind = "value", super.parseImport(s);
      let i;
      if (zs(this.state.type) && this.lookaheadCharCode() === 61)
        return s.importKind = "value", this.tsParseImportEqualsDeclaration(s);
      if (this.isContextual(130)) {
        let r = this.parseMaybeImportPhase(s, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(s, r);
        i = super.parseImportSpecifiersAndAfter(s, r);
      } else
        i = super.parseImport(s);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ut.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(s, i) {
      if (this.match(83)) {
        let r = s;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, a, !0);
      } else if (this.eat(29)) {
        let r = s;
        return r.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let r = s;
        return this.expectContextual(128), r.id = this.parseIdentifier(), this.semicolon(), this.finishNode(r, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(s, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let s = this.startNode();
        return this.next(), s.abstract = !0, this.parseClass(s, !0, !0);
      }
      if (this.match(129)) {
        let s = this.tsParseInterfaceDeclaration(this.startNode());
        if (s) return s;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(s, i, r = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(s, i, r || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (i !== "const" || l.typeAnnotation ? this.raise(ut.InitializerNotAllowedInAmbientContext, u) : Ent(u, this.hasPlugin("estree")) ||
        this.raise(ut.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(s, i) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseStatementContent(s, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(s, i) {
      return i.some((r) => gX(r) ? s.accessibility === r : !!s[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(s, i, r) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ut.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(ut.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(s, i)) : this.parseClassMemberWithIsStatic(s, i, r, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(s, i, r, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        s.body.push(o), i.abstract && this.raise(ut.IndexSignatureHasAbstract, i), i.accessibility && this.raise(ut.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(ut.IndexSignatureHasDeclare, i), i.override && this.raise(ut.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(ut.NonAbstractClassHasAbstractMethod, i), i.override && (r.hadSuperClass || this.
      raise(ut.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(s, i, r, a);
    }
    parsePostMemberNameModifiers(s) {
      this.eat(17) && (s.optional = !0), s.readonly && this.match(10) && this.raise(ut.ClassMethodHasReadonly, s), s.declare && this.match(10) &&
      this.raise(ut.ClassMethodHasDeclare, s);
    }
    parseExpressionStatement(s, i, r) {
      return (i.type === "Identifier" ? this.tsParseExpressionStatement(s, i, r) : void 0) || super.parseExpressionStatement(s, i, r);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(s, i, r) {
      if (!this.match(17)) return s;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(r), s;
      }
      return super.parseConditional(s, i, r);
    }
    parseParenItem(s, i) {
      let r = super.parseParenItem(s, i);
      if (this.eat(17) && (r.optional = !0, this.resetEndLocation(s)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = s, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return s;
    }
    parseExportDeclaration(s) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(s));
      let i = this.state.startLoc, r = this.eatContextual(125);
      if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ut.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = zs(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(s);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || r) && (s.exportKind = "type"), r && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(s, i, r, a) {
      if ((!i || r) && this.isContextual(113))
        return;
      super.parseClassId(s, i, r, s.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (s.typeParameters = o);
    }
    parseClassPropertyAnnotation(s) {
      s.optional || (this.eat(35) ? s.definite = !0 : this.eat(17) && (s.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (s.typeAnnotation = i);
    }
    parseClassProperty(s) {
      if (this.parseClassPropertyAnnotation(s), this.state.isAmbientContext && !(s.readonly && !s.typeAnnotation) && this.match(29) && this.
      raise(ut.DeclareClassFieldHasInitializer, this.state.startLoc), s.abstract && this.match(29)) {
        let {
          key: i
        } = s;
        this.raise(ut.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !s.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(s);
    }
    parseClassPrivateProperty(s) {
      return s.abstract && this.raise(ut.PrivateElementHasAbstract, s), s.accessibility && this.raise(ut.PrivateElementHasAccessibility, s, {
        modifier: s.accessibility
      }), this.parseClassPropertyAnnotation(s), super.parseClassPrivateProperty(s);
    }
    parseClassAccessorProperty(s) {
      return this.parseClassPropertyAnnotation(s), s.optional && this.raise(ut.AccessorCannotBeOptional, s), super.parseClassAccessorProperty(
      s);
    }
    pushClassMethod(s, i, r, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(ut.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = i;
      c && (p === "get" || p === "set") && this.raise(ut.DeclareAccessor, i, {
        kind: p
      }), u && (i.typeParameters = u), super.pushClassMethod(s, i, r, a, o, l);
    }
    pushClassPrivateMethod(s, i, r, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(s, i, r, a);
    }
    declareClassPrivateMethodInScope(s, i) {
      s.type !== "TSDeclareMethod" && (s.type === "MethodDefinition" && !hasOwnProperty.call(s.value, "body") || super.declareClassPrivateMethodInScope(
      s, i));
    }
    parseClassSuper(s) {
      super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (s.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(s, i, r, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (s.typeParameters = c), super.parseObjPropValue(s, i, r, a, o, l, u);
    }
    parseFunctionParams(s, i) {
      let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      r && (s.typeParameters = r), super.parseFunctionParams(s, i);
    }
    parseVarId(s, i) {
      super.parseVarId(s, i), s.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (s.definite = !0);
      let r = this.tsTryParseTypeAnnotation();
      r && (s.id.typeAnnotation = r, this.resetEndLocation(s.id));
    }
    parseAsyncArrowFromCallExpression(s, i) {
      return this.match(14) && (s.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(s, i);
    }
    parseMaybeAssign(s, i) {
      var r, a, o, l, u;
      let c, p, h;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(s, i), c), !p.error) return p.node;
        let {
          context: y
        } = this.state, m = y[y.length - 1];
        (m === Xs.j_oTag || m === Xs.j_expr) && y.pop();
      }
      if (!((r = p) != null && r.error) && !this.match(47))
        return super.parseMaybeAssign(s, i);
      (!c || c === this.state) && (c = this.state.clone());
      let f, d = this.tryParse((y) => {
        var m, T;
        f = this.tsParseTypeParameters(this.tsParseConstModifier);
        let b = super.parseMaybeAssign(s, i);
        return (b.type !== "ArrowFunctionExpression" || (m = b.extra) != null && m.parenthesized) && y(), ((T = f) == null ? void 0 : T.params.
        length) !== 0 && this.resetStartLocationFromNode(b, f), b.typeParameters = f, b;
      }, c);
      if (!d.error && !d.aborted)
        return f && this.reportReservedArrowTypeParam(f), d.node;
      if (!p && (yX(!this.hasPlugin("jsx")), h = this.tryParse(() => super.parseMaybeAssign(s, i), c), !h.error))
        return h.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (d.node)
        return this.state = d.failState, f && this.reportReservedArrowTypeParam(f), d.node;
      if ((o = h) != null && o.node)
        return this.state = h.failState, h.node;
      throw ((l = p) == null ? void 0 : l.error) || d.error || ((u = h) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(s) {
      var i;
      s.params.length === 1 && !s.params[0].constraint && !((i = s.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(ut.ReservedArrowTypeParam, s);
    }
    parseMaybeUnary(s, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(s, i);
    }
    parseArrow(s) {
      if (this.match(14)) {
        let i = this.tryParse((r) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), s.returnType = i.node);
      }
      return super.parseArrow(s);
    }
    parseFunctionParamType(s) {
      this.eat(17) && (s.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i), this.resetEndLocation(s), s;
    }
    isAssignable(s, i) {
      switch (s.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(s.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(s, i);
      }
    }
    toAssignable(s, i = !1) {
      switch (s.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(s, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(ut.UnexpectedTypeCastInParameter, s) : this.raise(ut.UnexpectedTypeCastInParameter,
          s), this.toAssignable(s.expression, i);
          break;
        case "AssignmentExpression":
          !i && s.left.type === "TSTypeCastExpression" && (s.left = this.typeCastToParameter(s.left));
        default:
          super.toAssignable(s, i);
      }
    }
    toAssignableParenthesizedExpression(s, i) {
      switch (s.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(s.expression, i);
          break;
        default:
          super.toAssignable(s, i);
      }
    }
    checkToRestConversion(s, i) {
      switch (s.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(s.expression, !1);
          break;
        default:
          super.checkToRestConversion(s, i);
      }
    }
    isValidLVal(s, i, r) {
      switch (s) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (r !== 64 || !i) && ["expression", !0];
        default:
          return super.isValidLVal(s, i, r);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(s, i) {
      if (this.match(47) || this.match(51)) {
        let r = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(s, i);
          return a.typeParameters = r, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(s, i);
    }
    checkCommaAfterRest(s) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === s ? (this.next(), !1) : super.checkCommaAfterRest(
      s);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(s, i) {
      let r = super.parseMaybeDefault(s, i);
      return r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ut.TypeAnnotationAfterAssign,
      r.typeAnnotation), r;
    }
    getTokenFromCode(s) {
      if (this.state.inType) {
        if (s === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (s === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(s);
    }
    reScan_lt_gt() {
      let {
        type: s
      } = this.state;
      s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: s
      } = this.state;
      return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
    }
    toAssignableListItem(s, i, r) {
      let a = s[i];
      a.type === "TSTypeCastExpression" && (s[i] = this.typeCastToParameter(a)), super.toAssignableListItem(s, i, r);
    }
    typeCastToParameter(s) {
      return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
    }
    shouldParseArrow(s) {
      return this.match(14) ? s.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(s) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (s.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(s);
    }
    getGetterSetterExpectedParamCount(s) {
      let i = super.getGetterSetterExpectedParamCount(s), a = this.getObjectOrClassMethodParams(s)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let s = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (s.typeAnnotation = i, this.resetEndLocation(s)), s;
    }
    tsInAmbientContext(s) {
      let {
        isAmbientContext: i,
        strict: r
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return s();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = r;
      }
    }
    parseClass(s, i, r) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!s.abstract;
      try {
        return super.parseClass(s, i, r);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(s, i) {
      if (this.match(80))
        return s.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(s, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return s.abstract = !0, this.raise(ut.NonClassMethodPropertyHasAbstractModifer, s), this.tsParseInterfaceDeclaration(s);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(s, i, r, a, o, l, u) {
      let c = super.parseMethod(s, i, r, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: f
        } = c;
        this.raise(ut.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(this.offsetToSourcePos(f.start), this.offsetToSourcePos(
          f.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(s, i, r, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !1, r), this.finishNode(s, "ExportSpecifier")) : (s.exportKind = "value",
      super.parseExportSpecifier(s, i, r, a));
    }
    parseImportSpecifier(s, i, r, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(s, !0, r), this.finishNode(s, "ImportSpecifier")) : (s.importKind = "value",
      super.parseImportSpecifier(s, i, r, a, r ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(s, i, r) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", l = s[a], u, c = !1, p = !0, h = l.loc.start;
      if (this.isContextual(93)) {
        let d = this.parseIdentifier();
        if (this.isContextual(93)) {
          let y = this.parseIdentifier();
          Eo(this.state.type) ? (c = !0, l = d, u = i ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = y, p = !1);
        } else Eo(this.state.type) ? (p = !1, u = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = d);
      } else Eo(this.state.type) && (c = !0, i ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && r && this.raise(i ? ut.TypeModifierIsUsedInTypeImports : ut.TypeModifierIsUsedInTypeExports, h), s[a] = l, s[o] = u;
      let f = i ? "importKind" : "exportKind";
      s[f] = c ? "type" : "value", p && this.eatContextual(93) && (s[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), s[o] ||
      (s[o] = yu(s[a])), i && this.checkIdentifier(s[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function Pnt(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: s
    } = t;
    return e && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? !1 : BX(t.object);
  }
  n(Pnt, "isPossiblyLiteralEnum");
  function Ent(t, e) {
    var s;
    let {
      type: i
    } = t;
    if ((s = t.extra) != null && s.parenthesized)
      return !1;
    if (e) {
      if (i === "Literal") {
        let {
          value: r
        } = t;
        if (typeof r == "string" || typeof r == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(LX(t, e) || Ant(t, e) || i === "TemplateLiteral" && t.expressions.length === 0 || Pnt(t));
  }
  n(Ent, "isValidAmbientConstInitializer");
  function LX(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(LX, "isNumber");
  function Ant(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: s,
        argument: i
      } = t;
      if (s === "-" && LX(i, e))
        return !0;
    }
    return !1;
  }
  n(Ant, "isNegativeNumber");
  function BX(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : BX(t.object);
  }
  n(BX, "isUncomputedMemberExpressionChain");
  var TX = mu`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), vnt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(s) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, s);
      }
    }
    finishPlaceholder(s, i) {
      let r = s;
      return (!r.expectedNode || !r.type) && (r = this.finishNode(r, "Placeholder")), r.expectedNode = i, r;
    }
    getTokenFromCode(s) {
      s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(s);
    }
    parseExprAtom(s) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(s);
    }
    parseIdentifier(s) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(s);
    }
    checkReservedWord(s, i, r, a) {
      s !== void 0 && super.checkReservedWord(s, i, r, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(s, i, r) {
      return s === "Placeholder" || super.isValidLVal(s, i, r);
    }
    toAssignable(s, i) {
      s && s.type === "Placeholder" && s.expectedNode === "Expression" ? s.expectedNode = "Pattern" : super.toAssignable(s, i);
    }
    chStartsBindingIdentifier(s, i) {
      return !!(super.chStartsBindingIdentifier(s, i) || this.lookahead().type === 133);
    }
    verifyBreakContinue(s, i) {
      s.label && s.label.type === "Placeholder" || super.verifyBreakContinue(s, i);
    }
    parseExpressionStatement(s, i) {
      var r;
      if (i.type !== "Placeholder" || (r = i.extra) != null && r.parenthesized)
        return super.parseExpressionStatement(s, i);
      if (this.match(14)) {
        let o = s;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = s;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(s, i, r) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(s, i, r);
    }
    parseFunctionId(s) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(s);
    }
    parseClass(s, i, r) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          s.id = l;
        else {
          if (r || !i)
            return s.id = null, s.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(s, a);
          throw this.raise(TX.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(s, i, r);
      return super.parseClassSuper(s), s.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!s.superClass, o), this.finishNode(
      s, a);
    }
    parseExport(s, i) {
      let r = this.parsePlaceholder("Identifier");
      if (!r) return super.parseExport(s, i);
      let a = s;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(r, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = r, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let s = this.nextTokenStart();
        if (this.isUnparsedContextual(s, "from") && this.input.startsWith(zc(133), this.nextTokenStartSince(s + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(s, i) {
      var r;
      return (r = s.specifiers) != null && r.length ? !0 : super.maybeParseExportDefaultSpecifier(s, i);
    }
    checkExport(s) {
      let {
        specifiers: i
      } = s;
      i != null && i.length && (s.specifiers = i.filter((r) => r.exported.type === "Placeholder")), super.checkExport(s), s.specifiers = i;
    }
    parseImport(s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(s);
      if (s.specifiers = [], !this.isContextual(98) && !this.match(12))
        return s.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(s, "ImportDeclaration");
      let r = this.startNodeAtNode(i);
      return r.local = i, s.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      s) || this.parseNamedImportSpecifiers(s)), this.expectContextual(98), s.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      s, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(TX.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), Cnt = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let s = this.state.startLoc, i = this.startNode();
        if (this.next(), zs(this.state.type)) {
          let r = this.parseIdentifierName(), a = this.createIdentifier(i, r);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(s);
      }
    }
    parseExprAtom(s) {
      return this.parseV8Intrinsic() || super.parseExprAtom(s);
    }
  }, "v8intrinsic"), bX = ["minimal", "fsharp", "hack", "smart"], xX = ["^^", "@@", "^", "%", "#"];
  function wnt(t) {
    if (t.has("decorators")) {
      if (t.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let s = t.get("decorators").decoratorsBeforeExport;
      if (s != null && typeof s != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let i = t.get("decorators").allowCallParenthesized;
      if (i != null && typeof i != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (t.has("flow") && t.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (t.has("placeholders") && t.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (t.has("pipelineOperator")) {
      var e;
      let s = t.get("pipelineOperator").proposal;
      if (!bX.includes(s)) {
        let r = bX.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${r}.`);
      }
      let i = ((e = t.get("recordAndTuple")) == null ? void 0 : e.syntaxType) === "hash";
      if (s === "hack") {
        if (t.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (t.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let r = t.get("pipelineOperator").topicToken;
        if (!xX.includes(r)) {
          let a = xX.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (r === "#" && i)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["\
recordAndTuple", t.get("recordAndTuple")])}\`.`);
      } else if (s === "smart" && i)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", t.
        get("recordAndTuple")])}\`.`);
    }
    if (t.has("moduleAttributes")) {
      if (t.has("deprecatedImportAssert") || t.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (t.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (t.has("importAssertions") && t.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!t.has("deprecatedImportAssert") && t.has("importAttributes") && t.get("importAttributes").deprecatedAssertSyntax && t.set("deprecat\
edImportAssert", {}), t.has("recordAndTuple")) {
      let s = t.get("recordAndTuple").syntaxType;
      if (s != null) {
        let i = ["hash", "bar"];
        if (!i.includes(s))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + i.map((r) => `'${r}'`).join(", "));
      }
    }
    if (t.has("asyncDoExpressions") && !t.has("doExpressions")) {
      let s = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw s.missingPlugins = "doExpressions", s;
    }
    if (t.has("optionalChainingAssign") && t.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(wnt, "validatePlugins");
  var MX = {
    estree: Nrt,
    jsx: gnt,
    flow: mnt,
    typescript: Snt,
    v8intrinsic: Cnt,
    placeholders: vnt
  }, Int = Object.keys(MX), t2 = class extends e2 {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, s, i, r) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return i;
      let a = e.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? s ? (this.raise(Z.RecordNoProto, a), !0) : (i && (r ? r.doubleProtoLoc ===
      null && (r.doubleProtoLoc = a.loc.start) : this.raise(Z.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(e, s) {
      return e.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e.start) === s;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.optionFlags & 256 && (e.tokens = this.tokens), e;
    }
    parseExpression(e, s) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(s)) : this.allowInAnd(() => this.parseExpressionBase(s));
    }
    parseExpressionBase(e) {
      let s = this.state.startLoc, i = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let r = this.startNodeAt(s);
        for (r.expressions = [i]; this.eat(12); )
          r.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(r.expressions), this.finishNode(r, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(e, s) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, s));
    }
    parseMaybeAssignAllowIn(e, s) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, s));
    }
    setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(e, s) {
      let i = this.state.startLoc, r = this.isContextual(108);
      if (r && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(i);
        return s && (u = s.call(this, u, i)), u;
      }
      let a;
      e ? a = !1 : (e = new Kd(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || zs(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(e);
      if (s && (l = s.call(this, l, i)), Lrt(this.state.type)) {
        let u = this.startNodeAt(i), c = this.state.value;
        if (u.operator = c, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let p = i.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= p && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= p && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression")), u;
      } else a && this.checkExpressionErrors(e, !0);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Hg(u) : Hg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Z.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return l;
    }
    parseMaybeConditional(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprOps(e);
      return this.shouldExitDescending(r, i) ? r : this.parseConditional(r, s, e);
    }
    parseConditional(e, s, i) {
      if (this.eat(17)) {
        let r = this.startNodeAt(s);
        return r.test = e, r.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r.alternate = this.parseMaybeAssign(), this.finishNode(
        r, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(r, i) ? r : this.parseExprOp(r, s, -1);
    }
    parseExprOp(e, s, i) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (i >= zS(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Z.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let r = this.state.type;
      if (Mrt(r) && (this.prodParam.hasIn || !this.match(58))) {
        let a = zS(r);
        if (a > i) {
          if (r === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, s);
          }
          let o = this.startNodeAt(s);
          o.left = e, o.operator = this.state.value;
          let l = r === 41 || r === 42, u = r === 40;
          if (u && (a = zS(42)), this.next(), r === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(Z.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(r, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(Z.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, s, i);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, s) {
      let i = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(s));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(Z.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, s), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(e, s);
      }
    }
    parseExprOpBaseRightExpr(e, s) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, Urt(e) ? s - 1 : s);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: s
      } = this.state, i = this.parseMaybeAssign();
      return Prt.has(i.type) && !((e = i.extra) != null && e.parenthesized) && this.raise(Z.PipeUnparenthesizedBody, s, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Z.PipeTopicUnused, s), i;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(Z.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, s) {
      let i = this.state.startLoc, r = this.isContextual(96);
      if (r && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(i);
        return s || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (jrt(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(Z.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(Z.DeletePrivateField, o);
        }
        if (!a)
          return s || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (r) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Hg(u) : Hg(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(Z.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return l;
    }
    parseUpdate(e, s, i) {
      if (s) {
        let o = e;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), e;
      }
      let r = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; Frt(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(r);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(e) {
      let s = this.state.startLoc, i = this.state.potentialArrowAt, r = this.parseExprAtom(e);
      return this.shouldExitDescending(r, i) ? r : this.parseSubscripts(r, s);
    }
    parseSubscripts(e, s, i) {
      let r = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, s, i, r), r.maybeAsyncArrow = !1;
      while (!r.stop);
      return e;
    }
    parseSubscript(e, s, i, r) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(e, s, i, r);
      if (ZS(a))
        return this.parseTaggedTemplateExpression(e, s, r);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(Z.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return r.stop = !0, e;
        r.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, s, r, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, s, r, l, o) : (r.stop = !0, e);
      }
    }
    parseMember(e, s, i, r, a) {
      let o = this.startNodeAt(s);
      return o.object = e, o.computed = r, r ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (e.type === "Super" &&
      this.raise(Z.SuperPrivateField, s), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, s, i, r) {
      let a = this.startNodeAt(s);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), s, i);
    }
    parseCoverCallAndAsyncArrowHead(e, s, i, r) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(s);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = i;
      u && (this.expressionScope.enter(ont()), o = new Kd()), c && (l.optional = r), r ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !r ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(s), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, s) {
      this.toReferencedListDeep(e.arguments, s);
    }
    parseTaggedTemplateExpression(e, s, i) {
      let r = this.startNodeAt(s);
      return r.tag = e, r.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(Z.OptionalChainingNoTemplate, s), this.finishNode(
      r, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(e, s) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 0 || e.arguments.length > 2)
          this.raise(Z.ImportCallArity, e);
        else
          for (let i of e.arguments)
            i.type === "SpreadElement" && this.raise(Z.ImportCallSpreadArgument, i);
      return this.finishNode(e, s ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, s, i, r) {
      let a = [], o = !0, l = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(!1, r, s));
      }
      return this.state.inFSharpPipelineDirectBody = l, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, s) {
      var i;
      return this.resetPreviousNodeTrailingComments(s), this.expect(19), this.parseArrowExpression(e, s.arguments, !0, (i = s.extra) == null ?
      void 0 : i.trailingCommaLoc), s.innerComments && Gg(e, s.innerComments), s.callee.trailingComments && Gg(e, s.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let s, i = null, {
        type: r
      } = this.state;
      switch (r) {
        case 79:
          return this.parseSuper();
        case 83:
          return s = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(s) : this.match(10) ? this.optionFlags & 512 ?
          this.parseImportCall(s) : this.finishNode(s, "Import") : (this.raise(Z.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          s, "Import"));
        case 78:
          return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          s = this.startNode(), this.next(), s.object = null;
          let a = s.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(s, "BindExpression");
          throw this.raise(Z.UnsupportedBind, a);
        }
        case 139:
          return this.raise(Z.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          du(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (r === 137)
            return this.parseDecimalLiteral(this.state.value);
          if (zs(r)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (zs(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, s) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = e, this.state.value = s, this.state.pos--, this.state.end--, this.state.endLoc = vn(this.state.endLoc, -1),
        this.parseTopicReference(i);
      this.unexpected();
    }
    parseTopicReference(e) {
      let s = this.startNode(), i = this.state.startLoc, r = this.state.type;
      return this.next(), this.finishTopicReference(s, i, e, r);
    }
    finishTopicReference(e, s, i, r) {
      if (this.testTopicReferenceConfiguration(i, s, r))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Z.PipeTopicUnbound, s), this.registerTopicReference(),
        this.finishNode(e, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Z.PrimaryTopicNotAllowed, s), this.
        registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"));
      throw this.raise(Z.PipeTopicUnconfiguredToken, s, {
        token: zc(r)
      });
    }
    testTopicReferenceConfiguration(e, s, i) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: zc(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(Z.PipeTopicRequiresHackPipes, s);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(GS(!0, this.prodParam.hasYield));
      let s = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Z.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, s, !0);
    }
    parseDo(e, s) {
      this.expectPlugin("doExpressions"), s && this.expectPlugin("asyncDoExpressions"), e.async = s, this.next();
      let i = this.state.labels;
      return this.state.labels = [], s ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(Z.SuperNotAllowed, e) : !this.
      scope.allowSuper && !(this.optionFlags & 16) && this.raise(Z.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(Z.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), s = this.startNodeAt(vn(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), e.id = this.createIdentifier(s, i), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, s, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, s, i) {
      e.meta = s;
      let r = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== i || r) && this.raise(Z.UnsupportedMetaProperty, e.property, {
        target: s.name,
        onlyValidPropertyName: i
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let s = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(Z.ImportMetaOutsideModule, s), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let i = this.isContextual(105);
        if (this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !(this.optionFlags & 512))
          throw this.raise(Z.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = i ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, s, "meta");
    }
    parseLiteralAtNode(e, s, i) {
      return this.addExtra(i, "rawValue", e), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = e, this.next(), this.finishNode(i, s);
    }
    parseLiteral(e, s) {
      let i = this.startNode();
      return this.parseLiteralAtNode(e, s, i);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let s = this.startNode();
      return this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.pattern = e.pattern, s.flags = e.
      flags, this.next(), this.finishNode(s, "RegExpLiteral");
    }
    parseBooleanLiteral(e) {
      let s = this.startNode();
      return s.value = e, this.next(), this.finishNode(s, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let s = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(ant());
      let r = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Kd(), c = !0, p, h;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          h = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let y = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let f = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = r, this.state.inFSharpPipelineDirectBody = a;
      let d = this.startNodeAt(s);
      return e && this.shouldParseArrow(l) && (d = this.parseArrow(d)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(d, l, !1), d) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), h && this.unexpected(h), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (i = this.startNodeAt(o), i.expressions = l, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      f)) : i = l[0], this.wrapParenthesis(s, i));
    }
    wrapParenthesis(e, s) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", e.index), this.takeSurroundingComments(s, e.index, this.
        state.lastTokEndLoc.index), s;
      let i = this.startNodeAt(e);
      return i.expression = s, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, s) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let s = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let i = this.parseMetaProperty(e, s, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4) && this.raise(Z.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let s = this.parseExprList(11);
        this.toReferencedList(s), e.arguments = s;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let s = this.match(83), i = this.parseNoCallExpr();
      e.callee = i, s && (i.type === "Import" || i.type === "ImportExpression") && this.raise(Z.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(e) {
      let {
        start: s,
        startLoc: i,
        end: r,
        value: a
      } = this.state, o = s + 1, l = this.startNodeAt(vn(i, 1));
      a === null && (e || this.raise(Z.InvalidEscapeSequenceTemplate, vn(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = r + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let h = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(h, vn(this.state.lastTokEndLoc, c)), h;
    }
    parseTemplate(e) {
      let s = this.startNode(), i = this.parseTemplateElement(e), r = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.push(i = this.parseTemplateElement(e));
      return s.expressions = a, s.quasis = r, this.finishNode(s, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        s ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(r), o = this.checkProto(p, i, o, r)), i && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(Z.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return s ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let s = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(Z.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          s.push(this.parseDecorator());
      let i = this.startNode(), r = !1, a = !1, o;
      if (this.match(21))
        return s.length && this.unexpected(), this.parseSpread();
      s.length && (i.decorators = s, s = []), i.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(i, e), !l && !u && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: c
        } = i, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (r = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        i)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = p, this.match(55) && (l = !0, this.
        raise(Z.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, l, r, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var s;
      let i = this.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e);
      r.length !== i && this.raise(e.kind === "get" ? Z.BadGetterArity : Z.BadSetterArity, e), e.kind === "set" && ((s = r[r.length - 1]) ==
      null ? void 0 : s.type) === "RestElement" && this.raise(Z.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, s, i, r, a) {
      if (a) {
        let o = this.parseMethod(e, s, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || s || this.match(10))
        return r && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, s, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, s, i, r) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(r), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), i)
          e.value = this.parseMaybeDefault(s, yu(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          r != null ? r.shorthandAssignLoc === null && (r.shorthandAssignLoc = a) : this.raise(Z.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(s, yu(e.key));
        } else
          e.value = yu(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, s, i, r, a, o, l) {
      let u = this.parseObjectMethod(e, i, r, a, o) || this.parseObjectProperty(e, s, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, s) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: r
        } = this.state, a;
        if (Eo(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(r);
              break;
            case 134:
              a = this.parseStringLiteral(r);
              break;
            case 136:
              a = this.parseBigIntLiteral(r);
              break;
            case 139: {
              let o = this.state.startLoc;
              s != null ? s.privateKeyLoc === null && (s.privateKeyLoc = o) : this.raise(Z.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(r);
                break;
              }
              this.unexpected();
          }
        e.key = a, i !== 139 && (e.computed = !1);
      }
    }
    initFunction(e, s) {
      e.id = null, e.generator = !1, e.async = s;
    }
    parseMethod(e, s, i, r, a, o, l = !1) {
      this.initFunction(e, i), e.generator = s, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(GS(i, e.generator)),
      this.parseFunctionParams(e, r);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, s, i, r) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !i, r, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, i ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, s, i, r) {
      this.scope.enter(6);
      let a = GS(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, i);
      let o = this.state.maybeInArrowParameters;
      return s && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, s, r)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, s, i) {
      this.toAssignableList(s, i, !1), e.params = s;
    }
    parseFunctionBodyAndFinish(e, s, i = !1) {
      return this.parseFunctionBody(e, !1, i), this.finishNode(e, s);
    }
    parseFunctionBody(e, s, i = !1) {
      let r = s && !this.match(5);
      if (this.expressionScope.enter(OX()), r)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, s, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(Z.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !s && !i && !u, s, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let s = 0, i = e.length; s < i; s++)
        if (!this.isSimpleParameter(e[s])) return !1;
      return !0;
    }
    checkParams(e, s, i, r = !0) {
      let a = !s && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, o, 5, a, r);
    }
    parseExprList(e, s, i, r) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        a.push(this.parseExprListItem(s, i));
      }
      return a;
    }
    parseExprListItem(e, s, i) {
      let r;
      if (this.match(12))
        e || this.raise(Z.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), r = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        r = this.parseParenItem(this.parseSpread(s), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), i || this.raise(Z.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), r = this.finishNode(a, "ArgumentPlaceholder");
      } else
        r = this.parseMaybeAssignAllowIn(s, this.parseParenItem);
      return r;
    }
    parseIdentifier(e) {
      let s = this.startNode(), i = this.parseIdentifierName(e);
      return this.createIdentifier(s, i);
    }
    createIdentifier(e, s) {
      return e.name = s, e.loc.identifierName = s, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let s, {
        startLoc: i,
        type: r
      } = this.state;
      Eo(r) ? s = this.state.value : this.unexpected();
      let a = Ort(r);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(s, i, a, !1), this.next(), s;
    }
    checkReservedWord(e, s, i, r) {
      if (e.length > 10 || !Grt(e))
        return;
      if (i && Yrt(e)) {
        this.raise(Z.UnexpectedKeyword, s, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? r ? IX : CX : vX)(e, this.inModule)) {
        this.raise(Z.UnexpectedReservedWord, s, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Z.YieldBindingIdentifier, s);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Z.AwaitBindingIdentifier, s);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Z.AwaitBindingIdentifierInStaticBlock, s);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(s);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Z.ArgumentsInClass, s);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
      return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
    }
    parseAwait(e) {
      let s = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(Z.AwaitExpressionFormalParameter, s), this.eat(55) && this.raise(Z.ObsoleteAwaitStar,
      s), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, !0)), this.finishNode(s, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || ZS(e) || e === 102 && !this.state.containsEsc || e === 138 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield(e) {
      let s = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(Z.YieldInParameter, s);
      let i = !1, r = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            r = this.parseMaybeAssign();
        }
      return s.delegate = i, s.argument = r, this.finishNode(s, "YieldExpression");
    }
    parseImportCall(e) {
      if (this.next(), e.source = this.parseMaybeAssignAllowIn(), e.options = null, this.eat(12) && !this.match(11) && (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12) && !this.match(11))) {
        do
          this.parseMaybeAssignAllowIn();
        while (this.eat(12) && !this.match(11));
        this.raise(Z.ImportCallArity, e);
      }
      return this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, s) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(Z.PipelineHeadSequenceExpression, s);
    }
    parseSmartPipelineBodyInStyle(e, s) {
      if (this.isSimpleReference(e)) {
        let i = this.startNodeAt(s);
        return i.callee = e, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(s);
        return this.checkSmartPipeTopicBodyEarlyErrors(s), i.expression = e, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(Z.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(Z.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let s = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = s;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let s = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = s;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let s = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = s;
      }
    }
    allowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & ~s) {
        this.prodParam.enter(s | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let s = this.prodParam.currentFlags();
      if (8 & s) {
        this.prodParam.enter(s & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let s = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let r = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, e);
      return this.state.inFSharpPipelineDirectBody = i, r;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let s = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(s, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, MO = {
    kind: 1
  }, Nnt = {
    kind: 2
  }, knt = /[\uD800-\uDFFF]/u, FO = /in(?:stanceof)?/y;
  function Dnt(t, e, s) {
    for (let i = 0; i < t.length; i++) {
      let r = t[i], {
        type: a
      } = r;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = vn(o.start, 1);
            t.splice(i, 1, new ll({
              type: hu(27),
              value: "#",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }), new ll({
              type: hu(132),
              value: u,
              start: p,
              end: c,
              startLoc: h,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (ZS(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = r, p = l + 1, h = vn(o.start, 1), f;
            e.charCodeAt(l - s) === 96 ? f = new ll({
              type: hu(22),
              value: "`",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            }) : f = new ll({
              type: hu(8),
              value: "}",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: h
            });
            let d, y, m, T;
            a === 24 ? (y = c - 1, m = vn(o.end, -1), d = u === null ? null : u.slice(1, -1), T = new ll({
              type: hu(22),
              value: "`",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })) : (y = c - 2, m = vn(o.end, -2), d = u === null ? null : u.slice(1, -2), T = new ll({
              type: hu(23),
              value: "${",
              start: y,
              end: c,
              startLoc: m,
              endLoc: o.end
            })), t.splice(i, 1, f, new ll({
              type: hu(20),
              value: d,
              start: p,
              end: y,
              startLoc: h,
              endLoc: m
            }), T), i += 2;
            continue;
          }
        }
        r.type = hu(a);
      }
    }
    return t;
  }
  n(Dnt, "babel7CompatTokens");
  var s2 = class extends t2 {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, s) {
      return e.program = this.parseProgram(s), e.comments = this.comments, this.optionFlags & 256 && (e.tokens = Dnt(this.tokens, this.input,
      this.startIndex)), this.finishNode(e, "File");
    }
    parseProgram(e, s = 140, i = this.options.sourceType) {
      if (e.sourceType = i, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, s), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(Z.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(e, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let r;
      return s === 140 ? r = this.finishNode(e, "Program") : r = this.finishNodeAt(e, "Program", vn(this.state.startLoc, -1)), r;
    }
    stmtToDirective(e) {
      let s = e;
      s.type = "Directive", s.value = s.expression, delete s.expression;
      let i = s.value, r = i.value, a = this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(
      1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", r), i.type = "DirectiveLiteral",
      s;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, s) {
      if (du(e)) {
        if (FO.lastIndex = s, FO.test(this.input)) {
          let i = this.codePointAtPos(FO.lastIndex);
          if (!qd(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), s = this.codePointAtPos(e);
      return this.chStartsBindingPattern(s) || this.chStartsBindingIdentifier(s, e);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
      return s === 123 || this.chStartsBindingIdentifier(s, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: s
      } = this.lookahead();
      if (e === 102 && !s)
        return !1;
      if (zs(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let s = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(s, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let s = 0;
      return this.options.annexB && !this.state.strict && (s |= 4, e && (s |= 8)), this.parseStatementLike(s);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let s = null;
      return this.match(26) && (s = this.parseDecorators(!0)), this.parseStatementContent(e, s);
    }
    parseStatementContent(e, s) {
      let i = this.state.type, r = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(r, !0);
        case 63:
          return this.parseBreakContinueStatement(r, !1);
        case 64:
          return this.parseDebuggerStatement(r);
        case 90:
          return this.parseDoWhileStatement(r);
        case 91:
          return this.parseForStatement(r);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? Z.StrictFunction : this.options.annexB ? Z.SloppyFunctionAnnexB : Z.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(r, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(s, r), !0);
        case 69:
          return this.parseIfStatement(r);
        case 70:
          return this.parseReturnStatement(r);
        case 71:
          return this.parseSwitchStatement(r);
        case 72:
          return this.parseThrowStatement(r);
        case 73:
          return this.parseTryStatement(r);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.recordAwaitIfAllowed() ? a || this.raise(Z.UnexpectedLexicalDeclaration, r) : this.raise(Z.AwaitUsingNotInAsyncContext,
            r), this.next(), this.parseVarStatement(r, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Z.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(Z.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(r, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), h = this.codePointAtPos(p);
          if (h !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(h, p) && h !== 123))
            break;
        }
        case 75:
          a || this.raise(Z.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(r, p);
        }
        case 92:
          return this.parseWhileStatement(r);
        case 76:
          return this.parseWithStatement(r);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(r);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(Z.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return i === 83 ? p = this.parseImport(r) : p = this.parseExport(r, s), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(Z.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(r,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return zs(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r, u, c, e) : this.parseExpressionStatement(r, c,
      s);
    }
    assertModuleNodeAllowed(e) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(Z.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, s, i) {
      if (e) {
        var r;
        (r = s.decorators) != null && r.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        Z.DecoratorsBeforeAfterExport, s.decorators[0]), s.decorators.unshift(...e)) : s.decorators = e, this.resetStartLocationFromNode(s, e[0]),
        i && this.resetStartLocationFromNode(i, s);
      }
      return s;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let s = [];
      do
        s.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Z.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(Z.UnexpectedLeadingDecorator, this.state.startLoc);
      return s;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let s = this.state.startLoc, i;
        if (this.match(10)) {
          let r = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(r, i);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(i, r), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          i && this.raise(Z.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let r = this.startNodeAt(s);
            r.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), r.property = this.parsePrivateName()) :
            r.property = this.parseIdentifier(!0), r.computed = !1, i = this.finishNode(r, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(i, s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e, s) {
      if (this.eat(10)) {
        let i = this.startNodeAt(s);
        return i.callee = e, i.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(i.arguments), this.finishNode(i, "Ca\
llExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, s) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, s), this.finishNode(e, s ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, s) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let r = this.state.labels[i];
        if ((e.label == null || r.name === e.label.name) && (r.kind != null && (s || r.kind === 1) || e.label && s))
          break;
      }
      if (i === this.state.labels.length) {
        let r = s ? "BreakStatement" : "ContinueStatement";
        this.raise(Z.IllegalBreakContinue, e, {
          type: r
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(MO), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(MO);
      let s = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (s = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return s !== null && this.unexpected(s), this.parseFor(e, null);
      let i = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = i && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let h = this.startNode(), f;
          u ? (f = "await using", this.recordAwaitIfAllowed() || this.raise(Z.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          f = this.state.value, this.next(), this.parseVar(h, !0, f);
          let d = this.finishNode(h, "VariableDeclaration"), y = this.match(58);
          return y && c && this.raise(Z.ForInUsing, d), (y || this.isContextual(102)) && d.declarations.length === 1 ? this.parseForIn(e, d,
          s) : (s !== null && this.unexpected(s), this.parseFor(e, d));
        }
      }
      let r = this.isContextual(95), a = new Kd(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (i && this.raise(Z.ForOfLet, o), s === null && r && o.type === "Identifier" && this.raise(Z.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(e, o, s);
      } else
        this.checkExpressionErrors(a, !0);
      return s !== null && this.unexpected(s), this.parseFor(e, o);
    }
    parseFunctionStatement(e, s, i) {
      return this.next(), this.parseFunction(e, 1 | (i ? 2 : 0) | (s ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !(this.optionFlags & 2) && this.raise(Z.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ?
      e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let s = e.cases = [];
      this.expect(5), this.state.labels.push(Nnt), this.scope.enter(0);
      let i;
      for (let r; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), s.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (r && this.raise(Z.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), r = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(Z.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        type: "CatchClause"
      }, 9), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let s = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), s.param = this.parseCatchClauseParam(), this.expect(11)) : (s.param = null, this.scope.
        enter(0)), s.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        s, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(Z.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, s, i = !1) {
      return this.next(), this.parseVar(e, !1, s, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(MO), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(Z.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, s, i, r) {
      for (let o of this.state.labels)
        o.name === s && this.raise(Z.LabelRedeclaration, i, {
          labelName: s
        });
      let a = Brt(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: s,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), e.body = r & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      i, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, s, i) {
      return e.expression = s, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, s = !0, i) {
      let r = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), s && this.scope.enter(0), this.parseBlockBody(r, e, !1, 8, i), s && this.
      scope.exit(), this.finishNode(r, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, s, i, r, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, s ? l : void 0, i, r, a);
    }
    parseBlockOrModuleBlockBody(e, s, i, r, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(r); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (s && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            s.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, s) {
      return e.init = s, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, s, i) {
      let r = this.match(58);
      return this.next(), r ? i !== null && this.unexpected(i) : e.await = i !== null, s.type === "VariableDeclaration" && s.declarations[0].
      init != null && (!r || !this.options.annexB || this.state.strict || s.kind !== "var" || s.declarations[0].id.type !== "Identifier") &&
      this.raise(Z.ForInOfLoopInitializer, s, {
        type: r ? "ForInStatement" : "ForOfStatement"
      }), s.type === "AssignmentPattern" && this.raise(Z.InvalidLhs, s, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = s, e.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, s, i, r = !1) {
      let a = e.declarations = [];
      for (e.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? s ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !r && (o.id.type !== "Identifier" && !(s && (this.match(58) || this.isContextual(102))) ? this.raise(Z.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Z.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, s) {
      let i = this.parseBindingAtom();
      (s === "using" || s === "await using") && (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(Z.UsingDeclarationHasBindingPattern,
      i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, s === "var" ? 5 : 8201), e.id = i;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, s = 0) {
      let i = s & 2, r = !!(s & 1), a = r && !(s & 4), o = !!(s & 8);
      this.initFunction(e, o), this.match(55) && (i && this.raise(Z.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), r && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(GS(o, e.generator)), r || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, r ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r && !i && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || zs(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, s) {
      this.expect(10), this.expressionScope.enter(nnt()), e.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, s, i) {
      this.next();
      let r = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, s, i), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, r), this.
      finishNode(e, s ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, s) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: e
      }, r = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (r.length > 0)
              throw this.raise(Z.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            r.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          r.length && (o.decorators = r, this.resetStartLocationFromNode(o, r[0]), r = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(Z.DecoratorConstructor, o);
        }
      }), this.state.strict = s, this.next(), r.length)
        throw this.raise(Z.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, s) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let r = s;
        return r.kind = "method", r.computed = !1, r.key = i, r.static = !1, this.pushClassMethod(e, r, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let r = s;
        return r.computed = !1, r.key = i, r.static = !1, e.body.push(this.parseClassProperty(r)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(e, s, i) {
      let r = this.isContextual(106);
      if (r) {
        if (this.parseClassMemberFromModifier(e, s))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, s);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, s, i, r);
    }
    parseClassMemberWithIsStatic(e, s, i, r) {
      let a = s, o = s, l = s, u = s, c = s, p = a, h = a;
      if (s.static = r, this.parsePropertyNamePrefixOperator(s), this.eat(55)) {
        p.kind = "method";
        let b = this.match(139);
        if (this.parseClassElementName(p), b) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(Z.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let f = !this.state.containsEsc && zs(this.state.type), d = this.parseClassElementName(s), y = f ? d.name : null, m = this.isPrivateName(
      d), T = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(h), this.isClassMethod()) {
        if (p.kind = "method", m) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let b = this.isNonstaticConstructor(a), E = !1;
        b && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(Z.DuplicateConstructor, d), b && this.
        hasPlugin("typescript") && s.override && this.raise(Z.OverrideOnConstructor, d), i.hadConstructor = !0, E = i.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, b, E);
      } else if (this.isClassProperty())
        m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (y === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(d);
        let b = this.eat(55);
        h.optional && this.unexpected(T), p.kind = "method";
        let E = this.match(139);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(h), E ? this.pushClassPrivateMethod(e, o, b, !0) : (this.isNonstaticConstructor(
        a) && this.raise(Z.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, b, !0, !1, !1));
      } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(d), p.kind = y;
        let b = this.match(139);
        this.parseClassElementName(a), b ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(Z.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (y === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
        let b = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, b);
      } else this.isLineTerminator() ? m ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: s,
        value: i
      } = this.state;
      if ((s === 132 || s === 134) && e.static && i === "prototype" && this.raise(Z.StaticPrototype, this.state.startLoc), s === 139) {
        i === "constructor" && this.raise(Z.ConstructorClassPrivateField, this.state.startLoc);
        let r = this.parsePrivateName();
        return e.key = r, r;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, s) {
      var i;
      this.scope.enter(208);
      let r = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = s.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, e.body.push(this.
      finishNode(s, "StaticBlock")), (i = s.decorators) != null && i.length && this.raise(Z.DecoratorStaticBlock, s);
    }
    pushClassProperty(e, s) {
      !s.computed && this.nameIsConstructor(s.key) && this.raise(Z.ConstructorClassField, s.key), e.body.push(this.parseClassProperty(s));
    }
    pushClassPrivateProperty(e, s) {
      let i = this.parseClassPrivateProperty(s);
      e.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(e, s, i) {
      !i && !s.computed && this.nameIsConstructor(s.key) && this.raise(Z.ConstructorClassField, s.key);
      let r = this.parseClassAccessorProperty(s);
      e.body.push(r), i && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
    }
    pushClassMethod(e, s, i, r, a, o) {
      e.body.push(this.parseMethod(s, i, r, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, s, i, r) {
      let a = this.parseMethod(s, i, r, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, s) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), s, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(OX()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, s, i, r = 8331) {
      if (zs(this.state.type))
        e.id = this.parseIdentifier(), s && this.declareNameFromIdentifier(e.id, r);
      else if (i || !s)
        e.id = null;
      else
        throw this.raise(Z.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, s) {
      let i = this.parseMaybeImportPhase(e, !0), r = this.maybeParseExportDefaultSpecifier(e, i), a = !r || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = r || o;
      if (o && !l) {
        if (r && this.unexpected(), s)
          throw this.raise(Z.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.sawUnambiguousESM = !0, this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      r && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let h;
      if (c || p) {
        if (h = !1, s)
          throw this.raise(Z.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        h = this.maybeParseExportDeclaration(e);
      if (c || p || h) {
        var f;
        let d = e;
        if (this.checkExport(d, !0, !1, !!d.source), ((f = d.declaration) == null ? void 0 : f.type) === "ClassDeclaration")
          this.maybeTakeDecorators(s, d.declaration, d);
        else if (s)
          throw this.raise(Z.UnsupportedDecoratorExport, e);
        return this.sawUnambiguousESM = !0, this.finishNode(d, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let d = e, y = this.parseExportDefaultExpression();
        if (d.declaration = y, y.type === "ClassDeclaration")
          this.maybeTakeDecorators(s, y, d);
        else if (s)
          throw this.raise(Z.UnsupportedDecoratorExport, e);
        return this.checkExport(d, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(d, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, s) {
      if (s || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", s?.loc.start);
        let i = s || this.parseIdentifier(!0), r = this.startNodeAtNode(i);
        return r.exported = i, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var s, i;
        (i = (s = e).specifiers) != null || (s.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let s = e;
        s.specifiers || (s.specifiers = []);
        let i = s.exportKind === "type";
        return s.specifiers.push(...this.parseExportSpecifiers(i)), s.source = null, this.hasPlugin("importAssertions") ? s.assertions = [] :
        s.attributes = [], s.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") ? e.assertions = [] :
      e.attributes = [], e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Z.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(Z.UnsupportedDefaultExport, this.state.startLoc);
      let s = this.parseMaybeAssignAllowIn();
      return this.semicolon(), s;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (zs(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: r
          } = this.lookahead();
          if (zs(r) && r !== 98 || r === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let s = this.nextTokenStart(), i = this.isUnparsedContextual(s, "from");
      if (this.input.charCodeAt(s) === 44 || zs(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let r = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
        return r === 34 || r === 39;
      }
      return !1;
    }
    parseExportFrom(e, s) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : s && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(Z.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(Z.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(Z.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, s, i, r) {
      if (s) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            Z.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !r && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(Z.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let s of e.properties)
          this.checkDeclaration(s);
      else if (e.type === "ArrayPattern")
        for (let s of e.elements)
          s && this.checkDeclaration(s);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, s) {
      this.exportedIdentifiers.has(s) && (s === "default" ? this.raise(Z.DuplicateDefaultExport, e) : this.raise(Z.DuplicateExport, e, {
        exportName: s
      })), this.exportedIdentifiers.add(s);
    }
    parseExportSpecifiers(e) {
      let s = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let r = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), s.push(this.parseExportSpecifier(o, a, e, r));
      }
      return s;
    }
    parseExportSpecifier(e, s, i, r) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : s ? e.exported = unt(e.local) : e.exported || (e.exported =
      yu(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let e = this.parseStringLiteral(this.state.value), s = knt.exec(e.value);
        return s && this.raise(Z.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: s[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: s,
        value: i
      }) => i.value === "json" && (s.type === "Identifier" ? s.name === "type" : s.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: s
      } = e, i = s.length === 1 ? s[0].type : null;
      if (e.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(Z.SourcePhaseImportRequiresDefault, s[0].loc.start);
      else if (e.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(Z.DeferImportRequiresNamespace, s[0].loc.start);
      else if (e.module) {
        var r;
        i !== "ImportDefaultSpecifier" && this.raise(Z.ImportReflectionNotBinding, s[0].loc.start), ((r = e.assertions) == null ? void 0 : r.
        length) > 0 && this.raise(Z.ImportReflectionHasAssertion, s[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: s
        } = e;
        if (s != null) {
          let i = s.find((r) => {
            let a;
            if (r.type === "ExportSpecifier" ? a = r.local : r.type === "ImportSpecifier" && (a = r.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(Z.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, s, i, r) {
      s || (i === "module" ? (this.expectPlugin("importReflection", r), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", r), e.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", r), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, s) {
      if (!this.isPotentialImportPhase(s))
        return this.applyImportPhase(e, s, null), null;
      let i = this.parseIdentifier(!0), {
        type: r
      } = this.state;
      return (Eo(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(
      e, s, i.name, i.loc.start), null) : (this.applyImportPhase(e, s, null), i);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: s
      } = this.state;
      return zs(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12;
    }
    parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, s) {
      e.specifiers = [];
      let r = !this.maybeParseDefaultImportSpecifier(e, s) || this.eat(12), a = r && this.maybeParseStarImportSpecifier(e);
      return r && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var s;
      return (s = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(e, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, s, i) {
      s.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
    }
    finishImportSpecifier(e, s, i = 8201) {
      return this.checkLVal(e.local, {
        type: s
      }, i), this.finishNode(e, s);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), r = this.state.value;
        if (s.has(r) && this.raise(Z.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: r
        }), s.add(r), this.match(134) ? i.key = this.parseStringLiteral(r) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(Z.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], s = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(Z.ModuleAttributeDifferentFromType, i.key), s.has(i.key.name) &&
        this.raise(Z.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), s.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(Z.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let s;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (s = this.parseModuleAttributes(), this.addExtra(e, "deprecatedWithLegacySyntax", !0)) :
        s = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(Z.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e, "depreca\
tedAssertSyntax", !0), this.next(), s = this.parseImportAttributes()) : s = [];
      !i && this.hasPlugin("importAssertions") ? e.assertions = s : e.attributes = s;
    }
    maybeParseDefaultImportSpecifier(e, s) {
      if (s) {
        let i = this.startNodeAtNode(s);
        return i.local = s, e.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (Eo(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let s = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, s, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else {
          if (this.eat(14))
            throw this.raise(Z.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), r = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, r, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, s, i, r, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (s)
          throw this.raise(Z.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = yu(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, tP = class extends s2 {
    static {
      n(this, "Parser");
    }
    constructor(e, s, i) {
      e = wrt(e), super(e, s), this.options = e, this.initializeScopes(), this.plugins = i, this.filename = e.sourceFilename, this.startIndex =
      e.startIndex;
      let r = 0;
      e.allowAwaitOutsideFunction && (r |= 1), e.allowReturnOutsideFunction && (r |= 2), e.allowImportExportEverywhere && (r |= 8), e.allowSuperOutsideMethod &&
      (r |= 16), e.allowUndeclaredExports && (r |= 64), e.allowNewTargetOutsideFunction && (r |= 4), e.allowYieldOutsideFunction && (r |= 32),
      e.ranges && (r |= 128), e.tokens && (r |= 256), e.createImportExpressions && (r |= 512), e.createParenthesizedExpressions && (r |= 1024),
      e.errorRecovery && (r |= 2048), e.attachComment && (r |= 4096), e.annexB && (r |= 8192), this.optionFlags = r;
    }
    getScopeHandler() {
      return zg;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), s = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, s), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function Ont(t, e) {
    var s;
    if (((s = e) == null ? void 0 : s.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let i = Jg(e, t), r = i.parse();
        if (i.sawUnambiguousESM)
          return r;
        if (i.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Jg(e, t).parse();
          } catch {
          }
        else
          r.program.sourceType = "script";
        return r;
      } catch (i) {
        try {
          return e.sourceType = "script", Jg(e, t).parse();
        } catch {
        }
        throw i;
      }
    } else
      return Jg(e, t).parse();
  }
  n(Ont, "parse");
  function _nt(t, e) {
    let s = Jg(e, t);
    return s.options.strictMode && (s.state.strict = !0), s.getExpression();
  }
  n(_nt, "parseExpression");
  function Lnt(t) {
    let e = {};
    for (let s of Object.keys(t))
      e[s] = hu(t[s]);
    return e;
  }
  n(Lnt, "generateExportedTokenTypes");
  var Bnt = Lnt(Drt);
  function Jg(t, e) {
    let s = tP, i = /* @__PURE__ */ new Map();
    if (t != null && t.plugins) {
      for (let r of t.plugins) {
        let a, o;
        typeof r == "string" ? a = r : [a, o] = r, i.has(a) || i.set(a, o || {});
      }
      wnt(i), s = Mnt(i);
    }
    return new s(t, e, i);
  }
  n(Jg, "getParser");
  var SX = /* @__PURE__ */ new Map();
  function Mnt(t) {
    let e = [];
    for (let r of Int)
      t.has(r) && e.push(r);
    let s = e.join("|"), i = SX.get(s);
    if (!i) {
      i = tP;
      for (let r of e)
        i = MX[r](i);
      SX.set(s, i);
    }
    return i;
  }
  n(Mnt, "getParserClass");
  Qg.parse = Ont;
  Qg.parseExpression = _nt;
  Qg.tokTypes = Bnt;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/replacement.js
var vO = g((Gc) => {
  "use strict";
  Object.defineProperty(Gc, "__esModule", {
    value: !0
  });
  Gc._replaceWith = $X;
  Gc.replaceExpressionWithStatements = cat;
  Gc.replaceInline = pat;
  Gc.replaceWith = uat;
  Gc.replaceWithMultiple = oat;
  Gc.replaceWithSourceString = lat;
  var Fnt = Yl(), d2 = Ld(), jnt = Jc(), KX = Ph(), m2 = WS(), Rnt = FX(), qnt = fe(), Hd = ol(), {
    FUNCTION_TYPES: jX,
    arrowFunctionExpression: Unt,
    assignmentExpression: VX,
    awaitExpression: Knt,
    blockStatement: Vnt,
    buildUndefinedNode: f2,
    callExpression: Wnt,
    cloneNode: y2,
    conditionalExpression: $nt,
    expressionStatement: Hnt,
    getBindingIdentifiers: Jnt,
    identifier: Ynt,
    inheritLeadingComments: Xnt,
    inheritTrailingComments: znt,
    inheritsComments: Gnt,
    isBlockStatement: Qnt,
    isEmptyStatement: RX,
    isExpression: WX,
    isExpressionStatement: Znt,
    isIfStatement: eat,
    isProgram: tat,
    isStatement: sat,
    isVariableDeclaration: iat,
    removeComments: rat,
    returnStatement: qX,
    sequenceExpression: nat,
    validate: UX,
    yieldExpression: aat
  } = qnt;
  function oat(t) {
    var e;
    Hd.resync.call(this), t = m2._verifyNodeList.call(this, t), Xnt(t[0], this.node), znt(t[t.length - 1], this.node), (e = (0, KX.getCachedPaths)(
    this.hub, this.parent)) == null || e.delete(this.node), this.node = this.container[this.key] = null;
    let s = this.insertAfter(t);
    return this.node ? this.requeue() : this.remove(), s;
  }
  n(oat, "replaceWithMultiple");
  function lat(t) {
    Hd.resync.call(this);
    let e;
    try {
      t = `(${t})`, e = (0, Rnt.parse)(t);
    } catch (i) {
      let r = i.loc;
      throw r && (i.message += ` - make sure this is an expression.
` + (0, Fnt.codeFrameColumns)(t, {
        start: {
          line: r.line,
          column: r.column + 1
        }
      }), i.code = "BABEL_REPLACE_SOURCE_ERROR"), i;
    }
    let s = e.program.body[0].expression;
    return d2.default.removeProperties(s), this.replaceWith(s);
  }
  n(lat, "replaceWithSourceString");
  function uat(t) {
    if (Hd.resync.call(this), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let e = t instanceof jnt.default ? t.node : t;
    if (!e)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === e)
      return [this];
    if (this.isProgram() && !tat(e))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(e))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof e == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let s = "";
    if (this.isNodeType("Statement") && WX(e) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    e) && !this.parentPath.isExportDefaultDeclaration() && (e = Hnt(e), s = "expression"), this.isNodeType("Expression") && sat(e) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(e))
      return this.replaceExpressionWithStatements([e]);
    let i = this.node;
    return i && (Gnt(e, i), rat(i)), $X.call(this, e), this.type = e.type, Hd.setScope.call(this), this.requeue(), [s ? this.get(s) : this];
  }
  n(uat, "replaceWith");
  function $X(t) {
    var e;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? UX(this.parent, this.key, [t]) : UX(this.parent, this.key, t), this.debug(`Replace with ${t?.type}`), (e = (0, KX.getCachedPaths)(
    this.hub, this.parent)) == null || e.set(t, this).delete(this.node), this.node = this.container[this.key] = t;
  }
  n($X, "_replaceWith");
  function cat(t) {
    Hd.resync.call(this);
    let e = [], s = sP(t, e);
    if (s) {
      for (let f of e) this.scope.push({
        id: f
      });
      return this.replaceWith(s)[0].get("expressions");
    }
    let i = this.getFunctionParent(), r = i?.node.async, a = i?.node.generator, o = Unt([], Vnt(t));
    this.replaceWith(Wnt(o, []));
    let l = this.get("callee");
    l.get("body").scope.hoistVariables((f) => this.scope.push({
      id: f
    }));
    let u = l.getCompletionRecords();
    for (let f of u) {
      if (!f.isExpressionStatement()) continue;
      let d = f.findParent((y) => y.isLoop());
      if (d) {
        let y = d.getData("expressionReplacementReturnUid");
        y ? y = Ynt(y.name) : (y = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", qX(y2(y))), d.setData("\
expressionReplacementReturnUid", y)), f.get("expression").replaceWith(VX("=", y2(y), f.node.expression));
      } else
        f.replaceWith(qX(f.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = r && d2.default.hasType(this.get("callee.body").node, "AwaitExpression", jX), h = a && d2.default.hasType(this.get("calle\
e.body").node, "YieldExpression", jX);
    return p && (c.set("async", !0), h || this.replaceWith(Knt(this.node))), h && (c.set("generator", !0), this.replaceWith(aat(this.node, !0))),
    c.get("body.body");
  }
  n(cat, "replaceExpressionWithStatements");
  function sP(t, e) {
    let s = [], i = !0;
    for (let r of t)
      if (RX(r) || (i = !1), WX(r))
        s.push(r);
      else if (Znt(r))
        s.push(r.expression);
      else if (iat(r)) {
        if (r.kind !== "var") return;
        for (let a of r.declarations) {
          let o = Jnt(a);
          for (let l of Object.keys(o))
            e.push(y2(o[l]));
          a.init && s.push(VX("=", a.id, a.init));
        }
        i = !0;
      } else if (eat(r)) {
        let a = r.consequent ? sP([r.consequent], e) : f2(), o = r.alternate ? sP([r.alternate], e) : f2();
        if (!a || !o) return;
        s.push($nt(r.test, a, o));
      } else if (Qnt(r)) {
        let a = sP(r.body, e);
        if (!a) return;
        s.push(a);
      } else if (RX(r))
        t.indexOf(r) === 0 && (i = !0);
      else
        return;
    return i && s.push(f2()), s.length === 1 ? s[0] : nat(s);
  }
  n(sP, "gatherSequenceExpressions");
  function pat(t) {
    if (Hd.resync.call(this), Array.isArray(t))
      if (Array.isArray(this.container)) {
        t = m2._verifyNodeList.call(this, t);
        let e = m2._containerInsertAfter.call(this, t);
        return this.remove(), e;
      } else
        return this.replaceWithMultiple(t);
    else
      return this.replaceWith(t);
  }
  n(pat, "replaceInline");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/evaluation.js
var XX = g((iP) => {
  "use strict";
  Object.defineProperty(iP, "__esModule", {
    value: !0
  });
  iP.evaluate = bat;
  iP.evaluateTruthy = gat;
  var hat = ["Number", "String", "Math"], fat = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], dat = ["random"];
  function HX(t) {
    return hat.includes(t);
  }
  n(HX, "isValidObjectCallee");
  function mat(t) {
    return fat.includes(t);
  }
  n(mat, "isValidIdentifierCallee");
  function yat(t) {
    return dat.includes(t);
  }
  n(yat, "isInvalidMethod");
  function gat() {
    let t = this.evaluate();
    if (t.confident) return !!t.value;
  }
  n(gat, "evaluateTruthy");
  function gu(t, e) {
    e.confident && (e.deoptPath = t, e.confident = !1);
  }
  n(gu, "deopt");
  var JX = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function Cn(t, e) {
    let {
      node: s
    } = t, {
      seen: i
    } = e;
    if (i.has(s)) {
      let r = i.get(s);
      if (r.resolved)
        return r.value;
      gu(t, e);
      return;
    } else {
      let r = {
        resolved: !1
      };
      i.set(s, r);
      let a = Tat(t, e);
      return e.confident && (r.resolved = !0, r.value = a), a;
    }
  }
  n(Cn, "evaluateCached");
  function Tat(t, e) {
    if (e.confident) {
      if (t.isSequenceExpression()) {
        let s = t.get("expressions");
        return Cn(s[s.length - 1], e);
      }
      if (t.isStringLiteral() || t.isNumericLiteral() || t.isBooleanLiteral())
        return t.node.value;
      if (t.isNullLiteral())
        return null;
      if (t.isTemplateLiteral())
        return YX(t, t.node.quasis, e);
      if (t.isTaggedTemplateExpression() && t.get("tag").isMemberExpression()) {
        let s = t.get("tag.object"), {
          node: {
            name: i
          }
        } = s, r = t.get("tag.property");
        if (s.isIdentifier() && i === "String" && !t.scope.getBinding(i) && r.isIdentifier() && r.node.name === "raw")
          return YX(t, t.node.quasi.quasis, e, !0);
      }
      if (t.isConditionalExpression()) {
        let s = Cn(t.get("test"), e);
        return e.confident ? Cn(s ? t.get("consequent") : t.get("alternate"), e) : void 0;
      }
      if (t.isExpressionWrapper())
        return Cn(t.get("expression"), e);
      if (t.isMemberExpression() && !t.parentPath.isCallExpression({
        callee: t.node
      })) {
        let s = t.get("property"), i = t.get("object");
        if (i.isLiteral()) {
          let r = i.node.value, a = typeof r, o = null;
          if (t.node.computed) {
            if (o = Cn(s, e), !e.confident) return;
          } else s.isIdentifier() && (o = s.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return r[o];
        }
      }
      if (t.isReferencedIdentifier()) {
        let s = t.scope.getBinding(t.node.name);
        if (s) {
          if (s.constantViolations.length > 0 || t.node.start < s.path.node.end) {
            gu(s.path, e);
            return;
          }
          if (s.hasValue)
            return s.value;
        }
        let i = t.node.name;
        if (JX.has(i)) {
          if (!s)
            return JX.get(i);
          gu(s.path, e);
          return;
        }
        let r = t.resolve();
        if (r === t) {
          gu(t, e);
          return;
        } else
          return Cn(r, e);
      }
      if (t.isUnaryExpression({
        prefix: !0
      })) {
        if (t.node.operator === "void")
          return;
        let s = t.get("argument");
        if (t.node.operator === "typeof" && (s.isFunction() || s.isClass()))
          return "function";
        let i = Cn(s, e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "!":
            return !i;
          case "+":
            return +i;
          case "-":
            return -i;
          case "~":
            return ~i;
          case "typeof":
            return typeof i;
        }
      }
      if (t.isArrayExpression()) {
        let s = [], i = t.get("elements");
        for (let r of i) {
          let a = r.evaluate();
          if (a.confident)
            s.push(a.value);
          else {
            gu(a.deopt, e);
            return;
          }
        }
        return s;
      }
      if (t.isObjectExpression()) {
        let s = {}, i = t.get("properties");
        for (let r of i) {
          if (r.isObjectMethod() || r.isSpreadElement()) {
            gu(r, e);
            return;
          }
          let a = r.get("key"), o;
          if (r.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              gu(o.deopt, e);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = r.get("value").evaluate();
          if (!u.confident) {
            gu(u.deopt, e);
            return;
          }
          u = u.value, s[o] = u;
        }
        return s;
      }
      if (t.isLogicalExpression()) {
        let s = e.confident, i = Cn(t.get("left"), e), r = e.confident;
        e.confident = s;
        let a = Cn(t.get("right"), e), o = e.confident;
        switch (t.node.operator) {
          case "||":
            return e.confident = r && (!!i || o), e.confident ? i || a : void 0;
          case "&&":
            return e.confident = r && (!i || o), e.confident ? i && a : void 0;
          case "??":
            return e.confident = r && (i != null || o), e.confident ? i ?? a : void 0;
        }
      }
      if (t.isBinaryExpression()) {
        let s = Cn(t.get("left"), e);
        if (!e.confident) return;
        let i = Cn(t.get("right"), e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "-":
            return s - i;
          case "+":
            return s + i;
          case "/":
            return s / i;
          case "*":
            return s * i;
          case "%":
            return s % i;
          case "**":
            return Math.pow(s, i);
          case "<":
            return s < i;
          case ">":
            return s > i;
          case "<=":
            return s <= i;
          case ">=":
            return s >= i;
          case "==":
            return s == i;
          case "!=":
            return s != i;
          case "===":
            return s === i;
          case "!==":
            return s !== i;
          case "|":
            return s | i;
          case "&":
            return s & i;
          case "^":
            return s ^ i;
          case "<<":
            return s << i;
          case ">>":
            return s >> i;
          case ">>>":
            return s >>> i;
        }
      }
      if (t.isCallExpression()) {
        let s = t.get("callee"), i, r;
        if (s.isIdentifier() && !t.scope.getBinding(s.node.name) && (HX(s.node.name) || mat(s.node.name)) && (r = global[s.node.name]), s.isMemberExpression()) {
          let a = s.get("object"), o = s.get("property");
          if (a.isIdentifier() && o.isIdentifier() && HX(a.node.name) && !yat(o.node.name)) {
            i = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(i, l) && (r = i[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (i = a.node.value, r = i[o.node.name]);
          }
        }
        if (r) {
          let a = t.get("arguments").map((o) => Cn(o, e));
          return e.confident ? r.apply(i, a) : void 0;
        }
      }
      gu(t, e);
    }
  }
  n(Tat, "_evaluate");
  function YX(t, e, s, i = !1) {
    let r = "", a = 0, o = t.isTemplateLiteral() ? t.get("expressions") : t.get("quasi.expressions");
    for (let l of e) {
      if (!s.confident) break;
      r += i ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (r += String(Cn(u, s)));
    }
    if (s.confident)
      return r;
  }
  n(YX, "evaluateQuasis");
  function bat() {
    let t = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, e = Cn(this, t);
    return t.confident || (e = void 0), {
      confident: t.confident,
      deopt: t.deoptPath,
      value: e
    };
  }
  n(bat, "evaluate");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/conversion.js
var iz = g((Tu) => {
  "use strict";
  Object.defineProperty(Tu, "__esModule", {
    value: !0
  });
  Tu.arrowFunctionToExpression = Xat;
  Tu.ensureBlock = Hat;
  Tu.ensureFunctionName = oot;
  Tu.splitExportDeclaration = not;
  Tu.toComputedKey = $at;
  Tu.unwrapFunctionEnvironment = Jat;
  var xat = fe(), Sat = Xl(), b2 = jg(), Pat = ol(), {
    arrowFunctionExpression: x2,
    assignmentExpression: Dh,
    binaryExpression: g2,
    blockStatement: Eat,
    callExpression: Jd,
    conditionalExpression: Aat,
    expressionStatement: QX,
    identifier: mi,
    isIdentifier: vat,
    jsxIdentifier: Cat,
    logicalExpression: wat,
    LOGICAL_OPERATORS: Iat,
    memberExpression: Ao,
    metaProperty: Nat,
    numericLiteral: kat,
    objectExpression: Dat,
    restElement: Oat,
    returnStatement: _at,
    sequenceExpression: Lat,
    spreadElement: Bat,
    stringLiteral: ZX,
    super: T2,
    thisExpression: Zg,
    toExpression: ez,
    unaryExpression: Mat,
    toBindingIdentifierName: Fat,
    isFunction: jat,
    isAssignmentPattern: Rat,
    isRestElement: qat,
    getFunctionName: Uat,
    cloneNode: Oh,
    variableDeclaration: Kat,
    variableDeclarator: Vat,
    exportNamedDeclaration: zX,
    exportSpecifier: GX,
    inherits: Wat
  } = xat;
  function $at() {
    let t;
    if (this.isMemberExpression())
      t = this.node.property;
    else if (this.isProperty() || this.isMethod())
      t = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || vat(t) && (t = ZX(t.name)), t;
  }
  n($at, "toComputedKey");
  function Hat() {
    let t = this.get("body"), e = t.node;
    if (Array.isArray(t))
      throw new Error("Can't convert array path to a block statement");
    if (!e)
      throw new Error("Can't convert node without a body");
    if (t.isBlockStatement())
      return e;
    let s = [], i = "body", r, a;
    t.isStatement() ? (a = "body", r = 0, s.push(t.node)) : (i += ".body.0", this.isFunction() ? (r = "argument", s.push(_at(t.node))) : (r =
    "expression", s.push(QX(t.node)))), this.node.body = Eat(s);
    let o = this.get(i);
    return Pat.setup.call(t, o, a ? o.node[a] : o.node, a, r), this.node;
  }
  n(Hat, "ensureBlock");
  Tu.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function Jat() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    tz(this);
  }
  n(Jat, "unwrapFunctionEnvironment");
  function Yat(t, e) {
    t.node.type = e;
  }
  n(Yat, "setType");
  function Xat({
    allowInsertArrow: t = !0,
    allowInsertArrowWithRest: e = t,
    noNewArrows: s = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let i = this;
    if (!s) {
      var r;
      i = (r = i.ensureFunctionName(!1)) != null ? r : i;
    }
    let {
      thisBinding: a,
      fnPath: o
    } = tz(i, s, t, e);
    if (o.ensureBlock(), Yat(o, "FunctionExpression"), !s) {
      let l = a ? null : o.scope.generateUidIdentifier("arrowCheckId");
      return l && o.parentPath.scope.push({
        id: l,
        init: Dat([])
      }), o.get("body").unshiftContainer("body", QX(Jd(this.hub.addHelper("newArrowCheck"), [Zg(), mi(l ? l.name : a)]))), o.replaceWith(Jd(
      Ao(o.node, mi("bind")), [l ? mi(l.name) : Zg()])), o.get("callee.object");
    }
    return o;
  }
  n(Xat, "arrowFunctionToExpression");
  var zat = (0, b2.environmentVisitor)({
    CallExpression(t, {
      allSuperCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    }
  });
  function tz(t, e = !0, s = !0, i = !0) {
    let r, a = t.findParent((d) => {
      if (d.isArrowFunctionExpression()) {
        var y;
        return (y = r) != null || (r = d), !1;
      }
      return d.isFunction() || d.isProgram() || d.isClassProperty({
        static: !1
      }) || d.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (r)
        a = r;
      else if (s)
        t.replaceWith(Jd(x2([], ez(t.node)), [])), a = t.get("callee"), t = a.get("body");
      else
        throw t.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: h
    } = rot(t);
    if (o && h.length > 0) {
      if (!s)
        throw h[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!i)
        throw h[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let d = [];
      a.traverse(zat, {
        allSuperCalls: d
      });
      let y = tot(a);
      d.forEach((m) => {
        let T = mi(y);
        T.loc = m.node.callee.loc, m.get("callee").replaceWith(T);
      });
    }
    if (u.length > 0) {
      let d = eT(a, "arguments", () => {
        let y = /* @__PURE__ */ n(() => mi("arguments"), "args");
        return a.scope.path.isProgram() ? Aat(g2("===", Mat("typeof", y()), ZX("undefined")), a.scope.buildUndefinedNode(), y()) : y();
      });
      u.forEach((y) => {
        let m = mi(d);
        m.loc = y.node.loc, y.replaceWith(m);
      });
    }
    if (c.length > 0) {
      let d = eT(a, "newtarget", () => Nat(mi("new"), mi("target")));
      c.forEach((y) => {
        let m = mi(d);
        m.loc = y.node.loc, y.replaceWith(m);
      });
    }
    if (p.length > 0) {
      if (!s)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((y, m) => y.concat(Qat(m)), []).forEach((y) => {
        let m = y.node.computed ? "" : y.get("property").node.name, T = y.parentPath, b = T.isAssignmentExpression({
          left: y.node
        }), E = T.isCallExpression({
          callee: y.node
        }), w = T.isTaggedTemplateExpression({
          tag: y.node
        }), K = sot(a, b, m), he = [];
        if (y.node.computed && he.push(y.get("property").node), b) {
          let me = T.node.right;
          he.push(me);
        }
        let de = Jd(mi(K), he);
        E ? (T.unshiftContainer("arguments", Zg()), y.replaceWith(Ao(de, mi("call"))), l.push(T.get("arguments.0"))) : b ? T.replaceWith(de) :
        w ? (y.replaceWith(Jd(Ao(de, mi("bind"), !1), [Zg()])), l.push(y.get("arguments.0"))) : y.replaceWith(de);
      });
    }
    let f;
    return (l.length > 0 || !e) && (f = eot(a, o), (e || o && sz(a)) && (l.forEach((d) => {
      let y = d.isJSX() ? Cat(f) : mi(f);
      y.loc = d.node.loc, d.replaceWith(y);
    }), e || (f = null))), {
      thisBinding: f,
      fnPath: t
    };
  }
  n(tz, "hoistFunctionEnvironment");
  function Gat(t) {
    return Iat.includes(t);
  }
  n(Gat, "isLogicalOp");
  function Qat(t) {
    if (t.parentPath.isAssignmentExpression() && t.parentPath.node.operator !== "=") {
      let s = t.parentPath, i = s.node.operator.slice(0, -1), r = s.node.right, a = Gat(i);
      if (t.node.computed) {
        let o = t.scope.generateDeclaredUidIdentifier("tmp"), l = t.node.object, u = t.node.property;
        s.get("left").replaceWith(Ao(l, Dh("=", o, u), !0)), s.get("right").replaceWith(e(a ? "=" : i, Ao(l, mi(o.name), !0), r));
      } else {
        let o = t.node.object, l = t.node.property;
        s.get("left").replaceWith(Ao(o, l)), s.get("right").replaceWith(e(a ? "=" : i, Ao(o, mi(l.name)), r));
      }
      return a ? s.replaceWith(wat(i, s.node.left, s.node.right)) : s.node.operator = "=", [s.get("left"), s.get("right").get("left")];
    } else if (t.parentPath.isUpdateExpression()) {
      let s = t.parentPath, i = t.scope.generateDeclaredUidIdentifier("tmp"), r = t.node.computed ? t.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [Dh("=", i, Ao(t.node.object, r ? Dh("=", r, t.node.property) : t.node.property, t.node.computed)), Dh("=", Ao(t.node.object,
      r ? mi(r.name) : t.node.property, t.node.computed), g2(t.parentPath.node.operator[0], mi(i.name), kat(1)))];
      t.parentPath.node.prefix || a.push(mi(i.name)), s.replaceWith(Lat(a));
      let o = s.get("expressions.0.right"), l = s.get("expressions.1.left");
      return [o, l];
    }
    return [t];
    function e(s, i, r) {
      return s === "=" ? Dh("=", i, r) : g2(s, i, r);
    }
  }
  n(Qat, "standardizeSuperProperty");
  function sz(t) {
    return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass;
  }
  n(sz, "hasSuperClass");
  var Zat = (0, b2.environmentVisitor)({
    CallExpression(t, {
      supers: e,
      thisBinding: s
    }) {
      t.get("callee").isSuper() && (e.has(t.node) || (e.add(t.node), t.replaceWithMultiple([t.node, Dh("=", mi(s), mi("this"))])));
    }
  });
  function eot(t, e) {
    return eT(t, "this", (s) => {
      if (!e || !sz(t)) return Zg();
      t.traverse(Zat, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: s
      });
    });
  }
  n(eot, "getThisBinding");
  function tot(t) {
    return eT(t, "supercall", () => {
      let e = t.scope.generateUidIdentifier("args");
      return x2([Oat(e)], Jd(T2(), [Bat(mi(e.name))]));
    });
  }
  n(tot, "getSuperBinding");
  function sot(t, e, s) {
    return eT(t, `superprop_${e ? "set" : "get"}:${s || ""}`, () => {
      let r = [], a;
      if (s)
        a = Ao(T2(), mi(s));
      else {
        let o = t.scope.generateUidIdentifier("prop");
        r.unshift(o), a = Ao(T2(), mi(o.name), !0);
      }
      if (e) {
        let o = t.scope.generateUidIdentifier("value");
        r.push(o), a = Dh("=", a, mi(o.name));
      }
      return x2(r, a);
    });
  }
  n(sot, "getSuperPropBinding");
  function eT(t, e, s) {
    let i = "binding:" + e, r = t.getData(i);
    if (!r) {
      let a = t.scope.generateUidIdentifier(e);
      r = a.name, t.setData(i, r), t.scope.push({
        id: a,
        init: s(r)
      });
    }
    return r;
  }
  n(eT, "getBinding");
  var iot = (0, b2.environmentVisitor)({
    ThisExpression(t, {
      thisPaths: e
    }) {
      e.push(t);
    },
    JSXIdentifier(t, {
      thisPaths: e
    }) {
      t.node.name === "this" && (!t.parentPath.isJSXMemberExpression({
        object: t.node
      }) && !t.parentPath.isJSXOpeningElement({
        name: t.node
      }) || e.push(t));
    },
    CallExpression(t, {
      superCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    },
    MemberExpression(t, {
      superProps: e
    }) {
      t.get("object").isSuper() && e.push(t);
    },
    Identifier(t, {
      argumentsPaths: e
    }) {
      if (!t.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let s = t.scope;
      do {
        if (s.hasOwnBinding("arguments")) {
          s.rename("arguments");
          return;
        }
        if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
          break;
      } while (s = s.parent);
      e.push(t);
    },
    MetaProperty(t, {
      newTargetPaths: e
    }) {
      t.get("meta").isIdentifier({
        name: "new"
      }) && t.get("property").isIdentifier({
        name: "target"
      }) && e.push(t);
    }
  });
  function rot(t) {
    let e = [], s = [], i = [], r = [], a = [];
    return t.traverse(iot, {
      thisPaths: e,
      argumentsPaths: s,
      newTargetPaths: i,
      superProps: r,
      superCalls: a
    }), {
      thisPaths: e,
      argumentsPaths: s,
      newTargetPaths: i,
      superProps: r,
      superCalls: a
    };
  }
  n(rot, "getScopeInformation");
  function not() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      let r = t.isFunctionDeclaration() || t.isClassDeclaration(), a = t.isFunctionExpression() || t.isClassExpression(), o = t.isScope() ? t.
      scope.parent : t.scope, l = t.node.id, u = !1;
      l ? a && o.hasBinding(l.name) && (u = !0, l = o.generateUidIdentifier(l.name)) : (u = !0, l = o.generateUidIdentifier("default"), (r ||
      a) && (t.node.id = Oh(l)));
      let c = r ? t.node : Kat("var", [Vat(Oh(l), t.node)]), p = zX(null, [GX(Oh(l), mi("default"))]);
      return this.insertAfter(p), this.replaceWith(c), u && o.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = t.getOuterBindingIdentifiers(), s = Object.keys(e).map((r) => GX(mi(r), mi(r))), i = zX(null, s);
    return this.insertAfter(i), this.replaceWith(t.node), this;
  }
  n(not, "splitExportDeclaration");
  var aot = {
    "ReferencedIdentifier|BindingIdentifier"(t, e) {
      t.node.name === e.name && (e.needsRename = !0, t.stop());
    },
    Scope(t, e) {
      t.scope.hasOwnBinding(e.name) && t.skip();
    }
  };
  function oot(t) {
    if (this.node.id) return this;
    let e = Uat(this.node, this.parent);
    if (e == null) return this;
    let {
      name: s
    } = e;
    if (!t && /[\uD800-\uDFFF]/.test(s) || s.startsWith("get ") || s.startsWith("set "))
      return null;
    s = Fat(s.replace(/[/ ]/g, "_"));
    let i = mi(s);
    Wat(i, e.originalNode);
    let r = {
      needsRename: !1,
      name: s
    }, {
      scope: a
    } = this, o = a.getOwnBinding(s);
    if (o ? o.kind === "param" && (r.needsRename = !0) : (a.parent.hasBinding(s) || a.hasGlobal(s)) && this.traverse(aot, r), !r.needsRename)
      return this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (a.hasBinding(i.name) && !a.hasGlobal(i.name))
      return a.rename(i.name), this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (!jat(this.node)) return null;
    let l = a.generateUidIdentifier(i.name), u = [];
    for (let p = 0, h = lot(this.node); p < h; p++)
      u.push(a.generateUidIdentifier("x"));
    let c = Sat.default.expression.ast`
    (function (${l}) {
      function ${i}(${u}) {
        return ${Oh(l)}.apply(this, arguments);
      }

      ${Oh(i)}.toString = function () {
        return ${Oh(l)}.toString();
      }

      return ${Oh(i)};
    })(${ez(this.node)})
  `;
    return this.replaceWith(c)[0].get("arguments.0");
  }
  n(oot, "ensureFunctionName");
  function lot(t) {
    let e = t.params.findIndex((s) => Rat(s) || qat(s));
    return e === -1 ? t.params.length : e;
  }
  n(lot, "getFunctionArity");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/introspection.js
var uz = g((rr) => {
  "use strict";
  Object.defineProperty(rr, "__esModule", {
    value: !0
  });
  rr._guessExecutionStatusRelativeTo = Not;
  rr._resolve = lz;
  rr.canHaveVariableDeclarationOrExpression = Sot;
  rr.canSwapBetweenExpressionAndStatement = Pot;
  rr.getSource = Cot;
  rr.isCompletionRecord = Eot;
  rr.isConstantExpression = _ot;
  rr.isInStrictMode = Lot;
  rr.isNodeType = xot;
  rr.isStatementOrBlock = Aot;
  rr.isStatic = bot;
  rr.matchesPattern = Tot;
  rr.referencesImport = vot;
  rr.resolve = Oot;
  rr.willIMaybeExecuteBefore = wot;
  var uot = fe(), {
    STATEMENT_OR_BLOCK_KEYS: cot,
    VISITOR_KEYS: pot,
    isBlockStatement: oz,
    isExpression: hot,
    isIdentifier: fot,
    isLiteral: dot,
    isStringLiteral: mot,
    isType: yot,
    matchesPattern: got
  } = uot;
  function Tot(t, e) {
    return got(this.node, t, e);
  }
  n(Tot, "matchesPattern");
  rr.has = /* @__PURE__ */ n(function(e) {
    var s;
    let i = (s = this.node) == null ? void 0 : s[e];
    return i && Array.isArray(i) ? !!i.length : !!i;
  }, "has");
  function bot() {
    return this.scope.isStatic(this.node);
  }
  n(bot, "isStatic");
  rr.is = rr.has, rr.isnt = /* @__PURE__ */ n(function(e) {
    return !this.has(e);
  }, "isnt"), rr.equals = /* @__PURE__ */ n(function(e, s) {
    return this.node[e] === s;
  }, "equals");
  function xot(t) {
    return yot(this.type, t);
  }
  n(xot, "isNodeType");
  function Sot() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  n(Sot, "canHaveVariableDeclarationOrExpression");
  function Pot(t) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? oz(t) : this.isBlockStatement() ?
    hot(t) : !1;
  }
  n(Pot, "canSwapBetweenExpressionAndStatement");
  function Eot(t) {
    let e = this, s = !0;
    do {
      let {
        type: i,
        container: r
      } = e;
      if (!s && (e.isFunction() || i === "StaticBlock"))
        return !!t;
      if (s = !1, Array.isArray(r) && e.key !== r.length - 1)
        return !1;
    } while ((e = e.parentPath) && !e.isProgram() && !e.isDoExpression());
    return !0;
  }
  n(Eot, "isCompletionRecord");
  function Aot() {
    return this.parentPath.isLabeledStatement() || oz(this.container) ? !1 : cot.includes(this.key);
  }
  n(Aot, "isStatementOrBlock");
  function vot(t, e) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === e || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? mot(this.node.property, {
        value: e
      }) : this.node.property.name === e)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(t, "*");
      }
      return !1;
    }
    let s = this.scope.getBinding(this.node.name);
    if (!s || s.kind !== "module") return !1;
    let i = s.path, r = i.parentPath;
    if (!r.isImportDeclaration()) return !1;
    if (r.node.source.value === t) {
      if (!e) return !0;
    } else
      return !1;
    return !!(i.isImportDefaultSpecifier() && e === "default" || i.isImportNamespaceSpecifier() && e === "*" || i.isImportSpecifier() && fot(
    i.node.imported, {
      name: e
    }));
  }
  n(vot, "referencesImport");
  function Cot() {
    let t = this.node;
    if (t.end) {
      let e = this.hub.getCode();
      if (e) return e.slice(t.start, t.end);
    }
    return "";
  }
  n(Cot, "getSource");
  function wot(t) {
    return this._guessExecutionStatusRelativeTo(t) !== "after";
  }
  n(wot, "willIMaybeExecuteBefore");
  function rz(t) {
    return t.isProgram() ? t : (t.parentPath.scope.getFunctionParent() || t.parentPath.scope.getProgramParent()).path;
  }
  n(rz, "getOuterFunction");
  function Iot(t, e) {
    switch (t) {
      case "LogicalExpression":
        return e === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return e === "consequent" || e === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return e === "body";
      case "ForStatement":
        return e === "body" || e === "update";
      case "SwitchStatement":
        return e === "cases";
      case "TryStatement":
        return e === "handler";
      case "AssignmentPattern":
        return e === "right";
      case "OptionalMemberExpression":
        return e === "property";
      case "OptionalCallExpression":
        return e === "arguments";
      default:
        return !1;
    }
  }
  n(Iot, "isExecutionUncertain");
  function nz(t, e) {
    for (let s = 0; s < e; s++) {
      let i = t[s];
      if (Iot(i.parent.type, i.parentKey))
        return !0;
    }
    return !1;
  }
  n(nz, "isExecutionUncertainInList");
  var az = Symbol();
  function Not(t) {
    return S2(this, t, /* @__PURE__ */ new Map());
  }
  n(Not, "_guessExecutionStatusRelativeTo");
  function S2(t, e, s) {
    let i = {
      this: rz(t),
      target: rz(e)
    };
    if (i.target.node !== i.this.node)
      return Dot(t, i.target, s);
    let r = {
      target: e.getAncestry(),
      this: t.getAncestry()
    };
    if (r.target.includes(t)) return "after";
    if (r.this.includes(e)) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < r.this.length; ) {
      let p = r.this[o.this];
      o.target = r.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (nz(r.this, o.this - 1) || nz(r.target, o.target - 1))
      return "unknown";
    let l = {
      this: r.this[o.this - 1],
      target: r.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = pot[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  n(S2, "_guessExecutionStatusRelativeToCached");
  function kot(t, e, s) {
    if (e.isFunctionDeclaration()) {
      if (e.parentPath.isExportDeclaration())
        return "unknown";
    } else return S2(t, e, s) === "before" ? "before" : "unknown";
    let i = e.scope.getBinding(e.node.id.name);
    if (!i.references) return "before";
    let r = i.referencePaths, a;
    for (let o of r) {
      if (!!o.find((c) => c.node === e.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = S2(t, o, s);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  n(kot, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function Dot(t, e, s) {
    let i = s.get(t.node), r;
    if (!i)
      s.set(t.node, i = /* @__PURE__ */ new Map());
    else if (r = i.get(e.node))
      return r === az ? "unknown" : r;
    i.set(e.node, az);
    let a = kot(t, e, s);
    return i.set(e.node, a), a;
  }
  n(Dot, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function Oot(t, e) {
    return lz.call(this, t, e) || this;
  }
  n(Oot, "resolve");
  function lz(t, e) {
    var s;
    if (!((s = e) != null && s.includes(this)))
      if (e = e || [], e.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(t, e);
      } else if (this.isReferencedIdentifier()) {
        let i = this.scope.getBinding(this.node.name);
        if (!i || !i.constant || i.kind === "module") return;
        if (i.path !== this) {
          let r = i.path.resolve(t, e);
          return this.find((a) => a.node === r.node) ? void 0 : r;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(t, e);
        if (t && this.isMemberExpression()) {
          let i = this.toComputedKey();
          if (!dot(i)) return;
          let r = i.value, a = this.get("object").resolve(t, e);
          if (a.isObjectExpression()) {
            let o = a.get("properties");
            for (let l of o) {
              if (!l.isProperty()) continue;
              let u = l.get("key"), c = l.isnt("computed") && u.isIdentifier({
                name: r
              });
              if (c = c || u.isLiteral({
                value: r
              }), c) return l.get("value").resolve(t, e);
            }
          } else if (a.isArrayExpression() && !isNaN(+r)) {
            let l = a.get("elements")[r];
            if (l) return l.resolve(t, e);
          }
        }
      }
  }
  n(lz, "_resolve");
  function _ot() {
    if (this.isIdentifier()) {
      let t = this.scope.getBinding(this.node.name);
      return t ? t.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((t) => t.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: t
      } = this.node;
      return t !== "in" && t !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  n(_ot, "isConstantExpression");
  function Lot() {
    return !!(this.isProgram() ? this : this.parentPath).find((s) => {
      if (s.isProgram({
        sourceType: "module"
      }) || s.isClass()) return !0;
      if (s.isArrowFunctionExpression() && !s.get("body").isBlockStatement())
        return !1;
      let i;
      if (s.isFunction())
        i = s.node.body;
      else if (s.isProgram())
        i = s.node;
      else
        return !1;
      for (let r of i.directives)
        if (r.value.value === "use strict")
          return !0;
    });
  }
  n(Lot, "isInStrictMode");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/family.js
var dz = g((Vr) => {
  "use strict";
  Object.defineProperty(Vr, "__esModule", {
    value: !0
  });
  Vr._getKey = hz;
  Vr._getPattern = fz;
  Vr.get = Got;
  Vr.getAllNextSiblings = Xot;
  Vr.getAllPrevSiblings = zot;
  Vr.getAssignmentIdentifiers = Qot;
  Vr.getBindingIdentifierPaths = tlt;
  Vr.getBindingIdentifiers = Zot;
  Vr.getCompletionRecords = $ot;
  Vr.getNextSibling = Yot;
  Vr.getOpposite = Kot;
  Vr.getOuterBindingIdentifierPaths = slt;
  Vr.getOuterBindingIdentifiers = elt;
  Vr.getPrevSibling = Jot;
  Vr.getSibling = Hot;
  var E2 = Jc(), Bot = fe(), {
    getAssignmentIdentifiers: Mot,
    getBindingIdentifiers: pz,
    getOuterBindingIdentifiers: Fot,
    numericLiteral: jot,
    unaryExpression: Rot
  } = Bot, A2 = 0, tT = 1;
  function qot(t) {
    return {
      type: A2,
      path: t
    };
  }
  n(qot, "NormalCompletion");
  function Uot(t) {
    return {
      type: tT,
      path: t
    };
  }
  n(Uot, "BreakCompletion");
  function Kot() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  n(Kot, "getOpposite");
  function Yd(t, e, s) {
    return t && e.push(...Xd(t, s)), e;
  }
  n(Yd, "addCompletionRecords");
  function Vot(t, e, s) {
    let i = [];
    for (let r = 0; r < t.length; r++) {
      let a = t[r], o = Xd(a, s), l = [], u = [];
      for (let c of o)
        c.type === A2 && l.push(c), c.type === tT && u.push(c);
      l.length && (i = l), e.push(...u);
    }
    return e.push(...i), e;
  }
  n(Vot, "completionRecordForSwitch");
  function Wot(t) {
    t.forEach((e) => {
      e.type = tT;
    });
  }
  n(Wot, "normalCompletionToBreak");
  function P2(t, e) {
    t.forEach((s) => {
      s.path.isBreakStatement({
        label: null
      }) && (e ? s.path.replaceWith(Rot("void", jot(0))) : s.path.remove());
    });
  }
  n(P2, "replaceBreakStatementInBreakCompletion");
  function cz(t, e) {
    let s = [];
    if (e.canHaveBreak) {
      let i = [];
      for (let r = 0; r < t.length; r++) {
        let a = t[r], o = Object.assign({}, e, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (e.inCaseClause || e.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Xd(a, o);
        if (l.length > 0 && l.every((u) => u.type === tT)) {
          i.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (Wot(i), s.push(...i), i.some((u) => u.path.isDeclaration()) && (s.push(...l), P2(l, !0)), P2(l, !1)) : (s.push(...l), e.shouldPopulateBreak ||
          P2(l, !0));
          break;
        }
        if (r === t.length - 1)
          s.push(...l);
        else {
          i = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === tT && s.push(c), c.type === A2 && i.push(c);
          }
        }
      }
    } else if (t.length)
      for (let i = t.length - 1; i >= 0; i--) {
        let r = Xd(t[i], e);
        if (r.length > 1 || r.length === 1 && !r[0].path.isVariableDeclaration()) {
          s.push(...r);
          break;
        }
      }
    return s;
  }
  n(cz, "getStatementListCompletion");
  function Xd(t, e) {
    let s = [];
    if (t.isIfStatement())
      s = Yd(t.get("consequent"), s, e), s = Yd(t.get("alternate"), s, e);
    else {
      if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement())
        return Yd(t.get("body"), s, e);
      if (t.isProgram() || t.isBlockStatement())
        return cz(t.get("body"), e);
      if (t.isFunction())
        return Xd(t.get("body"), e);
      if (t.isTryStatement())
        s = Yd(t.get("block"), s, e), s = Yd(t.get("handler"), s, e);
      else {
        if (t.isCatchClause())
          return Yd(t.get("body"), s, e);
        if (t.isSwitchStatement())
          return Vot(t.get("cases"), s, e);
        if (t.isSwitchCase())
          return cz(t.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        t.isBreakStatement() ? s.push(Uot(t)) : s.push(qot(t));
      }
    }
    return s;
  }
  n(Xd, "_getCompletionRecords");
  function $ot() {
    return Xd(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((e) => e.path);
  }
  n($ot, "getCompletionRecords");
  function Hot(t) {
    return E2.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: t
    }).setContext(this.context);
  }
  n(Hot, "getSibling");
  function Jot() {
    return this.getSibling(this.key - 1);
  }
  n(Jot, "getPrevSibling");
  function Yot() {
    return this.getSibling(this.key + 1);
  }
  n(Yot, "getNextSibling");
  function Xot() {
    let t = this.key, e = this.getSibling(++t), s = [];
    for (; e.node; )
      s.push(e), e = this.getSibling(++t);
    return s;
  }
  n(Xot, "getAllNextSiblings");
  function zot() {
    let t = this.key, e = this.getSibling(--t), s = [];
    for (; e.node; )
      s.push(e), e = this.getSibling(--t);
    return s;
  }
  n(zot, "getAllPrevSiblings");
  function Got(t, e = !0) {
    e === !0 && (e = this.context);
    let s = t.split(".");
    return s.length === 1 ? hz.call(this, t, e) : fz.call(this, s, e);
  }
  n(Got, "get");
  function hz(t, e) {
    let s = this.node, i = s[t];
    return Array.isArray(i) ? i.map((r, a) => E2.default.get({
      listKey: t,
      parentPath: this,
      parent: s,
      container: i,
      key: a
    }).setContext(e)) : E2.default.get({
      parentPath: this,
      parent: s,
      container: s,
      key: t
    }).setContext(e);
  }
  n(hz, "_getKey");
  function fz(t, e) {
    let s = this;
    for (let i of t)
      i === "." ? s = s.parentPath : Array.isArray(s) ? s = s[i] : s = s.get(i, e);
    return s;
  }
  n(fz, "_getPattern");
  function Qot() {
    return Mot(this.node);
  }
  n(Qot, "getAssignmentIdentifiers");
  function Zot(t) {
    return pz(this.node, t);
  }
  n(Zot, "getBindingIdentifiers");
  function elt(t) {
    return Fot(this.node, t);
  }
  n(elt, "getOuterBindingIdentifiers");
  function tlt(t = !1, e = !1) {
    let i = [this], r = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let a = i.shift();
      if (!a || !a.node) continue;
      let o = pz.keys[a.node.type];
      if (a.isIdentifier()) {
        t ? (r[a.node.name] = r[a.node.name] || []).push(a) : r[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        l.isDeclaration() && i.push(l);
        continue;
      }
      if (e) {
        if (a.isFunctionDeclaration()) {
          i.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c);
        }
    }
    return r;
  }
  n(tlt, "getBindingIdentifierPaths");
  function slt(t = !1) {
    return this.getBindingIdentifierPaths(t, !0);
  }
  n(slt, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/comments.js
var yz = g((sT) => {
  "use strict";
  Object.defineProperty(sT, "__esModule", {
    value: !0
  });
  sT.addComment = olt;
  sT.addComments = llt;
  sT.shareCommentsWithSiblings = alt;
  var ilt = fe(), {
    addComment: rlt,
    addComments: nlt
  } = ilt;
  function alt() {
    if (typeof this.key == "string") return;
    let t = this.node;
    if (!t) return;
    let e = t.trailingComments, s = t.leadingComments;
    if (!e && !s) return;
    let i = this.getSibling(this.key - 1), r = this.getSibling(this.key + 1), a = !!i.node, o = !!r.node;
    a && (s && i.addComments("trailing", mz(s, i.node.trailingComments)), e && !o && i.addComments("trailing", e)), o && (e && r.addComments(
    "leading", mz(e, r.node.leadingComments)), s && !a && r.addComments("leading", s));
  }
  n(alt, "shareCommentsWithSiblings");
  function mz(t, e) {
    if (!(e != null && e.length)) return t;
    let s = new Set(e);
    return t.filter((i) => !s.has(i));
  }
  n(mz, "removeIfExisting");
  function olt(t, e, s) {
    rlt(this.node, t, e, s);
  }
  n(olt, "addComment");
  function llt(t, e) {
    nlt(this.node, t, e);
  }
  n(llt, "addComments");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/index.js
var Jc = g((hl) => {
  "use strict";
  Object.defineProperty(hl, "__esModule", {
    value: !0
  });
  hl.default = hl.SHOULD_STOP = hl.SHOULD_SKIP = hl.REMOVED = void 0;
  var ult = BD(), clt = go(), plt = Ld(), hlt = WD(), bz = fe(), rP = bz, flt = Ph(), dlt = vY(), cl = CY(), zd = HY(), Gd = vO(), gz = XX(),
  _h = iz(), xr = uz(), xz = ol(), nr = xz, Qd = VS(), pl = WS(), wn = dz(), v2 = yz(), mlt = FD(), {
    validate: ylt
  } = bz, Tz = clt("babel"), hKs = hl.REMOVED = 1, fKs = hl.SHOULD_STOP = 2, dKs = hl.SHOULD_SKIP = 4, bu = hl.default = class Sz {
    static {
      n(this, "NodePath");
    }
    constructor(e, s) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = s, this.hub = e, this.data = null, this.
      context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(e) {
      e ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(e) {
      e ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(e) {
      e ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: e,
      parentPath: s,
      parent: i,
      container: r,
      listKey: a,
      key: o
    }) {
      if (!e && s && (e = s.hub), !i)
        throw new Error("To get a node path the parent needs to exist");
      let l = r[o], u = flt.getOrCreateCachedPaths(e, i), c = u.get(l);
      return c || (c = new Sz(e, i), l && u.set(l, c)), xz.setup.call(c, s, r, a, o), c;
    }
    getScope(e) {
      return this.isScope() ? new hlt.default(this) : e;
    }
    setData(e, s) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e] = s;
    }
    getData(e, s) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let i = this.data[e];
      return i === void 0 && s !== void 0 && (i = this.data[e] = s), i;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(e, s = SyntaxError) {
      return this.hub.buildError(this.node, e, s);
    }
    traverse(e, s) {
      (0, plt.default)(this.node, e, this.scope, s, this);
    }
    set(e, s) {
      ylt(this.node, e, s), this.node[e] = s;
    }
    getPathLocation() {
      let e = [], s = this;
      do {
        let i = s.key;
        s.inList && (i = `${s.listKey}[${i}]`), e.unshift(i);
      } while (s = s.parentPath);
      return e.join(".");
    }
    debug(e) {
      Tz.enabled && Tz(`${this.getPathLocation()} ${this.type}: ${e}`);
    }
    toString() {
      return (0, dlt.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e) {
      e || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, glt = {
    findParent: cl.findParent,
    find: cl.find,
    getFunctionParent: cl.getFunctionParent,
    getStatementParent: cl.getStatementParent,
    getEarliestCommonAncestorFrom: cl.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: cl.getDeepestCommonAncestorFrom,
    getAncestry: cl.getAncestry,
    isAncestor: cl.isAncestor,
    isDescendant: cl.isDescendant,
    inType: cl.inType,
    getTypeAnnotation: zd.getTypeAnnotation,
    isBaseType: zd.isBaseType,
    couldBeBaseType: zd.couldBeBaseType,
    baseTypeStrictlyMatches: zd.baseTypeStrictlyMatches,
    isGenericType: zd.isGenericType,
    replaceWithMultiple: Gd.replaceWithMultiple,
    replaceWithSourceString: Gd.replaceWithSourceString,
    replaceWith: Gd.replaceWith,
    replaceExpressionWithStatements: Gd.replaceExpressionWithStatements,
    replaceInline: Gd.replaceInline,
    evaluateTruthy: gz.evaluateTruthy,
    evaluate: gz.evaluate,
    toComputedKey: _h.toComputedKey,
    ensureBlock: _h.ensureBlock,
    unwrapFunctionEnvironment: _h.unwrapFunctionEnvironment,
    arrowFunctionToExpression: _h.arrowFunctionToExpression,
    splitExportDeclaration: _h.splitExportDeclaration,
    ensureFunctionName: _h.ensureFunctionName,
    matchesPattern: xr.matchesPattern,
    isStatic: xr.isStatic,
    isNodeType: xr.isNodeType,
    canHaveVariableDeclarationOrExpression: xr.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: xr.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: xr.isCompletionRecord,
    isStatementOrBlock: xr.isStatementOrBlock,
    referencesImport: xr.referencesImport,
    getSource: xr.getSource,
    willIMaybeExecuteBefore: xr.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: xr._guessExecutionStatusRelativeTo,
    resolve: xr.resolve,
    isConstantExpression: xr.isConstantExpression,
    isInStrictMode: xr.isInStrictMode,
    isDenylisted: nr.isDenylisted,
    visit: nr.visit,
    skip: nr.skip,
    skipKey: nr.skipKey,
    stop: nr.stop,
    setContext: nr.setContext,
    requeue: nr.requeue,
    requeueComputedKeyAndDecorators: nr.requeueComputedKeyAndDecorators,
    remove: Qd.remove,
    insertBefore: pl.insertBefore,
    insertAfter: pl.insertAfter,
    unshiftContainer: pl.unshiftContainer,
    pushContainer: pl.pushContainer,
    getOpposite: wn.getOpposite,
    getCompletionRecords: wn.getCompletionRecords,
    getSibling: wn.getSibling,
    getPrevSibling: wn.getPrevSibling,
    getNextSibling: wn.getNextSibling,
    getAllNextSiblings: wn.getAllNextSiblings,
    getAllPrevSiblings: wn.getAllPrevSiblings,
    get: wn.get,
    getAssignmentIdentifiers: wn.getAssignmentIdentifiers,
    getBindingIdentifiers: wn.getBindingIdentifiers,
    getOuterBindingIdentifiers: wn.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: wn.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: wn.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: v2.shareCommentsWithSiblings,
    addComment: v2.addComment,
    addComments: v2.addComments
  };
  Object.assign(bu.prototype, glt);
  bu.prototype.arrowFunctionToShadowed = _h.arrowFunctionToShadowed, Object.assign(bu.prototype, {
    has: xr.has,
    is: xr.is,
    isnt: xr.isnt,
    equals: xr.equals,
    hoist: pl.hoist,
    updateSiblingKeys: pl.updateSiblingKeys,
    call: nr.call,
    isBlacklisted: nr.isBlacklisted,
    setScope: nr.setScope,
    resync: nr.resync,
    popContext: nr.popContext,
    pushContext: nr.pushContext,
    setup: nr.setup,
    setKey: nr.setKey
  });
  bu.prototype._guessExecutionStatusRelativeToDifferentFunctions = xr._guessExecutionStatusRelativeTo, bu.prototype._guessExecutionStatusRelativeToDifferentFunctions =
  xr._guessExecutionStatusRelativeTo, Object.assign(bu.prototype, {
    _getTypeAnnotation: zd._getTypeAnnotation,
    _replaceWith: Gd._replaceWith,
    _resolve: xr._resolve,
    _call: nr._call,
    _resyncParent: nr._resyncParent,
    _resyncKey: nr._resyncKey,
    _resyncList: nr._resyncList,
    _resyncRemoved: nr._resyncRemoved,
    _getQueueContexts: nr._getQueueContexts,
    _removeFromScope: Qd._removeFromScope,
    _callRemovalHooks: Qd._callRemovalHooks,
    _remove: Qd._remove,
    _markRemoved: Qd._markRemoved,
    _assertUnremoved: Qd._assertUnremoved,
    _containerInsert: pl._containerInsert,
    _containerInsertBefore: pl._containerInsertBefore,
    _containerInsertAfter: pl._containerInsertAfter,
    _verifyNodeList: pl._verifyNodeList,
    _getKey: wn._getKey,
    _getPattern: wn._getPattern
  });
  for (let t of rP.TYPES) {
    let e = `is${t}`, s = rP[e];
    bu.prototype[e] = function(i) {
      return s(this.node, i);
    }, bu.prototype[`assert${t}`] = function(i) {
      if (!s(this.node, i))
        throw new TypeError(`Expected node path of type ${t}`);
    };
  }
  Object.assign(bu.prototype, mlt);
  for (let t of Object.keys(ult))
    t[0] !== "_" && (rP.TYPES.includes(t) || rP.TYPES.push(t));
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/context.js
var Pz = g((nP) => {
  "use strict";
  Object.defineProperty(nP, "__esModule", {
    value: !0
  });
  nP.default = void 0;
  var Tlt = Jc(), blt = fe(), C2 = ol(), {
    VISITOR_KEYS: xlt
  } = blt, w2 = class {
    static {
      n(this, "TraversalContext");
    }
    constructor(e, s, i, r) {
      this.queue = null, this.priorityQueue = null, this.parentPath = r, this.scope = e, this.state = i, this.opts = s;
    }
    shouldVisit(e) {
      let s = this.opts;
      if (s.enter || s.exit || s[e.type]) return !0;
      let i = xlt[e.type];
      if (!(i != null && i.length)) return !1;
      for (let r of i)
        if (e[r])
          return !0;
      return !1;
    }
    create(e, s, i, r) {
      return Tlt.default.get({
        parentPath: this.parentPath,
        parent: e,
        container: s,
        key: i,
        listKey: r
      });
    }
    maybeQueue(e, s) {
      this.queue && (s ? this.queue.push(e) : this.priorityQueue.push(e));
    }
    visitMultiple(e, s, i) {
      if (e.length === 0) return !1;
      let r = [];
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        o && this.shouldVisit(o) && r.push(this.create(s, e, a, i));
      }
      return this.visitQueue(r);
    }
    visitSingle(e, s) {
      return this.shouldVisit(e[s]) ? this.visitQueue([this.create(e, e, s)]) : !1;
    }
    visitQueue(e) {
      this.queue = e, this.priorityQueue = [];
      let s = /* @__PURE__ */ new WeakSet(), i = !1, r = 0;
      for (; r < e.length; ) {
        let a = e[r];
        if (r++, C2.resync.call(a), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && C2.pushContext.call(a, this),
        a.key === null) continue;
        let {
          node: o
        } = a;
        if (!s.has(o)) {
          if (o && s.add(o), a.visit()) {
            i = !0;
            break;
          }
          if (this.priorityQueue.length && (i = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e, i))
            break;
        }
      }
      for (let a = 0; a < r; a++)
        C2.popContext.call(e[a]);
      return this.queue = null, i;
    }
    visit(e, s) {
      let i = e[s];
      return i ? Array.isArray(i) ? this.visitMultiple(i, e, s) : this.visitSingle(e, s) : !1;
    }
  };
  nP.default = w2;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/traverse-node.js
var SS = g((I2) => {
  "use strict";
  Object.defineProperty(I2, "__esModule", {
    value: !0
  });
  I2.traverseNode = Alt;
  var Slt = Pz(), Plt = fe(), {
    VISITOR_KEYS: Elt
  } = Plt;
  function Alt(t, e, s, i, r, a, o) {
    let l = Elt[t.type];
    if (!l) return !1;
    let u = new Slt.default(s, e, i, r);
    if (o)
      return a != null && a[r.parentKey] ? !1 : u.visitQueue([r]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(t, c))
        return !0;
    return !1;
  }
  n(Alt, "traverseNode");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/path/context.js
var ol = g((Ki) => {
  "use strict";
  Object.defineProperty(Ki, "__esModule", {
    value: !0
  });
  Ki._call = k2;
  Ki._getQueueContexts = qlt;
  Ki._resyncKey = Iz;
  Ki._resyncList = Nz;
  Ki._resyncParent = wz;
  Ki._resyncRemoved = Llt;
  Ki.call = N2;
  Ki.isDenylisted = vz;
  Ki.popContext = Blt;
  Ki.pushContext = Mlt;
  Ki.requeue = jlt;
  Ki.requeueComputedKeyAndDecorators = Rlt;
  Ki.resync = _lt;
  Ki.setContext = Olt;
  Ki.setKey = aP;
  Ki.setScope = Cz;
  Ki.setup = Flt;
  Ki.skip = Nlt;
  Ki.skipKey = klt;
  Ki.stop = Dlt;
  Ki.visit = Ilt;
  var vlt = SS(), Ez = Jc(), Clt = VS(), wlt = fe();
  function N2(t) {
    let e = this.opts;
    if (this.debug(t), this.node && k2.call(this, e[t]))
      return !0;
    if (this.node) {
      var s;
      return k2.call(this, (s = e[this.node.type]) == null ? void 0 : s[t]);
    }
    return !1;
  }
  n(N2, "call");
  function k2(t) {
    if (!t) return !1;
    for (let e of t) {
      if (!e) continue;
      let s = this.node;
      if (!s) return !0;
      let i = e.call(this.state, this, this.state);
      if (i && typeof i == "object" && typeof i.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (i)
        throw new Error(`Unexpected return value from visitor method ${e}`);
      if (this.node !== s || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  n(k2, "_call");
  function vz() {
    var t;
    let e = (t = this.opts.denylist) != null ? t : this.opts.blacklist;
    return e?.includes(this.node.type);
  }
  n(vz, "isDenylisted");
  Ki.isBlacklisted = vz;
  function Az(t, e) {
    t.context !== e && (t.context = e, t.state = e.state, t.opts = e.opts);
  }
  n(Az, "restoreContext");
  function Ilt() {
    var t, e;
    if (!this.node || this.isDenylisted() || (t = (e = this.opts).shouldSkip) != null && t.call(e, this))
      return !1;
    let s = this.context;
    return this.shouldSkip || N2.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (Az(this, s), this.debug("Recursing into..\
."), this.shouldStop = (0, vlt.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), Az(this, s), N2.call(this, "\
exit"), this.shouldStop);
  }
  n(Ilt, "visit");
  function Nlt() {
    this.shouldSkip = !0;
  }
  n(Nlt, "skip");
  function klt(t) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[t] = !0;
  }
  n(klt, "skipKey");
  function Dlt() {
    this._traverseFlags |= Ez.SHOULD_SKIP | Ez.SHOULD_STOP;
  }
  n(Dlt, "stop");
  function Cz() {
    var t, e;
    if ((t = this.opts) != null && t.noScope) return;
    let s = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && s.isMethod() || this.key === "discriminant" && s.isSwitchStatement()) && (s = s.
    parentPath);
    let i;
    for (; s && !i; ) {
      var r;
      if ((r = s.opts) != null && r.noScope) return;
      i = s.scope, s = s.parentPath;
    }
    this.scope = this.getScope(i), (e = this.scope) == null || e.init();
  }
  n(Cz, "setScope");
  function Olt(t) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, t && (this.context = t, this.state = t.state, this.opts =
    t.opts), Cz.call(this), this;
  }
  n(Olt, "setContext");
  function _lt() {
    this.removed || (wz.call(this), Nz.call(this), Iz.call(this));
  }
  n(_lt, "resync");
  function wz() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  n(wz, "_resyncParent");
  function Iz() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let t = 0; t < this.container.length; t++)
          if (this.container[t] === this.node) {
            aP.call(this, t);
            return;
          }
      } else
        for (let t of Object.keys(this.container))
          if (this.container[t] === this.node) {
            aP.call(this, t);
            return;
          }
      this.key = null;
    }
  }
  n(Iz, "_resyncKey");
  function Nz() {
    if (!this.parent || !this.inList) return;
    let t = this.parent[this.listKey];
    this.container !== t && (this.container = t || null);
  }
  n(Nz, "_resyncList");
  function Llt() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && Clt._markRemoved.call(this);
  }
  n(Llt, "_resyncRemoved");
  function Blt() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  n(Blt, "popContext");
  function Mlt(t) {
    this.contexts.push(t), this.setContext(t);
  }
  n(Mlt, "pushContext");
  function Flt(t, e, s, i) {
    this.listKey = s, this.container = e, this.parentPath = t || this.parentPath, aP.call(this, i);
  }
  n(Flt, "setup");
  function aP(t) {
    var e;
    this.key = t, this.node = this.container[this.key], this.type = (e = this.node) == null ? void 0 : e.type;
  }
  n(aP, "setKey");
  function jlt(t = this) {
    if (t.removed) return;
    let e = this.contexts;
    for (let s of e)
      s.maybeQueue(t);
  }
  n(jlt, "requeue");
  function Rlt() {
    let {
      context: t,
      node: e
    } = this;
    if (!wlt.isPrivate(e) && e.computed && t.maybeQueue(this.get("key")), e.decorators)
      for (let s of this.get("decorators"))
        t.maybeQueue(s);
  }
  n(Rlt, "requeueComputedKeyAndDecorators");
  function qlt() {
    let t = this, e = this.contexts;
    for (; !e.length && (t = t.parentPath, !!t); )
      e = t.contexts;
    return e;
  }
  n(qlt, "_getQueueContexts");
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/hub.js
var kz = g((oP) => {
  "use strict";
  Object.defineProperty(oP, "__esModule", {
    value: !0
  });
  oP.default = void 0;
  var D2 = class {
    static {
      n(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e, s, i = TypeError) {
      return new i(s);
    }
  };
  oP.default = D2;
});

// ../node_modules/@babel/helper-module-transforms/node_modules/@babel/traverse/lib/index.js
var Ld = g((xu) => {
  "use strict";
  Object.defineProperty(xu, "__esModule", {
    value: !0
  });
  Object.defineProperty(xu, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $lt.default;
    }, "get")
  });
  Object.defineProperty(xu, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vlt.default;
    }, "get")
  });
  Object.defineProperty(xu, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wlt.default;
    }, "get")
  });
  xu.visitors = xu.default = void 0;
  ol();
  var iT = jg();
  xu.visitors = iT;
  var Ult = fe(), Klt = Ph(), Dz = SS(), Vlt = Jc(), Wlt = WD(), $lt = kz(), {
    VISITOR_KEYS: Hlt,
    removeProperties: Jlt,
    traverseFast: Oz
  } = Ult;
  function ja(t, e = {}, s, i, r, a) {
    if (t) {
      if (!e.noScope && !s && t.type !== "Program" && t.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${t.
        type} node without passing scope and parentPath.`);
      if (!r && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      Hlt[t.type] && (iT.explode(e), (0, Dz.traverseNode)(t, e, s, i, r, null, a));
    }
  }
  n(ja, "traverse");
  var vKs = xu.default = ja;
  ja.visitors = iT;
  ja.verify = iT.verify;
  ja.explode = iT.explode;
  ja.cheap = function(t, e) {
    Oz(t, e);
  };
  ja.node = function(t, e, s, i, r, a) {
    (0, Dz.traverseNode)(t, e, s, i, r, a);
  };
  ja.clearNode = function(t, e) {
    Jlt(t, e);
  };
  ja.removeProperties = function(t, e) {
    return Oz(t, ja.clearNode, e), t;
  };
  function Ylt(t, e) {
    t.node.type === e.type && (e.has = !0, t.stop());
  }
  n(Ylt, "hasDenylistedType");
  ja.hasType = function(t, e, s) {
    if (s != null && s.includes(t.type)) return !1;
    if (t.type === e) return !0;
    let i = {
      has: !1,
      type: e
    };
    return ja(t, {
      noScope: !0,
      denylist: s,
      enter: Ylt
    }, null, i), i.has;
  };
  ja.cache = Klt;
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var Bz = g((O2) => {
  "use strict";
  Object.defineProperty(O2, "__esModule", {
    value: !0
  });
  O2.default = Xlt;
  var _z = ar(), Lz = Ld(), lP;
  function Xlt(t) {
    lP || (lP = Lz.visitors.environmentVisitor({
      ThisExpression(e) {
        e.replaceWith(_z.types.unaryExpression("void", _z.types.numericLiteral(0), !0));
      }
    }), lP.noScope = !0), (0, Lz.default)(t.node, lP);
  }
  n(Xlt, "rewriteThis");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var Mz = g((_2) => {
  "use strict";
  Object.defineProperty(_2, "__esModule", {
    value: !0
  });
  _2.default = Glt;
  var qt = ar();
  function zlt(t) {
    do
      switch (t.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return !0;
        case "ExportSpecifier":
          return t.parentPath.parent.exportKind === "type";
        default:
          if (t.parentPath.isStatement() || t.parentPath.isExpression())
            return !1;
      }
    while (t = t.parentPath);
  }
  n(zlt, "isInType");
  function Glt(t, e, s) {
    let i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ n((u) => {
      t.requeue(u);
    }, "requeueInParent");
    for (let [u, c] of e.source) {
      for (let [p, h] of c.imports)
        i.set(p, [u, h, null]);
      for (let p of c.importsNamespace)
        i.set(p, [u, null, p]);
    }
    for (let [u, c] of e.local) {
      let p = r.get(u);
      p || (p = [], r.set(u, p)), p.push(...c.names);
    }
    let o = {
      metadata: e,
      requeueInParent: a,
      scope: t.scope,
      exported: r
    };
    t.traverse(Qlt, o);
    let l = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: e,
      requeueInParent: a,
      scope: t.scope,
      imported: i,
      exported: r,
      buildImportReference([u, c, p], h) {
        let f = e.source.get(u);
        if (f.referenced = !0, p) {
          if (f.wrap) {
            var d;
            h = (d = s(h, f.wrap)) != null ? d : h;
          }
          return h;
        }
        let y = qt.types.identifier(f.name);
        if (f.wrap) {
          var m;
          y = (m = s(y, f.wrap)) != null ? m : y;
        }
        if (c === "default" && f.interop === "node-default")
          return y;
        let T = e.stringSpecifiers.has(c);
        return qt.types.memberExpression(y, T ? qt.types.stringLiteral(c) : qt.types.identifier(c), T);
      }
    };
    t.traverse(Zlt, l);
  }
  n(Glt, "rewriteLiveReferences");
  var Qlt = {
    Scope(t) {
      t.skip();
    },
    ClassDeclaration(t) {
      let {
        requeueInParent: e,
        exported: s,
        metadata: i
      } = this, {
        id: r
      } = t.node;
      if (!r) throw new Error("Expected class to have a name");
      let a = r.name, o = s.get(a) || [];
      if (o.length > 0) {
        let l = qt.types.expressionStatement(Lh(i, o, qt.types.identifier(a), t.scope));
        l._blockHoist = t.node._blockHoist, e(t.insertAfter(l)[0]);
      }
    },
    VariableDeclaration(t) {
      let {
        requeueInParent: e,
        exported: s,
        metadata: i
      } = this, r = t.node.kind === "var";
      for (let a of t.get("declarations")) {
        let {
          id: o
        } = a.node, {
          init: l
        } = a.node;
        if (qt.types.isIdentifier(o) && s.has(o.name) && !qt.types.isArrowFunctionExpression(l) && (!qt.types.isFunctionExpression(l) || l.id) &&
        (!qt.types.isClassExpression(l) || l.id)) {
          if (!l) {
            if (r)
              continue;
            l = t.scope.buildUndefinedNode();
          }
          a.node.init = Lh(i, s.get(o.name), l, t.scope), e(a.get("init"));
        } else
          for (let u of Object.keys(a.getOuterBindingIdentifiers()))
            if (s.has(u)) {
              let c = qt.types.expressionStatement(Lh(i, s.get(u), qt.types.identifier(u), t.scope));
              c._blockHoist = t.node._blockHoist, e(t.insertAfter(c)[0]);
            }
      }
    }
  }, Lh = /* @__PURE__ */ n((t, e, s, i) => {
    let r = t.exportName;
    for (let a = i; a != null; a = a.parent)
      a.hasOwnBinding(r) && a.rename(r);
    return (e || []).reduce((a, o) => {
      let {
        stringSpecifiers: l
      } = t, u = l.has(o);
      return qt.types.assignmentExpression("=", qt.types.memberExpression(qt.types.identifier(r), u ? qt.types.stringLiteral(o) : qt.types.identifier(
      o), u), a);
    }, s);
  }, "buildBindingExportAssignmentExpression"), uP = /* @__PURE__ */ n((t) => qt.template.expression.ast`
    (function() {
      throw new Error('"' + '${t}' + '" is read-only.');
    })()
  `, "buildImportThrow"), Zlt = {
    ReferencedIdentifier(t) {
      let {
        seen: e,
        buildImportReference: s,
        scope: i,
        imported: r,
        requeueInParent: a
      } = this;
      if (e.has(t.node)) return;
      e.add(t.node);
      let o = t.node.name, l = r.get(o);
      if (l) {
        if (zlt(t))
          throw t.buildCodeFrameError(`Cannot transform the imported binding "${o}" since it's also used in a type annotation. Please strip \
type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        let u = t.scope.getBinding(o);
        if (i.getBinding(o) !== u) return;
        let p = s(l, t.node);
        if (p.loc = t.node.loc, (t.parentPath.isCallExpression({
          callee: t.node
        }) || t.parentPath.isOptionalCallExpression({
          callee: t.node
        }) || t.parentPath.isTaggedTemplateExpression({
          tag: t.node
        })) && qt.types.isMemberExpression(p))
          t.replaceWith(qt.types.sequenceExpression([qt.types.numericLiteral(0), p]));
        else if (t.isJSXIdentifier() && qt.types.isMemberExpression(p)) {
          let {
            object: h,
            property: f
          } = p;
          t.replaceWith(qt.types.jsxMemberExpression(qt.types.jsxIdentifier(h.name), qt.types.jsxIdentifier(f.name)));
        } else
          t.replaceWith(p);
        a(t), t.skip();
      }
    },
    UpdateExpression(t) {
      let {
        scope: e,
        seen: s,
        imported: i,
        exported: r,
        requeueInParent: a,
        buildImportReference: o
      } = this;
      if (s.has(t.node)) return;
      s.add(t.node);
      let l = t.get("argument");
      if (l.isMemberExpression()) return;
      let u = t.node;
      if (l.isIdentifier()) {
        let c = l.node.name;
        if (e.getBinding(c) !== t.scope.getBinding(c))
          return;
        let p = r.get(c), h = i.get(c);
        if (p?.length > 0 || h)
          if (h)
            t.replaceWith(qt.types.assignmentExpression(u.operator[0] + "=", o(h, l.node), uP(c)));
          else if (u.prefix)
            t.replaceWith(Lh(this.metadata, p, qt.types.cloneNode(u), t.scope));
          else {
            let f = e.generateDeclaredUidIdentifier(c);
            t.replaceWith(qt.types.sequenceExpression([qt.types.assignmentExpression("=", qt.types.cloneNode(f), qt.types.cloneNode(u)), Lh(
            this.metadata, p, qt.types.identifier(c), t.scope), qt.types.cloneNode(f)]));
          }
      }
      a(t), t.skip();
    },
    AssignmentExpression: {
      exit(t) {
        let {
          scope: e,
          seen: s,
          imported: i,
          exported: r,
          requeueInParent: a,
          buildImportReference: o
        } = this;
        if (s.has(t.node)) return;
        s.add(t.node);
        let l = t.get("left");
        if (!l.isMemberExpression())
          if (l.isIdentifier()) {
            let u = l.node.name;
            if (e.getBinding(u) !== t.scope.getBinding(u))
              return;
            let c = r.get(u), p = i.get(u);
            if (c?.length > 0 || p) {
              let h = t.node;
              p && (h.left = o(p, l.node), h.right = qt.types.sequenceExpression([h.right, uP(u)]));
              let {
                operator: f
              } = h, d;
              f === "=" ? d = h : f === "&&=" || f === "||=" || f === "??=" ? d = qt.types.assignmentExpression("=", h.left, qt.types.logicalExpression(
              f.slice(0, -1), qt.types.cloneNode(h.left), h.right)) : d = qt.types.assignmentExpression("=", h.left, qt.types.binaryExpression(
              f.slice(0, -1), qt.types.cloneNode(h.left), h.right)), t.replaceWith(Lh(this.metadata, c, d, t.scope)), a(t), t.skip();
            }
          } else {
            let u = l.getOuterBindingIdentifiers(), c = Object.keys(u).filter((f) => e.getBinding(f) === t.scope.getBinding(f)), p = c.find(
            (f) => i.has(f));
            p && (t.node.right = qt.types.sequenceExpression([t.node.right, uP(p)]));
            let h = [];
            if (c.forEach((f) => {
              let d = r.get(f) || [];
              d.length > 0 && h.push(Lh(this.metadata, d, qt.types.identifier(f), t.scope));
            }), h.length > 0) {
              let f = qt.types.sequenceExpression(h);
              t.parentPath.isExpressionStatement() && (f = qt.types.expressionStatement(f), f._blockHoist = t.parentPath.node._blockHoist);
              let d = t.insertAfter(f)[0];
              a(d);
            }
          }
      }
    },
    ForXStatement(t) {
      let {
        scope: e,
        node: s
      } = t, {
        left: i
      } = s, {
        exported: r,
        imported: a,
        scope: o
      } = this;
      if (!qt.types.isVariableDeclaration(i)) {
        let l = !1, u, c = t.get("body").scope;
        for (let f of Object.keys(qt.types.getOuterBindingIdentifiers(i)))
          o.getBinding(f) === e.getBinding(f) && (r.has(f) && (l = !0, c.hasOwnBinding(f) && c.rename(f)), a.has(f) && !u && (u = f));
        if (!l && !u)
          return;
        t.ensureBlock();
        let p = t.get("body"), h = e.generateUidIdentifierBasedOnNode(i);
        t.get("left").replaceWith(qt.types.variableDeclaration("let", [qt.types.variableDeclarator(qt.types.cloneNode(h))])), e.registerDeclaration(
        t.get("left")), l && p.unshiftContainer("body", qt.types.expressionStatement(qt.types.assignmentExpression("=", i, h))), u && p.unshiftContainer(
        "body", qt.types.expressionStatement(uP(u)));
      }
    }
  };
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var L2 = g((Zd) => {
  "use strict";
  Object.defineProperty(Zd, "__esModule", {
    value: !0
  });
  Zd.default = rut;
  Zd.hasExports = tut;
  Zd.isSideEffectImport = sut;
  Zd.validateImportInteropOption = jz;
  var Fz = require("path"), eut = Ea();
  function tut(t) {
    return t.hasExports;
  }
  n(tut, "hasExports");
  function sut(t) {
    return t.imports.size === 0 && t.importsNamespace.size === 0 && t.reexports.size === 0 && t.reexportNamespace.size === 0 && !t.reexportAll;
  }
  n(sut, "isSideEffectImport");
  function jz(t) {
    if (typeof t != "function" && t !== "none" && t !== "babel" && t !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${t}).`);
    return t;
  }
  n(jz, "validateImportInteropOption");
  function iut(t, e, s) {
    return typeof t == "function" ? jz(t(e, s)) : t;
  }
  n(iut, "resolveImportInterop");
  function rut(t, e, {
    importInterop: s,
    initializeReexports: i = !1,
    getWrapperPayload: r,
    esNamespaceOnly: a = !1,
    filename: o
  }) {
    e || (e = t.scope.generateUidIdentifier("exports").name);
    let l = /* @__PURE__ */ new Set();
    out(t);
    let {
      local: u,
      sources: c,
      hasExports: p
    } = nut(t, {
      initializeReexports: i,
      getWrapperPayload: r
    }, l);
    lut(t);
    for (let [h, f] of c) {
      let {
        importsNamespace: d,
        imports: y
      } = f;
      if (d.size > 0 && y.size === 0) {
        let [T] = d;
        f.name = T;
      }
      let m = iut(s, h, o);
      m === "none" ? f.interop = "none" : m === "node" && f.interop === "namespace" ? f.interop = "node-namespace" : m === "node" && f.interop ===
      "default" ? f.interop = "node-default" : a && f.interop === "namespace" && (f.interop = "default");
    }
    return {
      exportName: e,
      exportNameListName: null,
      hasExports: p,
      local: u,
      source: c,
      stringSpecifiers: l
    };
  }
  n(rut, "normalizeModuleAndLoadMetadata");
  function cP(t, e) {
    if (t.isIdentifier())
      return t.node.name;
    if (t.isStringLiteral()) {
      let s = t.node.value;
      return (0, eut.isIdentifierName)(s) || e.add(s), s;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${t.node.type}`);
  }
  n(cP, "getExportSpecifierName");
  function Rz(t) {
    if (!t.isExportSpecifier())
      throw t.isExportNamespaceSpecifier() ? t.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform\
-export-namespace-from`.") : t.buildCodeFrameError("Unexpected export specifier type");
  }
  n(Rz, "assertExportSpecifier");
  function nut(t, {
    getWrapperPayload: e,
    initializeReexports: s
  }, i) {
    let r = aut(t, s, i), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ n((c, p) => {
      let h = c.value, f = o.get(h);
      return f ? a.get(h).push(p) : (f = {
        name: t.scope.generateUidIdentifier((0, Fz.basename)(h, (0, Fz.extname)(h))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: !1
      }, o.set(h, f), a.set(h, [p])), f;
    }, "getData"), u = !1;
    t.get("body").forEach((c) => {
      if (c.isImportDeclaration()) {
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), c.get("specifiers").forEach((h) => {
          if (h.isImportDefaultSpecifier()) {
            let f = h.get("local").node.name;
            p.imports.set(f, "default");
            let d = r.get(f);
            d && (r.delete(f), d.names.forEach((y) => {
              p.reexports.set(y, "default");
            }), p.referenced = !0);
          } else if (h.isImportNamespaceSpecifier()) {
            let f = h.get("local").node.name;
            p.importsNamespace.add(f);
            let d = r.get(f);
            d && (r.delete(f), d.names.forEach((y) => {
              p.reexportNamespace.add(y);
            }), p.referenced = !0);
          } else if (h.isImportSpecifier()) {
            let f = cP(h.get("imported"), i), d = h.get("local").node.name;
            p.imports.set(d, f);
            let y = r.get(d);
            y && (r.delete(d), y.names.forEach((m) => {
              p.reexports.set(m, f);
            }), p.referenced = !0);
          }
        });
      } else if (c.isExportAllDeclaration()) {
        u = !0;
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), p.reexportAll = {
          loc: c.node.loc
        }, p.referenced = !0;
      } else if (c.isExportNamedDeclaration() && c.node.source) {
        u = !0;
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), c.get("specifiers").forEach((h) => {
          Rz(h);
          let f = cP(h.get("local"), i), d = cP(h.get("exported"), i);
          if (p.reexports.set(d, f), p.referenced = !0, d === "__esModule")
            throw h.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else (c.isExportNamedDeclaration() || c.isExportDefaultDeclaration()) && (u = !0);
    });
    for (let c of o.values()) {
      let p = !1, h = !1;
      c.importsNamespace.size > 0 && (p = !0, h = !0), c.reexportAll && (h = !0);
      for (let f of c.imports.values())
        f === "default" ? p = !0 : h = !0;
      for (let f of c.reexports.values())
        f === "default" ? p = !0 : h = !0;
      p && h ? c.interop = "namespace" : p && (c.interop = "default");
    }
    if (e)
      for (let [c, p] of o)
        p.wrap = e(c, p, a.get(c));
    return {
      hasExports: u,
      local: r,
      sources: o
    };
  }
  n(nut, "getModuleMetadata");
  function aut(t, e, s) {
    let i = /* @__PURE__ */ new Map();
    t.get("body").forEach((o) => {
      let l;
      if (o.isImportDeclaration())
        l = "import";
      else {
        if (o.isExportDefaultDeclaration() && (o = o.get("declaration")), o.isExportNamedDeclaration()) {
          if (o.node.declaration)
            o = o.get("declaration");
          else if (e && o.node.source && o.get("source").isStringLiteral()) {
            o.get("specifiers").forEach((u) => {
              Rz(u), i.set(u.get("local").node.name, "block");
            });
            return;
          }
        }
        if (o.isFunctionDeclaration())
          l = "hoisted";
        else if (o.isClassDeclaration())
          l = "block";
        else if (o.isVariableDeclaration({
          kind: "var"
        }))
          l = "var";
        else if (o.isVariableDeclaration())
          l = "block";
        else
          return;
      }
      Object.keys(o.getOuterBindingIdentifiers()).forEach((u) => {
        i.set(u, l);
      });
    });
    let r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ n((o) => {
      let l = o.node.name, u = r.get(l);
      if (!u) {
        let c = i.get(l);
        if (c === void 0)
          throw o.buildCodeFrameError(`Exporting local "${l}", which is not declared.`);
        u = {
          names: [],
          kind: c
        }, r.set(l, u);
      }
      return u;
    }, "getLocalMetadata");
    return t.get("body").forEach((o) => {
      if (o.isExportNamedDeclaration() && (e || !o.node.source))
        if (o.node.declaration) {
          let l = o.get("declaration"), u = l.getOuterBindingIdentifierPaths();
          Object.keys(u).forEach((c) => {
            if (c === "__esModule")
              throw l.buildCodeFrameError('Illegal export "__esModule".');
            a(u[c]).names.push(c);
          });
        } else
          o.get("specifiers").forEach((l) => {
            let u = l.get("local"), c = l.get("exported"), p = a(u), h = cP(c, s);
            if (h === "__esModule")
              throw c.buildCodeFrameError('Illegal export "__esModule".');
            p.names.push(h);
          });
      else if (o.isExportDefaultDeclaration()) {
        let l = o.get("declaration");
        if (l.isFunctionDeclaration() || l.isClassDeclaration())
          a(l.get("id")).names.push("default");
        else
          throw l.buildCodeFrameError("Unexpected default expression export.");
      }
    }), r;
  }
  n(aut, "getLocalExportMetadata");
  function out(t) {
    t.get("body").forEach((e) => {
      if (e.isExportDefaultDeclaration()) {
        {
          var s;
          (s = e.splitExportDeclaration) != null || (e.splitExportDeclaration = Ld().NodePath.prototype.splitExportDeclaration);
        }
        e.splitExportDeclaration();
      }
    });
  }
  n(out, "nameAnonymousExports");
  function lut(t) {
    t.get("body").forEach((e) => {
      if (e.isImportDeclaration())
        e.remove();
      else if (e.isExportNamedDeclaration())
        e.node.declaration ? (e.node.declaration._blockHoist = e.node._blockHoist, e.replaceWith(e.node.declaration)) : e.remove();
      else if (e.isExportDefaultDeclaration()) {
        let s = e.get("declaration");
        if (s.isFunctionDeclaration() || s.isClassDeclaration())
          s._blockHoist = e.node._blockHoist, e.replaceWith(s);
        else
          throw s.buildCodeFrameError("Unexpected default expression export.");
      } else e.isExportAllDeclaration() && e.remove();
    });
  }
  n(lut, "removeImportExportDeclarations");
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var qz = g((pP) => {
  "use strict";
  Object.defineProperty(pP, "__esModule", {
    value: !0
  });
  pP.toGetWrapperPayload = put;
  pP.wrapReference = hut;
  var uut = ar(), cut = L2();
  function put(t) {
    return (e, s) => {
      if (t === !1 || (0, cut.isSideEffectImport)(s) || s.reexportAll) return null;
      if (t === !0)
        return e.includes(".") ? null : "lazy";
      if (Array.isArray(t))
        return t.includes(e) ? "lazy" : null;
      if (typeof t == "function")
        return t(e) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }
  n(put, "toGetWrapperPayload");
  function hut(t, e) {
    return e === "lazy" ? uut.types.callExpression(t, []) : null;
  }
  n(hut, "wrapReference");
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var B2 = g((hP) => {
  "use strict";
  Object.defineProperty(hP, "__esModule", {
    value: !0
  });
  hP.buildDynamicImport = fut;
  var Wr = ar();
  hP.getDynamicImportSource = /* @__PURE__ */ n(function(e) {
    let [s] = e.arguments;
    return Wr.types.isStringLiteral(s) || Wr.types.isTemplateLiteral(s) ? s : Wr.template.expression.ast`\`\${${s}}\``;
  }, "getDynamicImportSource");
  function fut(t, e, s, i) {
    let r = Wr.types.isCallExpression(t) ? t.arguments[0] : t.source;
    if (Wr.types.isStringLiteral(r) || Wr.types.isTemplateLiteral(r) && r.quasis.length === 0)
      return e ? Wr.template.expression.ast`
        Promise.resolve().then(() => ${i(r)})
      ` : i(r);
    let a = Wr.types.isTemplateLiteral(r) ? Wr.types.identifier("specifier") : Wr.types.templateLiteral([Wr.types.templateElement({
      raw: ""
    }), Wr.types.templateElement({
      raw: ""
    })], [Wr.types.identifier("specifier")]);
    return e ? Wr.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${i(Wr.types.identifier("s"))})
      )(${r})
    ` : s ? Wr.template.expression.ast`
      (specifier =>
        new Promise(r => r(${i(a)}))
      )(${r})
    ` : Wr.template.expression.ast`
      (specifier => ${i(a)})(${r})
    `;
  }
  n(fut, "buildDynamicImport");
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var Uz = g((fP) => {
  "use strict";
  Object.defineProperty(fP, "__esModule", {
    value: !0
  });
  fP.default = M2;
  {
    let t = M2;
    fP.default = M2 = /* @__PURE__ */ n(function(s, i) {
      var r, a, o, l;
      return t(s, {
        moduleId: (r = i.moduleId) != null ? r : s.moduleId,
        moduleIds: (a = i.moduleIds) != null ? a : s.moduleIds,
        getModuleId: (o = i.getModuleId) != null ? o : s.getModuleId,
        moduleRoot: (l = i.moduleRoot) != null ? l : s.moduleRoot
      });
    }, "getModuleName");
  }
  function M2(t, e) {
    let {
      filename: s,
      filenameRelative: i = s,
      sourceRoot: r = e.moduleRoot
    } = t, {
      moduleId: a,
      moduleIds: o = !!a,
      getModuleId: l,
      moduleRoot: u = r
    } = e;
    if (!o) return null;
    if (a != null && !l)
      return a;
    let c = u != null ? u + "/" : "";
    if (i) {
      let p = r != null ? new RegExp("^" + r + "/?") : "";
      c += i.replace(p, "").replace(/\.\w*$/, "");
    }
    return c = c.replace(/\\/g, "/"), l && l(c) || c;
  }
  n(M2, "getModuleName");
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var nT = g((pa) => {
  "use strict";
  Object.defineProperty(pa, "__esModule", {
    value: !0
  });
  Object.defineProperty(pa, "buildDynamicImport", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yut.buildDynamicImport;
    }, "get")
  });
  pa.buildNamespaceInitStatements = Sut;
  pa.ensureStatementsHoisted = but;
  Object.defineProperty(pa, "getModuleName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gut.default;
    }, "get")
  });
  Object.defineProperty(pa, "hasExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rT.hasExports;
    }, "get")
  });
  Object.defineProperty(pa, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Kz.isModule;
    }, "get")
  });
  Object.defineProperty(pa, "isSideEffectImport", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rT.isSideEffectImport;
    }, "get")
  });
  pa.rewriteModuleStatementsAndPrepareHeader = Tut;
  Object.defineProperty(pa, "rewriteThis", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vz.default;
    }, "get")
  });
  pa.wrapInterop = xut;
  var dut = require("assert"), Ss = ar(), Kz = HH(), Vz = Bz(), mut = Mz(), rT = L2(), q2 = qz(), yut = B2(), gut = Uz();
  pa.getDynamicImportSource = B2().getDynamicImportSource;
  function Tut(t, {
    exportName: e,
    strict: s,
    allowTopLevelThis: i,
    strictMode: r,
    noInterop: a,
    importInterop: o = a ? "none" : "babel",
    lazy: l,
    getWrapperPayload: u = q2.toGetWrapperPayload(l ?? !1),
    wrapReference: c = q2.wrapReference,
    esNamespaceOnly: p,
    filename: h,
    constantReexports: f = arguments[1].loose,
    enumerableModuleMeta: d = arguments[1].loose,
    noIncompleteNsImportDetection: y
  }) {
    (0, rT.validateImportInteropOption)(o), dut((0, Kz.isModule)(t), "Cannot process module statements in a script"), t.node.sourceType = "s\
cript";
    let m = (0, rT.default)(t, e, {
      importInterop: o,
      initializeReexports: f,
      getWrapperPayload: u,
      esNamespaceOnly: p,
      filename: h
    });
    i || (0, Vz.default)(t), (0, mut.default)(t, m, c), r !== !1 && (t.node.directives.some((w) => w.value.value === "use strict") || t.unshiftContainer(
    "directives", Ss.types.directive(Ss.types.directiveLiteral("use strict"))));
    let T = [];
    (0, rT.hasExports)(m) && !s && T.push(Put(m, d));
    let b = Aut(t, m);
    return b && (m.exportNameListName = b.name, T.push(b.statement)), T.push(...vut(t, m, c, f, y)), {
      meta: m,
      headers: T
    };
  }
  n(Tut, "rewriteModuleStatementsAndPrepareHeader");
  function but(t) {
    t.forEach((e) => {
      e._blockHoist = 3;
    });
  }
  n(but, "ensureStatementsHoisted");
  function xut(t, e, s) {
    if (s === "none")
      return null;
    if (s === "node-namespace")
      return Ss.types.callExpression(t.hub.addHelper("interopRequireWildcard"), [e, Ss.types.booleanLiteral(!0)]);
    if (s === "node-default")
      return null;
    let i;
    if (s === "default")
      i = "interopRequireDefault";
    else if (s === "namespace")
      i = "interopRequireWildcard";
    else
      throw new Error(`Unknown interop: ${s}`);
    return Ss.types.callExpression(t.hub.addHelper(i), [e]);
  }
  n(xut, "wrapInterop");
  function Sut(t, e, s = !1, i = q2.wrapReference) {
    var r;
    let a = [], o = Ss.types.identifier(e.name);
    for (let u of e.importsNamespace)
      u !== e.name && a.push(Ss.template.statement`var NAME = SOURCE;`({
        NAME: u,
        SOURCE: Ss.types.cloneNode(o)
      }));
    let l = (r = i(o, e.wrap)) != null ? r : o;
    s && a.push(...Wz(t, e, !0, i));
    for (let u of e.reexportNamespace)
      a.push((Ss.types.isIdentifier(l) ? Ss.template.statement`EXPORTS.NAME = NAMESPACE;` : Ss.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
        EXPORTS: t.exportName,
        NAME: u,
        NAMESPACE: Ss.types.cloneNode(l)
      }));
    if (e.reexportAll) {
      let u = Eut(t, Ss.types.cloneNode(l), s);
      u.loc = e.reexportAll.loc, a.push(u);
    }
    return a;
  }
  n(Sut, "buildNamespaceInitStatements");
  var F2 = {
    constant: /* @__PURE__ */ n(({
      exports: t,
      exportName: e,
      namespaceImport: s
    }) => Ss.template.statement.ast`
      ${t}.${e} = ${s};
    `, "constant"),
    constantComputed: /* @__PURE__ */ n(({
      exports: t,
      exportName: e,
      namespaceImport: s
    }) => Ss.template.statement.ast`
      ${t}["${e}"] = ${s};
    `, "constantComputed"),
    spec: /* @__PURE__ */ n(({
      exports: t,
      exportName: e,
      namespaceImport: s
    }) => Ss.template.statement.ast`
      Object.defineProperty(${t}, "${e}", {
        enumerable: true,
        get: function() {
          return ${s};
        },
      });
    `, "spec")
  };
  function Wz(t, e, s, i) {
    var r;
    let a = Ss.types.identifier(e.name);
    a = (r = i(a, e.wrap)) != null ? r : a;
    let {
      stringSpecifiers: o
    } = t;
    return Array.from(e.reexports, ([l, u]) => {
      let c = Ss.types.cloneNode(a);
      u === "default" && e.interop === "node-default" || (o.has(u) ? c = Ss.types.memberExpression(c, Ss.types.stringLiteral(u), !0) : c = Ss.
      types.memberExpression(c, Ss.types.identifier(u)));
      let p = {
        exports: t.exportName,
        exportName: l,
        namespaceImport: c
      };
      return s || Ss.types.isIdentifier(c) ? o.has(l) ? F2.constantComputed(p) : F2.constant(p) : F2.spec(p);
    });
  }
  n(Wz, "buildReexportsFromMeta");
  function Put(t, e = !1) {
    return (e ? Ss.template.statement`
        EXPORTS.__esModule = true;
      ` : Ss.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: t.exportName
    });
  }
  n(Put, "buildESModuleHeader");
  function Eut(t, e, s) {
    return (s ? Ss.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : Ss.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: e,
      EXPORTS: t.exportName,
      VERIFY_NAME_LIST: t.exportNameListName ? (0, Ss.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: t.exportNameListName
      }) : null
    });
  }
  n(Eut, "buildNamespaceReexport");
  function Aut(t, e) {
    let s = /* @__PURE__ */ Object.create(null);
    for (let a of e.local.values())
      for (let o of a.names)
        s[o] = !0;
    let i = !1;
    for (let a of e.source.values()) {
      for (let o of a.reexports.keys())
        s[o] = !0;
      for (let o of a.reexportNamespace)
        s[o] = !0;
      i = i || !!a.reexportAll;
    }
    if (!i || Object.keys(s).length === 0) return null;
    let r = t.scope.generateUidIdentifier("exportNames");
    return delete s.default, {
      name: r.name,
      statement: Ss.types.variableDeclaration("var", [Ss.types.variableDeclarator(r, Ss.types.valueToNode(s))])
    };
  }
  n(Aut, "buildExportNameListDeclaration");
  function vut(t, e, s, i = !1, r = !1) {
    let a = [];
    for (let [l, u] of e.local)
      if (u.kind !== "import") {
        if (u.kind === "hoisted")
          a.push([u.names[0], R2(e, u.names, Ss.types.identifier(l))]);
        else if (!r)
          for (let c of u.names)
            a.push([c, null]);
      }
    for (let l of e.source.values()) {
      if (!i) {
        let u = Wz(e, l, !1, s), c = [...l.reexports.keys()];
        for (let p = 0; p < u.length; p++)
          a.push([c[p], u[p]]);
      }
      if (!r)
        for (let u of l.reexportNamespace)
          a.push([u, null]);
    }
    a.sort(([l], [u]) => l < u ? -1 : u < l ? 1 : 0);
    let o = [];
    if (r)
      for (let [, l] of a)
        o.push(l);
    else
      for (let u = 0; u < a.length; u += 100) {
        let c = [];
        for (let p = 0; p < 100 && u + p < a.length; p++) {
          let [h, f] = a[u + p];
          f !== null ? (c.length > 0 && (o.push(R2(e, c, t.scope.buildUndefinedNode())), c = []), o.push(f)) : c.push(h);
        }
        c.length > 0 && o.push(R2(e, c, t.scope.buildUndefinedNode()));
      }
    return o;
  }
  n(vut, "buildExportInitializationStatements");
  var j2 = {
    computed: /* @__PURE__ */ n(({
      exports: t,
      name: e,
      value: s
    }) => Ss.template.expression.ast`${t}["${e}"] = ${s}`, "computed"),
    default: /* @__PURE__ */ n(({
      exports: t,
      name: e,
      value: s
    }) => Ss.template.expression.ast`${t}.${e} = ${s}`, "default"),
    define: /* @__PURE__ */ n(({
      exports: t,
      name: e,
      value: s
    }) => Ss.template.expression.ast`
      Object.defineProperty(${t}, "${e}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${e}"] = ${s}`, "define")
  };
  function R2(t, e, s) {
    let {
      stringSpecifiers: i,
      exportName: r
    } = t;
    return Ss.types.expressionStatement(e.reduce((a, o) => {
      let l = {
        exports: r,
        name: o,
        value: a
      };
      return o === "__proto__" ? j2.define(l) : i.has(o) ? j2.computed(l) : j2.default(l);
    }, s));
  }
  n(R2, "buildInitStatement");
});

// ../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var Hz = g(($z) => {
  $z.getModuleName = () => nT().getModuleName;
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var K2 = g((mP) => {
  "use strict";
  Object.defineProperty(mP, "__esModule", {
    value: !0
  });
  mP.default = void 0;
  function aT() {
    let t = AN();
    return aT = /* @__PURE__ */ n(function() {
      return t;
    }, "helpers"), t;
  }
  n(aT, "helpers");
  function U2() {
    let t = zl();
    return U2 = /* @__PURE__ */ n(function() {
      return t;
    }, "_traverse"), t;
  }
  n(U2, "_traverse");
  function Jz() {
    let t = Yl();
    return Jz = /* @__PURE__ */ n(function() {
      return t;
    }, "_codeFrame"), t;
  }
  n(Jz, "_codeFrame");
  function Yz() {
    let t = fe();
    return Yz = /* @__PURE__ */ n(function() {
      return t;
    }, "_t"), t;
  }
  n(Yz, "_t");
  function dP() {
    let t = require("semver");
    return dP = /* @__PURE__ */ n(function() {
      return t;
    }, "_semver"), t;
  }
  n(dP, "_semver");
  var Cut = Hz(), {
    cloneNode: wut,
    interpreterDirective: Iut
  } = Yz(), Nut = {
    enter(t, e) {
      let s = t.node.loc;
      s && (e.loc = s, t.stop());
    }
  }, em = class {
    static {
      n(this, "File");
    }
    constructor(e, {
      code: s,
      ast: i,
      inputMap: r
    }) {
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope =
      void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
        file: this,
        getCode: /* @__PURE__ */ n(() => this.code, "getCode"),
        getScope: /* @__PURE__ */ n(() => this.scope, "getScope"),
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = e, this.code = s, this.ast = i, this.inputMap = r, this.path = U2().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      let {
        interpreter: e
      } = this.path.node;
      return e ? e.value : "";
    }
    set shebang(e) {
      e ? this.path.get("interpreter").replaceWith(Iut(e)) : this.path.get("interpreter").remove();
    }
    set(e, s) {
      if (e === "helpersNamespace")
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-\
helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to \
explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(e, s);
    }
    get(e) {
      return this._map.get(e);
    }
    has(e) {
      return this._map.has(e);
    }
    availableHelper(e, s) {
      let i;
      try {
        i = aT().minVersion(e);
      } catch (r) {
        if (r.code !== "BABEL_HELPER_UNKNOWN") throw r;
        return !1;
      }
      return typeof s != "string" ? !0 : (dP().valid(s) && (s = `^${s}`), !dP().intersects(`<${i}`, s) && !dP().intersects(">=8.0.0", s));
    }
    addHelper(e) {
      let s = this.declarations[e];
      if (s) return wut(s);
      let i = this.get("helperGenerator");
      if (i) {
        let c = i(e);
        if (c) return c;
      }
      aT().minVersion(e);
      let r = this.declarations[e] = this.scope.generateUidIdentifier(e), a = {};
      for (let c of aT().getDependencies(e))
        a[c] = this.addHelper(c);
      let {
        nodes: o,
        globals: l
      } = aT().get(e, (c) => a[c], r.name, Object.keys(this.scope.getAllBindings()));
      l.forEach((c) => {
        this.path.scope.hasBinding(c, !0) && this.path.scope.rename(c);
      }), o.forEach((c) => {
        c._compact = !0;
      });
      let u = this.path.unshiftContainer("body", o);
      for (let c of u)
        c.isVariableDeclaration() && this.scope.registerDeclaration(c);
      return r;
    }
    buildCodeFrameError(e, s, i = SyntaxError) {
      let r = e?.loc;
      if (!r && e) {
        let a = {
          loc: null
        };
        (0, U2().default)(e, Nut, this.scope, a), r = a.loc;
        let o = "This is an error on an internal node. Probably an internal error.";
        r && (o += " Location has been estimated."), s += ` (${o})`;
      }
      if (r) {
        let {
          highlightCode: a = !0
        } = this.opts;
        s += `
` + (0, Jz().codeFrameColumns)(this.code, {
          start: {
            line: r.start.line,
            column: r.start.column + 1
          },
          end: r.end && r.start.line === r.end.line ? {
            line: r.end.line,
            column: r.end.column + 1
          } : void 0
        }, {
          highlightCode: a
        });
      }
      return new i(s);
    }
  };
  mP.default = em;
  em.prototype.addImport = /* @__PURE__ */ n(function() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-mo\
dule-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }, "addImport"), em.prototype.addTemplateObject = /* @__PURE__ */ n(function() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }, "addTemplateObject"), em.prototype.getModuleName = /* @__PURE__ */ n(function() {
    return Cut.getModuleName()(this.opts, this.opts);
  }, "getModuleName");
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var Zz = g((X2) => {
  "use strict";
  Object.defineProperty(X2, "__esModule", {
    value: !0
  });
  X2.default = $ut;
  function V2() {
    let t = AN();
    return V2 = /* @__PURE__ */ n(function() {
      return t;
    }, "helpers"), t;
  }
  n(V2, "helpers");
  function Xz() {
    let t = $x();
    return Xz = /* @__PURE__ */ n(function() {
      return t;
    }, "_generator"), t;
  }
  n(Xz, "_generator");
  function zz() {
    let t = Xl();
    return zz = /* @__PURE__ */ n(function() {
      return t;
    }, "_template"), t;
  }
  n(zz, "_template");
  function Gz() {
    let t = fe();
    return Gz = /* @__PURE__ */ n(function() {
      return t;
    }, "_t"), t;
  }
  n(Gz, "_t");
  var {
    arrayExpression: kut,
    assignmentExpression: yP,
    binaryExpression: Dut,
    blockStatement: Out,
    callExpression: _ut,
    cloneNode: Lut,
    conditionalExpression: But,
    exportNamedDeclaration: Mut,
    exportSpecifier: Fut,
    expressionStatement: W2,
    functionExpression: jut,
    identifier: $r,
    memberExpression: $2,
    objectExpression: H2,
    program: gP,
    stringLiteral: Qz,
    unaryExpression: Rut,
    variableDeclaration: J2,
    variableDeclarator: Y2
  } = Gz(), qut = /* @__PURE__ */ n((t) => zz().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(t), "buildUmdWrapper");
  function Uut(t) {
    let e = $r("babelHelpers"), s = [], i = jut(null, [$r("global")], Out(s)), r = gP([W2(_ut(i, [But(Dut("===", Rut("typeof", $r("global")),
    Qz("undefined")), $r("self"), $r("global"))]))]);
    return s.push(J2("var", [Y2(e, yP("=", $2($r("global"), e), H2([])))])), TP(s, e, t), r;
  }
  n(Uut, "buildGlobal");
  function Kut(t) {
    let e = [], s = TP(e, null, t);
    return e.unshift(Mut(null, Object.keys(s).map((i) => Fut(Lut(s[i]), $r(i))))), gP(e, [], "module");
  }
  n(Kut, "buildModule");
  function Vut(t) {
    let e = $r("babelHelpers"), s = [];
    return s.push(J2("var", [Y2(e, $r("global"))])), TP(s, e, t), gP([qut({
      FACTORY_PARAMETERS: $r("global"),
      BROWSER_ARGUMENTS: yP("=", $2($r("root"), e), H2([])),
      COMMON_ARGUMENTS: $r("exports"),
      AMD_ARGUMENTS: kut([Qz("exports")]),
      FACTORY_BODY: s,
      UMD_ROOT: $r("this")
    })]);
  }
  n(Vut, "buildUmd");
  function Wut(t) {
    let e = $r("babelHelpers"), s = [];
    s.push(J2("var", [Y2(e, H2([]))]));
    let i = gP(s);
    return TP(s, e, t), s.push(W2(e)), i;
  }
  n(Wut, "buildVar");
  function TP(t, e, s) {
    let i = /* @__PURE__ */ n((a) => e ? $2(e, $r(a)) : $r(`_${a}`), "getHelperReference"), r = {};
    return V2().list.forEach(function(a) {
      if (s && !s.includes(a)) return;
      let o = r[a] = i(a), {
        nodes: l
      } = V2().get(a, i, e ? null : `_${a}`, [], e ? (u, c, p) => {
        p((h) => yP("=", o, h)), u.body.push(W2(yP("=", o, $r(c))));
      } : null);
      t.push(...l);
    }), r;
  }
  n(TP, "buildHelpers");
  function $ut(t, e = "global") {
    let s, i = {
      global: Uut,
      module: Kut,
      umd: Vut,
      var: Wut
    }[e];
    if (i)
      s = i(t);
    else
      throw new Error(`Unsupported output type ${e}`);
    return (0, Xz().default)(s).code;
  }
  n($ut, "_default");
});

// ../node_modules/gensync/index.js
var ha = g((JKs, oG) => {
  "use strict";
  var tG = Symbol.for("gensync:v1:start"), sG = Symbol.for("gensync:v1:suspend"), Hut = "GENSYNC_EXPECTED_START", Jut = "GENSYNC_EXPECTED_SU\
SPEND", iG = "GENSYNC_OPTIONS_ERROR", eG = "GENSYNC_RACE_NONEMPTY", Yut = "GENSYNC_ERRBACK_NO_CALLBACK";
  oG.exports = Object.assign(
    /* @__PURE__ */ n(function(e) {
      let s = e;
      return typeof e != "function" ? s = zut(e) : s = Gut(e), Object.assign(s, Xut(s));
    }, "gensync"),
    {
      all: z2({
        name: "all",
        arity: 1,
        sync: /* @__PURE__ */ n(function(t) {
          return Array.from(t[0]).map((s) => G2(s));
        }, "sync"),
        async: /* @__PURE__ */ n(function(t, e, s) {
          let i = Array.from(t[0]);
          if (i.length === 0) {
            Promise.resolve().then(() => e([]));
            return;
          }
          let r = 0, a = i.map(() => {
          });
          i.forEach((o, l) => {
            bP(
              o,
              (u) => {
                a[l] = u, r += 1, r === a.length && e(a);
              },
              s
            );
          });
        }, "async")
      }),
      race: z2({
        name: "race",
        arity: 1,
        sync: /* @__PURE__ */ n(function(t) {
          let e = Array.from(t[0]);
          if (e.length === 0)
            throw Bh("Must race at least 1 item", eG);
          return G2(e[0]);
        }, "sync"),
        async: /* @__PURE__ */ n(function(t, e, s) {
          let i = Array.from(t[0]);
          if (i.length === 0)
            throw Bh("Must race at least 1 item", eG);
          for (let r of i)
            bP(r, e, s);
        }, "async")
      })
    }
  );
  function Xut(t) {
    return {
      sync: /* @__PURE__ */ n(function(...s) {
        return G2(t.apply(this, s));
      }, "sync"),
      async: /* @__PURE__ */ n(function(...s) {
        return new Promise((i, r) => {
          bP(t.apply(this, s), i, r);
        });
      }, "async"),
      errback: /* @__PURE__ */ n(function(...s) {
        let i = s.pop();
        if (typeof i != "function")
          throw Bh(
            "Asynchronous function called without callback",
            Yut
          );
        let r;
        try {
          r = t.apply(this, s);
        } catch (a) {
          i(a);
          return;
        }
        bP(r, (a) => i(void 0, a), (a) => i(a));
      }, "errback")
    };
  }
  n(Xut, "makeFunctionAPI");
  function oT(t, e, s, i) {
    if (typeof s === t || i && typeof s > "u")
      return;
    let r;
    throw i ? r = `Expected opts.${e} to be either a ${t}, or undefined.` : r = `Expected opts.${e} to be a ${t}.`, Bh(r, iG);
  }
  n(oT, "assertTypeof");
  function Bh(t, e) {
    return Object.assign(new Error(t), { code: e });
  }
  n(Bh, "makeError");
  function zut({ name: t, arity: e, sync: s, async: i, errback: r }) {
    if (oT(
      "string",
      "name",
      t,
      !0
      /* allowUndefined */
    ), oT(
      "number",
      "arity",
      e,
      !0
      /* allowUndefined */
    ), oT("function", "sync", s), oT(
      "function",
      "async",
      i,
      !0
      /* allowUndefined */
    ), oT(
      "function",
      "errback",
      r,
      !0
      /* allowUndefined */
    ), i && r)
      throw Bh(
        "Expected one of either opts.async or opts.errback, but got _both_.",
        iG
      );
    if (typeof t != "string") {
      let a;
      r && r.name && r.name !== "errback" && (a = r.name), i && i.name && i.name !== "async" && (a = i.name.replace(/Async$/, "")), s && s.name &&
      s.name !== "sync" && (a = s.name.replace(/Sync$/, "")), typeof a == "string" && (t = a);
    }
    return typeof e != "number" && (e = s.length), z2({
      name: t,
      arity: e,
      sync: /* @__PURE__ */ n(function(a) {
        return s.apply(this, a);
      }, "sync"),
      async: /* @__PURE__ */ n(function(a, o, l) {
        i ? i.apply(this, a).then(o, l) : r ? r.call(this, ...a, (u, c) => {
          u == null ? o(c) : l(u);
        }) : o(s.apply(this, a));
      }, "async")
    });
  }
  n(zut, "newGenerator");
  function Gut(t) {
    return aG(t.name, t.length, function(...e) {
      return t.apply(this, e);
    });
  }
  n(Gut, "wrapGenerator");
  function z2({ name: t, arity: e, sync: s, async: i }) {
    return aG(t, e, function* (...r) {
      let a = yield tG;
      if (!a)
        return s.call(this, r);
      let o;
      try {
        i.call(
          this,
          r,
          (l) => {
            o || (o = { value: l }, a());
          },
          (l) => {
            o || (o = { err: l }, a());
          }
        );
      } catch (l) {
        o = { err: l }, a();
      }
      if (yield sG, o.hasOwnProperty("err"))
        throw o.err;
      return o.value;
    });
  }
  n(z2, "buildOperation");
  function G2(t) {
    let e;
    for (; !({ value: e } = t.next()).done; )
      rG(e, t);
    return e;
  }
  n(G2, "evaluateSync");
  function bP(t, e, s) {
    (/* @__PURE__ */ n(function i() {
      try {
        let r;
        for (; !({ value: r } = t.next()).done; ) {
          rG(r, t);
          let a = !0, o = !1, l = t.next(() => {
            a ? o = !0 : i();
          });
          if (a = !1, Qut(l, t), !o)
            return;
        }
        return e(r);
      } catch (r) {
        return s(r);
      }
    }, "step"))();
  }
  n(bP, "evaluateAsync");
  function rG(t, e) {
    t !== tG && nG(
      e,
      Bh(
        `Got unexpected yielded value in gensync generator: ${JSON.stringify(
          t
        )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
        Hut
      )
    );
  }
  n(rG, "assertStart");
  function Qut({ value: t, done: e }, s) {
    !e && t === sG || nG(
      s,
      Bh(
        e ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
          t
        )}. If you get this, it is probably a gensync bug.`,
        Jut
      )
    );
  }
  n(Qut, "assertSuspend");
  function nG(t, e) {
    throw t.throw && t.throw(e), e;
  }
  n(nG, "throwError");
  function aG(t, e, s) {
    if (typeof t == "string") {
      let i = Object.getOwnPropertyDescriptor(s, "name");
      (!i || i.configurable) && Object.defineProperty(
        s,
        "name",
        Object.assign(i || {}, {
          configurable: !0,
          value: t
        })
      );
    }
    if (typeof e == "number") {
      let i = Object.getOwnPropertyDescriptor(s, "length");
      (!i || i.configurable) && Object.defineProperty(
        s,
        "length",
        Object.assign(i || {}, {
          configurable: !0,
          value: e
        })
      );
    }
    return s;
  }
  n(aG, "setFunctionMetadata");
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var Zc = g((vo) => {
  "use strict";
  Object.defineProperty(vo, "__esModule", {
    value: !0
  });
  vo.forwardAsync = tct;
  vo.isAsync = void 0;
  vo.isThenable = pG;
  vo.maybeAsync = Zut;
  vo.waitFor = vo.onFirstPause = void 0;
  function Qc() {
    let t = ha();
    return Qc = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(Qc, "_gensync");
  function lG(t, e, s, i, r, a, o) {
    try {
      var l = t[a](o), u = l.value;
    } catch (c) {
      return void s(c);
    }
    l.done ? e(u) : Promise.resolve(u).then(i, r);
  }
  n(lG, "asyncGeneratorStep");
  function cG(t) {
    return function() {
      var e = this, s = arguments;
      return new Promise(function(i, r) {
        var a = t.apply(e, s);
        function o(u) {
          lG(a, i, r, o, l, "next", u);
        }
        n(o, "_next");
        function l(u) {
          lG(a, i, r, o, l, "throw", u);
        }
        n(l, "_throw"), o(void 0);
      });
    };
  }
  n(cG, "_asyncToGenerator");
  var uG = Qc()(function* (t) {
    return yield* t;
  }), XKs = vo.isAsync = Qc()({
    sync: /* @__PURE__ */ n(() => !1, "sync"),
    errback: /* @__PURE__ */ n((t) => t(null, !0), "errback")
  });
  function Zut(t, e) {
    return Qc()({
      sync(...s) {
        let i = t.apply(this, s);
        if (pG(i)) throw new Error(e);
        return i;
      },
      async(...s) {
        return Promise.resolve(t.apply(this, s));
      }
    });
  }
  n(Zut, "maybeAsync");
  var ect = Qc()({
    sync: /* @__PURE__ */ n((t) => t("sync"), "sync"),
    async: function() {
      var t = cG(function* (e) {
        return e("async");
      });
      return /* @__PURE__ */ n(function(s) {
        return t.apply(this, arguments);
      }, "async");
    }()
  });
  function tct(t, e) {
    let s = Qc()(t);
    return ect((i) => {
      let r = s[i];
      return e(r);
    });
  }
  n(tct, "forwardAsync");
  var zKs = vo.onFirstPause = Qc()({
    name: "onFirstPause",
    arity: 2,
    sync: /* @__PURE__ */ n(function(t) {
      return uG.sync(t);
    }, "sync"),
    errback: /* @__PURE__ */ n(function(t, e, s) {
      let i = !1;
      uG.errback(t, (r, a) => {
        i = !0, s(r, a);
      }), i || e();
    }, "errback")
  }), GKs = vo.waitFor = Qc()({
    sync: /* @__PURE__ */ n((t) => t, "sync"),
    async: function() {
      var t = cG(function* (e) {
        return e;
      });
      return /* @__PURE__ */ n(function(s) {
        return t.apply(this, arguments);
      }, "async");
    }()
  });
  function pG(t) {
    return !!t && (typeof t == "object" || typeof t == "function") && !!t.then && typeof t.then == "function";
  }
  n(pG, "isThenable");
});

// ../node_modules/@babel/core/lib/config/util.js
var SP = g((xP) => {
  "use strict";
  Object.defineProperty(xP, "__esModule", {
    value: !0
  });
  xP.isIterableIterator = rct;
  xP.mergeOptions = sct;
  function sct(t, e) {
    for (let s of Object.keys(e))
      if ((s === "parserOpts" || s === "generatorOpts" || s === "assumptions") && e[s]) {
        let i = e[s], r = t[s] || (t[s] = {});
        ict(r, i);
      } else {
        let i = e[s];
        i !== void 0 && (t[s] = i);
      }
  }
  n(sct, "mergeOptions");
  function ict(t, e) {
    for (let s of Object.keys(e)) {
      let i = e[s];
      i !== void 0 && (t[s] = i);
    }
  }
  n(ict, "mergeDefaultFields");
  function rct(t) {
    return !!t && typeof t.next == "function" && typeof t[Symbol.iterator] == "function";
  }
  n(rct, "isIterableIterator");
});

// ../node_modules/@babel/core/lib/config/caching.js
var Fh = g((Mh) => {
  "use strict";
  Object.defineProperty(Mh, "__esModule", {
    value: !0
  });
  Mh.assertSimpleType = PP;
  Mh.makeStrongCache = yG;
  Mh.makeStrongCacheSync = lct;
  Mh.makeWeakCache = mG;
  Mh.makeWeakCacheSync = oct;
  function fG() {
    let t = ha();
    return fG = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(fG, "_gensync");
  var tm = Zc(), nct = SP(), dG = /* @__PURE__ */ n((t) => fG()(t).sync, "synchronize");
  function* act() {
    return !0;
  }
  n(act, "genTrue");
  function mG(t) {
    return gG(WeakMap, t);
  }
  n(mG, "makeWeakCache");
  function oct(t) {
    return dG(mG(t));
  }
  n(oct, "makeWeakCacheSync");
  function yG(t) {
    return gG(Map, t);
  }
  n(yG, "makeStrongCache");
  function lct(t) {
    return dG(yG(t));
  }
  n(lct, "makeStrongCacheSync");
  function gG(t, e) {
    let s = new t(), i = new t(), r = new t();
    return /* @__PURE__ */ n(function* (o, l) {
      let u = yield* (0, tm.isAsync)(), c = u ? i : s, p = yield* uct(u, c, r, o, l);
      if (p.valid) return p.value;
      let h = new Q2(l), f = e(o, h), d, y;
      return (0, nct.isIterableIterator)(f) ? y = yield* (0, tm.onFirstPause)(f, () => {
        d = cct(h, r, o);
      }) : y = f, TG(c, h, o, y), d && (r.delete(o), d.release(y)), y;
    }, "cachedFunction");
  }
  n(gG, "makeCachedFunction");
  function* hG(t, e, s) {
    let i = t.get(e);
    if (i) {
      for (let {
        value: r,
        valid: a
      } of i)
        if (yield* a(s)) return {
          valid: !0,
          value: r
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  n(hG, "getCachedValue");
  function* uct(t, e, s, i, r) {
    let a = yield* hG(e, i, r);
    if (a.valid)
      return a;
    if (t) {
      let o = yield* hG(s, i, r);
      if (o.valid)
        return {
          valid: !0,
          value: yield* (0, tm.waitFor)(o.value.promise)
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  n(uct, "getCachedValueOrWait");
  function cct(t, e, s) {
    let i = new Z2();
    return TG(e, t, s, i), i;
  }
  n(cct, "setupAsyncLocks");
  function TG(t, e, s, i) {
    e.configured() || e.forever();
    let r = t.get(s);
    switch (e.deactivate(), e.mode()) {
      case "forever":
        r = [{
          value: i,
          valid: act
        }], t.set(s, r);
        break;
      case "invalidate":
        r = [{
          value: i,
          valid: e.validator()
        }], t.set(s, r);
        break;
      case "valid":
        r ? r.push({
          value: i,
          valid: e.validator()
        }) : (r = [{
          value: i,
          valid: e.validator()
        }], t.set(s, r));
    }
  }
  n(TG, "updateFunctionCache");
  var Q2 = class {
    static {
      n(this, "CacheConfigurator");
    }
    constructor(e) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0,
      this._data = e;
    }
    simple() {
      return pct(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never)
        throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }
    never() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever)
        throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }
    using(e) {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever)
        throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let s = e(this._data), i = (0, tm.maybeAsync)(e, "You appear to be using an async cache handler, but Babel has been called synchronous\
ly");
      return (0, tm.isThenable)(s) ? s.then((r) => (this._pairs.push([r, i]), r)) : (this._pairs.push([s, i]), s);
    }
    invalidate(e) {
      return this._invalidate = !0, this.using(e);
    }
    validator() {
      let e = this._pairs;
      return function* (s) {
        for (let [i, r] of e)
          if (i !== (yield* r(s))) return !1;
        return !0;
      };
    }
    deactivate() {
      this._active = !1;
    }
    configured() {
      return this._configured;
    }
  };
  function pct(t) {
    function e(s) {
      if (typeof s == "boolean") {
        s ? t.forever() : t.never();
        return;
      }
      return t.using(() => PP(s()));
    }
    return n(e, "cacheFn"), e.forever = () => t.forever(), e.never = () => t.never(), e.using = (s) => t.using(() => PP(s())), e.invalidate =
    (s) => t.invalidate(() => PP(s())), e;
  }
  n(pct, "makeSimpleConfigurator");
  function PP(t) {
    if ((0, tm.isThenable)(t))
      throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add suppo\
rt for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchron\
ously handle your caching logic.");
    if (t != null && typeof t != "string" && typeof t != "boolean" && typeof t != "number")
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return t;
  }
  n(PP, "assertSimpleType");
  var Z2 = class {
    static {
      n(this, "Lock");
    }
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((e) => {
        this._resolve = e;
      });
    }
    release(e) {
      this.released = !0, this._resolve(e);
    }
  };
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var EP = g((sm) => {
  "use strict";
  Object.defineProperty(sm, "__esModule", {
    value: !0
  });
  sm.stat = sm.readFile = void 0;
  function lT() {
    let t = require("fs");
    return lT = /* @__PURE__ */ n(function() {
      return t;
    }, "_fs"), t;
  }
  n(lT, "_fs");
  function e_() {
    let t = ha();
    return e_ = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(e_, "_gensync");
  var rVs = sm.readFile = e_()({
    sync: lT().readFileSync,
    errback: lT().readFile
  }), nVs = sm.stat = e_()({
    sync: lT().statSync,
    errback: lT().stat
  });
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var i_ = g((s_) => {
  "use strict";
  Object.defineProperty(s_, "__esModule", {
    value: !0
  });
  s_.makeStaticFileCache = dct;
  var hct = Fh(), fct = EP();
  function t_() {
    let t = require("fs");
    return t_ = /* @__PURE__ */ n(function() {
      return t;
    }, "_fs2"), t;
  }
  n(t_, "_fs2");
  function dct(t) {
    return (0, hct.makeStrongCache)(function* (e, s) {
      return s.invalidate(() => mct(e)) === null ? null : t(e, yield* fct.readFile(e, "utf8"));
    });
  }
  n(dct, "makeStaticFileCache");
  function mct(t) {
    if (!t_().existsSync(t)) return null;
    try {
      return +t_().statSync(t).mtime;
    } catch (e) {
      if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
    }
    return null;
  }
  n(mct, "fileMtime");
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var Su = g((im) => {
  "use strict";
  Object.defineProperty(im, "__esModule", {
    value: !0
  });
  im.beginHiddenCallStack = bct;
  im.endHiddenCallStack = xct;
  im.expectedError = Tct;
  im.injectVirtualStackFrame = gct;
  var bG, xG = Function.call.bind(Error.prototype.toString), vP = !!Error.captureStackTrace && ((bG = Object.getOwnPropertyDescriptor(Error,
  "stackTraceLimit")) == null ? void 0 : bG.writable) === !0, SG = "startHiding - secret - don't use this - v1", PG = "stopHiding - secret -\
 don't use this - v1", EG = /* @__PURE__ */ new WeakSet(), AP = /* @__PURE__ */ new WeakMap();
  function yct(t) {
    return /* @__PURE__ */ Object.create({
      isNative: /* @__PURE__ */ n(() => !1, "isNative"),
      isConstructor: /* @__PURE__ */ n(() => !1, "isConstructor"),
      isToplevel: /* @__PURE__ */ n(() => !0, "isToplevel"),
      getFileName: /* @__PURE__ */ n(() => t, "getFileName"),
      getLineNumber: /* @__PURE__ */ n(() => {
      }, "getLineNumber"),
      getColumnNumber: /* @__PURE__ */ n(() => {
      }, "getColumnNumber"),
      getFunctionName: /* @__PURE__ */ n(() => {
      }, "getFunctionName"),
      getMethodName: /* @__PURE__ */ n(() => {
      }, "getMethodName"),
      getTypeName: /* @__PURE__ */ n(() => {
      }, "getTypeName"),
      toString: /* @__PURE__ */ n(() => t, "toString")
    });
  }
  n(yct, "CallSite");
  function gct(t, e) {
    if (!vP) return;
    let s = AP.get(t);
    return s || AP.set(t, s = []), s.push(yct(e)), t;
  }
  n(gct, "injectVirtualStackFrame");
  function Tct(t) {
    if (vP)
      return EG.add(t), t;
  }
  n(Tct, "expectedError");
  function bct(t) {
    return vP ? Object.defineProperty(function(...e) {
      return AG(), t(...e);
    }, "name", {
      value: PG
    }) : t;
  }
  n(bct, "beginHiddenCallStack");
  function xct(t) {
    return vP ? Object.defineProperty(function(...e) {
      return t(...e);
    }, "name", {
      value: SG
    }) : t;
  }
  n(xct, "endHiddenCallStack");
  function AG() {
    AG = /* @__PURE__ */ n(() => {
    }, "setupPrepareStackTrace");
    let {
      prepareStackTrace: t = Sct
    } = Error, e = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, e)), Error.prepareStackTrace = /* @__PURE__ */ n(function(i, r) {
      let a = [], l = EG.has(i) ? "hiding" : "unknown";
      for (let u = 0; u < r.length; u++) {
        let c = r[u].getFunctionName();
        if (c === SG)
          l = "hiding";
        else if (c === PG) {
          if (l === "hiding")
            l = "showing", AP.has(i) && a.unshift(...AP.get(i));
          else if (l === "unknown") {
            a = r;
            break;
          }
        } else l !== "hiding" && a.push(r[u]);
      }
      return t(i, a);
    }, "stackTraceRewriter");
  }
  n(AG, "setupPrepareStackTrace");
  function Sct(t, e) {
    return e.length === 0 ? xG(t) : `${xG(t)}
    at ${e.join(`
    at `)}`;
  }
  n(Sct, "defaultPrepareStackTrace");
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var jh = g((CP) => {
  "use strict";
  Object.defineProperty(CP, "__esModule", {
    value: !0
  });
  CP.default = void 0;
  var vG = Su(), r_ = class extends Error {
    static {
      n(this, "ConfigError");
    }
    constructor(e, s) {
      super(e), (0, vG.expectedError)(this), s && (0, vG.injectVirtualStackFrame)(this, s);
    }
  };
  CP.default = r_;
});

// ../node_modules/@babel/core/lib/config/files/package.js
var CG = g((a_) => {
  "use strict";
  Object.defineProperty(a_, "__esModule", {
    value: !0
  });
  a_.findPackageData = vct;
  function rm() {
    let t = require("path");
    return rm = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(rm, "_path");
  var Pct = i_(), n_ = jh(), Ect = "package.json", Act = (0, Pct.makeStaticFileCache)((t, e) => {
    let s;
    try {
      s = JSON.parse(e);
    } catch (i) {
      throw new n_.default(`Error while parsing JSON - ${i.message}`, t);
    }
    if (!s) throw new Error(`${t}: No config detected`);
    if (typeof s != "object")
      throw new n_.default(`Config returned typeof ${typeof s}`, t);
    if (Array.isArray(s))
      throw new n_.default("Expected config object but found array", t);
    return {
      filepath: t,
      dirname: rm().dirname(t),
      options: s
    };
  });
  function* vct(t) {
    let e = null, s = [], i = !0, r = rm().dirname(t);
    for (; !e && rm().basename(r) !== "node_modules"; ) {
      s.push(r), e = yield* Act(rm().join(r, Ect));
      let a = rm().dirname(r);
      if (r === a) {
        i = !1;
        break;
      }
      r = a;
    }
    return {
      filepath: t,
      directories: s,
      pkg: e,
      isPackage: i
    };
  }
  n(vct, "findPackageData");
});

// ../node_modules/json5/lib/unicode.js
var wG = g((yVs, wP) => {
  wP.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  wP.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  wP.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var l_ = g((gVs, IG) => {
  var o_ = wG();
  IG.exports = {
    isSpaceSeparator(t) {
      return typeof t == "string" && o_.Space_Separator.test(t);
    },
    isIdStartChar(t) {
      return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t === "$" || t === "_" || o_.ID_Start.test(t));
    },
    isIdContinueChar(t) {
      return typeof t == "string" && (t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t >= "0" && t <= "9" || t === "$" || t === "_" || t ===
      "\u200C" || t === "\u200D" || o_.ID_Continue.test(t));
    },
    isDigit(t) {
      return typeof t == "string" && /[0-9]/.test(t);
    },
    isHexDigit(t) {
      return typeof t == "string" && /[0-9A-Fa-f]/.test(t);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var _G = g((TVs, OG) => {
  var Br = l_(), c_, In, Eu, NP, ep, Co, Mr, f_, cT;
  OG.exports = /* @__PURE__ */ n(function(e, s) {
    c_ = String(e), In = "start", Eu = [], NP = 0, ep = 1, Co = 0, Mr = void 0, f_ = void 0, cT = void 0;
    do
      Mr = Cct(), Nct[In]();
    while (Mr.type !== "eof");
    return typeof s == "function" ? p_({ "": cT }, "", s) : cT;
  }, "parse");
  function p_(t, e, s) {
    let i = t[e];
    if (i != null && typeof i == "object")
      if (Array.isArray(i))
        for (let r = 0; r < i.length; r++) {
          let a = String(r), o = p_(i, a, s);
          o === void 0 ? delete i[a] : Object.defineProperty(i, a, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let r in i) {
          let a = p_(i, r, s);
          a === void 0 ? delete i[r] : Object.defineProperty(i, r, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return s.call(t, e, i);
  }
  n(p_, "internalize");
  var ts, zt, uT, Pu, Ps;
  function Cct() {
    for (ts = "default", zt = "", uT = !1, Pu = 1; ; ) {
      Ps = Au();
      let t = kG[ts]();
      if (t)
        return t;
    }
  }
  n(Cct, "lex");
  function Au() {
    if (c_[NP])
      return String.fromCodePoint(c_.codePointAt(NP));
  }
  n(Au, "peek");
  function Ee() {
    let t = Au();
    return t === `
` ? (ep++, Co = 0) : t ? Co += t.length : Co++, t && (NP += t.length), t;
  }
  n(Ee, "read");
  var kG = {
    default() {
      switch (Ps) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Ee();
          return;
        case "/":
          Ee(), ts = "comment";
          return;
        case void 0:
          return Ee(), Li("eof");
      }
      if (Br.isSpaceSeparator(Ps)) {
        Ee();
        return;
      }
      return kG[In]();
    },
    comment() {
      switch (Ps) {
        case "*":
          Ee(), ts = "multiLineComment";
          return;
        case "/":
          Ee(), ts = "singleLineComment";
          return;
      }
      throw Bi(Ee());
    },
    multiLineComment() {
      switch (Ps) {
        case "*":
          Ee(), ts = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw Bi(Ee());
      }
      Ee();
    },
    multiLineCommentAsterisk() {
      switch (Ps) {
        case "*":
          Ee();
          return;
        case "/":
          Ee(), ts = "default";
          return;
        case void 0:
          throw Bi(Ee());
      }
      Ee(), ts = "multiLineComment";
    },
    singleLineComment() {
      switch (Ps) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Ee(), ts = "default";
          return;
        case void 0:
          return Ee(), Li("eof");
      }
      Ee();
    },
    value() {
      switch (Ps) {
        case "{":
        case "[":
          return Li("punctuator", Ee());
        case "n":
          return Ee(), Rh("ull"), Li("null", null);
        case "t":
          return Ee(), Rh("rue"), Li("boolean", !0);
        case "f":
          return Ee(), Rh("alse"), Li("boolean", !1);
        case "-":
        case "+":
          Ee() === "-" && (Pu = -1), ts = "sign";
          return;
        case ".":
          zt = Ee(), ts = "decimalPointLeading";
          return;
        case "0":
          zt = Ee(), ts = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          zt = Ee(), ts = "decimalInteger";
          return;
        case "I":
          return Ee(), Rh("nfinity"), Li("numeric", 1 / 0);
        case "N":
          return Ee(), Rh("aN"), Li("numeric", NaN);
        case '"':
        case "'":
          uT = Ee() === '"', zt = "", ts = "string";
          return;
      }
      throw Bi(Ee());
    },
    identifierNameStartEscape() {
      if (Ps !== "u")
        throw Bi(Ee());
      Ee();
      let t = h_();
      switch (t) {
        case "$":
        case "_":
          break;
        default:
          if (!Br.isIdStartChar(t))
            throw NG();
          break;
      }
      zt += t, ts = "identifierName";
    },
    identifierName() {
      switch (Ps) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          zt += Ee();
          return;
        case "\\":
          Ee(), ts = "identifierNameEscape";
          return;
      }
      if (Br.isIdContinueChar(Ps)) {
        zt += Ee();
        return;
      }
      return Li("identifier", zt);
    },
    identifierNameEscape() {
      if (Ps !== "u")
        throw Bi(Ee());
      Ee();
      let t = h_();
      switch (t) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!Br.isIdContinueChar(t))
            throw NG();
          break;
      }
      zt += t, ts = "identifierName";
    },
    sign() {
      switch (Ps) {
        case ".":
          zt = Ee(), ts = "decimalPointLeading";
          return;
        case "0":
          zt = Ee(), ts = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          zt = Ee(), ts = "decimalInteger";
          return;
        case "I":
          return Ee(), Rh("nfinity"), Li("numeric", Pu * (1 / 0));
        case "N":
          return Ee(), Rh("aN"), Li("numeric", NaN);
      }
      throw Bi(Ee());
    },
    zero() {
      switch (Ps) {
        case ".":
          zt += Ee(), ts = "decimalPoint";
          return;
        case "e":
        case "E":
          zt += Ee(), ts = "decimalExponent";
          return;
        case "x":
        case "X":
          zt += Ee(), ts = "hexadecimal";
          return;
      }
      return Li("numeric", Pu * 0);
    },
    decimalInteger() {
      switch (Ps) {
        case ".":
          zt += Ee(), ts = "decimalPoint";
          return;
        case "e":
        case "E":
          zt += Ee(), ts = "decimalExponent";
          return;
      }
      if (Br.isDigit(Ps)) {
        zt += Ee();
        return;
      }
      return Li("numeric", Pu * Number(zt));
    },
    decimalPointLeading() {
      if (Br.isDigit(Ps)) {
        zt += Ee(), ts = "decimalFraction";
        return;
      }
      throw Bi(Ee());
    },
    decimalPoint() {
      switch (Ps) {
        case "e":
        case "E":
          zt += Ee(), ts = "decimalExponent";
          return;
      }
      if (Br.isDigit(Ps)) {
        zt += Ee(), ts = "decimalFraction";
        return;
      }
      return Li("numeric", Pu * Number(zt));
    },
    decimalFraction() {
      switch (Ps) {
        case "e":
        case "E":
          zt += Ee(), ts = "decimalExponent";
          return;
      }
      if (Br.isDigit(Ps)) {
        zt += Ee();
        return;
      }
      return Li("numeric", Pu * Number(zt));
    },
    decimalExponent() {
      switch (Ps) {
        case "+":
        case "-":
          zt += Ee(), ts = "decimalExponentSign";
          return;
      }
      if (Br.isDigit(Ps)) {
        zt += Ee(), ts = "decimalExponentInteger";
        return;
      }
      throw Bi(Ee());
    },
    decimalExponentSign() {
      if (Br.isDigit(Ps)) {
        zt += Ee(), ts = "decimalExponentInteger";
        return;
      }
      throw Bi(Ee());
    },
    decimalExponentInteger() {
      if (Br.isDigit(Ps)) {
        zt += Ee();
        return;
      }
      return Li("numeric", Pu * Number(zt));
    },
    hexadecimal() {
      if (Br.isHexDigit(Ps)) {
        zt += Ee(), ts = "hexadecimalInteger";
        return;
      }
      throw Bi(Ee());
    },
    hexadecimalInteger() {
      if (Br.isHexDigit(Ps)) {
        zt += Ee();
        return;
      }
      return Li("numeric", Pu * Number(zt));
    },
    string() {
      switch (Ps) {
        case "\\":
          Ee(), zt += wct();
          return;
        case '"':
          if (uT)
            return Ee(), Li("string", zt);
          zt += Ee();
          return;
        case "'":
          if (!uT)
            return Ee(), Li("string", zt);
          zt += Ee();
          return;
        case `
`:
        case "\r":
          throw Bi(Ee());
        case "\u2028":
        case "\u2029":
          kct(Ps);
          break;
        case void 0:
          throw Bi(Ee());
      }
      zt += Ee();
    },
    start() {
      switch (Ps) {
        case "{":
        case "[":
          return Li("punctuator", Ee());
      }
      ts = "value";
    },
    beforePropertyName() {
      switch (Ps) {
        case "$":
        case "_":
          zt = Ee(), ts = "identifierName";
          return;
        case "\\":
          Ee(), ts = "identifierNameStartEscape";
          return;
        case "}":
          return Li("punctuator", Ee());
        case '"':
        case "'":
          uT = Ee() === '"', ts = "string";
          return;
      }
      if (Br.isIdStartChar(Ps)) {
        zt += Ee(), ts = "identifierName";
        return;
      }
      throw Bi(Ee());
    },
    afterPropertyName() {
      if (Ps === ":")
        return Li("punctuator", Ee());
      throw Bi(Ee());
    },
    beforePropertyValue() {
      ts = "value";
    },
    afterPropertyValue() {
      switch (Ps) {
        case ",":
        case "}":
          return Li("punctuator", Ee());
      }
      throw Bi(Ee());
    },
    beforeArrayValue() {
      if (Ps === "]")
        return Li("punctuator", Ee());
      ts = "value";
    },
    afterArrayValue() {
      switch (Ps) {
        case ",":
        case "]":
          return Li("punctuator", Ee());
      }
      throw Bi(Ee());
    },
    end() {
      throw Bi(Ee());
    }
  };
  function Li(t, e) {
    return {
      type: t,
      value: e,
      line: ep,
      column: Co
    };
  }
  n(Li, "newToken");
  function Rh(t) {
    for (let e of t) {
      if (Au() !== e)
        throw Bi(Ee());
      Ee();
    }
  }
  n(Rh, "literal");
  function wct() {
    switch (Au()) {
      case "b":
        return Ee(), "\b";
      case "f":
        return Ee(), "\f";
      case "n":
        return Ee(), `
`;
      case "r":
        return Ee(), "\r";
      case "t":
        return Ee(), "	";
      case "v":
        return Ee(), "\v";
      case "0":
        if (Ee(), Br.isDigit(Au()))
          throw Bi(Ee());
        return "\0";
      case "x":
        return Ee(), Ict();
      case "u":
        return Ee(), h_();
      case `
`:
      case "\u2028":
      case "\u2029":
        return Ee(), "";
      case "\r":
        return Ee(), Au() === `
` && Ee(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw Bi(Ee());
      case void 0:
        throw Bi(Ee());
    }
    return Ee();
  }
  n(wct, "escape");
  function Ict() {
    let t = "", e = Au();
    if (!Br.isHexDigit(e) || (t += Ee(), e = Au(), !Br.isHexDigit(e)))
      throw Bi(Ee());
    return t += Ee(), String.fromCodePoint(parseInt(t, 16));
  }
  n(Ict, "hexEscape");
  function h_() {
    let t = "", e = 4;
    for (; e-- > 0; ) {
      let s = Au();
      if (!Br.isHexDigit(s))
        throw Bi(Ee());
      t += Ee();
    }
    return String.fromCodePoint(parseInt(t, 16));
  }
  n(h_, "unicodeEscape");
  var Nct = {
    start() {
      if (Mr.type === "eof")
        throw qh();
      u_();
    },
    beforePropertyName() {
      switch (Mr.type) {
        case "identifier":
        case "string":
          f_ = Mr.value, In = "afterPropertyName";
          return;
        case "punctuator":
          IP();
          return;
        case "eof":
          throw qh();
      }
    },
    afterPropertyName() {
      if (Mr.type === "eof")
        throw qh();
      In = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (Mr.type === "eof")
        throw qh();
      u_();
    },
    beforeArrayValue() {
      if (Mr.type === "eof")
        throw qh();
      if (Mr.type === "punctuator" && Mr.value === "]") {
        IP();
        return;
      }
      u_();
    },
    afterPropertyValue() {
      if (Mr.type === "eof")
        throw qh();
      switch (Mr.value) {
        case ",":
          In = "beforePropertyName";
          return;
        case "}":
          IP();
      }
    },
    afterArrayValue() {
      if (Mr.type === "eof")
        throw qh();
      switch (Mr.value) {
        case ",":
          In = "beforeArrayValue";
          return;
        case "]":
          IP();
      }
    },
    end() {
    }
  };
  function u_() {
    let t;
    switch (Mr.type) {
      case "punctuator":
        switch (Mr.value) {
          case "{":
            t = {};
            break;
          case "[":
            t = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        t = Mr.value;
        break;
    }
    if (cT === void 0)
      cT = t;
    else {
      let e = Eu[Eu.length - 1];
      Array.isArray(e) ? e.push(t) : Object.defineProperty(e, f_, {
        value: t,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (t !== null && typeof t == "object")
      Eu.push(t), Array.isArray(t) ? In = "beforeArrayValue" : In = "beforePropertyName";
    else {
      let e = Eu[Eu.length - 1];
      e == null ? In = "end" : Array.isArray(e) ? In = "afterArrayValue" : In = "afterPropertyValue";
    }
  }
  n(u_, "push");
  function IP() {
    Eu.pop();
    let t = Eu[Eu.length - 1];
    t == null ? In = "end" : Array.isArray(t) ? In = "afterArrayValue" : In = "afterPropertyValue";
  }
  n(IP, "pop");
  function Bi(t) {
    return kP(t === void 0 ? `JSON5: invalid end of input at ${ep}:${Co}` : `JSON5: invalid character '${DG(t)}' at ${ep}:${Co}`);
  }
  n(Bi, "invalidChar");
  function qh() {
    return kP(`JSON5: invalid end of input at ${ep}:${Co}`);
  }
  n(qh, "invalidEOF");
  function NG() {
    return Co -= 5, kP(`JSON5: invalid identifier character at ${ep}:${Co}`);
  }
  n(NG, "invalidIdentifier");
  function kct(t) {
    console.warn(`JSON5: '${DG(t)}' in strings is not valid ECMAScript; consider escaping`);
  }
  n(kct, "separatorChar");
  function DG(t) {
    let e = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (e[t])
      return e[t];
    if (t < " ") {
      let s = t.charCodeAt(0).toString(16);
      return "\\x" + ("00" + s).substring(s.length);
    }
    return t;
  }
  n(DG, "formatChar");
  function kP(t) {
    let e = new SyntaxError(t);
    return e.lineNumber = ep, e.columnNumber = Co, e;
  }
  n(kP, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var BG = g((xVs, LG) => {
  var d_ = l_();
  LG.exports = /* @__PURE__ */ n(function(e, s, i) {
    let r = [], a = "", o, l, u = "", c;
    if (s != null && typeof s == "object" && !Array.isArray(s) && (i = s.space, c = s.quote, s = s.replacer), typeof s == "function")
      l = s;
    else if (Array.isArray(s)) {
      o = [];
      for (let m of s) {
        let T;
        typeof m == "string" ? T = m : (typeof m == "number" || m instanceof String || m instanceof Number) && (T = String(m)), T !== void 0 &&
        o.indexOf(T) < 0 && o.push(T);
      }
    }
    return i instanceof Number ? i = Number(i) : i instanceof String && (i = String(i)), typeof i == "number" ? i > 0 && (i = Math.min(10, Math.
    floor(i)), u = "          ".substr(0, i)) : typeof i == "string" && (u = i.substr(0, 10)), p("", { "": e });
    function p(m, T) {
      let b = T[m];
      switch (b != null && (typeof b.toJSON5 == "function" ? b = b.toJSON5(m) : typeof b.toJSON == "function" && (b = b.toJSON(m))), l && (b =
      l.call(T, m, b)), b instanceof Number ? b = Number(b) : b instanceof String ? b = String(b) : b instanceof Boolean && (b = b.valueOf()),
      b) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof b == "string")
        return h(b, !1);
      if (typeof b == "number")
        return String(b);
      if (typeof b == "object")
        return Array.isArray(b) ? y(b) : f(b);
    }
    n(p, "serializeProperty");
    function h(m) {
      let T = {
        "'": 0.1,
        '"': 0.2
      }, b = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, E = "";
      for (let K = 0; K < m.length; K++) {
        let he = m[K];
        switch (he) {
          case "'":
          case '"':
            T[he]++, E += he;
            continue;
          case "\0":
            if (d_.isDigit(m[K + 1])) {
              E += "\\x00";
              continue;
            }
        }
        if (b[he]) {
          E += b[he];
          continue;
        }
        if (he < " ") {
          let de = he.charCodeAt(0).toString(16);
          E += "\\x" + ("00" + de).substring(de.length);
          continue;
        }
        E += he;
      }
      let w = c || Object.keys(T).reduce((K, he) => T[K] < T[he] ? K : he);
      return E = E.replace(new RegExp(w, "g"), b[w]), w + E + w;
    }
    n(h, "quoteString");
    function f(m) {
      if (r.indexOf(m) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      r.push(m);
      let T = a;
      a = a + u;
      let b = o || Object.keys(m), E = [];
      for (let K of b) {
        let he = p(K, m);
        if (he !== void 0) {
          let de = d(K) + ":";
          u !== "" && (de += " "), de += he, E.push(de);
        }
      }
      let w;
      if (E.length === 0)
        w = "{}";
      else {
        let K;
        if (u === "")
          K = E.join(","), w = "{" + K + "}";
        else {
          let he = `,
` + a;
          K = E.join(he), w = `{
` + a + K + `,
` + T + "}";
        }
      }
      return r.pop(), a = T, w;
    }
    n(f, "serializeObject");
    function d(m) {
      if (m.length === 0)
        return h(m, !0);
      let T = String.fromCodePoint(m.codePointAt(0));
      if (!d_.isIdStartChar(T))
        return h(m, !0);
      for (let b = T.length; b < m.length; b++)
        if (!d_.isIdContinueChar(String.fromCodePoint(m.codePointAt(b))))
          return h(m, !0);
      return m;
    }
    n(d, "serializeKey");
    function y(m) {
      if (r.indexOf(m) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      r.push(m);
      let T = a;
      a = a + u;
      let b = [];
      for (let w = 0; w < m.length; w++) {
        let K = p(String(w), m);
        b.push(K !== void 0 ? K : "null");
      }
      let E;
      if (b.length === 0)
        E = "[]";
      else if (u === "")
        E = "[" + b.join(",") + "]";
      else {
        let w = `,
` + a, K = b.join(w);
        E = `[
` + a + K + `,
` + T + "]";
      }
      return r.pop(), a = T, E;
    }
    n(y, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var FG = g((PVs, MG) => {
  var Dct = _G(), Oct = BG(), _ct = {
    parse: Dct,
    stringify: Oct
  };
  MG.exports = _ct;
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var m_ = g((pT) => {
  "use strict";
  Object.defineProperty(pT, "__esModule", {
    value: !0
  });
  pT.makeConfigAPI = qG;
  pT.makePluginAPI = Lct;
  pT.makePresetAPI = UG;
  function RG() {
    let t = require("semver");
    return RG = /* @__PURE__ */ n(function() {
      return t;
    }, "_semver"), t;
  }
  n(RG, "_semver");
  var DP = ar(), jG = Fh();
  function qG(t) {
    let e = /* @__PURE__ */ n((i) => t.using((r) => i === void 0 ? r.envName : typeof i == "function" ? (0, jG.assertSimpleType)(i(r.envName)) :
    (Array.isArray(i) ? i : [i]).some((a) => {
      if (typeof a != "string")
        throw new Error("Unexpected non-string value");
      return a === r.envName;
    })), "env"), s = /* @__PURE__ */ n((i) => t.using((r) => (0, jG.assertSimpleType)(i(r.caller))), "caller");
    return {
      version: DP.version,
      cache: t.simple(),
      env: e,
      async: /* @__PURE__ */ n(() => !1, "async"),
      caller: s,
      assertVersion: Bct
    };
  }
  n(qG, "makeConfigAPI");
  function UG(t, e) {
    let s = /* @__PURE__ */ n(() => JSON.parse(t.using((r) => JSON.stringify(r.targets))), "targets"), i = /* @__PURE__ */ n((r) => {
      e.push(r);
    }, "addExternalDependency");
    return Object.assign({}, qG(t), {
      targets: s,
      addExternalDependency: i
    });
  }
  n(UG, "makePresetAPI");
  function Lct(t, e) {
    let s = /* @__PURE__ */ n((i) => t.using((r) => r.assumptions[i]), "assumption");
    return Object.assign({}, UG(t, e), {
      assumption: s
    });
  }
  n(Lct, "makePluginAPI");
  function Bct(t) {
    if (typeof t == "number") {
      if (!Number.isInteger(t))
        throw new Error("Expected string or integer value.");
      t = `^${t}.0.0-0`;
    }
    if (typeof t != "string")
      throw new Error("Expected string or integer value.");
    if (t === "*" || RG().satisfies(DP.version, t)) return;
    let e = Error.stackTraceLimit;
    typeof e == "number" && e < 25 && (Error.stackTraceLimit = 25);
    let s = new Error(`Requires Babel "${t}", but was loaded with "${DP.version}". If you are sure you have a compatible version of @babel/c\
ore, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the f\
irst entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof e == "number" && (Error.stackTraceLimit = e), Object.assign(s, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: DP.version,
      range: t
    });
  }
  n(Bct, "assertVersion");
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var _P = g((OP) => {
  "use strict";
  Object.defineProperty(OP, "__esModule", {
    value: !0
  });
  OP.finalize = Mct;
  OP.flattenToSet = Fct;
  function Mct(t) {
    return Object.freeze(t);
  }
  n(Mct, "finalize");
  function Fct(t) {
    let e = /* @__PURE__ */ new Set(), s = [t];
    for (; s.length > 0; )
      for (let i of s.pop())
        Array.isArray(i) ? s.push(i) : e.add(i);
    return e;
  }
  n(Fct, "flattenToSet");
});

// ../node_modules/@babel/core/lib/config/plugin.js
var BP = g((LP) => {
  "use strict";
  Object.defineProperty(LP, "__esModule", {
    value: !0
  });
  LP.default = void 0;
  var jct = _P(), y_ = class {
    static {
      n(this, "Plugin");
    }
    constructor(e, s, i, r = (0, jct.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride =
      void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = e.name || i, this.manipulateOptions =
      e.manipulateOptions, this.post = e.post, this.pre = e.pre, this.visitor = e.visitor || {}, this.parserOverride = e.parserOverride, this.
      generatorOverride = e.generatorOverride, this.options = s, this.externalDependencies = r;
    }
  };
  LP.default = y_;
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var VG = g((g_) => {
  "use strict";
  Object.defineProperty(g_, "__esModule", {
    value: !0
  });
  g_.once = Rct;
  var KG = Zc();
  function Rct(t) {
    let e, s, i = !1;
    return function* () {
      if (!e) {
        if (s)
          return i = !0, yield* (0, KG.waitFor)(s);
        if (yield* (0, KG.isAsync)()) {
          let r, a;
          s = new Promise((o, l) => {
            r = o, a = l;
          });
          try {
            e = {
              ok: !0,
              value: yield* t()
            }, s = null, i && r(e.value);
          } catch (o) {
            e = {
              ok: !1,
              value: o
            }, s = null, i && a(o);
          }
        } else
          try {
            e = {
              ok: !0,
              value: yield* t()
            };
          } catch (r) {
            e = {
              ok: !1,
              value: r
            };
          }
      }
      if (e.ok) return e.value;
      throw e.value;
    };
  }
  n(Rct, "once");
});

// ../node_modules/node-releases/data/processed/envs.json
var WG = g((DVs, qct) => {
  qct.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "\
0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1,
  v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "\
0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1,
  v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "\
0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1,
  v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "\
0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1,
  v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "\
4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Ar\
gon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" },
  { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0",
  date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1,
  v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodej\
s", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10\
-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.3\
1" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "\
2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4\
.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5\
.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1,
  v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "\
6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1,
  v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "\
6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1,
  v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "\
6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron",
  security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" },
  { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12\
.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Bor\
on", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.11\
1" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "\
6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "\
Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" },
  { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "\
2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "\
5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "\
7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1,
  v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "\
7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1,
  v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "\
8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1,
  v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "\
8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1,
  v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "\
8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1,
  v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "\
8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "\
Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.41\
4.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "\
8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "\
Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.41\
4.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "\
8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1,
  security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "\
nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12\
-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414\
.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0",
  date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1,
  v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "\
10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1,
  v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "\
10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1,
  v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "\
10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1,
  v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30",
  lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "\
6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "201\
9-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "\
2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "\
2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "\
7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs",
  version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28",
  lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.3\
8" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.\
0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1,
  v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "\
12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1,
  v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1,
  v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1,
  v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs",
  version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21",
  lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "\
7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "\
12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "\
Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "\
12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "\
Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13\
.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1,
  v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs",
  version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29",
  lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" },
  { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "\
2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "\
8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "\
14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "\
14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs",
  version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22",
  lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.1\
9" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15\
.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "F\
ermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.\
371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "\
14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "\
Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4\
.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "\
15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs",
  version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06",
  lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" },
  { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "\
2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "\
9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "\
16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0,
  v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "\
16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1,
  v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs",
  version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20",
  lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.\
4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "\
16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "\
Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4\
.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "\
16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "\
Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" },
  { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "\
2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "\
9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "\
18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1,
  v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "\
18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0,
  v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs",
  version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24",
  lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.\
15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.\
11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydro\
gen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.\
154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "\
18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "\
Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "\
10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodej\
s", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "\
2024-03-26", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: !1, security: !1,
  v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "10.7.193.20" }, { name: "nodejs",
  version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14",
  lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1, v8: "10.8.168.\
25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6\
.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: !1, security: !1,
  v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs",
  version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17",
  lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1, v8: "11.3.244.8" },
  { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "\
2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1, v8: "\
11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.13.0", date: "2024-05-07", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.16.0", date: "2024-07-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.17.0", date: "2024-08-21", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.18.0", date: "2024-10-03", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" },
  { name: "nodejs", version: "21.1.0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "\
2023-11-14", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "\
11.8.172.17" }, { name: "nodejs", version: "21.4.0", date: "2023-12-05", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "\
21.5.0", date: "2023-12-19", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: !1, security: !1,
  v8: "11.8.172.17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs",
  version: "22.0.0", date: "2024-04-24", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02",
  lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: !1, security: !1, v8: "12.4.254.\
14" }, { name: "nodejs", version: "22.3.0", date: "2024-06-11", lts: !1, security: !1, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4\
.0", date: "2024-07-02", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1,
  v8: "12.4.254.21" }, { name: "nodejs", version: "22.6.0", date: "2024-08-06", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs",
  version: "22.7.0", date: "2024-08-21", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.8.0", date: "2024-09-03",
  lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.9.0", date: "2024-09-17", lts: !1, security: !1, v8: "12.4.254.\
21" }, { name: "nodejs", version: "22.10.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.\
11.0", date: "2024-10-29", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.12.0", date: "2024-12-02", lts: "Jo\
d", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "23.0.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.9.202.26" }, {
  name: "nodejs", version: "23.1.0", date: "2024-10-24", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.2.0", date: "\
2024-11-11", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.3.0", date: "2024-11-20", lts: !1, security: !1, v8: "\
12.9.202.28" }];
});

// ../node_modules/caniuse-lite/data/browsers.js
var HG = g((OVs, $G) => {
  $G.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "\
op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var MP = g((_Vs, JG) => {
  JG.exports.browsers = HG();
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var XG = g((LVs, YG) => {
  YG.exports = { 0: "22", 1: "23", 2: "24", 3: "25", 4: "26", 5: "27", 6: "115", 7: "116", 8: "117", 9: "118", A: "10", B: "11", C: "12", D: "\
7", E: "8", F: "9", G: "15", H: "80", I: "131", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "\
84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "\
100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "\
114", y: "20", z: "21", AB: "119", BB: "120", CB: "121", DB: "122", EB: "123", FB: "124", GB: "125", HB: "126", IB: "127", JB: "128", KB: "1\
29", LB: "130", MB: "5", NB: "19", OB: "28", PB: "29", QB: "30", RB: "31", SB: "32", TB: "33", UB: "34", VB: "35", WB: "36", XB: "37", YB: "\
38", ZB: "39", aB: "40", bB: "41", cB: "42", dB: "43", eB: "44", fB: "45", gB: "46", hB: "47", iB: "48", jB: "49", kB: "50", lB: "51", mB: "\
52", nB: "53", oB: "54", pB: "55", qB: "56", rB: "57", sB: "58", tB: "60", uB: "62", vB: "63", wB: "64", xB: "65", yB: "66", zB: "67", "0B": "\
68", "1B": "69", "2B": "70", "3B": "71", "4B": "72", "5B": "73", "6B": "74", "7B": "75", "8B": "76", "9B": "77", AC: "78", BC: "132", CC: "1\
1.1", DC: "12.1", EC: "15.5", FC: "16.0", GC: "17.0", HC: "18.0", IC: "3", JC: "59", KC: "61", LC: "82", MC: "133", NC: "134", OC: "3.2", PC: "\
10.1", QC: "15.2-15.3", RC: "15.4", SC: "16.1", TC: "16.2", UC: "16.3", VC: "16.4", WC: "16.5", XC: "17.1", YC: "17.2", ZC: "17.3", aC: "17.\
4", bC: "17.5", cC: "18.1", dC: "18.2", eC: "18.3", fC: "11.5", gC: "4.2-4.3", hC: "5.5", iC: "2", jC: "135", kC: "136", lC: "3.5", mC: "3.6",
  nC: "3.1", oC: "5.1", pC: "6.1", qC: "7.1", rC: "9.1", sC: "13.1", tC: "14.1", uC: "15.1", vC: "15.6", wC: "16.6", xC: "17.6", yC: "TP", zC: "\
9.5-9.6", "0C": "10.0-10.1", "1C": "10.5", "2C": "10.6", "3C": "11.6", "4C": "4.0-4.1", "5C": "5.0-5.1", "6C": "6.0-6.1", "7C": "7.0-7.1", "\
8C": "8.1-8.4", "9C": "9.0-9.2", AD: "9.3", BD: "10.0-10.2", CD: "10.3", DD: "11.0-11.2", ED: "11.3-11.4", FD: "12.0-12.1", GD: "12.2-12.5",
  HD: "13.0-13.1", ID: "13.2", JD: "13.3", KD: "13.4-13.7", LD: "14.0-14.4", MD: "14.5-14.8", ND: "15.0-15.1", OD: "15.6-15.8", PD: "16.6-16\
.7", QD: "17.6-17.7", RD: "all", SD: "2.1", TD: "2.2", UD: "2.3", VD: "4.1", WD: "4.4", XD: "4.4.3-4.4.4", YD: "5.0-5.4", ZD: "6.2-6.4", aD: "\
7.2-7.4", bD: "8.2", cD: "9.2", dD: "11.1-11.2", eD: "12.0", fD: "13.0", gD: "14.0", hD: "15.0", iD: "19.0", jD: "14.9", kD: "13.52", lD: "2\
.5", mD: "3.0-3.1" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var T_ = g((BVs, zG) => {
  zG.exports.browserVersions = XG();
});

// ../node_modules/caniuse-lite/data/agents.js
var QG = g((MVs, GG) => {
  GG.exports = { A: { A: { K: 0, D: 0, E: 0, F: 0.0346884, A: 0, B: 0.433605, hC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "hC", "K", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { hC: 962323200, K: 998870400, D: 1161129600,
  E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 6: 3521e-6, 7: 3521e-6, 8: 3521e-6, 9: 3521e-6, C: 0, L: 0, M: 0,
  G: 0, N: 0, O: 3521e-6, P: 0.084504, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0.014084, c: 0, d: 0, e: 0,
  f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 3521e-6, n: 0, o: 0, p: 0, q: 0, r: 3521e-6, s: 0.052815, t: 0, u: 3521e-6, v: 3521e-6, w: 7042e-6,
  x: 0.010563, AB: 7042e-6, BB: 0.017605, CB: 0.010563, DB: 0.014084, EB: 7042e-6, FB: 0.010563, GB: 0.010563, HB: 0.024647, IB: 0.021126, JB: 0.024647,
  KB: 0.03521, LB: 0.137319, I: 4.16182 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U",
  "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w",
  "x", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "I", "", "", ""], E: "Edge", F: { 6: 1689897600,
  7: 1692576e3, 8: 1694649600, 9: 1697155200, C: 1438128e3, L: 1447286400, M: 1470096e3, G: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200,
  Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3,
  Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600,
  j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600,
  t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3, AB: 1698969600, BB: 1701993600, CB: 1706227200, DB: 1708732800, EB: 1711152e3,
  FB: 1713398400, GB: 1715990400, HB: 1718841600, IB: 1721865600, JB: 1724371200, KB: 1726704e3, LB: 1729123200, I: 1731542400 }, D: { C: "m\
s", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0.253512, 7: 0, 8: 0, 9: 0.088025,
  iC: 0, IC: 0, J: 0, MB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.014084, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, NB: 0, y: 0, z: 0, OB: 0, PB: 0,
  QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 7042e-6, eB: 3521e-6, fB: 0, gB: 0, hB: 0, iB: 0,
  jB: 0, kB: 0, lB: 0, mB: 0.028168, nB: 0, oB: 0, pB: 7042e-6, qB: 0.014084, rB: 0, sB: 0, JC: 3521e-6, tB: 0, KC: 0, uB: 0, vB: 0, wB: 0, xB: 0,
  yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0.010563, Q: 0, H: 0, R: 0, LC: 0,
  S: 0, T: 0, U: 0, V: 0, W: 0, X: 3521e-6, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 7042e-6, n: 0,
  o: 0, p: 0, q: 0, r: 0, s: 3521e-6, t: 0, u: 0, v: 0, w: 7042e-6, x: 3521e-6, AB: 0, BB: 3521e-6, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0.017605,
  HB: 3521e-6, IB: 0.010563, JB: 0.07042, KB: 7042e-6, LB: 7042e-6, I: 0.017605, BC: 0.077462, MC: 1.38727, NC: 7042e-6, jC: 0, kC: 0, lC: 0,
  mC: 0 }, B: "moz", C: ["iC", "IC", "lC", "mC", "J", "MB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "NB", "y", "z",
  "0", "1", "2", "3", "4", "5", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "\
gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "JC", "tB", "KC", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B",
  "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "Q", "H", "R", "LC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e",
  "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "6", "7", "8", "9", "AB", "BB", "CB", "DB",
  "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "I", "BC", "MC", "NC", "jC", "kC"], E: "Firefox", F: { 0: 1368489600, 1: 1372118400, 2: 1375747200,
  3: 1379376e3, 4: 1386633600, 5: 1391472e3, 6: 1688428800, 7: 1690848e3, 8: 1693267200, 9: 1695686400, iC: 1161648e3, IC: 1213660800, lC: 124632e4,
  mC: 1264032e3, J: 1300752e3, MB: 1308614400, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800,
  L: 1335225600, M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, NB: 1357603200, y: 1361232e3, z: 1364860800, OB: 1395100800,
  PB: 1398729600, QB: 1402358400, RB: 1405987200, SB: 1409616e3, TB: 1413244800, UB: 1417392e3, VB: 1421107200, WB: 1424736e3, XB: 1428278400,
  YB: 1431475200, ZB: 1435881600, aB: 1439251200, bB: 144288e4, cB: 1446508800, dB: 1450137600, eB: 1453852800, fB: 1457395200, gB: 1461628800,
  hB: 1465257600, iB: 1470096e3, jB: 1474329600, kB: 1479168e3, lB: 1485216e3, mB: 1488844800, nB: 149256e4, oB: 1497312e3, pB: 1502150400, qB: 1506556800,
  rB: 1510617600, sB: 1516665600, JC: 1520985600, tB: 1525824e3, KC: 1529971200, uB: 1536105600, vB: 1540252800, wB: 1544486400, xB: 154872e4,
  yB: 1552953600, zB: 1558396800, "0B": 1562630400, "1B": 1567468800, "2B": 1571788800, "3B": 1575331200, "4B": 1578355200, "5B": 1581379200,
  "6B": 1583798400, "7B": 1586304e3, "8B": 1588636800, "9B": 1591056e3, AC: 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800, LC: 1603152e3,
  S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800,
  c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400,
  m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3, v: 1681171200,
  w: 1683590400, x: 1686009600, AB: 1698105600, BB: 1700524800, CB: 1702944e3, DB: 1705968e3, EB: 1708387200, FB: 1710806400, GB: 1713225600,
  HB: 1715644800, IB: 1718064e3, JB: 1720483200, KB: 1722902400, LB: 1725321600, I: 1727740800, BC: 173016e4, MC: 1732579200, NC: null, jC: null,
  kC: null } }, D: { A: { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0.024647, 7: 0.130277, 8: 0.07042, 9: 0.059857, J: 0, MB: 0, K: 0, D: 0, E: 0,
  F: 0, A: 0, B: 0, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, NB: 0, y: 0, z: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0,
  XB: 0, YB: 7042e-6, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 3521e-6, gB: 0, hB: 3521e-6, iB: 0.017605, jB: 0.014084, kB: 0.014084, lB: 0,
  mB: 3521e-6, nB: 3521e-6, oB: 0, pB: 0, qB: 7042e-6, rB: 0, sB: 0.024647, JC: 0, tB: 0, KC: 7042e-6, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0.021126,
  zB: 0, "0B": 0, "1B": 0.010563, "2B": 0.014084, "3B": 0, "4B": 0, "5B": 7042e-6, "6B": 7042e-6, "7B": 7042e-6, "8B": 3521e-6, "9B": 0.017605,
  AC: 0.010563, Q: 0.084504, H: 7042e-6, R: 0.03521, S: 0.028168, T: 3521e-6, U: 0.014084, V: 0.021126, W: 0.063378, X: 7042e-6, Y: 0.010563,
  Z: 7042e-6, a: 0.031689, b: 0.014084, c: 0.014084, d: 0.03521, e: 0.038731, f: 7042e-6, g: 0.010563, h: 0.042252, i: 0.014084, j: 0.021126,
  k: 0.014084, l: 0.010563, m: 0.10563, n: 0.021126, o: 0.010563, p: 0.017605, q: 0.021126, r: 0.03521, s: 1.09503, t: 0.017605, u: 0.031689,
  v: 0.03521, w: 0.109151, x: 0.07042, AB: 0.042252, BB: 0.063378, CB: 0.119714, DB: 0.077462, EB: 0.080983, FB: 0.14084, GB: 1.28869, HB: 0.415478,
  IB: 0.334495, JB: 0.179571, KB: 0.232386, LB: 0.982359, I: 15.0065, BC: 0.017605, MC: 0.014084, NC: 0 }, B: "webkit", C: ["", "", "", "", "",
  "", "", "J", "MB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "NB", "y", "z", "0", "1", "2", "3", "4", "5", "OB", "P\
B", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB",
  "nB", "oB", "pB", "qB", "rB", "sB", "JC", "tB", "KC", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "\
8B", "9B", "AC", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
  "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "L\
B", "I", "BC", "MC", "NC"], E: "Chrome", F: { 0: 1343692800, 1: 1348531200, 2: 1352246400, 3: 1357862400, 4: 1361404800, 5: 1364428800, 6: 1689724800,
  7: 1692057600, 8: 1694476800, 9: 1696896e3, J: 1264377600, MB: 1274745600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400,
  B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, NB: 1332892800, y: 133704e4,
  z: 1340668800, OB: 1369094400, PB: 1374105600, QB: 1376956800, RB: 1384214400, SB: 1389657600, TB: 1392940800, UB: 1397001600, VB: 1400544e3,
  WB: 1405468800, XB: 1409011200, YB: 141264e4, ZB: 1416268800, aB: 1421798400, bB: 1425513600, cB: 1429401600, dB: 143208e4, eB: 1437523200,
  fB: 1441152e3, gB: 1444780800, hB: 1449014400, iB: 1453248e3, jB: 1456963200, kB: 1460592e3, lB: 1464134400, mB: 1469059200, nB: 1472601600,
  oB: 1476230400, pB: 1480550400, qB: 1485302400, rB: 1489017600, sB: 149256e4, JC: 1496707200, tB: 1500940800, KC: 1504569600, uB: 1508198400,
  vB: 1512518400, wB: 1516752e3, xB: 1520294400, yB: 1523923200, zB: 1527552e3, "0B": 1532390400, "1B": 1536019200, "2B": 1539648e3, "3B": 1543968e3,
  "4B": 154872e4, "5B": 1552348800, "6B": 1555977600, "7B": 1559606400, "8B": 1564444800, "9B": 1568073600, AC: 1571702400, Q: 1575936e3, H: 1580860800,
  R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200,
  b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200,
  l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3, r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200,
  v: 1680566400, w: 1682985600, x: 1685404800, AB: 1698710400, BB: 1701993600, CB: 1705968e3, DB: 1708387200, EB: 1710806400, FB: 1713225600,
  GB: 1715644800, HB: 1718064e3, IB: 1721174400, JB: 1724112e3, KB: 1726531200, LB: 1728950400, I: 1731369600, BC: null, MC: null, NC: null } },
  E: { A: { J: 0, MB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 3521e-6, M: 0.017605, G: 3521e-6, nC: 0, OC: 0, oC: 0, pC: 0, qC: 0, rC: 0,
  PC: 0, CC: 3521e-6, DC: 7042e-6, sC: 0.038731, tC: 0.052815, uC: 0.014084, QC: 7042e-6, RC: 0.014084, EC: 0.021126, vC: 0.169008, FC: 0.024647,
  SC: 0.028168, TC: 0.021126, UC: 0.049294, VC: 0.017605, WC: 0.031689, wC: 0.225344, GC: 0.014084, XC: 0.024647, YC: 0.024647, ZC: 0.028168,
  aC: 0.066899, bC: 0.130277, xC: 0.415478, HC: 0.080983, cC: 1.05278, dC: 0.144361, eC: 3521e-6, yC: 0 }, B: "webkit", C: ["", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "nC", "OC", "J", "MB", "oC", "K", "pC", "D", "qC", "E", "F", "rC", "A", "PC", "B",
  "CC", "C", "DC", "L", "sC", "M", "tC", "G", "uC", "QC", "RC", "EC", "vC", "FC", "SC", "TC", "UC", "VC", "WC", "wC", "GC", "XC", "YC", "ZC",
  "aC", "bC", "xC", "HC", "cC", "dC", "eC", "yC", ""], E: "Safari", F: { nC: 1205798400, OC: 1226534400, J: 1244419200, MB: 1275868800, oC: 131112e4,
  K: 1343174400, pC: 13824e5, D: 13824e5, qC: 1410998400, E: 1413417600, F: 1443657600, rC: 1458518400, A: 1474329600, PC: 1490572800, B: 1505779200,
  CC: 1522281600, C: 1537142400, DC: 1553472e3, L: 1568851200, sC: 1585008e3, M: 1600214400, tC: 1619395200, G: 1632096e3, uC: 1635292800, QC: 1639353600,
  RC: 1647216e3, EC: 1652745600, vC: 1658275200, FC: 1662940800, SC: 1666569600, TC: 1670889600, UC: 1674432e3, VC: 1679875200, WC: 1684368e3,
  wC: 1690156800, GC: 1695686400, XC: 1698192e3, YC: 1702252800, ZC: 1705881600, aC: 1709596800, bC: 1715558400, xC: 1722211200, HC: 1726444800,
  cC: 1730073600, dC: 1733875200, eC: null, yC: null } }, F: { A: { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0,
  NB: 0, y: 0, z: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 3521e-6, bB: 0, cB: 0, dB: 0, eB: 0,
  fB: 0, gB: 0.014084, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0,
  yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, Q: 0, H: 0, R: 0, LC: 0, S: 0,
  T: 0, U: 7042e-6, V: 0.028168, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0.031689, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.021126,
  m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 3521e-6, x: 0.616175, zC: 0, "0C": 0, "1C": 0, "2C": 0, CC: 0, fC: 0, "3C": 0,
  DC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "zC", "\
0C", "1C", "2C", "B", "CC", "fC", "3C", "C", "DC", "G", "N", "O", "P", "NB", "y", "z", "0", "1", "2", "3", "4", "5", "OB", "PB", "QB", "RB",
  "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "\
pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "Q", "H",
  "R", "LC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r",
  "s", "t", "u", "v", "w", "x", "", "", ""], E: "Opera", F: { 0: 1401753600, 1: 1405987200, 2: 1409616e3, 3: 1413331200, 4: 1417132800, 5: 1422316800,
  F: 1150761600, zC: 1223424e3, "0C": 1251763200, "1C": 1267488e3, "2C": 1277942400, B: 1292457600, CC: 1302566400, fC: 1309219200, "3C": 1323129600,
  C: 1323129600, DC: 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3, NB: 1390867200, y: 1393891200, z: 1399334400, OB: 1425945600,
  PB: 1430179200, QB: 1433808e3, RB: 1438646400, SB: 1442448e3, TB: 1445904e3, UB: 1449100800, VB: 1454371200, WB: 1457308800, XB: 146232e4,
  YB: 1465344e3, ZB: 1470096e3, aB: 1474329600, bB: 1477267200, cB: 1481587200, dB: 1486425600, eB: 1490054400, fB: 1494374400, gB: 1498003200,
  hB: 1502236800, iB: 1506470400, jB: 1510099200, kB: 1515024e3, lB: 1517961600, mB: 1521676800, nB: 1525910400, oB: 1530144e3, pB: 1534982400,
  qB: 1537833600, rB: 1543363200, sB: 1548201600, tB: 1554768e3, uB: 1561593600, vB: 1566259200, wB: 1570406400, xB: 1573689600, yB: 1578441600,
  zB: 1583971200, "0B": 1587513600, "1B": 1592956800, "2B": 1595894400, "3B": 1600128e3, "4B": 1603238400, "5B": 161352e4, "6B": 1612224e3, "\
7B": 1616544e3, "8B": 1619568e3, "9B": 1623715200, AC: 1627948800, Q: 1631577600, H: 1633392e3, R: 1635984e3, LC: 1638403200, S: 1642550400,
  T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200,
  d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800,
  n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600, t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800,
  x: 1727222400 }, D: { F: "o", B: "o", C: "o", zC: "o", "0C": "o", "1C": "o", "2C": "o", CC: "o", fC: "o", "3C": "o", DC: "o" } }, G: { A: {
  E: 0, OC: 0, "4C": 0, gC: 278986e-8, "5C": 139493e-8, "6C": 557971e-8, "7C": 836957e-8, "8C": 0, "9C": 557971e-8, AD: 0.0223189, BD: 278986e-8,
  CD: 0.0320834, DD: 0.234348, ED: 0.0111594, FD: 697464e-8, GD: 0.156232, HD: 278986e-8, ID: 0.0474276, JD: 697464e-8, KD: 0.0237138, LD: 0.10462,
  MD: 0.0655617, ND: 0.0362681, QC: 0.0348732, RC: 0.0418479, EC: 0.0474276, OD: 0.542627, FC: 0.0906704, SC: 0.193895, TC: 0.0990399, UC: 0.171576,
  VC: 0.0348732, WC: 0.0711414, PD: 0.683515, GC: 0.0474276, XC: 0.078116, YC: 0.0641667, ZC: 0.0920653, aC: 0.199475, bC: 0.485435, QD: 1.82178,
  HC: 0.59424, cC: 6.92303, dC: 0.813243, eC: 0.0306884 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "OC", "4C", "gC", "5C", "6C", "7C", "E", "8C", "9C", "AD", "BD", "CD", "DD", "ED", "FD", "GD", "HD", "ID", "JD", "KD", "LD", "\
MD", "ND", "QC", "RC", "EC", "OD", "FC", "SC", "TC", "UC", "VC", "WC", "PD", "GC", "XC", "YC", "ZC", "aC", "bC", "QD", "HC", "cC", "dC", "eC",
  "", ""], E: "Safari on iOS", F: { OC: 1270252800, "4C": 1283904e3, gC: 1299628800, "5C": 1331078400, "6C": 1359331200, "7C": 1394409600, E: 1410912e3,
  "8C": 1413763200, "9C": 1442361600, AD: 1458518400, BD: 1473724800, CD: 1490572800, DD: 1505779200, ED: 1522281600, FD: 1537142400, GD: 1553472e3,
  HD: 1568851200, ID: 1572220800, JD: 1580169600, KD: 1585008e3, LD: 1600214400, MD: 1619395200, ND: 1632096e3, QC: 1639353600, RC: 1647216e3,
  EC: 1652659200, OD: 1658275200, FC: 1662940800, SC: 1666569600, TC: 1670889600, UC: 1674432e3, VC: 1679875200, WC: 1684368e3, PD: 1690156800,
  GC: 1694995200, XC: 1698192e3, YC: 1702252800, ZC: 1705881600, aC: 1709596800, bC: 1715558400, QD: 1722211200, HC: 1726444800, cC: 1730073600,
  dC: 1733875200, eC: null } }, H: { A: { RD: 0.04 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "RD", "", "", ""], E: "Opera Mini", F: { RD: 1426464e3 } }, I: { A: { IC: 0, J: 0, I: 0.24566, SD: 0, TD: 0,
  UD: 0, VD: 246202e-10, gC: 492404e-10, WD: 0, XD: 295442e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "SD", "TD", "UD", "IC", "J", "VD", "gC", "WD", "XD", "I", "", "", ""], E: "Android Browser", F: { SD: 1256515200, TD: 1274313600,
  UD: 1291593600, IC: 1298332800, J: 1318896e3, VD: 1341792e3, gC: 1374624e3, WD: 1386547200, XD: 1401667200, I: 1731369600 } }, J: { A: { D: 0,
  A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "\
A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 1.0096, CC: 0, fC: 0, DC: 0 },
  B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "CC", "fC", "C", "DC", "H", "",
  "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, CC: 1314835200, fC: 1318291200, C: 1330300800, DC: 1349740800, H: 1709769600 },
  D: { H: "webkit" } }, L: { A: { I: 47.0453 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "I", "", "", ""], E: "Chrome for Android", F: { I: 1731369600 } }, M: { A: { BC: 0.32395 }, B: "moz", C: [
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BC", "", "", ""], E: "Fir\
efox for Android", F: { BC: 173016e4 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { EC: 0.855228 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "",
  ""], E: "UC Browser for Android", F: { EC: 1710115200 }, D: { EC: "webkit" } }, P: { A: { 0: 0.0322125, 1: 0.04295, 2: 0.0536875, 3: 0.04295,
  4: 0.1718, 5: 1.77169, J: 0.0859, y: 0, z: 0.0322125, YD: 0.0107375, ZD: 0, aD: 0.021475, bD: 0, cD: 0, PC: 0, dD: 0, eD: 0, fD: 0, gD: 0,
  hD: 0, FC: 0, GC: 0.0107375, HC: 0, iD: 0.0107375 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "YD", "ZD", "aD", "bD", "cD", "PC", "dD", "eD",
  "fD", "gD", "hD", "FC", "GC", "HC", "iD", "y", "z", "0", "1", "2", "3", "4", "5", "", "", ""], E: "Samsung Internet", F: { 0: 1689292800, 1: 1697587200,
  2: 1711497600, 3: 1715126400, 4: 1717718400, 5: 1725667200, J: 1461024e3, YD: 1481846400, ZD: 1509408e3, aD: 1528329600, bD: 1546128e3, cD: 1554163200,
  PC: 1567900800, dD: 1582588800, eD: 1593475200, fD: 1605657600, gD: 1618531200, hD: 1629072e3, FC: 1640736e3, GC: 1651708800, HC: 1659657600,
  iD: 1667260800, y: 1677369600, z: 1684454400 } }, Q: { A: { jD: 0.239723 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "jD", "", "", ""], E: "QQ Browser", F: { jD: 1710288e3 } }, R: { A: { kD: 0 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "kD", "", "",
  ""], E: "Baidu Browser", F: { kD: 1710201600 } }, S: { A: { lD: 0.019437, mD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "lD", "mD", "", "", ""], E: "KaiOS Browser", F: { lD: 1527811200, mD: 1631664e3 } } };
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var sQ = g((FVs, tQ) => {
  "use strict";
  var Uct = MP().browsers, b_ = T_().browserVersions, ZG = QG();
  function eQ(t) {
    return Object.keys(t).reduce((e, s) => (e[b_[s]] = t[s], e), {});
  }
  n(eQ, "unpackBrowserVersions");
  tQ.exports.agents = Object.keys(ZG).reduce((t, e) => {
    let s = ZG[e];
    return t[Uct[e]] = Object.keys(s).reduce((i, r) => (r === "A" ? i.usage_global = eQ(s[r]) : r === "C" ? i.versions = s[r].reduce((a, o) => (o ===
    "" ? a.push(null) : a.push(b_[o]), a), []) : r === "D" ? i.prefix_exceptions = eQ(s[r]) : r === "E" ? i.browser = s[r] : r === "F" ? i.release_date =
    Object.keys(s[r]).reduce(
      (a, o) => (a[b_[o]] = s[r][o], a),
      {}
    ) : i.prefix = s[r], i), {}), t;
  }, {});
});

// ../node_modules/electron-to-chromium/versions.js
var rQ = g((RVs, iQ) => {
  iQ.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "34.0": "132",
    "35.0": "133"
  };
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var nQ = g((qVs, Kct) => {
  Kct.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "\
2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Arg\
on" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "\
2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "\
2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "\
2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Du\
bnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "\
2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "\
2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "\
2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Ga\
llium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "\
2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "\
2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "\
2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "Jo\
d" }, v23: { start: "2024-10-16", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-04-22", lts: "2025-10-28", maintenance: "\
2026-10-20", end: "2028-04-30", codename: "" } };
});

// ../node_modules/browserslist/error.js
var S_ = g((UVs, aQ) => {
  function x_(t) {
    this.name = "BrowserslistError", this.message = t, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, x_);
  }
  n(x_, "BrowserslistError");
  x_.prototype = Error.prototype;
  aQ.exports = x_;
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var lQ = g((VVs, oQ) => {
  oQ.exports = {
    1: "ls",
    // WHATWG Living Standard
    2: "rec",
    // W3C Recommendation
    3: "pr",
    // W3C Proposed Recommendation
    4: "cr",
    // W3C Candidate Recommendation
    5: "wd",
    // W3C Working Draft
    6: "other",
    // Non-W3C, but reputable
    7: "unoff"
    // Unofficial, Editor's Draft or W3C "Note"
  };
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var cQ = g((WVs, uQ) => {
  uQ.exports = {
    y: 1,
    n: 2,
    a: 4,
    p: 8,
    u: 16,
    x: 32,
    d: 64
  };
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var fQ = g(($Vs, P_) => {
  "use strict";
  var Vct = lQ(), pQ = cQ(), Wct = MP().browsers, $ct = T_().browserVersions, Hct = Math.log(2);
  function Jct(t) {
    let e = Object.keys(pQ).reduce((r, a) => (t & pQ[a] && r.push(a), r), []), s = t >> 7, i = [];
    for (; s; ) {
      let r = Math.floor(Math.log(s) / Hct) + 1;
      i.unshift(`#${r}`), s -= Math.pow(2, r - 1);
    }
    return e.concat(i).join(" ");
  }
  n(Jct, "unpackSupport");
  function hQ(t) {
    let e = {
      status: Vct[t.B],
      title: t.C,
      shown: t.D
    };
    return e.stats = Object.keys(t.A).reduce((s, i) => {
      let r = t.A[i];
      return s[Wct[i]] = Object.keys(r).reduce(
        (a, o) => {
          let l = r[o].split(" "), u = Jct(o);
          return l.forEach((c) => a[$ct[c]] = u), a;
        },
        {}
      ), s;
    }, {}), e;
  }
  n(hQ, "unpackFeature");
  P_.exports = hQ;
  P_.exports.default = hQ;
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var mQ = g((JVs, E_) => {
  "use strict";
  var Yct = MP().browsers;
  function dQ(t) {
    return Object.keys(t).reduce((e, s) => {
      let i = t[s];
      return e[Yct[s]] = Object.keys(i).reduce((r, a) => {
        let o = i[a];
        return a === "_" ? o.split(" ").forEach((l) => r[l] = null) : r[a] = o, r;
      }, {}), e;
    }, {});
  }
  n(dQ, "unpackRegion");
  E_.exports = dQ;
  E_.exports.default = dQ;
});

// ../node_modules/browserslist/node.js
var vQ = g((XVs, hT) => {
  var Xct = fQ().default, zct = mQ().default, tp = require("fs"), wo = require("path"), sn = S_(), yQ = /^\s*\[(.+)]\s*$/, Gct = /^browserslist-config-/,
  Qct = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, gQ = "Browserslist config should be a string or an array of strings with browse\
r queries", A_ = !1, TQ = {}, bQ = {}, FP = {};
  function xQ(t) {
    var e = " Use `dangerousExtend` option to disable.";
    if (!Gct.test(t) && !Qct.test(t))
      throw new sn(
        "Browserslist config needs `browserslist-config-` prefix. " + e
      );
    if (t.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
      throw new sn(
        "`.` not allowed in Browserslist config name. " + e
      );
    if (t.indexOf("node_modules") !== -1)
      throw new sn(
        "`node_modules` not allowed in Browserslist config." + e
      );
  }
  n(xQ, "checkExtend");
  function vu(t) {
    return tp.existsSync(t) && tp.statSync(t).isFile();
  }
  n(vu, "isFile");
  function Zct(t) {
    return tp.existsSync(t) && tp.statSync(t).isDirectory();
  }
  n(Zct, "isDirectory");
  function SQ(t, e, s) {
    var i = wo.resolve(t), r = [], a;
    do {
      if (!ept(i))
        break;
      if (s && i in s) {
        a = s[i];
        break;
      }
      if (r.push(i), !!Zct(i)) {
        var o = e(i);
        if (typeof o < "u") {
          a = o;
          break;
        }
      }
    } while (i !== (i = wo.dirname(i)));
    return s && !process.env.BROWSERSLIST_DISABLE_CACHE && r.forEach(function(l) {
      s[l] = a;
    }), a;
  }
  n(SQ, "eachParent");
  function ept(t) {
    if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
    var e = wo.resolve(process.env.BROWSERSLIST_ROOT_PATH);
    return wo.relative(e, t).substring(0, 2) !== "..";
  }
  n(ept, "pathInRoot");
  function tpt(t) {
    if (Array.isArray(t)) {
      for (var e = 0; e < t.length; e++)
        if (typeof t[e] != "string")
          throw new sn(gQ);
    } else if (typeof t != "string")
      throw new sn(gQ);
  }
  n(tpt, "check");
  function v_(t, e) {
    if (typeof t != "object") return t;
    var s;
    if (typeof e.env == "string" ? s = e.env : process.env.BROWSERSLIST_ENV ? s = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? s = process.
    env.NODE_ENV : s = "production", e.throwOnMissing && s && s !== "defaults" && !t[s])
      throw new sn(
        "Missing config for Browserslist environment `" + s + "`"
      );
    return t[s] || t.defaults;
  }
  n(v_, "pickEnv");
  function AQ(t) {
    var e = tp.readFileSync(t).toString().replace(/^\uFEFF/m, ""), s;
    if (e.indexOf('"browserslist"') >= 0)
      s = JSON.parse(e).browserslist;
    else if (e.indexOf('"browserlist"') >= 0) {
      var i = JSON.parse(e);
      if (i.browserlist && !i.browserslist)
        throw new sn(
          "`browserlist` key instead of `browserslist` in " + t
        );
    }
    (Array.isArray(s) || typeof s == "string") && (s = { defaults: s });
    for (var r in s)
      tpt(s[r]);
    return s;
  }
  n(AQ, "parsePackage");
  function PQ(t) {
    if (t in FP)
      return FP[t];
    var e = wo.basename(t) === "package.json", s = e ? AQ(t) : hT.exports.readConfig(t);
    return process.env.BROWSERSLIST_DISABLE_CACHE || (FP[t] = s), s;
  }
  n(PQ, "parsePackageOrReadConfig");
  function spt(t) {
    var e = 0;
    for (var s in t) {
      var i = t[s].releaseDate || {};
      for (var r in i)
        e < i[r] && (e = i[r]);
    }
    return e * 1e3;
  }
  n(spt, "latestReleaseTime");
  function ipt(t) {
    var e = /* @__PURE__ */ new Date(), s = new Date(t), i = e.getFullYear() - s.getFullYear(), r = e.getMonth() - s.getMonth();
    return i * 12 + r;
  }
  n(ipt, "getMonthsPassed");
  function EQ(t, e) {
    if (t || (t = {}), e && "dataByBrowser" in e && (e = e.dataByBrowser), typeof e == "object") {
      var s = {};
      for (var i in e) {
        var r = Object.keys(e[i]);
        if (r.length === 1 && t[i] && t[i].versions.length === 1) {
          var a = t[i].versions[0];
          s[i] = {}, s[i][a] = e[i][r[0]];
        } else
          s[i] = e[i];
      }
      return s;
    }
  }
  n(EQ, "normalizeStats");
  function rpt(t, e) {
    for (var s in t) {
      var i = t[s];
      if ("0" in i) {
        var r = e[s].versions;
        i[r[r.length - 1]] = i[0], delete i[0];
      }
    }
  }
  n(rpt, "normalizeUsageData");
  hT.exports = {
    loadQueries: /* @__PURE__ */ n(function(e, s) {
      !e.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && xQ(s);
      var i = require(require.resolve(s, { paths: [".", e.path] }));
      if (i) {
        if (Array.isArray(i))
          return i;
        if (typeof i == "object")
          return i.defaults || (i.defaults = []), v_(i, e, s);
      }
      throw new sn(
        "`" + s + "` config exports not an array of queries or an object of envs"
      );
    }, "loadQueries"),
    loadStat: /* @__PURE__ */ n(function(e, s, i) {
      !e.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && xQ(s);
      var r = require(require.resolve(
        wo.join(s, "browserslist-stats.json"),
        { paths: ["."] }
      ));
      return EQ(i, r);
    }, "loadStat"),
    getStat: /* @__PURE__ */ n(function(e, s) {
      var i;
      if (e.stats ? i = e.stats : process.env.BROWSERSLIST_STATS ? i = process.env.BROWSERSLIST_STATS : e.path && wo.resolve && tp.existsSync &&
      (i = SQ(e.path, function(r) {
        var a = wo.join(r, "browserslist-stats.json");
        return vu(a) ? a : void 0;
      }, TQ)), typeof i == "string")
        try {
          i = JSON.parse(tp.readFileSync(i));
        } catch {
          throw new sn("Can't read " + i);
        }
      return EQ(s, i);
    }, "getStat"),
    loadConfig: /* @__PURE__ */ n(function(e) {
      if (process.env.BROWSERSLIST)
        return process.env.BROWSERSLIST;
      if (e.config || process.env.BROWSERSLIST_CONFIG) {
        var s = e.config || process.env.BROWSERSLIST_CONFIG;
        return v_(PQ(s), e);
      } else return e.path ? v_(hT.exports.findConfig(e.path), e) : void 0;
    }, "loadConfig"),
    loadCountry: /* @__PURE__ */ n(function(e, s, i) {
      var r = s.replace(/[^\w-]/g, "");
      if (!e[r]) {
        var a;
        try {
          a = require("caniuse-lite/data/regions/" + r + ".js");
        } catch {
          throw new sn("Unknown region name `" + r + "`.");
        }
        var o = zct(a);
        rpt(o, i), e[s] = {};
        for (var l in o)
          for (var u in o[l])
            e[s][l + " " + u] = o[l][u];
      }
    }, "loadCountry"),
    loadFeature: /* @__PURE__ */ n(function(e, s) {
      if (s = s.replace(/[^\w-]/g, ""), !e[s]) {
        var i;
        try {
          i = require("caniuse-lite/data/features/" + s + ".js");
        } catch {
          throw new sn("Unknown feature name `" + s + "`.");
        }
        var r = Xct(i).stats;
        e[s] = {};
        for (var a in r) {
          e[s][a] = {};
          for (var o in r[a])
            e[s][a][o] = r[a][o];
        }
      }
    }, "loadFeature"),
    parseConfig: /* @__PURE__ */ n(function(e) {
      var s = { defaults: [] }, i = ["defaults"];
      return e.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(r) {
        return r.trim();
      }).filter(function(r) {
        return r !== "";
      }).forEach(function(r) {
        yQ.test(r) ? (i = r.match(yQ)[1].trim().split(" "), i.forEach(function(a) {
          if (s[a])
            throw new sn(
              "Duplicate section " + a + " in Browserslist config"
            );
          s[a] = [];
        })) : i.forEach(function(a) {
          s[a].push(r);
        });
      }), s;
    }, "parseConfig"),
    readConfig: /* @__PURE__ */ n(function(e) {
      if (!vu(e))
        throw new sn("Can't read " + e + " config");
      return hT.exports.parseConfig(tp.readFileSync(e));
    }, "readConfig"),
    findConfigFile: /* @__PURE__ */ n(function(e) {
      return SQ(e, function(s) {
        var i = wo.join(s, "browserslist"), r = wo.join(s, "package.json"), a = wo.join(s, ".browserslistrc"), o;
        if (vu(r))
          try {
            o = AQ(r);
          } catch (l) {
            if (l.name === "BrowserslistError") throw l;
            console.warn(
              "[Browserslist] Could not parse " + r + ". Ignoring it."
            );
          }
        if (vu(i) && o)
          throw new sn(
            s + " contains both browserslist and package.json with browsers"
          );
        if (vu(a) && o)
          throw new sn(
            s + " contains both .browserslistrc and package.json with browsers"
          );
        if (vu(i) && vu(a))
          throw new sn(
            s + " contains both .browserslistrc and browserslist"
          );
        if (vu(i))
          return i;
        if (vu(a))
          return a;
        if (o)
          return r;
      }, bQ);
    }, "findConfigFile"),
    findConfig: /* @__PURE__ */ n(function(e) {
      var s = this.findConfigFile(e);
      return s ? PQ(s) : void 0;
    }, "findConfig"),
    clearCaches: /* @__PURE__ */ n(function() {
      A_ = !1, TQ = {}, bQ = {}, FP = {}, this.cache = {};
    }, "clearCaches"),
    oldDataWarning: /* @__PURE__ */ n(function(e) {
      if (!A_ && (A_ = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
        var s = spt(e), i = ipt(s);
        if (s !== 0 && i >= 6) {
          var r = i + " " + (i > 1 ? "months" : "month");
          console.warn(
            "Browserslist: browsers data (caniuse-lite) is " + r + ` old. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
          );
        }
      }
    }, "oldDataWarning"),
    currentNode: /* @__PURE__ */ n(function() {
      return "node " + process.versions.node;
    }, "currentNode"),
    env: process.env
  };
});

// ../node_modules/browserslist/parse.js
var kQ = g((GVs, NQ) => {
  var CQ = /^\s+and\s+(.*)/i, wQ = /^(?:,\s*|\s+or\s+)(.*)/i;
  function IQ(t) {
    return Array.isArray(t) ? t.reduce(function(e, s) {
      return e.concat(IQ(s));
    }, []) : [t];
  }
  n(IQ, "flatten");
  function npt(t, e) {
    for (var s = t.length, i = 1; i <= s; i++) {
      var r = t.substr(-i, i);
      if (e(r, i, s))
        return t.slice(0, -i);
    }
    return "";
  }
  n(npt, "find");
  function C_(t, e) {
    var s = { query: e };
    e.indexOf("not ") === 0 && (s.not = !0, e = e.slice(4));
    for (var i in t) {
      var r = t[i], a = e.match(r.regexp);
      if (a) {
        s.type = i;
        for (var o = 0; o < r.matches.length; o++)
          s[r.matches[o]] = a[o + 1];
        return s;
      }
    }
    return s.type = "unknown", s;
  }
  n(C_, "matchQuery");
  function apt(t, e, s) {
    var i;
    return npt(e, function(r, a, o) {
      return CQ.test(r) ? (i = C_(t, r.match(CQ)[1]), i.compose = "and", s.unshift(i), !0) : wQ.test(r) ? (i = C_(t, r.match(wQ)[1]), i.compose =
      "or", s.unshift(i), !0) : a === o ? (i = C_(t, r.trim()), i.compose = "or", s.unshift(i), !0) : !1;
    });
  }
  n(apt, "matchBlock");
  NQ.exports = /* @__PURE__ */ n(function(e, s) {
    return Array.isArray(s) || (s = [s]), IQ(
      s.map(function(i) {
        var r = [];
        do
          i = apt(e, i, r);
        while (i);
        return r;
      })
    );
  }, "parse");
});

// ../node_modules/browserslist/index.js
var JQ = g((ZVs, HQ) => {
  var opt = WG(), Cu = sQ().agents, Io = rQ(), w_ = nQ(), VP = require("path"), ia = S_(), Fr = vQ(), lpt = kQ(), upt = 365.259641 * 24 * 60 *
  60 * 1e3, RQ = "37", cpt = 14;
  function qQ(t, e) {
    return (t + ".").indexOf(e + ".") === 0;
  }
  n(qQ, "isVersionsMatch");
  function ppt(t) {
    var e = t.slice(1);
    return bt.nodeVersions.some(function(s) {
      return qQ(s, e);
    });
  }
  n(ppt, "isEolReleased");
  function DQ(t) {
    return t.filter(function(e) {
      return typeof e == "string";
    });
  }
  n(DQ, "normalize");
  function jP(t) {
    var e = t;
    return t.split(".").length === 3 && (e = t.split(".").slice(0, -1).join(".")), e;
  }
  n(jP, "normalizeElectron");
  function sp(t) {
    return /* @__PURE__ */ n(function(s) {
      return t + " " + s;
    }, "mapName");
  }
  n(sp, "nameMapper");
  function O_(t) {
    return parseInt(t.split(".")[0]);
  }
  n(O_, "getMajor");
  function RP(t, e) {
    if (t.length === 0) return [];
    var s = UQ(t.map(O_)), i = s[s.length - e];
    if (!i)
      return t;
    for (var r = [], a = t.length - 1; a >= 0 && !(i > O_(t[a])); a--)
      r.unshift(t[a]);
    return r;
  }
  n(RP, "getMajorVersions");
  function UQ(t) {
    for (var e = [], s = 0; s < t.length; s++)
      e.indexOf(t[s]) === -1 && e.push(t[s]);
    return e;
  }
  n(UQ, "uniq");
  function WP(t, e, s) {
    for (var i in s)
      t[e + " " + i] = s[i];
  }
  n(WP, "fillUsage");
  function OQ(t, e) {
    if (e = parseFloat(e), t === ">")
      return function(i) {
        return s(i) > e;
      };
    return t === ">=" ? function(i) {
      return s(i) >= e;
    } : t === "<" ? function(i) {
      return parseFloat(i) < e;
    } : function(i) {
      return parseFloat(i) <= e;
    };
    function s(i) {
      return parseFloat(i.split("-")[1] || i);
    }
  }
  n(OQ, "generateFilter");
  function hpt(t, e) {
    return e = e.split(".").map(ip), e[1] = e[1] || 0, e[2] = e[2] || 0, t === ">" ? function(s) {
      return s = s.split(".").map(ip), fT(s, e) > 0;
    } : t === ">=" ? function(s) {
      return s = s.split(".").map(ip), fT(s, e) >= 0;
    } : t === "<" ? function(s) {
      return s = s.split(".").map(ip), fT(e, s) > 0;
    } : function(s) {
      return s = s.split(".").map(ip), fT(e, s) >= 0;
    };
  }
  n(hpt, "generateSemverFilter");
  function ip(t) {
    return parseInt(t);
  }
  n(ip, "parseSimpleInt");
  function KP(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  n(KP, "compare");
  function fT(t, e) {
    return KP(parseInt(t[0]), parseInt(e[0])) || KP(parseInt(t[1] || "0"), parseInt(e[1] || "0")) || KP(parseInt(t[2] || "0"), parseInt(e[2] ||
    "0"));
  }
  n(fT, "compareSemver");
  function _Q(t, e) {
    switch (e = e.split(".").map(ip), typeof e[1] > "u" && (e[1] = "x"), t) {
      case "<=":
        return function(s) {
          return s = s.split(".").map(ip), LQ(s, e) <= 0;
        };
      case ">=":
      default:
        return function(s) {
          return s = s.split(".").map(ip), LQ(s, e) >= 0;
        };
    }
  }
  n(_Q, "semverFilterLoose");
  function LQ(t, e) {
    return t[0] !== e[0] ? t[0] < e[0] ? -1 : 1 : e[1] === "x" ? 0 : t[1] !== e[1] ? t[1] < e[1] ? -1 : 1 : 0;
  }
  n(LQ, "compareSemverLoose");
  function fpt(t, e) {
    return t.versions.indexOf(e) !== -1 ? e : bt.versionAliases[t.name][e] ? bt.versionAliases[t.name][e] : !1;
  }
  n(fpt, "resolveVersion");
  function qP(t, e) {
    var s = fpt(t, e);
    return s || (t.versions.length === 1 ? t.versions[0] : !1);
  }
  n(qP, "normalizeVersion");
  function KQ(t, e) {
    return t = t / 1e3, Object.keys(Cu).reduce(function(s, i) {
      var r = rp(i, e);
      if (!r) return s;
      var a = Object.keys(r.releaseDate).filter(function(o) {
        var l = r.releaseDate[o];
        return l !== null && l >= t;
      });
      return s.concat(a.map(sp(r.name)));
    }, []);
  }
  n(KQ, "filterByYear");
  function BQ(t) {
    return {
      name: t.name,
      versions: t.versions,
      released: t.released,
      releaseDate: t.releaseDate
    };
  }
  n(BQ, "cloneData");
  function rp(t, e) {
    if (t = t.toLowerCase(), t = bt.aliases[t] || t, e.mobileToDesktop && bt.desktopNames[t]) {
      var s = bt.data[bt.desktopNames[t]];
      if (t === "android")
        return mpt(BQ(bt.data[t]), s);
      var i = BQ(s);
      return i.name = t, i;
    }
    return bt.data[t];
  }
  n(rp, "byName");
  function MQ(t, e) {
    var s = e.indexOf(RQ);
    return t.filter(function(i) {
      return /^(?:[2-4]\.|[34]$)/.test(i);
    }).concat(e.slice(s));
  }
  n(MQ, "normalizeAndroidVersions");
  function dpt(t) {
    var e = {};
    for (var s in t)
      e[s] = t[s];
    return e;
  }
  n(dpt, "copyObject");
  function mpt(t, e) {
    return t.released = MQ(t.released, e.released), t.versions = MQ(t.versions, e.versions), t.releaseDate = dpt(t.releaseDate), t.released.
    forEach(function(s) {
      t.releaseDate[s] === void 0 && (t.releaseDate[s] = e.releaseDate[s]);
    }), t;
  }
  n(mpt, "normalizeAndroidData");
  function nm(t, e) {
    var s = rp(t, e);
    if (!s) throw new ia("Unknown browser " + t);
    return s;
  }
  n(nm, "checkName");
  function ypt(t) {
    return new ia(
      "Unknown browser query `" + t + "`. Maybe you are using old Browserslist or made typo in query."
    );
  }
  n(ypt, "unknownQuery");
  function UP(t, e, s, i) {
    var r = 1;
    switch (e) {
      case "android":
        if (i.mobileToDesktop) return t;
        var a = bt.data.chrome.released;
        r = a.length - a.indexOf(RQ);
        break;
      case "op_mob":
        var o = bt.data.op_mob.released.slice(-1)[0];
        r = O_(o) - cpt + 1;
        break;
      default:
        return t;
    }
    return s <= r ? t.slice(-1) : t.slice(r - 1 - s);
  }
  n(UP, "filterJumps");
  function FQ(t, e) {
    return typeof t == "string" && (t.indexOf("y") >= 0 || e && t.indexOf("a") >= 0);
  }
  n(FQ, "isSupported");
  function am(t, e) {
    return __(t).reduce(function(s, i, r) {
      if (i.not && r === 0)
        throw new ia(
          "Write any browsers query (for instance, `defaults`) before `" + i.query + "`"
        );
      var a = L_[i.type], o = a.select.call(bt, e, i).map(function(u) {
        var c = u.split(" ");
        return c[1] === "0" ? c[0] + " " + rp(c[0], e).versions[0] : u;
      });
      if (i.compose === "and")
        return i.not ? s.filter(function(u) {
          return o.indexOf(u) === -1;
        }) : s.filter(function(u) {
          return o.indexOf(u) !== -1;
        });
      if (i.not) {
        var l = {};
        return o.forEach(function(u) {
          l[u] = !0;
        }), s.filter(function(u) {
          return !l[u];
        });
      }
      return s.concat(o);
    }, []);
  }
  n(am, "resolve");
  function VQ(t) {
    return typeof t > "u" && (t = {}), typeof t.path > "u" && (t.path = VP.resolve ? VP.resolve(".") : "."), t;
  }
  n(VQ, "prepareOpts");
  function WQ(t, e) {
    if (typeof t > "u" || t === null) {
      var s = bt.loadConfig(e);
      s ? t = s : t = bt.defaults;
    }
    return t;
  }
  n(WQ, "prepareQueries");
  function $Q(t) {
    if (!(typeof t == "string" || Array.isArray(t)))
      throw new ia(
        "Browser queries must be an array or string. Got " + typeof t + "."
      );
  }
  n($Q, "checkQueries");
  var I_ = {}, N_ = {};
  function bt(t, e) {
    e = VQ(e), t = WQ(t, e), $Q(t);
    var s = __(t).some(function(u) {
      return L_[u.type].needsPath;
    }), i = {
      ignoreUnknownVersions: e.ignoreUnknownVersions,
      dangerousExtend: e.dangerousExtend,
      mobileToDesktop: e.mobileToDesktop,
      env: e.env
    };
    s && (i.path = e.path), Fr.oldDataWarning(bt.data);
    var r = Fr.getStat(e, bt.data);
    if (r) {
      i.customUsage = {};
      for (var a in r)
        WP(i.customUsage, a, r[a]);
    }
    var o = JSON.stringify([t, i]);
    if (I_[o]) return I_[o];
    var l = UQ(am(t, i)).sort(function(u, c) {
      if (u = u.split(" "), c = c.split(" "), u[0] === c[0]) {
        var p = u[1].split("-")[0], h = c[1].split("-")[0];
        return fT(h.split("."), p.split("."));
      } else
        return KP(u[0], c[0]);
    });
    return Fr.env.BROWSERSLIST_DISABLE_CACHE || (I_[o] = l), l;
  }
  n(bt, "browserslist");
  function __(t) {
    var e = JSON.stringify(t);
    if (e in N_) return N_[e];
    var s = lpt(L_, t);
    return Fr.env.BROWSERSLIST_DISABLE_CACHE || (N_[e] = s), s;
  }
  n(__, "parseQueries");
  bt.parse = function(t, e) {
    return e = VQ(e), t = WQ(t, e), $Q(t), __(t);
  };
  bt.cache = {};
  bt.data = {};
  bt.usage = {
    global: {},
    custom: null
  };
  bt.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  bt.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  bt.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
    // has extra processing logic
  };
  bt.versionAliases = {};
  bt.clearCaches = Fr.clearCaches;
  bt.parseConfig = Fr.parseConfig;
  bt.readConfig = Fr.readConfig;
  bt.findConfigFile = Fr.findConfigFile;
  bt.findConfig = Fr.findConfig;
  bt.loadConfig = Fr.loadConfig;
  bt.coverage = function(t, e) {
    var s;
    if (typeof e > "u")
      s = bt.usage.global;
    else if (e === "my stats") {
      var i = {};
      i.path = VP.resolve ? VP.resolve(".") : ".";
      var r = Fr.getStat(i);
      if (!r)
        throw new ia("Custom usage statistics was not provided");
      s = {};
      for (var a in r)
        WP(s, a, r[a]);
    } else if (typeof e == "string")
      e.length > 2 ? e = e.toLowerCase() : e = e.toUpperCase(), Fr.loadCountry(bt.usage, e, bt.data), s = bt.usage[e];
    else {
      "dataByBrowser" in e && (e = e.dataByBrowser), s = {};
      for (var o in e)
        for (var l in e[o])
          s[o + " " + l] = e[o][l];
    }
    return t.reduce(function(u, c) {
      var p = s[c];
      return p === void 0 && (p = s[c.replace(/ \S+$/, " 0")]), u + (p || 0);
    }, 0);
  };
  function k_(t, e) {
    var s = bt.nodeVersions.filter(function(i) {
      return qQ(i, e.version);
    });
    if (s.length === 0) {
      if (t.ignoreUnknownVersions)
        return [];
      throw new ia(
        "Unknown version " + e.version + " of Node.js"
      );
    }
    return ["node " + s[s.length - 1]];
  }
  n(k_, "nodeQuery");
  function D_(t, e) {
    var s = parseInt(e.year), i = parseInt(e.month || "01") - 1, r = parseInt(e.day || "01");
    return KQ(Date.UTC(s, i, r, 0, 0, 0), t);
  }
  n(D_, "sinceQuery");
  function jQ(t, e) {
    var s = parseFloat(e.coverage), i = bt.usage.global;
    if (e.place)
      if (e.place.match(/^my\s+stats$/i)) {
        if (!t.customUsage)
          throw new ia("Custom usage statistics was not provided");
        i = t.customUsage;
      } else {
        var r;
        e.place.length === 2 ? r = e.place.toUpperCase() : r = e.place.toLowerCase(), Fr.loadCountry(bt.usage, r, bt.data), i = bt.usage[r];
      }
    for (var a = Object.keys(i).sort(function(p, h) {
      return i[h] - i[p];
    }), o = 0, l = [], u, c = 0; c < a.length && (u = a[c], !(i[u] === 0 || (o += i[u], l.push(u), o >= s))); c++)
      ;
    return l;
  }
  n(jQ, "coverQuery");
  var L_ = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return Object.keys(Cu).reduce(function(s, i) {
          var r = rp(i, t);
          if (!r) return s;
          var a = RP(r.released, e.versions);
          return a = a.map(sp(r.name)), a = UP(a, r.name, e.versions, t), s.concat(a);
        }, []);
      }, "select")
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return Object.keys(Cu).reduce(function(s, i) {
          var r = rp(i, t);
          if (!r) return s;
          var a = r.released.slice(-e.versions);
          return a = a.map(sp(r.name)), a = UP(a, r.name, e.versions, t), s.concat(a);
        }, []);
      }, "select")
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = RP(Object.keys(Io), e.versions);
        return s.map(function(i) {
          return "chrome " + Io[i];
        });
      }, "select")
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return RP(bt.nodeVersions, e.versions).map(
          function(s) {
            return "node " + s;
          }
        );
      }, "select")
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = nm(e.browser, t), i = RP(s.released, e.versions), r = i.map(sp(s.name));
        return r = UP(r, s.name, e.versions, t), r;
      }, "select")
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return Object.keys(Io).slice(-e.versions).map(function(s) {
          return "chrome " + Io[s];
        });
      }, "select")
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return bt.nodeVersions.slice(-e.versions).map(function(s) {
          return "node " + s;
        });
      }, "select")
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = nm(e.browser, t), i = s.released.slice(-e.versions).map(sp(s.name));
        return i = UP(i, s.name, e.versions, t), i;
      }, "select")
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: /* @__PURE__ */ n(function(t) {
        return Object.keys(Cu).reduce(function(e, s) {
          var i = rp(s, t);
          if (!i) return e;
          var r = i.versions.filter(function(a) {
            return i.released.indexOf(a) === -1;
          });
          return r = r.map(sp(i.name)), e.concat(r);
        }, []);
      }, "select")
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ n(function() {
        return [];
      }, "select")
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = nm(e.browser, t);
        return s.versions.filter(function(i) {
          return s.released.indexOf(i) === -1;
        }).map(sp(s.name));
      }, "select")
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return KQ(Date.now() - upt * e.years, t);
      }, "select")
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: D_
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: D_
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: D_
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = parseFloat(e.popularity), i = bt.usage.global;
        return Object.keys(i).reduce(function(r, a) {
          return e.sign === ">" ? i[a] > s && r.push(a) : e.sign === "<" ? i[a] < s && r.push(a) : e.sign === "<=" ? i[a] <= s && r.push(a) :
          i[a] >= s && r.push(a), r;
        }, []);
      }, "select")
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = parseFloat(e.popularity);
        if (!t.customUsage)
          throw new ia("Custom usage statistics was not provided");
        var i = t.customUsage;
        return Object.keys(i).reduce(function(r, a) {
          var o = i[a];
          return o == null || (e.sign === ">" ? o > s && r.push(a) : e.sign === "<" ? o < s && r.push(a) : e.sign === "<=" ? o <= s && r.push(
          a) : o >= s && r.push(a)), r;
        }, []);
      }, "select")
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = parseFloat(e.popularity), i = Fr.loadStat(t, e.config, bt.data);
        if (i) {
          t.customUsage = {};
          for (var r in i)
            WP(t.customUsage, r, i[r]);
        }
        if (!t.customUsage)
          throw new ia("Custom usage statistics was not provided");
        var a = t.customUsage;
        return Object.keys(a).reduce(function(o, l) {
          var u = a[l];
          return u == null || (e.sign === ">" ? u > s && o.push(l) : e.sign === "<" ? u < s && o.push(l) : e.sign === "<=" ? u <= s && o.push(
          l) : u >= s && o.push(l)), o;
        }, []);
      }, "select")
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = parseFloat(e.popularity), i = e.place;
        i.length === 2 ? i = i.toUpperCase() : i = i.toLowerCase(), Fr.loadCountry(bt.usage, i, bt.data);
        var r = bt.usage[i];
        return Object.keys(r).reduce(function(a, o) {
          var l = r[o];
          return l == null || (e.sign === ">" ? l > s && a.push(o) : e.sign === "<" ? l < s && a.push(o) : e.sign === "<=" ? l <= s && a.push(
          o) : l >= s && a.push(o)), a;
        }, []);
      }, "select")
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: jQ
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: jQ
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
      select: /* @__PURE__ */ n(function(t, e) {
        Fr.loadFeature(bt.cache, e.feature);
        var s = e.supportType !== "fully", i = bt.cache[e.feature], r = [];
        for (var a in i) {
          for (var o = rp(a, t), l = o.released.length - 1; l >= 0 && !(o.released[l] in i[a]); )
            l--;
          var u = t.mobileToDesktop && a in bt.desktopNames && FQ(i[a][o.released[l]], s);
          o.versions.forEach(function(c) {
            var p = i[a][c];
            p === void 0 && u && (p = i[bt.desktopNames[a]][c]), FQ(p, s) && r.push(a + " " + c);
          });
        }
        return r;
      }, "select")
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = jP(e.from), i = jP(e.to), r = parseFloat(e.from), a = parseFloat(e.to);
        if (!Io[s])
          throw new ia("Unknown version " + r + " of electron");
        if (!Io[i])
          throw new ia("Unknown version " + a + " of electron");
        return Object.keys(Io).filter(function(o) {
          var l = parseFloat(o);
          return l >= r && l <= a;
        }).map(function(o) {
          return "chrome " + Io[o];
        });
      }, "select")
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return bt.nodeVersions.filter(_Q(">=", e.from)).filter(_Q("<=", e.to)).map(function(s) {
          return "node " + s;
        });
      }, "select")
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = nm(e.browser, t), i = parseFloat(qP(s, e.from) || e.from), r = parseFloat(qP(s, e.to) || e.to);
        function a(o) {
          var l = parseFloat(o);
          return l >= i && l <= r;
        }
        return n(a, "filter"), s.released.filter(a).map(sp(s.name));
      }, "select")
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = jP(e.version);
        return Object.keys(Io).filter(OQ(e.sign, s)).map(function(i) {
          return "chrome " + Io[i];
        });
      }, "select")
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        return bt.nodeVersions.filter(hpt(e.sign, e.version)).map(function(s) {
          return "node " + s;
        });
      }, "select")
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = e.version, i = nm(e.browser, t), r = bt.versionAliases[i.name][s];
        return r && (s = r), i.released.filter(OQ(e.sign, s)).map(function(a) {
          return i.name + " " + a;
        });
      }, "select")
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: /* @__PURE__ */ n(function() {
        return ["firefox 128"];
      }, "select")
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: /* @__PURE__ */ n(function() {
        return ["op_mini all"];
      }, "select")
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = jP(e.version), i = Io[s];
        if (!i)
          throw new ia(
            "Unknown version " + e.version + " of electron"
          );
        return ["chrome " + i];
      }, "select")
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: k_
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: k_
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: k_
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: /* @__PURE__ */ n(function(t) {
        return [Fr.currentNode(am, t)];
      }, "select")
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: /* @__PURE__ */ n(function(t) {
        var e = Date.now(), s = Object.keys(w_).filter(function(i) {
          return e < Date.parse(w_[i].end) && e > Date.parse(w_[i].start) && ppt(i);
        }).map(function(i) {
          return "node " + i.slice(1);
        });
        return am(s, t);
      }, "select")
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: /* @__PURE__ */ n(function() {
        return ["safari 5"];
      }, "select")
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: /* @__PURE__ */ n(function() {
        return ["safari 6"];
      }, "select")
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        var s = e.version;
        /^tp$/i.test(s) && (s = "TP");
        var i = nm(e.browser, t), r = qP(i, s);
        if (r)
          s = r;
        else if (s.indexOf(".") === -1 ? r = s + ".0" : r = s.replace(/\.0$/, ""), r = qP(i, r), r)
          s = r;
        else {
          if (t.ignoreUnknownVersions)
            return [];
          throw new ia(
            "Unknown version " + s + " of " + e.browser
          );
        }
        return [i.name + " " + s];
      }, "select")
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      needsPath: !0,
      select: /* @__PURE__ */ n(function(t) {
        return bt(void 0, t);
      }, "select")
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      needsPath: !0,
      select: /* @__PURE__ */ n(function(t, e) {
        return am(Fr.loadQueries(t, e.config), t);
      }, "select")
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: /* @__PURE__ */ n(function(t) {
        return am(bt.defaults, t);
      }, "select")
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: /* @__PURE__ */ n(function(t) {
        var e = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return am(e, t);
      }, "select")
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: /* @__PURE__ */ n(function(t, e) {
        throw rp(e.query, t) ? new ia(
          "Specify versions in Browserslist query for browser " + e.query
        ) : ypt(e.query);
      }, "select")
    }
  };
  (function() {
    for (var t in Cu) {
      var e = Cu[t];
      bt.data[t] = {
        name: t,
        versions: DQ(Cu[t].versions),
        released: DQ(Cu[t].versions.slice(0, -3)),
        releaseDate: Cu[t].release_date
      }, WP(bt.usage.global, t, e.usage_global), bt.versionAliases[t] = {};
      for (var s = 0; s < e.versions.length; s++) {
        var i = e.versions[s];
        if (i && i.indexOf("-") !== -1)
          for (var r = i.split("-"), a = 0; a < r.length; a++)
            bt.versionAliases[t][r[a]] = i;
      }
    }
    bt.nodeVersions = opt.map(function(o) {
      return o.version;
    });
  })();
  HQ.exports = bt;
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var M_ = g((B_) => {
  "use strict";
  Object.defineProperty(B_, "__esModule", {
    value: !0
  });
  B_.findSuggestion = Tpt;
  var {
    min: YQ
  } = Math;
  function gpt(t, e) {
    let s = [], i = [], r, a, o = t.length, l = e.length;
    if (!o)
      return l;
    if (!l)
      return o;
    for (a = 0; a <= l; a++)
      s[a] = a;
    for (r = 1; r <= o; r++) {
      for (i = [r], a = 1; a <= l; a++)
        i[a] = t[r - 1] === e[a - 1] ? s[a - 1] : YQ(s[a - 1], s[a], i[a - 1]) + 1;
      s = i;
    }
    return i[l];
  }
  n(gpt, "levenshtein");
  function Tpt(t, e) {
    let s = e.map((i) => gpt(i, t));
    return e[s.indexOf(YQ(...s))];
  }
  n(Tpt, "findSuggestion");
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var XQ = g(($P) => {
  "use strict";
  Object.defineProperty($P, "__esModule", {
    value: !0
  });
  $P.OptionValidator = void 0;
  var bpt = M_(), F_ = class {
    static {
      n(this, "OptionValidator");
    }
    constructor(e) {
      this.descriptor = e;
    }
    validateTopLevelOptions(e, s) {
      let i = Object.keys(s);
      for (let r of Object.keys(e))
        if (!i.includes(r))
          throw new Error(this.formatMessage(`'${r}' is not a valid top-level option.
- Did you mean '${(0, bpt.findSuggestion)(r, i)}'?`));
    }
    validateBooleanOption(e, s, i) {
      return s === void 0 ? i : (this.invariant(typeof s == "boolean", `'${e}' option must be a boolean.`), s);
    }
    validateStringOption(e, s, i) {
      return s === void 0 ? i : (this.invariant(typeof s == "string", `'${e}' option must be a string.`), s);
    }
    invariant(e, s) {
      if (!e)
        throw new Error(this.formatMessage(s));
    }
    formatMessage(e) {
      return `${this.descriptor}: ${e}`;
    }
  };
  $P.OptionValidator = F_;
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var JP = g((HP) => {
  "use strict";
  Object.defineProperty(HP, "__esModule", {
    value: !0
  });
  Object.defineProperty(HP, "OptionValidator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xpt.OptionValidator;
    }, "get")
  });
  Object.defineProperty(HP, "findSuggestion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Spt.findSuggestion;
    }, "get")
  });
  var xpt = XQ(), Spt = M_();
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var zQ = g((oWs, Ppt) => {
  Ppt.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// ../node_modules/@babel/compat-data/native-modules.js
var QQ = g((lWs, GQ) => {
  GQ.exports = zQ();
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var eZ = g((uWs, ZQ) => {
  "use strict";
  ZQ.exports = function(t) {
    t.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next)
        yield e.value;
    };
  };
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var sZ = g((cWs, tZ) => {
  "use strict";
  tZ.exports = Gs;
  Gs.Node = Uh;
  Gs.create = Gs;
  function Gs(t) {
    var e = this;
    if (e instanceof Gs || (e = new Gs()), e.tail = null, e.head = null, e.length = 0, t && typeof t.forEach == "function")
      t.forEach(function(r) {
        e.push(r);
      });
    else if (arguments.length > 0)
      for (var s = 0, i = arguments.length; s < i; s++)
        e.push(arguments[s]);
    return e;
  }
  n(Gs, "Yallist");
  Gs.prototype.removeNode = function(t) {
    if (t.list !== this)
      throw new Error("removing node which does not belong to this list");
    var e = t.next, s = t.prev;
    return e && (e.prev = s), s && (s.next = e), t === this.head && (this.head = e), t === this.tail && (this.tail = s), t.list.length--, t.
    next = null, t.prev = null, t.list = null, e;
  };
  Gs.prototype.unshiftNode = function(t) {
    if (t !== this.head) {
      t.list && t.list.removeNode(t);
      var e = this.head;
      t.list = this, t.next = e, e && (e.prev = t), this.head = t, this.tail || (this.tail = t), this.length++;
    }
  };
  Gs.prototype.pushNode = function(t) {
    if (t !== this.tail) {
      t.list && t.list.removeNode(t);
      var e = this.tail;
      t.list = this, t.prev = e, e && (e.next = t), this.tail = t, this.head || (this.head = t), this.length++;
    }
  };
  Gs.prototype.push = function() {
    for (var t = 0, e = arguments.length; t < e; t++)
      Apt(this, arguments[t]);
    return this.length;
  };
  Gs.prototype.unshift = function() {
    for (var t = 0, e = arguments.length; t < e; t++)
      vpt(this, arguments[t]);
    return this.length;
  };
  Gs.prototype.pop = function() {
    if (this.tail) {
      var t = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
    }
  };
  Gs.prototype.shift = function() {
    if (this.head) {
      var t = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
    }
  };
  Gs.prototype.forEach = function(t, e) {
    e = e || this;
    for (var s = this.head, i = 0; s !== null; i++)
      t.call(e, s.value, i, this), s = s.next;
  };
  Gs.prototype.forEachReverse = function(t, e) {
    e = e || this;
    for (var s = this.tail, i = this.length - 1; s !== null; i--)
      t.call(e, s.value, i, this), s = s.prev;
  };
  Gs.prototype.get = function(t) {
    for (var e = 0, s = this.head; s !== null && e < t; e++)
      s = s.next;
    if (e === t && s !== null)
      return s.value;
  };
  Gs.prototype.getReverse = function(t) {
    for (var e = 0, s = this.tail; s !== null && e < t; e++)
      s = s.prev;
    if (e === t && s !== null)
      return s.value;
  };
  Gs.prototype.map = function(t, e) {
    e = e || this;
    for (var s = new Gs(), i = this.head; i !== null; )
      s.push(t.call(e, i.value, this)), i = i.next;
    return s;
  };
  Gs.prototype.mapReverse = function(t, e) {
    e = e || this;
    for (var s = new Gs(), i = this.tail; i !== null; )
      s.push(t.call(e, i.value, this)), i = i.prev;
    return s;
  };
  Gs.prototype.reduce = function(t, e) {
    var s, i = this.head;
    if (arguments.length > 1)
      s = e;
    else if (this.head)
      i = this.head.next, s = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var r = 0; i !== null; r++)
      s = t(s, i.value, r), i = i.next;
    return s;
  };
  Gs.prototype.reduceReverse = function(t, e) {
    var s, i = this.tail;
    if (arguments.length > 1)
      s = e;
    else if (this.tail)
      i = this.tail.prev, s = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var r = this.length - 1; i !== null; r--)
      s = t(s, i.value, r), i = i.prev;
    return s;
  };
  Gs.prototype.toArray = function() {
    for (var t = new Array(this.length), e = 0, s = this.head; s !== null; e++)
      t[e] = s.value, s = s.next;
    return t;
  };
  Gs.prototype.toArrayReverse = function() {
    for (var t = new Array(this.length), e = 0, s = this.tail; s !== null; e++)
      t[e] = s.value, s = s.prev;
    return t;
  };
  Gs.prototype.slice = function(t, e) {
    e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
    var s = new Gs();
    if (e < t || e < 0)
      return s;
    t < 0 && (t = 0), e > this.length && (e = this.length);
    for (var i = 0, r = this.head; r !== null && i < t; i++)
      r = r.next;
    for (; r !== null && i < e; i++, r = r.next)
      s.push(r.value);
    return s;
  };
  Gs.prototype.sliceReverse = function(t, e) {
    e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
    var s = new Gs();
    if (e < t || e < 0)
      return s;
    t < 0 && (t = 0), e > this.length && (e = this.length);
    for (var i = this.length, r = this.tail; r !== null && i > e; i--)
      r = r.prev;
    for (; r !== null && i > t; i--, r = r.prev)
      s.push(r.value);
    return s;
  };
  Gs.prototype.splice = function(t, e) {
    t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
    for (var s = 0, i = this.head; i !== null && s < t; s++)
      i = i.next;
    for (var r = [], s = 0; i && s < e; s++)
      r.push(i.value), i = this.removeNode(i);
    i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
    for (var s = 2; s < arguments.length; s++)
      i = Ept(this, i, arguments[s]);
    return r;
  };
  Gs.prototype.reverse = function() {
    for (var t = this.head, e = this.tail, s = t; s !== null; s = s.prev) {
      var i = s.prev;
      s.prev = s.next, s.next = i;
    }
    return this.head = e, this.tail = t, this;
  };
  function Ept(t, e, s) {
    var i = e === t.head ? new Uh(s, null, e, t) : new Uh(s, e, e.next, t);
    return i.next === null && (t.tail = i), i.prev === null && (t.head = i), t.length++, i;
  }
  n(Ept, "insert");
  function Apt(t, e) {
    t.tail = new Uh(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++;
  }
  n(Apt, "push");
  function vpt(t, e) {
    t.head = new Uh(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++;
  }
  n(vpt, "unshift");
  function Uh(t, e, s, i) {
    if (!(this instanceof Uh))
      return new Uh(t, e, s, i);
    this.list = i, this.value = t, e ? (e.next = this, this.prev = e) : this.prev = null, s ? (s.prev = this, this.next = s) : this.next = null;
  }
  n(Uh, "Node");
  try {
    eZ()(Gs);
  } catch {
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var oZ = g((hWs, aZ) => {
  "use strict";
  var Cpt = sZ(), Kh = Symbol("max"), Iu = Symbol("length"), om = Symbol("lengthCalculator"), mT = Symbol("allowStale"), Vh = Symbol("maxAge"),
  wu = Symbol("dispose"), iZ = Symbol("noDisposeOnSet"), jr = Symbol("lruList"), No = Symbol("cache"), nZ = Symbol("updateAgeOnGet"), j_ = /* @__PURE__ */ n(
  () => 1, "naiveLength"), q_ = class {
    static {
      n(this, "LRUCache");
    }
    constructor(e) {
      if (typeof e == "number" && (e = { max: e }), e || (e = {}), e.max && (typeof e.max != "number" || e.max < 0))
        throw new TypeError("max must be a non-negative number");
      let s = this[Kh] = e.max || 1 / 0, i = e.length || j_;
      if (this[om] = typeof i != "function" ? j_ : i, this[mT] = e.stale || !1, e.maxAge && typeof e.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[Vh] = e.maxAge || 0, this[wu] = e.dispose, this[iZ] = e.noDisposeOnSet || !1, this[nZ] = e.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(e) {
      if (typeof e != "number" || e < 0)
        throw new TypeError("max must be a non-negative number");
      this[Kh] = e || 1 / 0, dT(this);
    }
    get max() {
      return this[Kh];
    }
    set allowStale(e) {
      this[mT] = !!e;
    }
    get allowStale() {
      return this[mT];
    }
    set maxAge(e) {
      if (typeof e != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[Vh] = e, dT(this);
    }
    get maxAge() {
      return this[Vh];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(e) {
      typeof e != "function" && (e = j_), e !== this[om] && (this[om] = e, this[Iu] = 0, this[jr].forEach((s) => {
        s.length = this[om](s.value, s.key), this[Iu] += s.length;
      })), dT(this);
    }
    get lengthCalculator() {
      return this[om];
    }
    get length() {
      return this[Iu];
    }
    get itemCount() {
      return this[jr].length;
    }
    rforEach(e, s) {
      s = s || this;
      for (let i = this[jr].tail; i !== null; ) {
        let r = i.prev;
        rZ(this, e, i, s), i = r;
      }
    }
    forEach(e, s) {
      s = s || this;
      for (let i = this[jr].head; i !== null; ) {
        let r = i.next;
        rZ(this, e, i, s), i = r;
      }
    }
    keys() {
      return this[jr].toArray().map((e) => e.key);
    }
    values() {
      return this[jr].toArray().map((e) => e.value);
    }
    reset() {
      this[wu] && this[jr] && this[jr].length && this[jr].forEach((e) => this[wu](e.key, e.value)), this[No] = /* @__PURE__ */ new Map(), this[jr] =
      new Cpt(), this[Iu] = 0;
    }
    dump() {
      return this[jr].map((e) => YP(this, e) ? !1 : {
        k: e.key,
        v: e.value,
        e: e.now + (e.maxAge || 0)
      }).toArray().filter((e) => e);
    }
    dumpLru() {
      return this[jr];
    }
    set(e, s, i) {
      if (i = i || this[Vh], i && typeof i != "number")
        throw new TypeError("maxAge must be a number");
      let r = i ? Date.now() : 0, a = this[om](s, e);
      if (this[No].has(e)) {
        if (a > this[Kh])
          return lm(this, this[No].get(e)), !1;
        let u = this[No].get(e).value;
        return this[wu] && (this[iZ] || this[wu](e, u.value)), u.now = r, u.maxAge = i, u.value = s, this[Iu] += a - u.length, u.length = a,
        this.get(e), dT(this), !0;
      }
      let o = new U_(e, s, a, r, i);
      return o.length > this[Kh] ? (this[wu] && this[wu](e, s), !1) : (this[Iu] += o.length, this[jr].unshift(o), this[No].set(e, this[jr].head),
      dT(this), !0);
    }
    has(e) {
      if (!this[No].has(e)) return !1;
      let s = this[No].get(e).value;
      return !YP(this, s);
    }
    get(e) {
      return R_(this, e, !0);
    }
    peek(e) {
      return R_(this, e, !1);
    }
    pop() {
      let e = this[jr].tail;
      return e ? (lm(this, e), e.value) : null;
    }
    del(e) {
      lm(this, this[No].get(e));
    }
    load(e) {
      this.reset();
      let s = Date.now();
      for (let i = e.length - 1; i >= 0; i--) {
        let r = e[i], a = r.e || 0;
        if (a === 0)
          this.set(r.k, r.v);
        else {
          let o = a - s;
          o > 0 && this.set(r.k, r.v, o);
        }
      }
    }
    prune() {
      this[No].forEach((e, s) => R_(this, s, !1));
    }
  }, R_ = /* @__PURE__ */ n((t, e, s) => {
    let i = t[No].get(e);
    if (i) {
      let r = i.value;
      if (YP(t, r)) {
        if (lm(t, i), !t[mT])
          return;
      } else
        s && (t[nZ] && (i.value.now = Date.now()), t[jr].unshiftNode(i));
      return r.value;
    }
  }, "get"), YP = /* @__PURE__ */ n((t, e) => {
    if (!e || !e.maxAge && !t[Vh])
      return !1;
    let s = Date.now() - e.now;
    return e.maxAge ? s > e.maxAge : t[Vh] && s > t[Vh];
  }, "isStale"), dT = /* @__PURE__ */ n((t) => {
    if (t[Iu] > t[Kh])
      for (let e = t[jr].tail; t[Iu] > t[Kh] && e !== null; ) {
        let s = e.prev;
        lm(t, e), e = s;
      }
  }, "trim"), lm = /* @__PURE__ */ n((t, e) => {
    if (e) {
      let s = e.value;
      t[wu] && t[wu](s.key, s.value), t[Iu] -= s.length, t[No].delete(s.key), t[jr].removeNode(e);
    }
  }, "del"), U_ = class {
    static {
      n(this, "Entry");
    }
    constructor(e, s, i, r, a) {
      this.key = e, this.value = s, this.length = i, this.now = r, this.maxAge = a || 0;
    }
  }, rZ = /* @__PURE__ */ n((t, e, s, i) => {
    let r = s.value;
    YP(t, r) && (lm(t, s), t[mT] || (r = void 0)), r && e.call(i, r.value, r.key, t);
  }, "forEachStep");
  aZ.exports = q_;
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var XP = g((um) => {
  "use strict";
  Object.defineProperty(um, "__esModule", {
    value: !0
  });
  um.unreleasedLabels = um.browserNameMap = void 0;
  var dWs = um.unreleasedLabels = {
    safari: "tp"
  }, mWs = um.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var zP = g((np) => {
  "use strict";
  Object.defineProperty(np, "__esModule", {
    value: !0
  });
  np.getHighestUnreleased = Opt;
  np.getLowestImplementedVersion = _pt;
  np.getLowestUnreleased = pZ;
  np.isUnreleasedVersion = Dpt;
  np.semverMin = cZ;
  np.semverify = kpt;
  var lZ = require("semver"), wpt = JP(), uZ = XP(), Ipt = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/,
  Npt = new wpt.OptionValidator("@babel/helper-compilation-targets");
  function cZ(t, e) {
    return t && lZ.lt(t, e) ? t : e;
  }
  n(cZ, "semverMin");
  function kpt(t) {
    if (typeof t == "string" && lZ.valid(t))
      return t;
    Npt.invariant(typeof t == "number" || typeof t == "string" && Ipt.test(t), `'${t}' is not a valid version`), t = t.toString();
    let e = 0, s = 0;
    for (; (e = t.indexOf(".", e + 1)) > 0; )
      s++;
    return t + ".0".repeat(2 - s);
  }
  n(kpt, "semverify");
  function Dpt(t, e) {
    let s = uZ.unreleasedLabels[e];
    return !!s && s === t.toString().toLowerCase();
  }
  n(Dpt, "isUnreleasedVersion");
  function pZ(t, e, s) {
    let i = uZ.unreleasedLabels[s];
    return t === i ? e : e === i ? t : cZ(t, e);
  }
  n(pZ, "getLowestUnreleased");
  function Opt(t, e, s) {
    return pZ(t, e, s) === t ? e : t;
  }
  n(Opt, "getHighestUnreleased");
  function _pt(t, e) {
    let s = t[e];
    return !s && e === "android" ? t.chrome : s;
  }
  n(_pt, "getLowestImplementedVersion");
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var hZ = g((GP) => {
  "use strict";
  Object.defineProperty(GP, "__esModule", {
    value: !0
  });
  GP.TargetNames = void 0;
  var bWs = GP.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var K_ = g((QP) => {
  "use strict";
  Object.defineProperty(QP, "__esModule", {
    value: !0
  });
  QP.prettifyTargets = Mpt;
  QP.prettifyVersion = fZ;
  var Lpt = require("semver"), Bpt = XP();
  function fZ(t) {
    if (typeof t != "string")
      return t;
    let {
      major: e,
      minor: s,
      patch: i
    } = Lpt.parse(t), r = [e];
    return (s || i) && r.push(s), i && r.push(i), r.join(".");
  }
  n(fZ, "prettifyVersion");
  function Mpt(t) {
    return Object.keys(t).reduce((e, s) => {
      let i = t[s], r = Bpt.unreleasedLabels[s];
      return typeof i == "string" && r !== i && (i = fZ(i)), e[s] = i, e;
    }, {});
  }
  n(Mpt, "prettifyTargets");
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var mZ = g((V_) => {
  "use strict";
  Object.defineProperty(V_, "__esModule", {
    value: !0
  });
  V_.getInclusionReasons = jpt;
  var Fpt = require("semver"), dZ = K_(), ZP = zP();
  function jpt(t, e, s) {
    let i = s[t] || {};
    return Object.keys(e).reduce((r, a) => {
      let o = (0, ZP.getLowestImplementedVersion)(i, a), l = e[a];
      if (!o)
        r[a] = (0, dZ.prettifyVersion)(l);
      else {
        let u = (0, ZP.isUnreleasedVersion)(o, a);
        !(0, ZP.isUnreleasedVersion)(l, a) && (u || Fpt.lt(l.toString(), (0, ZP.semverify)(o))) && (r[a] = (0, dZ.prettifyVersion)(l));
      }
      return r;
    }, {});
  }
  n(jpt, "getInclusionReasons");
});

// ../node_modules/@babel/compat-data/data/plugins.json
var yZ = g((vWs, Rpt) => {
  Rpt.exports = {
    "transform-duplicate-named-capturing-groups-regex": {
      chrome: "126",
      opera: "112",
      edge: "126",
      firefox: "129",
      safari: "17.4",
      node: "23",
      ios: "17.4",
      electron: "31.0"
    },
    "transform-regexp-modifiers": {
      chrome: "125",
      opera: "111",
      edge: "125",
      firefox: "132",
      node: "23",
      electron: "31.0"
    },
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "17",
      node: "20",
      deno: "1.32",
      ios: "17",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "75",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "bugfix/transform-firefox-class-in-computed-class-key": {
      chrome: "74",
      opera: "62",
      edge: "79",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "bugfix/transform-safari-class-field-initializer-scope": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "69",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "53",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      rhino: "1.7.15",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.15",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "48",
      opera: "35",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "6",
      deno: "1",
      ios: "9",
      samsung: "5",
      opera_mobile: "35",
      electron: "0.37"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// ../node_modules/@babel/compat-data/plugins.js
var TZ = g((CWs, gZ) => {
  gZ.exports = yZ();
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var PZ = g((yT) => {
  "use strict";
  Object.defineProperty(yT, "__esModule", {
    value: !0
  });
  yT.default = Upt;
  yT.isRequired = SZ;
  yT.targetsSupported = xZ;
  var bZ = require("semver"), qpt = TZ(), eE = zP();
  function xZ(t, e) {
    let s = Object.keys(t);
    return s.length === 0 ? !1 : s.filter((r) => {
      let a = (0, eE.getLowestImplementedVersion)(e, r);
      if (!a)
        return !0;
      let o = t[r];
      if ((0, eE.isUnreleasedVersion)(o, r))
        return !1;
      if ((0, eE.isUnreleasedVersion)(a, r))
        return !0;
      if (!bZ.valid(o.toString()))
        throw new Error(`Invalid version passed for target "${r}": "${o}". Versions must be in semver format (major.minor.patch)`);
      return bZ.gt((0, eE.semverify)(a), o.toString());
    }).length === 0;
  }
  n(xZ, "targetsSupported");
  function SZ(t, e, {
    compatData: s = qpt,
    includes: i,
    excludes: r
  } = {}) {
    return r != null && r.has(t) ? !1 : i != null && i.has(t) ? !0 : !xZ(e, s[t]);
  }
  n(SZ, "isRequired");
  function Upt(t, e, s, i, r, a, o) {
    let l = /* @__PURE__ */ new Set(), u = {
      compatData: t,
      includes: e,
      excludes: s
    };
    for (let c in t)
      if (SZ(c, i, u))
        l.add(c);
      else if (o) {
        let p = o.get(c);
        p && l.add(p);
      }
    return r?.forEach((c) => !s.has(c) && l.add(c)), a?.forEach((c) => !e.has(c) && l.delete(c)), l;
  }
  n(Upt, "filterItems");
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var Y_ = g((fl) => {
  "use strict";
  Object.defineProperty(fl, "__esModule", {
    value: !0
  });
  Object.defineProperty(fl, "TargetNames", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return H_.TargetNames;
    }, "get")
  });
  fl.default = tht;
  Object.defineProperty(fl, "filterItems", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return CZ.default;
    }, "get")
  });
  Object.defineProperty(fl, "getInclusionReasons", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $pt.getInclusionReasons;
    }, "get")
  });
  fl.isBrowsersQueryValid = wZ;
  Object.defineProperty(fl, "isRequired", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return CZ.isRequired;
    }, "get")
  });
  Object.defineProperty(fl, "prettifyTargets", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wpt.prettifyTargets;
    }, "get")
  });
  Object.defineProperty(fl, "unreleasedLabels", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vZ.unreleasedLabels;
    }, "get")
  });
  var $_ = JQ(), AZ = JP(), Kpt = QQ(), Vpt = oZ(), ko = zP(), vZ = XP(), H_ = hZ(), Wpt = K_(), $pt = mZ(), CZ = PZ(), W_ = Kpt["es6.module"],
  J_ = new AZ.OptionValidator("@babel/helper-compilation-targets");
  function Hpt(t) {
    let e = Object.keys(H_.TargetNames);
    for (let s of Object.keys(t))
      if (!(s in H_.TargetNames))
        throw new Error(J_.formatMessage(`'${s}' is not a valid target
- Did you mean '${(0, AZ.findSuggestion)(s, e)}'?`));
    return t;
  }
  n(Hpt, "validateTargetNames");
  function wZ(t) {
    return typeof t == "string" || Array.isArray(t) && t.every((e) => typeof e == "string");
  }
  n(wZ, "isBrowsersQueryValid");
  function Jpt(t) {
    return J_.invariant(t === void 0 || wZ(t), `'${String(t)}' is not a valid browserslist query`), t;
  }
  n(Jpt, "validateBrowsers");
  function Ypt(t) {
    return t.reduce((e, s) => {
      let [i, r] = s.split(" "), a = vZ.browserNameMap[i];
      if (!a)
        return e;
      try {
        let o = r.split("-")[0].toLowerCase(), l = (0, ko.isUnreleasedVersion)(o, a);
        if (!e[a])
          return e[a] = l ? o : (0, ko.semverify)(o), e;
        let u = e[a], c = (0, ko.isUnreleasedVersion)(u, a);
        if (c && l)
          e[a] = (0, ko.getLowestUnreleased)(u, o, a);
        else if (c)
          e[a] = (0, ko.semverify)(o);
        else if (!c && !l) {
          let p = (0, ko.semverify)(o);
          e[a] = (0, ko.semverMin)(u, p);
        }
      } catch {
      }
      return e;
    }, {});
  }
  n(Ypt, "getLowestVersions");
  function Xpt(t) {
    t.length && (console.warn(`Warning, the following targets are using a decimal version:
`), t.forEach(({
      target: e,
      value: s
    }) => console.warn(`  ${e}: ${s}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
  }
  n(Xpt, "outputDecimalWarning");
  function IZ(t, e) {
    try {
      return (0, ko.semverify)(e);
    } catch {
      throw new Error(J_.formatMessage(`'${e}' is not a valid value for 'targets.${t}'.`));
    }
  }
  n(IZ, "semverifyTarget");
  function zpt(t) {
    return ["node", t === !0 || t === "current" ? process.versions.node.split("-")[0] : IZ("node", t)];
  }
  n(zpt, "nodeTargetParser");
  function Gpt(t, e) {
    let s = (0, ko.isUnreleasedVersion)(e, t) ? e.toLowerCase() : IZ(t, e);
    return [t, s];
  }
  n(Gpt, "defaultTargetParser");
  function Qpt(t) {
    let e = Object.assign({}, t);
    return delete e.esmodules, delete e.browsers, e;
  }
  n(Qpt, "generateTargets");
  function Zpt(t, e) {
    let s = $_(t, {
      mobileToDesktop: !0,
      env: e
    });
    return Ypt(s);
  }
  n(Zpt, "resolveTargets");
  var EZ = new Vpt({
    max: 64
  });
  function eht(t, e) {
    let s = typeof t == "string" ? t : t.join() + e, i = EZ.get(s);
    return i || (i = Zpt(t, e), EZ.set(s, i)), Object.assign({}, i);
  }
  n(eht, "resolveTargetsCached");
  function tht(t = {}, e = {}) {
    var s, i;
    let {
      browsers: r,
      esmodules: a
    } = t, {
      configPath: o = ".",
      onBrowserslistConfigFound: l
    } = e;
    Jpt(r);
    let u = Qpt(t), c = Hpt(u), h = !!r || Object.keys(c).length > 0, f = !e.ignoreBrowserslistConfig && !h;
    if (!r && f) {
      if (r = process.env.BROWSERSLIST, !r) {
        let m = e.configFile || process.env.BROWSERSLIST_CONFIG || $_.findConfigFile(o);
        m != null && (l?.(m), r = $_.loadConfig({
          config: m,
          env: e.browserslistEnv
        }));
      }
      r == null && (r = []);
    }
    if (a && (a !== "intersect" || !((s = r) != null && s.length)) && (r = Object.keys(W_).map((m) => `${m} >= ${W_[m]}`).join(", "), a = !1),
    (i = r) != null && i.length) {
      let m = eht(r, e.browserslistEnv);
      if (a === "intersect")
        for (let T of Object.keys(m))
          if (T !== "deno" && T !== "ie") {
            let b = W_[T === "opera_mobile" ? "op_mob" : T];
            if (b) {
              let E = m[T];
              m[T] = (0, ko.getHighestUnreleased)(E, (0, ko.semverify)(b), T);
            } else
              delete m[T];
          } else
            delete m[T];
      c = Object.assign(m, c);
    }
    let d = {}, y = [];
    for (let m of Object.keys(c).sort()) {
      let T = c[m];
      typeof T == "number" && T % 1 !== 0 && y.push({
        target: m,
        value: T
      });
      let [b, E] = m === "node" ? zpt(T) : Gpt(m, T);
      E && (d[b] = E);
    }
    return Xpt(y), d;
  }
  n(tht, "getTargets");
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var X_ = g((tE) => {
  "use strict";
  Object.defineProperty(tE, "__esModule", {
    value: !0
  });
  tE.resolveBrowserslistConfigFile = sht;
  tE.resolveTargets = iht;
  function NZ() {
    let t = require("path");
    return NZ = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(NZ, "_path");
  function kZ() {
    let t = Y_();
    return kZ = /* @__PURE__ */ n(function() {
      return t;
    }, "_helperCompilationTargets"), t;
  }
  n(kZ, "_helperCompilationTargets");
  function sht(t, e) {
    return NZ().resolve(e, t);
  }
  n(sht, "resolveBrowserslistConfigFile");
  function iht(t, e) {
    let s = t.targets, i;
    typeof s == "string" || Array.isArray(s) ? i = {
      browsers: s
    } : s && ("esmodules" in s ? i = Object.assign({}, s, {
      esmodules: "intersect"
    }) : i = s);
    let {
      browserslistConfigFile: r
    } = t, a, o = !1;
    return typeof r == "string" ? a = r : o = r === !1, (0, kZ().default)(i, {
      ignoreBrowserslistConfig: o,
      configFile: a,
      configPath: e,
      browserslistEnv: t.browserslistEnv
    });
  }
  n(iht, "resolveTargets");
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var z_ = g((TT) => {
  "use strict";
  Object.defineProperty(TT, "__esModule", {
    value: !0
  });
  TT.createCachedDescriptors = oht;
  TT.createDescriptor = qZ;
  TT.createUncachedDescriptors = lht;
  function LZ() {
    let t = ha();
    return LZ = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(LZ, "_gensync");
  var DZ = VG(), OZ = xT(), rht = bT(), gT = Fh(), nht = X_();
  function aht(t, e) {
    var s, i, r, a;
    return t.name === e.name && t.value === e.value && t.options === e.options && t.dirname === e.dirname && t.alias === e.alias && t.ownPass ===
    e.ownPass && ((s = t.file) == null ? void 0 : s.request) === ((i = e.file) == null ? void 0 : i.request) && ((r = t.file) == null ? void 0 :
    r.resolved) === ((a = e.file) == null ? void 0 : a.resolved);
  }
  n(aht, "isEqualDescriptor");
  function* _Z(t) {
    return t;
  }
  n(_Z, "handlerOf");
  function BZ(t, e) {
    return typeof t.browserslistConfigFile == "string" && (t.browserslistConfigFile = (0, nht.resolveBrowserslistConfigFile)(t.browserslistConfigFile,
    e)), t;
  }
  n(BZ, "optionsWithResolvedBrowserslistConfigFile");
  function oht(t, e, s) {
    let {
      plugins: i,
      presets: r,
      passPerPreset: a
    } = e;
    return {
      options: BZ(e, t),
      plugins: i ? () => hht(i, t)(s) : () => _Z([]),
      presets: r ? () => cht(r, t)(s)(!!a) : () => _Z([])
    };
  }
  n(oht, "createCachedDescriptors");
  function lht(t, e, s) {
    return {
      options: BZ(e, t),
      plugins: (0, DZ.once)(() => jZ(e.plugins || [], t, s)),
      presets: (0, DZ.once)(() => FZ(e.presets || [], t, s, !!e.passPerPreset))
    };
  }
  n(lht, "createUncachedDescriptors");
  var uht = /* @__PURE__ */ new WeakMap(), cht = (0, gT.makeWeakCacheSync)((t, e) => {
    let s = e.using((i) => i);
    return (0, gT.makeStrongCacheSync)((i) => (0, gT.makeStrongCache)(function* (r) {
      return (yield* FZ(t, s, i, r)).map((o) => MZ(uht, o));
    }));
  }), pht = /* @__PURE__ */ new WeakMap(), hht = (0, gT.makeWeakCacheSync)((t, e) => {
    let s = e.using((i) => i);
    return (0, gT.makeStrongCache)(function* (i) {
      return (yield* jZ(t, s, i)).map((a) => MZ(pht, a));
    });
  }), fht = {};
  function MZ(t, e) {
    let {
      value: s,
      options: i = fht
    } = e;
    if (i === !1) return e;
    let r = t.get(s);
    r || (r = /* @__PURE__ */ new WeakMap(), t.set(s, r));
    let a = r.get(i);
    if (a || (a = [], r.set(i, a)), !a.includes(e)) {
      let o = a.filter((l) => aht(l, e));
      if (o.length > 0)
        return o[0];
      a.push(e);
    }
    return e;
  }
  n(MZ, "loadCachedDescriptor");
  function* FZ(t, e, s, i) {
    return yield* RZ("preset", t, e, s, i);
  }
  n(FZ, "createPresetDescriptors");
  function* jZ(t, e, s) {
    return yield* RZ("plugin", t, e, s);
  }
  n(jZ, "createPluginDescriptors");
  function* RZ(t, e, s, i, r) {
    let a = yield* LZ().all(e.map((o, l) => qZ(o, s, {
      type: t,
      alias: `${i}$${l}`,
      ownPass: !!r
    })));
    return dht(a), a;
  }
  n(RZ, "createDescriptors");
  function* qZ(t, e, {
    type: s,
    alias: i,
    ownPass: r
  }) {
    let a = (0, rht.getItemDescriptor)(t);
    if (a)
      return a;
    let o, l, u = t;
    Array.isArray(u) && (u.length === 3 ? [u, l, o] = u : [u, l] = u);
    let c, p = null;
    if (typeof u == "string") {
      if (typeof s != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      let h = s === "plugin" ? OZ.loadPlugin : OZ.loadPreset, f = u;
      ({
        filepath: p,
        value: u
      } = yield* h(u, e)), c = {
        request: f,
        resolved: p
      };
    }
    if (!u)
      throw new Error(`Unexpected falsy value: ${String(u)}`);
    if (typeof u == "object" && u.__esModule)
      if (u.default)
        u = u.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof u != "object" && typeof u != "function")
      throw new Error(`Unsupported format: ${typeof u}. Expected an object or a function.`);
    if (p !== null && typeof u == "object" && u)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${p}`);
    return {
      name: o,
      alias: p || i,
      value: u,
      options: l,
      dirname: e,
      ownPass: r,
      file: c
    };
  }
  n(qZ, "createDescriptor");
  function dht(t) {
    let e = /* @__PURE__ */ new Map();
    for (let s of t) {
      if (typeof s.value != "function") continue;
      let i = e.get(s.value);
      if (i || (i = /* @__PURE__ */ new Set(), e.set(s.value, i)), i.has(s.name)) {
        let r = t.filter((a) => a.value === s.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separat\
e names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detec\
ted are:", `${JSON.stringify(r, null, 2)}`].join(`
`));
      }
      i.add(s.name);
    }
  }
  n(dht, "assertNoDuplicates");
});

// ../node_modules/@babel/core/lib/config/item.js
var bT = g((ST) => {
  "use strict";
  Object.defineProperty(ST, "__esModule", {
    value: !0
  });
  ST.createConfigItem = yht;
  ST.createItemFromDescriptor = KZ;
  ST.getItemDescriptor = ght;
  function UZ() {
    let t = require("path");
    return UZ = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(UZ, "_path");
  var mht = z_();
  function KZ(t) {
    return new sE(t);
  }
  n(KZ, "createItemFromDescriptor");
  function* yht(t, {
    dirname: e = ".",
    type: s
  } = {}) {
    let i = yield* (0, mht.createDescriptor)(t, UZ().resolve(e), {
      type: s,
      alias: "programmatic item"
    });
    return KZ(i);
  }
  n(yht, "createConfigItem");
  var G_ = Symbol.for("@babel/core@7 - ConfigItem");
  function ght(t) {
    if (t != null && t[G_])
      return t._descriptor;
  }
  n(ght, "getItemDescriptor");
  var sE = class {
    static {
      n(this, "ConfigItem");
    }
    constructor(e) {
      this._descriptor = void 0, this[G_] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.
      file = void 0, this._descriptor = e, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, G_, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name =
      this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  };
  Object.freeze(sE.prototype);
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var VZ = g((iE) => {
  "use strict";
  Object.defineProperty(iE, "__esModule", {
    value: !0
  });
  iE.default = void 0;
  var FWs = iE.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.i\
o/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file\
` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.fi\
le` themselves."
    }
  };
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var eL = g((or) => {
  "use strict";
  Object.defineProperty(or, "__esModule", {
    value: !0
  });
  or.access = fa;
  or.assertArray = Z_;
  or.assertAssumptions = Mht;
  or.assertBabelrcSearch = Dht;
  or.assertBoolean = Q_;
  or.assertCallerMetadata = Eht;
  or.assertCompact = Sht;
  or.assertConfigApplicableTest = Nht;
  or.assertConfigFileSearch = kht;
  or.assertFunction = Cht;
  or.assertIgnoreList = wht;
  or.assertInputSourceMap = Aht;
  or.assertObject = HZ;
  or.assertPluginList = Oht;
  or.assertRootMode = bht;
  or.assertSourceMaps = xht;
  or.assertSourceType = Pht;
  or.assertString = vht;
  or.assertTargets = Lht;
  or.msg = Es;
  function PT() {
    let t = Y_();
    return PT = /* @__PURE__ */ n(function() {
      return t;
    }, "_helperCompilationTargets"), t;
  }
  n(PT, "_helperCompilationTargets");
  var Tht = ET();
  function Es(t) {
    switch (t.type) {
      case "root":
        return "";
      case "env":
        return `${Es(t.parent)}.env["${t.name}"]`;
      case "overrides":
        return `${Es(t.parent)}.overrides[${t.index}]`;
      case "option":
        return `${Es(t.parent)}.${t.name}`;
      case "access":
        return `${Es(t.parent)}[${JSON.stringify(t.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${t.type}`);
    }
  }
  n(Es, "msg");
  function fa(t, e) {
    return {
      type: "access",
      name: e,
      parent: t
    };
  }
  n(fa, "access");
  function bht(t, e) {
    if (e !== void 0 && e !== "root" && e !== "upward" && e !== "upward-optional")
      throw new Error(`${Es(t)} must be a "root", "upward", "upward-optional" or undefined`);
    return e;
  }
  n(bht, "assertRootMode");
  function xht(t, e) {
    if (e !== void 0 && typeof e != "boolean" && e !== "inline" && e !== "both")
      throw new Error(`${Es(t)} must be a boolean, "inline", "both", or undefined`);
    return e;
  }
  n(xht, "assertSourceMaps");
  function Sht(t, e) {
    if (e !== void 0 && typeof e != "boolean" && e !== "auto")
      throw new Error(`${Es(t)} must be a boolean, "auto", or undefined`);
    return e;
  }
  n(Sht, "assertCompact");
  function Pht(t, e) {
    if (e !== void 0 && e !== "module" && e !== "script" && e !== "unambiguous")
      throw new Error(`${Es(t)} must be "module", "script", "unambiguous", or undefined`);
    return e;
  }
  n(Pht, "assertSourceType");
  function Eht(t, e) {
    let s = HZ(t, e);
    if (s) {
      if (typeof s.name != "string")
        throw new Error(`${Es(t)} set but does not contain "name" property string`);
      for (let i of Object.keys(s)) {
        let r = fa(t, i), a = s[i];
        if (a != null && typeof a != "boolean" && typeof a != "string" && typeof a != "number")
          throw new Error(`${Es(r)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return e;
  }
  n(Eht, "assertCallerMetadata");
  function Aht(t, e) {
    if (e !== void 0 && typeof e != "boolean" && (typeof e != "object" || !e))
      throw new Error(`${Es(t)} must be a boolean, object, or undefined`);
    return e;
  }
  n(Aht, "assertInputSourceMap");
  function vht(t, e) {
    if (e !== void 0 && typeof e != "string")
      throw new Error(`${Es(t)} must be a string, or undefined`);
    return e;
  }
  n(vht, "assertString");
  function Cht(t, e) {
    if (e !== void 0 && typeof e != "function")
      throw new Error(`${Es(t)} must be a function, or undefined`);
    return e;
  }
  n(Cht, "assertFunction");
  function Q_(t, e) {
    if (e !== void 0 && typeof e != "boolean")
      throw new Error(`${Es(t)} must be a boolean, or undefined`);
    return e;
  }
  n(Q_, "assertBoolean");
  function HZ(t, e) {
    if (e !== void 0 && (typeof e != "object" || Array.isArray(e) || !e))
      throw new Error(`${Es(t)} must be an object, or undefined`);
    return e;
  }
  n(HZ, "assertObject");
  function Z_(t, e) {
    if (e != null && !Array.isArray(e))
      throw new Error(`${Es(t)} must be an array, or undefined`);
    return e;
  }
  n(Z_, "assertArray");
  function wht(t, e) {
    let s = Z_(t, e);
    return s?.forEach((i, r) => Iht(fa(t, r), i)), s;
  }
  n(wht, "assertIgnoreList");
  function Iht(t, e) {
    if (typeof e != "string" && typeof e != "function" && !(e instanceof RegExp))
      throw new Error(`${Es(t)} must be an array of string/Function/RegExp values, or undefined`);
    return e;
  }
  n(Iht, "assertIgnoreItem");
  function Nht(t, e) {
    if (e === void 0)
      return e;
    if (Array.isArray(e))
      e.forEach((s, i) => {
        if (!rE(s))
          throw new Error(`${Es(fa(t, i))} must be a string/Function/RegExp.`);
      });
    else if (!rE(e))
      throw new Error(`${Es(t)} must be a string/Function/RegExp, or an array of those`);
    return e;
  }
  n(Nht, "assertConfigApplicableTest");
  function rE(t) {
    return typeof t == "string" || typeof t == "function" || t instanceof RegExp;
  }
  n(rE, "checkValidTest");
  function kht(t, e) {
    if (e !== void 0 && typeof e != "boolean" && typeof e != "string")
      throw new Error(`${Es(t)} must be a undefined, a boolean, a string, got ${JSON.stringify(e)}`);
    return e;
  }
  n(kht, "assertConfigFileSearch");
  function Dht(t, e) {
    if (e === void 0 || typeof e == "boolean")
      return e;
    if (Array.isArray(e))
      e.forEach((s, i) => {
        if (!rE(s))
          throw new Error(`${Es(fa(t, i))} must be a string/Function/RegExp.`);
      });
    else if (!rE(e))
      throw new Error(`${Es(t)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(e)}`);
    return e;
  }
  n(Dht, "assertBabelrcSearch");
  function Oht(t, e) {
    let s = Z_(t, e);
    return s && s.forEach((i, r) => _ht(fa(t, r), i)), s;
  }
  n(Oht, "assertPluginList");
  function _ht(t, e) {
    if (Array.isArray(e)) {
      if (e.length === 0)
        throw new Error(`${Es(t)} must include an object`);
      if (e.length > 3)
        throw new Error(`${Es(t)} may only be a two-tuple or three-tuple`);
      if (WZ(fa(t, 0), e[0]), e.length > 1) {
        let s = e[1];
        if (s !== void 0 && s !== !1 && (typeof s != "object" || Array.isArray(s) || s === null))
          throw new Error(`${Es(fa(t, 1))} must be an object, false, or undefined`);
      }
      if (e.length === 3) {
        let s = e[2];
        if (s !== void 0 && typeof s != "string")
          throw new Error(`${Es(fa(t, 2))} must be a string, or undefined`);
      }
    } else
      WZ(t, e);
    return e;
  }
  n(_ht, "assertPluginItem");
  function WZ(t, e) {
    if ((typeof e != "object" || !e) && typeof e != "string" && typeof e != "function")
      throw new Error(`${Es(t)} must be a string, object, function`);
    return e;
  }
  n(WZ, "assertPluginTarget");
  function Lht(t, e) {
    if ((0, PT().isBrowsersQueryValid)(e)) return e;
    if (typeof e != "object" || !e || Array.isArray(e))
      throw new Error(`${Es(t)} must be a string, an array of strings or an object`);
    let s = fa(t, "browsers"), i = fa(t, "esmodules");
    $Z(s, e.browsers), Q_(i, e.esmodules);
    for (let r of Object.keys(e)) {
      let a = e[r], o = fa(t, r);
      if (r === "esmodules") Q_(o, a);
      else if (r === "browsers") $Z(o, a);
      else if (hasOwnProperty.call(PT().TargetNames, r))
        Bht(o, a);
      else {
        let l = Object.keys(PT().TargetNames).join(", ");
        throw new Error(`${Es(o)} is not a valid target. Supported targets are ${l}`);
      }
    }
    return e;
  }
  n(Lht, "assertTargets");
  function $Z(t, e) {
    if (e !== void 0 && !(0, PT().isBrowsersQueryValid)(e))
      throw new Error(`${Es(t)} must be undefined, a string or an array of strings`);
  }
  n($Z, "assertBrowsersList");
  function Bht(t, e) {
    if (!(typeof e == "number" && Math.round(e) === e) && typeof e != "string")
      throw new Error(`${Es(t)} must be a string or an integer number`);
  }
  n(Bht, "assertBrowserVersion");
  function Mht(t, e) {
    if (e === void 0) return;
    if (typeof e != "object" || e === null)
      throw new Error(`${Es(t)} must be an object or undefined.`);
    let s = t;
    do
      s = s.parent;
    while (s.type !== "root");
    let i = s.source === "preset";
    for (let r of Object.keys(e)) {
      let a = fa(t, r);
      if (!Tht.assumptionsNames.has(r))
        throw new Error(`${Es(a)} is not a supported assumption.`);
      if (typeof e[r] != "boolean")
        throw new Error(`${Es(a)} must be a boolean.`);
      if (i && e[r] === !1)
        throw new Error(`${Es(a)} cannot be set to 'false' inside presets.`);
    }
    return e;
  }
  n(Mht, "assertAssumptions");
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var ET = g((cm) => {
  "use strict";
  Object.defineProperty(cm, "__esModule", {
    value: !0
  });
  cm.assumptionsNames = void 0;
  cm.checkNoUnwrappedItemOptionPairs = Wht;
  cm.validate = Rht;
  var JZ = VZ(), dt = eL(), Fht = jh(), YZ = {
    cwd: dt.assertString,
    root: dt.assertString,
    rootMode: dt.assertRootMode,
    configFile: dt.assertConfigFileSearch,
    caller: dt.assertCallerMetadata,
    filename: dt.assertString,
    filenameRelative: dt.assertString,
    code: dt.assertBoolean,
    ast: dt.assertBoolean,
    cloneInputAst: dt.assertBoolean,
    envName: dt.assertString
  }, XZ = {
    babelrc: dt.assertBoolean,
    babelrcRoots: dt.assertBabelrcSearch
  }, zZ = {
    extends: dt.assertString,
    ignore: dt.assertIgnoreList,
    only: dt.assertIgnoreList,
    targets: dt.assertTargets,
    browserslistConfigFile: dt.assertConfigFileSearch,
    browserslistEnv: dt.assertString
  }, GZ = {
    inputSourceMap: dt.assertInputSourceMap,
    presets: dt.assertPluginList,
    plugins: dt.assertPluginList,
    passPerPreset: dt.assertBoolean,
    assumptions: dt.assertAssumptions,
    env: Kht,
    overrides: Vht,
    test: dt.assertConfigApplicableTest,
    include: dt.assertConfigApplicableTest,
    exclude: dt.assertConfigApplicableTest,
    retainLines: dt.assertBoolean,
    comments: dt.assertBoolean,
    shouldPrintComment: dt.assertFunction,
    compact: dt.assertCompact,
    minified: dt.assertBoolean,
    auxiliaryCommentBefore: dt.assertString,
    auxiliaryCommentAfter: dt.assertString,
    sourceType: dt.assertSourceType,
    wrapPluginVisitorMethod: dt.assertFunction,
    highlightCode: dt.assertBoolean,
    sourceMaps: dt.assertSourceMaps,
    sourceMap: dt.assertSourceMaps,
    sourceFileName: dt.assertString,
    sourceRoot: dt.assertString,
    parserOpts: dt.assertObject,
    generatorOpts: dt.assertObject
  };
  Object.assign(GZ, {
    getModuleId: dt.assertFunction,
    moduleRoot: dt.assertString,
    moduleIds: dt.assertBoolean,
    moduleId: dt.assertString
  });
  var jht = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitive\
Hint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUnini\
tializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods",
  "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], UWs = cm.
  assumptionsNames = new Set(jht);
  function QZ(t) {
    return t.type === "root" ? t.source : QZ(t.parent);
  }
  n(QZ, "getSource");
  function Rht(t, e, s) {
    try {
      return tL({
        type: "root",
        source: t
      }, e);
    } catch (i) {
      let r = new Fht.default(i.message, s);
      throw i.code && (r.code = i.code), r;
    }
  }
  n(Rht, "validate");
  function tL(t, e) {
    let s = QZ(t);
    return Uht(e), Object.keys(e).forEach((i) => {
      let r = {
        type: "option",
        name: i,
        parent: t
      };
      if (s === "preset" && zZ[i])
        throw new Error(`${(0, dt.msg)(r)} is not allowed in preset options`);
      if (s !== "arguments" && YZ[i])
        throw new Error(`${(0, dt.msg)(r)} is only allowed in root programmatic options`);
      if (s !== "arguments" && s !== "configfile" && XZ[i])
        throw s === "babelrcfile" || s === "extendsfile" ? new Error(`${(0, dt.msg)(r)} is not allowed in .babelrc or "extends"ed files, onl\
y in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, dt.msg)(r)} is only allowed in root programmatic\
 options, or babel.config.js/config file options`);
      (GZ[i] || zZ[i] || XZ[i] || YZ[i] || qht)(r, e[i]);
    }), e;
  }
  n(tL, "validateNested");
  function qht(t) {
    let e = t.name;
    if (JZ.default[e]) {
      let {
        message: s,
        version: i = 5
      } = JZ.default[e];
      throw new Error(`Using removed Babel ${i} option: ${(0, dt.msg)(t)} - ${s}`);
    } else {
      let s = new Error(`Unknown option: ${(0, dt.msg)(t)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information ab\
out options.`);
      throw s.code = "BABEL_UNKNOWN_OPTION", s;
    }
  }
  n(qht, "throwUnknownError");
  function Uht(t) {
    if (hasOwnProperty.call(t, "sourceMap") && hasOwnProperty.call(t, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  n(Uht, "assertNoDuplicateSourcemap");
  function Kht(t, e) {
    if (t.parent.type === "env")
      throw new Error(`${(0, dt.msg)(t)} is not allowed inside of another .env block`);
    let s = t.parent, i = (0, dt.assertObject)(t, e);
    if (i)
      for (let r of Object.keys(i)) {
        let a = (0, dt.assertObject)((0, dt.access)(t, r), i[r]);
        if (!a) continue;
        tL({
          type: "env",
          name: r,
          parent: s
        }, a);
      }
    return i;
  }
  n(Kht, "assertEnvSet");
  function Vht(t, e) {
    if (t.parent.type === "env")
      throw new Error(`${(0, dt.msg)(t)} is not allowed inside an .env block`);
    if (t.parent.type === "overrides")
      throw new Error(`${(0, dt.msg)(t)} is not allowed inside an .overrides block`);
    let s = t.parent, i = (0, dt.assertArray)(t, e);
    if (i)
      for (let [r, a] of i.entries()) {
        let o = (0, dt.access)(t, r), l = (0, dt.assertObject)(o, a);
        if (!l) throw new Error(`${(0, dt.msg)(o)} must be an object`);
        tL({
          type: "overrides",
          index: r,
          parent: s
        }, l);
      }
    return i;
  }
  n(Vht, "assertOverridesList");
  function Wht(t, e, s, i) {
    if (e === 0) return;
    let r = t[e - 1], a = t[e];
    r.file && r.options === void 0 && typeof a.value == "object" && (i.message += `
- Maybe you meant to use
"${s}s": [
  ["${r.file.request}", ${JSON.stringify(a.value, void 0, 2)}]
]
To be a valid ${s}, its name and options should be wrapped in a pair of brackets`);
  }
  n(Wht, "checkNoUnwrappedItemOptionPairs");
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var aL = g((nL) => {
  "use strict";
  Object.defineProperty(nL, "__esModule", {
    value: !0
  });
  nL.default = Jht;
  function nE() {
    let t = require("path");
    return nE = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(nE, "_path");
  var AT = `\\${nE().sep}`, sL = `(?:${AT}|$)`, iL = `[^${AT}]+`, rL = `(?:${iL}${AT})`, eee = `(?:${iL}${sL})`, $ht = `${rL}*?`, Hht = `${rL}\
*?${eee}?`;
  function ZZ(t) {
    return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
  n(ZZ, "escapeRegExp");
  function Jht(t, e) {
    let s = nE().resolve(e, t).split(nE().sep);
    return new RegExp(["^", ...s.map((i, r) => {
      let a = r === s.length - 1;
      return i === "**" ? a ? Hht : $ht : i === "*" ? a ? eee : rL : i.indexOf("*.") === 0 ? iL + ZZ(i.slice(1)) + (a ? sL : AT) : ZZ(i) + (a ?
      sL : AT);
    })].join(""));
  }
  n(Jht, "pathToPattern");
});

// ../node_modules/@babel/core/lib/config/printer.js
var iee = g((pm) => {
  "use strict";
  Object.defineProperty(pm, "__esModule", {
    value: !0
  });
  pm.ConfigPrinter = pm.ChainFormatter = void 0;
  function see() {
    let t = ha();
    return see = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(see, "_gensync");
  var Yht = pm.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  }, oL = {
    title(t, e, s) {
      let i = "";
      return t === Yht.Programmatic ? (i = "programmatic options", e && (i += " from " + e)) : i = "config " + s, i;
    },
    loc(t, e) {
      let s = "";
      return t != null && (s += `.overrides[${t}]`), e != null && (s += `.env["${e}"]`), s;
    },
    *optionsAndDescriptors(t) {
      let e = Object.assign({}, t.options);
      delete e.overrides, delete e.env;
      let s = [...yield* t.plugins()];
      s.length && (e.plugins = s.map((r) => tee(r)));
      let i = [...yield* t.presets()];
      return i.length && (e.presets = [...i].map((r) => tee(r))), JSON.stringify(e, void 0, 2);
    }
  };
  function tee(t) {
    var e;
    let s = (e = t.file) == null ? void 0 : e.request;
    return s == null && (typeof t.value == "object" ? s = t.value : typeof t.value == "function" && (s = `[Function: ${t.value.toString().slice(
    0, 50)} ... ]`)), s == null && (s = "[Unknown]"), t.options === void 0 ? s : t.name == null ? [s, t.options] : [s, t.options, t.name];
  }
  n(tee, "descriptorToConfig");
  var lL = class t {
    static {
      n(this, "ConfigPrinter");
    }
    constructor() {
      this._stack = [];
    }
    configure(e, s, {
      callerName: i,
      filepath: r
    }) {
      return e ? (a, o, l) => {
        this._stack.push({
          type: s,
          callerName: i,
          filepath: r,
          content: a,
          index: o,
          envName: l
        });
      } : () => {
      };
    }
    static *format(e) {
      let s = oL.title(e.type, e.callerName, e.filepath), i = oL.loc(e.index, e.envName);
      i && (s += ` ${i}`);
      let r = yield* oL.optionsAndDescriptors(e.content);
      return `${s}
${r}`;
    }
    *output() {
      return this._stack.length === 0 ? "" : (yield* see().all(this._stack.map((s) => t.format(s)))).join(`

`);
    }
  };
  pm.ConfigPrinter = lL;
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var TL = g((fm) => {
  "use strict";
  Object.defineProperty(fm, "__esModule", {
    value: !0
  });
  fm.buildPresetChain = Ght;
  fm.buildPresetChainWalker = void 0;
  fm.buildRootChain = ift;
  function aee() {
    let t = require("path");
    return aee = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(aee, "_path");
  function oee() {
    let t = go();
    return oee = /* @__PURE__ */ n(function() {
      return t;
    }, "_debug"), t;
  }
  n(oee, "_debug");
  var hL = ET(), lee = aL(), CT = iee(), Xht = Su(), zht = jh(), vT = xT(), kr = Fh(), Ra = z_(), ree = oee()("babel:config:config-chain");
  function* Ght(t, e) {
    let s = yield* Qht(t, e);
    return s ? {
      plugins: lE(s.plugins),
      presets: lE(s.presets),
      options: s.options.map((i) => uee(i)),
      files: /* @__PURE__ */ new Set()
    } : null;
  }
  n(Ght, "buildPresetChain");
  var Qht = fm.buildPresetChainWalker = gL({
    root: /* @__PURE__ */ n((t) => Zht(t), "root"),
    env: /* @__PURE__ */ n((t, e) => eft(t)(e), "env"),
    overrides: /* @__PURE__ */ n((t, e) => tft(t)(e), "overrides"),
    overridesEnv: /* @__PURE__ */ n((t, e, s) => sft(t)(e)(s), "overridesEnv"),
    createLogger: /* @__PURE__ */ n(() => () => {
    }, "createLogger")
  }), Zht = (0, kr.makeWeakCacheSync)((t) => fL(t, t.alias, Ra.createUncachedDescriptors)), eft = (0, kr.makeWeakCacheSync)((t) => (0, kr.makeStrongCacheSync)(
  (e) => dL(t, t.alias, Ra.createUncachedDescriptors, e))), tft = (0, kr.makeWeakCacheSync)((t) => (0, kr.makeStrongCacheSync)((e) => mL(t, t.
  alias, Ra.createUncachedDescriptors, e))), sft = (0, kr.makeWeakCacheSync)((t) => (0, kr.makeStrongCacheSync)((e) => (0, kr.makeStrongCacheSync)(
  (s) => yL(t, t.alias, Ra.createUncachedDescriptors, e, s))));
  function* ift(t, e) {
    let s, i, r = new CT.ConfigPrinter(), a = yield* lft({
      options: t,
      dirname: e.cwd
    }, e, void 0, r);
    if (!a) return null;
    let o = yield* r.output(), l;
    typeof t.configFile == "string" ? l = yield* (0, vT.loadConfig)(t.configFile, e.cwd, e.envName, e.caller) : t.configFile !== !1 && (l = yield* (0, vT.
    findRootConfig)(e.root, e.envName, e.caller));
    let {
      babelrc: u,
      babelrcRoots: c
    } = t, p = e.cwd, h = oE(), f = new CT.ConfigPrinter();
    if (l) {
      let E = nft(l), w = yield* cL(E, e, void 0, f);
      if (!w) return null;
      s = yield* f.output(), u === void 0 && (u = E.options.babelrc), c === void 0 && (p = E.dirname, c = E.options.babelrcRoots), hm(h, w);
    }
    let d, y, m = !1, T = oE();
    if ((u === !0 || u === void 0) && typeof e.filename == "string") {
      let E = yield* (0, vT.findPackageData)(e.filename);
      if (E && rft(e, E, c, p)) {
        if ({
          ignore: d,
          config: y
        } = yield* (0, vT.findRelativeConfig)(E, e.envName, e.caller), d && T.files.add(d.filepath), d && cee(e, d.ignore, null, d.dirname) &&
        (m = !0), y && !m) {
          let w = aft(y), K = new CT.ConfigPrinter(), he = yield* cL(w, e, void 0, K);
          he ? (i = yield* K.output(), hm(T, he)) : m = !0;
        }
        y && m && T.files.add(y.filepath);
      }
    }
    e.showConfig && console.log(`Babel configs on "${e.filename}" (ascending priority):
` + [s, i, o].filter((E) => !!E).join(`

`) + `
-----End Babel configs-----`);
    let b = hm(hm(hm(oE(), h), T), a);
    return {
      plugins: m ? [] : lE(b.plugins),
      presets: m ? [] : lE(b.presets),
      options: m ? [] : b.options.map((E) => uee(E)),
      fileHandling: m ? "ignored" : "transpile",
      ignore: d || void 0,
      babelrc: y || void 0,
      config: l || void 0,
      files: b.files
    };
  }
  n(ift, "buildRootChain");
  function rft(t, e, s, i) {
    if (typeof s == "boolean") return s;
    let r = t.root;
    if (s === void 0)
      return e.directories.includes(r);
    let a = s;
    return Array.isArray(a) || (a = [a]), a = a.map((o) => typeof o == "string" ? aee().resolve(i, o) : o), a.length === 1 && a[0] === r ? e.
    directories.includes(r) : a.some((o) => (typeof o == "string" && (o = (0, lee.default)(o, i)), e.directories.some((l) => pee(o, i, l, t))));
  }
  n(rft, "babelrcLoadEnabled");
  var nft = (0, kr.makeWeakCacheSync)((t) => ({
    filepath: t.filepath,
    dirname: t.dirname,
    options: (0, hL.validate)("configfile", t.options, t.filepath)
  })), aft = (0, kr.makeWeakCacheSync)((t) => ({
    filepath: t.filepath,
    dirname: t.dirname,
    options: (0, hL.validate)("babelrcfile", t.options, t.filepath)
  })), oft = (0, kr.makeWeakCacheSync)((t) => ({
    filepath: t.filepath,
    dirname: t.dirname,
    options: (0, hL.validate)("extendsfile", t.options, t.filepath)
  })), lft = gL({
    root: /* @__PURE__ */ n((t) => fL(t, "base", Ra.createCachedDescriptors), "root"),
    env: /* @__PURE__ */ n((t, e) => dL(t, "base", Ra.createCachedDescriptors, e), "env"),
    overrides: /* @__PURE__ */ n((t, e) => mL(t, "base", Ra.createCachedDescriptors, e), "overrides"),
    overridesEnv: /* @__PURE__ */ n((t, e, s) => yL(t, "base", Ra.createCachedDescriptors, e, s), "overridesEnv"),
    createLogger: /* @__PURE__ */ n((t, e, s) => mft(t, e, s), "createLogger")
  }), uft = gL({
    root: /* @__PURE__ */ n((t) => cft(t), "root"),
    env: /* @__PURE__ */ n((t, e) => pft(t)(e), "env"),
    overrides: /* @__PURE__ */ n((t, e) => hft(t)(e), "overrides"),
    overridesEnv: /* @__PURE__ */ n((t, e, s) => fft(t)(e)(s), "overridesEnv"),
    createLogger: /* @__PURE__ */ n((t, e, s) => dft(t.filepath, e, s), "createLogger")
  });
  function* cL(t, e, s, i) {
    let r = yield* uft(t, e, s, i);
    return r?.files.add(t.filepath), r;
  }
  n(cL, "loadFileChain");
  var cft = (0, kr.makeWeakCacheSync)((t) => fL(t, t.filepath, Ra.createUncachedDescriptors)), pft = (0, kr.makeWeakCacheSync)((t) => (0, kr.
  makeStrongCacheSync)((e) => dL(t, t.filepath, Ra.createUncachedDescriptors, e))), hft = (0, kr.makeWeakCacheSync)((t) => (0, kr.makeStrongCacheSync)(
  (e) => mL(t, t.filepath, Ra.createUncachedDescriptors, e))), fft = (0, kr.makeWeakCacheSync)((t) => (0, kr.makeStrongCacheSync)((e) => (0, kr.
  makeStrongCacheSync)((s) => yL(t, t.filepath, Ra.createUncachedDescriptors, e, s))));
  function dft(t, e, s) {
    return s ? s.configure(e.showConfig, CT.ChainFormatter.Config, {
      filepath: t
    }) : () => {
    };
  }
  n(dft, "buildFileLogger");
  function fL({
    dirname: t,
    options: e
  }, s, i) {
    return i(t, e, s);
  }
  n(fL, "buildRootDescriptors");
  function mft(t, e, s) {
    var i;
    return s ? s.configure(e.showConfig, CT.ChainFormatter.Programmatic, {
      callerName: (i = e.caller) == null ? void 0 : i.name
    }) : () => {
    };
  }
  n(mft, "buildProgrammaticLogger");
  function dL({
    dirname: t,
    options: e
  }, s, i, r) {
    var a;
    let o = (a = e.env) == null ? void 0 : a[r];
    return o ? i(t, o, `${s}.env["${r}"]`) : null;
  }
  n(dL, "buildEnvDescriptors");
  function mL({
    dirname: t,
    options: e
  }, s, i, r) {
    var a;
    let o = (a = e.overrides) == null ? void 0 : a[r];
    if (!o) throw new Error("Assertion failure - missing override");
    return i(t, o, `${s}.overrides[${r}]`);
  }
  n(mL, "buildOverrideDescriptors");
  function yL({
    dirname: t,
    options: e
  }, s, i, r, a) {
    var o, l;
    let u = (o = e.overrides) == null ? void 0 : o[r];
    if (!u) throw new Error("Assertion failure - missing override");
    let c = (l = u.env) == null ? void 0 : l[a];
    return c ? i(t, c, `${s}.overrides[${r}].env["${a}"]`) : null;
  }
  n(yL, "buildOverrideEnvDescriptors");
  function gL({
    root: t,
    env: e,
    overrides: s,
    overridesEnv: i,
    createLogger: r
  }) {
    return /* @__PURE__ */ n(function* (o, l, u = /* @__PURE__ */ new Set(), c) {
      let {
        dirname: p
      } = o, h = [], f = t(o);
      if (aE(f, p, l, o.filepath)) {
        h.push({
          config: f,
          envName: void 0,
          index: void 0
        });
        let m = e(o, l.envName);
        m && aE(m, p, l, o.filepath) && h.push({
          config: m,
          envName: l.envName,
          index: void 0
        }), (f.options.overrides || []).forEach((T, b) => {
          let E = s(o, b);
          if (aE(E, p, l, o.filepath)) {
            h.push({
              config: E,
              index: b,
              envName: void 0
            });
            let w = i(o, b, l.envName);
            w && aE(w, p, l, o.filepath) && h.push({
              config: w,
              index: b,
              envName: l.envName
            });
          }
        });
      }
      if (h.some(({
        config: {
          options: {
            ignore: m,
            only: T
          }
        }
      }) => cee(l, m, T, p)))
        return null;
      let d = oE(), y = r(o, l, c);
      for (let {
        config: m,
        index: T,
        envName: b
      } of h) {
        if (!(yield* yft(d, m.options, p, l, u, c)))
          return null;
        y(m, T, b), yield* gft(d, m);
      }
      return d;
    }, "chainWalker");
  }
  n(gL, "makeChainWalker");
  function* yft(t, e, s, i, r, a) {
    if (e.extends === void 0) return !0;
    let o = yield* (0, vT.loadConfig)(e.extends, s, i.envName, i.caller);
    if (r.has(o))
      throw new Error(`Configuration cycle detected loading ${o.filepath}.
File already loaded following the config chain:
` + Array.from(r, (u) => ` - ${u.filepath}`).join(`
`));
    r.add(o);
    let l = yield* cL(oft(o), i, r, a);
    return r.delete(o), l ? (hm(t, l), !0) : !1;
  }
  n(yft, "mergeExtendsChain");
  function hm(t, e) {
    t.options.push(...e.options), t.plugins.push(...e.plugins), t.presets.push(...e.presets);
    for (let s of e.files)
      t.files.add(s);
    return t;
  }
  n(hm, "mergeChain");
  function* gft(t, {
    options: e,
    plugins: s,
    presets: i
  }) {
    return t.options.push(e), t.plugins.push(...yield* s()), t.presets.push(...yield* i()), t;
  }
  n(gft, "mergeChainOpts");
  function oE() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: /* @__PURE__ */ new Set()
    };
  }
  n(oE, "emptyChain");
  function uee(t) {
    let e = Object.assign({}, t);
    return delete e.extends, delete e.env, delete e.overrides, delete e.plugins, delete e.presets, delete e.passPerPreset, delete e.ignore, delete e.
    only, delete e.test, delete e.include, delete e.exclude, hasOwnProperty.call(e, "sourceMap") && (e.sourceMaps = e.sourceMap, delete e.sourceMap),
    e;
  }
  n(uee, "normalizeOptions");
  function lE(t) {
    let e = /* @__PURE__ */ new Map(), s = [];
    for (let i of t)
      if (typeof i.value == "function") {
        let r = i.value, a = e.get(r);
        a || (a = /* @__PURE__ */ new Map(), e.set(r, a));
        let o = a.get(i.name);
        o ? o.value = i : (o = {
          value: i
        }, s.push(o), i.ownPass || a.set(i.name, o));
      } else
        s.push({
          value: i
        });
    return s.reduce((i, r) => (i.push(r.value), i), []);
  }
  n(lE, "dedupDescriptors");
  function aE({
    options: t
  }, e, s, i) {
    return (t.test === void 0 || uL(s, t.test, e, i)) && (t.include === void 0 || uL(s, t.include, e, i)) && (t.exclude === void 0 || !uL(s,
    t.exclude, e, i));
  }
  n(aE, "configIsApplicable");
  function uL(t, e, s, i) {
    let r = Array.isArray(e) ? e : [e];
    return pL(t, r, s, i);
  }
  n(uL, "configFieldIsApplicable");
  function nee(t, e) {
    return e instanceof RegExp ? String(e) : e;
  }
  n(nee, "ignoreListReplacer");
  function cee(t, e, s, i) {
    if (e && pL(t, e, i)) {
      var r;
      let o = `No config is applied to "${(r = t.filename) != null ? r : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(
      e, nee)}\` from "${i}"`;
      return ree(o), t.showConfig && console.log(o), !0;
    }
    if (s && !pL(t, s, i)) {
      var a;
      let o = `No config is applied to "${(a = t.filename) != null ? a : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(
      s, nee)}\` from "${i}"`;
      return ree(o), t.showConfig && console.log(o), !0;
    }
    return !1;
  }
  n(cee, "shouldIgnore");
  function pL(t, e, s, i) {
    return e.some((r) => pee(r, s, t.filename, t, i));
  }
  n(pL, "matchesPatterns");
  function pee(t, e, s, i, r) {
    if (typeof t == "function")
      return !!(0, Xht.endHiddenCallStack)(t)(s, {
        dirname: e,
        envName: i.envName,
        caller: i.caller
      });
    if (typeof s != "string")
      throw new zht.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", r);
    return typeof t == "string" && (t = (0, lee.default)(t, e)), t.test(s);
  }
  n(pee, "matchPattern");
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var hee = g((bL) => {
  "use strict";
  Object.defineProperty(bL, "__esModule", {
    value: !0
  });
  bL.validatePluginObject = Sft;
  var Nu = eL(), Tft = {
    name: Nu.assertString,
    manipulateOptions: Nu.assertFunction,
    pre: Nu.assertFunction,
    post: Nu.assertFunction,
    inherits: Nu.assertFunction,
    visitor: bft,
    parserOverride: Nu.assertFunction,
    generatorOverride: Nu.assertFunction
  };
  function bft(t, e) {
    let s = (0, Nu.assertObject)(t, e);
    if (s && (Object.keys(s).forEach((i) => {
      i !== "_exploded" && i !== "_verified" && xft(i, s[i]);
    }), s.enter || s.exit))
      throw new Error(`${(0, Nu.msg)(t)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return s;
  }
  n(bft, "assertVisitorMap");
  function xft(t, e) {
    if (e && typeof e == "object")
      Object.keys(e).forEach((s) => {
        if (s !== "enter" && s !== "exit")
          throw new Error(`.visitor["${t}"] may only have .enter and/or .exit handlers.`);
      });
    else if (typeof e != "function")
      throw new Error(`.visitor["${t}"] must be a function`);
  }
  n(xft, "assertVisitorHandler");
  function Sft(t) {
    let e = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(t).forEach((s) => {
      let i = Tft[s];
      if (i)
        i({
          type: "option",
          name: s,
          parent: e
        }, t[s]);
      else {
        let r = new Error(`.${s} is not a valid Plugin property`);
        throw r.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", r;
      }
    }), t;
  }
  n(Sft, "validatePluginObject");
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var SL = g((xL) => {
  "use strict";
  Object.defineProperty(xL, "__esModule", {
    value: !0
  });
  xL.getEnv = Pft;
  function Pft(t = "development") {
    return process.env.BABEL_ENV || process.env.NODE_ENV || t;
  }
  n(Pft, "getEnv");
});

// ../node_modules/@babel/core/lib/config/partial.js
var PL = g((hE) => {
  "use strict";
  Object.defineProperty(hE, "__esModule", {
    value: !0
  });
  hE.default = dee;
  hE.loadPartialConfig = Oft;
  function uE() {
    let t = require("path");
    return uE = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(uE, "_path");
  var Eft = BP(), Aft = SP(), fee = bT(), vft = TL(), Cft = SL(), wft = ET(), cE = xT(), Ift = X_(), Nft = ["showIgnoredFiles"];
  function kft(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.includes(i)) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(kft, "_objectWithoutPropertiesLoose");
  function Dft(t, e) {
    switch (e) {
      case "root":
        return t;
      case "upward-optional": {
        let s = (0, cE.findConfigUpwards)(t);
        return s === null ? t : s;
      }
      case "upward": {
        let s = (0, cE.findConfigUpwards)(t);
        if (s !== null) return s;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${t}".\

One of the following config files must be in the directory tree: "${cE.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: t
        });
      }
      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }
  n(Dft, "resolveRootMode");
  function* dee(t) {
    if (t != null && (typeof t != "object" || Array.isArray(t)))
      throw new Error("Babel options must be an object, null, or undefined");
    let e = t ? (0, wft.validate)("arguments", t) : {}, {
      envName: s = (0, Cft.getEnv)(),
      cwd: i = ".",
      root: r = ".",
      rootMode: a = "root",
      caller: o,
      cloneInputAst: l = !0
    } = e, u = uE().resolve(i), c = Dft(uE().resolve(u, r), a), p = typeof e.filename == "string" ? uE().resolve(i, e.filename) : void 0, h = yield* (0, cE.
    resolveShowConfigPath)(u), f = {
      filename: p,
      cwd: u,
      root: c,
      envName: s,
      caller: o,
      showConfig: h === p
    }, d = yield* (0, vft.buildRootChain)(e, f);
    if (!d) return null;
    let y = {
      assumptions: {}
    };
    return d.options.forEach((T) => {
      (0, Aft.mergeOptions)(y, T);
    }), {
      options: Object.assign({}, y, {
        targets: (0, Ift.resolveTargets)(y, c),
        cloneInputAst: l,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: f.envName,
        cwd: f.cwd,
        root: f.root,
        rootMode: "root",
        filename: typeof f.filename == "string" ? f.filename : void 0,
        plugins: d.plugins.map((T) => (0, fee.createItemFromDescriptor)(T)),
        presets: d.presets.map((T) => (0, fee.createItemFromDescriptor)(T))
      }),
      context: f,
      fileHandling: d.fileHandling,
      ignore: d.ignore,
      babelrc: d.babelrc,
      config: d.config,
      files: d.files
    };
  }
  n(dee, "loadPrivatePartialConfig");
  function* Oft(t) {
    let e = !1;
    if (typeof t == "object" && t !== null && !Array.isArray(t)) {
      var s = t;
      ({
        showIgnoredFiles: e
      } = s), t = kft(s, Nft);
    }
    let i = yield* dee(t);
    if (!i) return null;
    let {
      options: r,
      babelrc: a,
      ignore: o,
      config: l,
      fileHandling: u,
      files: c
    } = i;
    return u === "ignored" && !e ? null : ((r.plugins || []).forEach((p) => {
      if (p.value instanceof Eft.default)
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new pE(r, a ? a.filepath : void 0, o ? o.filepath : void 0, l ? l.filepath : void 0, u, c));
  }
  n(Oft, "loadPartialConfig");
  var pE = class {
    static {
      n(this, "PartialConfig");
    }
    constructor(e, s, i, r, a, o) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files =
      void 0, this.options = e, this.babelignore = i, this.babelrc = s, this.config = r, this.fileHandling = a, this.files = o, Object.freeze(
      this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }
  };
  Object.freeze(pE.prototype);
});

// ../node_modules/@babel/core/lib/config/full.js
var Eee = g((fE) => {
  "use strict";
  Object.defineProperty(fE, "__esModule", {
    value: !0
  });
  fE.default = void 0;
  function Tee() {
    let t = ha();
    return Tee = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(Tee, "_gensync");
  var vL = Zc(), mee = SP(), _ft = ar(), bee = BP(), Lft = bT(), Bft = TL(), IL = _P();
  function CL() {
    let t = zl();
    return CL = /* @__PURE__ */ n(function() {
      return t;
    }, "_traverse"), t;
  }
  n(CL, "_traverse");
  var NL = Fh(), wL = ET(), Mft = hee(), xee = m_(), Fft = PL(), jft = jh(), s$s = fE.default = Tee()(/* @__PURE__ */ n(function* (e) {
    var s;
    let i = yield* (0, Fft.default)(e);
    if (!i)
      return null;
    let {
      options: r,
      context: a,
      fileHandling: o
    } = i;
    if (o === "ignored")
      return null;
    let l = {}, {
      plugins: u,
      presets: c
    } = r;
    if (!u || !c)
      throw new Error("Assertion failure - plugins and presets exist");
    let p = Object.assign({}, a, {
      targets: r.targets
    }), h = /* @__PURE__ */ n((K) => {
      let he = (0, Lft.getItemDescriptor)(K);
      if (!he)
        throw new Error("Assertion failure - must be config item");
      return he;
    }, "toDescriptor"), f = c.map(h), d = u.map(h), y = [[]], m = [], T = [];
    if (yield* yee(a, /* @__PURE__ */ n(function* K(he, de) {
      let me = [];
      for (let ye = 0; ye < he.length; ye++) {
        let ge = he[ye];
        if (ge.options !== !1) {
          try {
            var ve = yield* Wft(ge, p);
          } catch (oe) {
            throw oe.code === "BABEL_UNKNOWN_OPTION" && (0, wL.checkNoUnwrappedItemOptionPairs)(he, ye, "preset", oe), oe;
          }
          T.push(ve.externalDependencies), ge.ownPass ? me.push({
            preset: ve.chain,
            pass: []
          }) : me.unshift({
            preset: ve.chain,
            pass: de
          });
        }
      }
      if (me.length > 0) {
        y.splice(1, 0, ...me.map((ye) => ye.pass).filter((ye) => ye !== de));
        for (let {
          preset: ye,
          pass: ge
        } of me) {
          if (!ye || (ge.push(...ye.plugins), yield* K(ye.presets, ge))) return !0;
          ye.options.forEach((Ae) => {
            (0, mee.mergeOptions)(l, Ae);
          });
        }
      }
    }, "recursePresetDescriptors"))(f, y[0])) return null;
    let E = l;
    (0, mee.mergeOptions)(E, r);
    let w = Object.assign({}, p, {
      assumptions: (s = E.assumptions) != null ? s : {}
    });
    return yield* yee(a, /* @__PURE__ */ n(function* () {
      y[0].unshift(...d);
      for (let de of y) {
        let me = [];
        m.push(me);
        for (let ve = 0; ve < de.length; ve++) {
          let ye = de[ve];
          if (ye.options !== !1) {
            try {
              var he = yield* Pee(ye, w);
            } catch (ge) {
              throw ge.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, wL.checkNoUnwrappedItemOptionPairs)(de, ve, "plugin", ge), ge;
            }
            me.push(he), T.push(he.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), E.plugins = m[0], E.presets = m.slice(1).filter((K) => K.length > 0).map((K) => ({
      plugins: K
    })), E.passPerPreset = E.presets.length > 0, {
      options: E,
      passes: m,
      externalDependencies: (0, IL.finalize)(T)
    };
  }, "loadFullConfig"));
  function yee(t, e) {
    return function* (s, i) {
      try {
        return yield* e(s, i);
      } catch (a) {
        if (!/^\[BABEL\]/.test(a.message)) {
          var r;
          a.message = `[BABEL] ${(r = t.filename) != null ? r : "unknown file"}: ${a.message}`;
        }
        throw a;
      }
    };
  }
  n(yee, "enhanceError");
  var See = /* @__PURE__ */ n((t) => (0, NL.makeWeakCache)(function* ({
    value: e,
    options: s,
    dirname: i,
    alias: r
  }, a) {
    if (s === !1) throw new Error("Assertion failure");
    s = s || {};
    let o = [], l = e;
    if (typeof e == "function") {
      let u = (0, vL.maybeAsync)(e, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), c = Object.assign(
      {}, _ft, t(a, o));
      try {
        l = yield* u(c, s, i);
      } catch (p) {
        throw r && (p.message += ` (While processing: ${JSON.stringify(r)})`), p;
      }
    }
    if (!l || typeof l != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, vL.isThenable)(l))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you\
're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". \
(While processing: ${JSON.stringify(r)})`);
    if (o.length > 0 && (!a.configured() || a.mode() === "forever")) {
      let u = `A plugin/preset has external untracked dependencies (${o[0]}), but the cache `;
      throw a.configured() ? u += " has been configured to never be invalidated. " : u += "has not been configured to be invalidated when th\
e external dependencies change. ", u += `Plugins/presets should configure their cache to be invalidated when the external dependencies chang\
e, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(r)})`, new Error(u);
    }
    return {
      value: l,
      options: s,
      dirname: i,
      alias: r,
      externalDependencies: (0, IL.finalize)(o)
    };
  }), "makeDescriptorLoader"), Rft = See(xee.makePluginAPI), qft = See(xee.makePresetAPI), Uft = (0, NL.makeWeakCache)(function* ({
    value: t,
    options: e,
    dirname: s,
    alias: i,
    externalDependencies: r
  }, a) {
    let o = (0, Mft.validatePluginObject)(t), l = Object.assign({}, o);
    if (l.visitor && (l.visitor = CL().default.explode(Object.assign({}, l.visitor))), l.inherits) {
      let u = {
        name: void 0,
        alias: `${i}$inherits`,
        value: l.inherits,
        options: e,
        dirname: s
      }, c = yield* (0, vL.forwardAsync)(Pee, (p) => a.invalidate((h) => p(u, h)));
      l.pre = AL(c.pre, l.pre), l.post = AL(c.post, l.post), l.manipulateOptions = AL(c.manipulateOptions, l.manipulateOptions), l.visitor =
      CL().default.visitors.merge([c.visitor || {}, l.visitor || {}]), c.externalDependencies.length > 0 && (r.length === 0 ? r = c.externalDependencies :
      r = (0, IL.finalize)([r, c.externalDependencies]));
    }
    return new bee.default(l, e, i, r);
  });
  function* Pee(t, e) {
    if (t.value instanceof bee.default) {
      if (t.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return t.value;
    }
    return yield* Uft(yield* Rft(t, e), e);
  }
  n(Pee, "loadPluginDescriptor");
  var EL = /* @__PURE__ */ n((t) => t && typeof t != "function", "needsFilename"), gee = /* @__PURE__ */ n((t, e) => {
    if (EL(t.test) || EL(t.include) || EL(t.exclude)) {
      let s = e.name ? `"${e.name}"` : "/* your preset */";
      throw new jft.default([`Preset ${s} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, {\
 filename: 'file.ts', presets: [${s}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"), Kft = /* @__PURE__ */ n((t, e, s) => {
    if (!e.filename) {
      var i;
      let {
        options: r
      } = t;
      gee(r, s), (i = r.overrides) == null || i.forEach((a) => gee(a, s));
    }
  }, "validatePreset"), Vft = (0, NL.makeWeakCacheSync)(({
    value: t,
    dirname: e,
    alias: s,
    externalDependencies: i
  }) => ({
    options: (0, wL.validate)("preset", t),
    alias: s,
    dirname: e,
    externalDependencies: i
  }));
  function* Wft(t, e) {
    let s = Vft(yield* qft(t, e));
    return Kft(s, e, t), {
      chain: yield* (0, Bft.buildPresetChain)(s, e),
      externalDependencies: s.externalDependencies
    };
  }
  n(Wft, "loadPresetDescriptor");
  function AL(t, e) {
    return t ? e ? function(...s) {
      let i = t.apply(this, s);
      return i && typeof i.then == "function" ? i.then(() => e.apply(this, s)) : e.apply(this, s);
    } : t : e;
  }
  n(AL, "chainMaybeAsync");
});

// ../node_modules/@babel/core/lib/config/index.js
var dm = g((Ua) => {
  "use strict";
  Object.defineProperty(Ua, "__esModule", {
    value: !0
  });
  Ua.createConfigItem = Zft;
  Ua.createConfigItemAsync = Qft;
  Ua.createConfigItemSync = wee;
  Object.defineProperty(Ua, "default", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Aee.default;
    }, "get")
  });
  Ua.loadOptions = Gft;
  Ua.loadOptionsAsync = zft;
  Ua.loadOptionsSync = Cee;
  Ua.loadPartialConfig = Yft;
  Ua.loadPartialConfigAsync = Jft;
  Ua.loadPartialConfigSync = vee;
  function gE() {
    let t = ha();
    return gE = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(gE, "_gensync");
  var Aee = Eee(), $ft = PL(), Hft = bT(), qa = Su(), dE = gE()($ft.loadPartialConfig);
  function Jft(...t) {
    return (0, qa.beginHiddenCallStack)(dE.async)(...t);
  }
  n(Jft, "loadPartialConfigAsync");
  function vee(...t) {
    return (0, qa.beginHiddenCallStack)(dE.sync)(...t);
  }
  n(vee, "loadPartialConfigSync");
  function Yft(t, e) {
    if (e !== void 0)
      (0, qa.beginHiddenCallStack)(dE.errback)(t, e);
    else if (typeof t == "function")
      (0, qa.beginHiddenCallStack)(dE.errback)(void 0, t);
    else
      return vee(t);
  }
  n(Yft, "loadPartialConfig");
  function* Xft(t) {
    var e;
    let s = yield* (0, Aee.default)(t);
    return (e = s?.options) != null ? e : null;
  }
  n(Xft, "loadOptionsImpl");
  var mE = gE()(Xft);
  function zft(...t) {
    return (0, qa.beginHiddenCallStack)(mE.async)(...t);
  }
  n(zft, "loadOptionsAsync");
  function Cee(...t) {
    return (0, qa.beginHiddenCallStack)(mE.sync)(...t);
  }
  n(Cee, "loadOptionsSync");
  function Gft(t, e) {
    if (e !== void 0)
      (0, qa.beginHiddenCallStack)(mE.errback)(t, e);
    else if (typeof t == "function")
      (0, qa.beginHiddenCallStack)(mE.errback)(void 0, t);
    else
      return Cee(t);
  }
  n(Gft, "loadOptions");
  var yE = gE()(Hft.createConfigItem);
  function Qft(...t) {
    return (0, qa.beginHiddenCallStack)(yE.async)(...t);
  }
  n(Qft, "createConfigItemAsync");
  function wee(...t) {
    return (0, qa.beginHiddenCallStack)(yE.sync)(...t);
  }
  n(wee, "createConfigItemSync");
  function Zft(t, e, s) {
    if (s !== void 0)
      (0, qa.beginHiddenCallStack)(yE.errback)(t, e, s);
    else if (typeof e == "function")
      (0, qa.beginHiddenCallStack)(yE.errback)(t, void 0, s);
    else
      return wee(t, e);
  }
  n(Zft, "createConfigItem");
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var Iee = g((TE) => {
  "use strict";
  Object.defineProperty(TE, "__esModule", {
    value: !0
  });
  TE.default = void 0;
  var wT = class {
    static {
      n(this, "PluginPass");
    }
    constructor(e, s, i, r) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0,
      this.isAsync = void 0, this.key = s, this.file = e, this.opts = i || {}, this.cwd = e.opts.cwd, this.filename = e.opts.filename, this.
      isAsync = r;
    }
    set(e, s) {
      this._map.set(e, s);
    }
    get(e) {
      return this._map.get(e);
    }
    availableHelper(e, s) {
      return this.file.availableHelper(e, s);
    }
    addHelper(e) {
      return this.file.addHelper(e);
    }
    buildCodeFrameError(e, s, i) {
      return this.file.buildCodeFrameError(e, s, i);
    }
  };
  TE.default = wT;
  wT.prototype.getModuleName = /* @__PURE__ */ n(function() {
    return this.file.getModuleName();
  }, "getModuleName"), wT.prototype.addImport = /* @__PURE__ */ n(function() {
    this.file.addImport();
  }, "addImport");
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var _ee = g((DL) => {
  "use strict";
  Object.defineProperty(DL, "__esModule", {
    value: !0
  });
  DL.default = tdt;
  function Dee() {
    let t = zl();
    return Dee = /* @__PURE__ */ n(function() {
      return t;
    }, "_traverse"), t;
  }
  n(Dee, "_traverse");
  var edt = BP(), kL, Nee = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: t
        }) {
          t.body = kee(t.body);
        }
      },
      SwitchCase: {
        exit({
          node: t
        }) {
          t.consequent = kee(t.consequent);
        }
      }
    }
  };
  function kee(t) {
    let e = Math.pow(2, 30) - 1, s = !1;
    for (let i = 0; i < t.length; i++) {
      let r = t[i], a = Oee(r);
      if (a > e) {
        s = !0;
        break;
      }
      e = a;
    }
    return s ? sdt(t.slice()) : t;
  }
  n(kee, "performHoisting");
  function tdt() {
    return kL || (kL = new edt.default(Object.assign({}, Nee, {
      visitor: Dee().default.explode(Nee.visitor)
    }), {})), kL;
  }
  n(tdt, "loadBlockHoistPlugin");
  function Oee(t) {
    let e = t?._blockHoist;
    return e == null ? 1 : e === !0 ? 2 : e;
  }
  n(Oee, "priority");
  function sdt(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let r = 0; r < t.length; r++) {
      let a = t[r], o = Oee(a);
      (e[o] || (e[o] = [])).push(a);
    }
    let s = Object.keys(e).map((r) => +r).sort((r, a) => a - r), i = 0;
    for (let r of s) {
      let a = e[r];
      for (let o of a)
        t[i++] = o;
    }
    return t;
  }
  n(sdt, "stableSort");
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var _L = g((OL) => {
  "use strict";
  Object.defineProperty(OL, "__esModule", {
    value: !0
  });
  OL.default = idt;
  function bE() {
    let t = require("path");
    return bE = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(bE, "_path");
  function idt(t) {
    let {
      filename: e,
      cwd: s,
      filenameRelative: i = typeof e == "string" ? bE().relative(s, e) : "unknown",
      sourceType: r = "module",
      inputSourceMap: a,
      sourceMaps: o = !!a,
      sourceRoot: l = t.options.moduleRoot,
      sourceFileName: u = bE().basename(i),
      comments: c = !0,
      compact: p = "auto"
    } = t.options, h = t.options, f = Object.assign({}, h, {
      parserOpts: Object.assign({
        sourceType: bE().extname(i) === ".mjs" ? "module" : r,
        sourceFileName: e,
        plugins: []
      }, h.parserOpts),
      generatorOpts: Object.assign({
        filename: e,
        auxiliaryCommentBefore: h.auxiliaryCommentBefore,
        auxiliaryCommentAfter: h.auxiliaryCommentAfter,
        retainLines: h.retainLines,
        comments: c,
        shouldPrintComment: h.shouldPrintComment,
        compact: p,
        minified: h.minified,
        sourceMaps: o,
        sourceRoot: l,
        sourceFileName: u
      }, h.generatorOpts)
    });
    for (let d of t.passes)
      for (let y of d)
        y.manipulateOptions && y.manipulateOptions(f, f.parserOpts);
    return f;
  }
  n(idt, "normalizeOptions");
});

// ../node_modules/convert-source-map/index.js
var LL = g((lr) => {
  "use strict";
  Object.defineProperty(lr, "commentRegex", {
    get: /* @__PURE__ */ n(function() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }, "getCommentRegex")
  });
  Object.defineProperty(lr, "mapFileCommentRegex", {
    get: /* @__PURE__ */ n(function() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }, "getMapFileCommentRegex")
  });
  var xE;
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? xE = rdt : xE = ndt : xE = adt;
  function rdt(t) {
    return Buffer.from(t, "base64").toString();
  }
  n(rdt, "decodeBase64WithBufferFrom");
  function ndt(t) {
    if (typeof value == "number")
      throw new TypeError("The value to decode must not be of type number.");
    return new Buffer(t, "base64").toString();
  }
  n(ndt, "decodeBase64WithNewBuffer");
  function adt(t) {
    return decodeURIComponent(escape(atob(t)));
  }
  n(adt, "decodeBase64WithAtob");
  function odt(t) {
    return t.split(",").pop();
  }
  n(odt, "stripComment");
  function ldt(t, e) {
    var s = lr.mapFileCommentRegex.exec(t), i = s[1] || s[2];
    try {
      var t = e(i);
      return t != null && typeof t.catch == "function" ? t.catch(r) : t;
    } catch (a) {
      r(a);
    }
    function r(a) {
      throw new Error("An error occurred while trying to read the map file at " + i + `
` + a.stack);
    }
    n(r, "throwError");
  }
  n(ldt, "readFromFileMap");
  function rn(t, e) {
    e = e || {}, e.hasComment && (t = odt(t)), e.encoding === "base64" ? t = xE(t) : e.encoding === "uri" && (t = decodeURIComponent(t)), (e.
    isJSON || e.encoding) && (t = JSON.parse(t)), this.sourcemap = t;
  }
  n(rn, "Converter");
  rn.prototype.toJSON = function(t) {
    return JSON.stringify(this.sourcemap, null, t);
  };
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? rn.prototype.toBase64 = udt : rn.prototype.toBase64 = cdt : rn.prototype.toBase64 =
  pdt;
  function udt() {
    var t = this.toJSON();
    return Buffer.from(t, "utf8").toString("base64");
  }
  n(udt, "encodeBase64WithBufferFrom");
  function cdt() {
    var t = this.toJSON();
    if (typeof t == "number")
      throw new TypeError("The json to encode must not be of type number.");
    return new Buffer(t, "utf8").toString("base64");
  }
  n(cdt, "encodeBase64WithNewBuffer");
  function pdt() {
    var t = this.toJSON();
    return btoa(unescape(encodeURIComponent(t)));
  }
  n(pdt, "encodeBase64WithBtoa");
  rn.prototype.toURI = function() {
    var t = this.toJSON();
    return encodeURIComponent(t);
  };
  rn.prototype.toComment = function(t) {
    var e, s, i;
    return t != null && t.encoding === "uri" ? (e = "", s = this.toURI()) : (e = ";base64", s = this.toBase64()), i = "sourceMappingURL=data\
:application/json;charset=utf-8" + e + "," + s, t != null && t.multiline ? "/*# " + i + " */" : "//# " + i;
  };
  rn.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  rn.prototype.addProperty = function(t, e) {
    if (this.sourcemap.hasOwnProperty(t)) throw new Error('property "' + t + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(t, e);
  };
  rn.prototype.setProperty = function(t, e) {
    return this.sourcemap[t] = e, this;
  };
  rn.prototype.getProperty = function(t) {
    return this.sourcemap[t];
  };
  lr.fromObject = function(t) {
    return new rn(t);
  };
  lr.fromJSON = function(t) {
    return new rn(t, { isJSON: !0 });
  };
  lr.fromURI = function(t) {
    return new rn(t, { encoding: "uri" });
  };
  lr.fromBase64 = function(t) {
    return new rn(t, { encoding: "base64" });
  };
  lr.fromComment = function(t) {
    var e, s;
    return t = t.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), e = lr.commentRegex.exec(t), s = e && e[4] || "uri", new rn(t, { encoding: s,
    hasComment: !0 });
  };
  function Lee(t) {
    return new rn(t, { isJSON: !0 });
  }
  n(Lee, "makeConverter");
  lr.fromMapFileComment = function(t, e) {
    if (typeof e == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://githu\
b.com/thlorenz/convert-source-map#upgrading"
      );
    var s = ldt(t, e);
    return s != null && typeof s.then == "function" ? s.then(Lee) : Lee(s);
  };
  lr.fromSource = function(t) {
    var e = t.match(lr.commentRegex);
    return e ? lr.fromComment(e.pop()) : null;
  };
  lr.fromMapFileSource = function(t, e) {
    if (typeof e == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github\
.com/thlorenz/convert-source-map#upgrading"
      );
    var s = t.match(lr.mapFileCommentRegex);
    return s ? lr.fromMapFileComment(s.pop(), e) : null;
  };
  lr.removeComments = function(t) {
    return t.replace(lr.commentRegex, "");
  };
  lr.removeMapFileComments = function(t) {
    return t.replace(lr.mapFileCommentRegex, "");
  };
  lr.generateMapFileComment = function(t, e) {
    var s = "sourceMappingURL=" + t;
    return e && e.multiline ? "/*# " + s + " */" : "//# " + s;
  };
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var Fee = g((BL) => {
  "use strict";
  Object.defineProperty(BL, "__esModule", {
    value: !0
  });
  BL.default = hdt;
  var Mee = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  Object.assign(Mee, {
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-transform-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-transform-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-transform-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-transform-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-transform-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-transform-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-transform-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-transform-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-transform-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-transform-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-transform-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    }
  });
  var Bee = /* @__PURE__ */ n(({
    name: t,
    url: e
  }) => `${t} (${e})`, "getNameURLCombination");
  function hdt(t, e, s, i) {
    let r = `Support for the experimental syntax '${t}' isn't currently enabled (${e.line}:${e.column + 1}):

` + s, a = Mee[t];
    if (a) {
      let {
        syntax: l,
        transform: u
      } = a;
      if (l) {
        let c = Bee(l);
        if (u) {
          let p = Bee(u), h = u.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          r += `

Add ${p} to the '${h}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${c} to the 'plugins' section to enable parsing.`;
        } else
          r += `

Add ${c} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return r += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${i === "unknown" ? "<name of the input file>" : i} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, r;
  }
  n(hdt, "generateMissingPluginMessage");
});

// ../node_modules/@babel/core/lib/parser/index.js
var jL = g((FL) => {
  "use strict";
  Object.defineProperty(FL, "__esModule", {
    value: !0
  });
  FL.default = ddt;
  function ML() {
    let t = lS();
    return ML = /* @__PURE__ */ n(function() {
      return t;
    }, "_parser"), t;
  }
  n(ML, "_parser");
  function jee() {
    let t = Yl();
    return jee = /* @__PURE__ */ n(function() {
      return t;
    }, "_codeFrame"), t;
  }
  n(jee, "_codeFrame");
  var fdt = Fee();
  function* ddt(t, {
    parserOpts: e,
    highlightCode: s = !0,
    filename: i = "unknown"
  }, r) {
    try {
      let a = [];
      for (let o of t)
        for (let l of o) {
          let {
            parserOverride: u
          } = l;
          if (u) {
            let c = u(r, e, ML().parse);
            c !== void 0 && a.push(c);
          }
        }
      if (a.length === 0)
        return (0, ML().parse)(r, e);
      if (a.length === 1) {
        if (yield* [], typeof a[0].then == "function")
          throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're us\
ing a published plugin, you may need to upgrade your @babel/core version.");
        return a[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (a) {
      a.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (a.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: o,
        missingPlugin: l
      } = a;
      if (o) {
        let u = (0, jee().codeFrameColumns)(r, {
          start: {
            line: o.line,
            column: o.column + 1
          }
        }, {
          highlightCode: s
        });
        l ? a.message = `${i}: ` + (0, fdt.default)(l[0], o, u, i) : a.message = `${i}: ${a.message}

` + u, a.code = "BABEL_PARSE_ERROR";
      }
      throw a;
    }
  }
  n(ddt, "parser");
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var Ree = g((qL) => {
  "use strict";
  Object.defineProperty(qL, "__esModule", {
    value: !0
  });
  qL.default = mdt;
  function RL(t, e) {
    if (t !== null) {
      if (e.has(t)) return e.get(t);
      let s;
      if (Array.isArray(t)) {
        s = new Array(t.length), e.set(t, s);
        for (let i = 0; i < t.length; i++)
          s[i] = typeof t[i] != "object" ? t[i] : RL(t[i], e);
      } else {
        s = {}, e.set(t, s);
        let i = Object.keys(t);
        for (let r = 0; r < i.length; r++) {
          let a = i[r];
          s[a] = typeof t[a] != "object" ? t[a] : RL(t[a], e);
        }
      }
      return s;
    }
    return t;
  }
  n(RL, "deepClone");
  function mdt(t) {
    return typeof t != "object" ? t : RL(t, /* @__PURE__ */ new Map());
  }
  n(mdt, "_default");
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var $ee = g((WL) => {
  "use strict";
  Object.defineProperty(WL, "__esModule", {
    value: !0
  });
  WL.default = Pdt;
  function Kee() {
    let t = require("fs");
    return Kee = /* @__PURE__ */ n(function() {
      return t;
    }, "_fs"), t;
  }
  n(Kee, "_fs");
  function VL() {
    let t = require("path");
    return VL = /* @__PURE__ */ n(function() {
      return t;
    }, "_path"), t;
  }
  n(VL, "_path");
  function Vee() {
    let t = go();
    return Vee = /* @__PURE__ */ n(function() {
      return t;
    }, "_debug"), t;
  }
  n(Vee, "_debug");
  function Wee() {
    let t = fe();
    return Wee = /* @__PURE__ */ n(function() {
      return t;
    }, "_t"), t;
  }
  n(Wee, "_t");
  function SE() {
    let t = LL();
    return SE = /* @__PURE__ */ n(function() {
      return t;
    }, "_convertSourceMap"), t;
  }
  n(SE, "_convertSourceMap");
  var ydt = K2(), gdt = jL(), Tdt = Ree(), {
    file: bdt,
    traverseFast: xdt
  } = Wee(), UL = Vee()("babel:transform:file"), Sdt = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,
  qee = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function* Pdt(t, e, s, i) {
    if (s = `${s || ""}`, i) {
      if (i.type === "Program")
        i = bdt(i, [], []);
      else if (i.type !== "File")
        throw new Error("AST root must be a Program or File node");
      e.cloneInputAst && (i = (0, Tdt.default)(i));
    } else
      i = yield* (0, gdt.default)(t, e, s);
    let r = null;
    if (e.inputSourceMap !== !1) {
      if (typeof e.inputSourceMap == "object" && (r = SE().fromObject(e.inputSourceMap)), !r) {
        let a = Uee(Sdt, i);
        if (a)
          try {
            r = SE().fromComment("//" + a);
          } catch {
            UL("discarding unknown inline input sourcemap");
          }
      }
      if (!r) {
        let a = Uee(qee, i);
        if (typeof e.filename == "string" && a)
          try {
            let o = qee.exec(a), l = Kee().readFileSync(VL().resolve(VL().dirname(e.filename), o[1]), "utf8");
            r = SE().fromJSON(l);
          } catch (o) {
            UL("discarding unknown file input sourcemap", o);
          }
        else a && UL("discarding un-loadable file input sourcemap");
      }
    }
    return new ydt.default(e, {
      code: s,
      ast: i,
      inputMap: r
    });
  }
  n(Pdt, "normalizeFile");
  function KL(t, e, s) {
    return e && (e = e.filter(({
      value: i
    }) => t.test(i) ? (s = i, !1) : !0)), [e, s];
  }
  n(KL, "extractCommentsFromList");
  function Uee(t, e) {
    let s = null;
    return xdt(e, (i) => {
      [i.leadingComments, s] = KL(t, i.leadingComments, s), [i.innerComments, s] = KL(t, i.innerComments, s), [i.trailingComments, s] = KL(t,
      i.trailingComments, s);
    }), s;
  }
  n(Uee, "extractComments");
});

// ../node_modules/@ampproject/remapping/dist/remapping.umd.js
var Hee = g(($L, HL) => {
  (function(t, e) {
    typeof $L == "object" && typeof HL < "u" ? HL.exports = e(Nc(), ch()) : typeof define == "function" && define.amd ? define(["@jridgewell\
/trace-mapping", "@jridgewell/gen-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, t.remapping = e(t.traceMapping, t.genMapping));
  })($L, function(t, e) {
    "use strict";
    let s = /* @__PURE__ */ r("", -1, -1, "", null, !1), i = [];
    function r(m, T, b, E, w, K) {
      return { source: m, line: T, column: b, name: E, content: w, ignore: K };
    }
    n(r, "SegmentObject");
    function a(m, T, b, E, w) {
      return {
        map: m,
        sources: T,
        source: b,
        content: E,
        ignore: w
      };
    }
    n(a, "Source");
    function o(m, T) {
      return a(m, T, "", null, !1);
    }
    n(o, "MapSource");
    function l(m, T, b) {
      return a(null, i, m, T, b);
    }
    n(l, "OriginalSource");
    function u(m) {
      let T = new e.GenMapping({ file: m.map.file }), { sources: b, map: E } = m, w = E.names, K = t.decodedMappings(E);
      for (let he = 0; he < K.length; he++) {
        let de = K[he];
        for (let me = 0; me < de.length; me++) {
          let ve = de[me], ye = ve[0], ge = s;
          if (ve.length !== 1) {
            let qe = b[ve[1]];
            if (ge = c(qe, ve[2], ve[3], ve.length === 5 ? w[ve[4]] : ""), ge == null)
              continue;
          }
          let { column: oe, line: Ae, name: xt, content: kt, source: Oe, ignore: ke } = ge;
          e.maybeAddSegment(T, he, ye, Oe, Ae, oe, xt), Oe && kt != null && e.setSourceContent(T, Oe, kt), ke && e.setIgnore(T, Oe, !0);
        }
      }
      return T;
    }
    n(u, "traceMappings");
    function c(m, T, b, E) {
      if (!m.map)
        return r(m.source, T, b, E, m.content, m.ignore);
      let w = t.traceSegment(m.map, T, b);
      return w == null ? null : w.length === 1 ? s : c(m.sources[w[1]], w[2], w[3], w.length === 5 ? m.map.names[w[4]] : E);
    }
    n(c, "originalPositionFor");
    function p(m) {
      return Array.isArray(m) ? m : [m];
    }
    n(p, "asArray");
    function h(m, T) {
      let b = p(m).map((K) => new t.TraceMap(K, "")), E = b.pop();
      for (let K = 0; K < b.length; K++)
        if (b[K].sources.length > 1)
          throw new Error(`Transformation map ${K} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
      let w = f(E, T, "", 0);
      for (let K = b.length - 1; K >= 0; K--)
        w = o(b[K], [w]);
      return w;
    }
    n(h, "buildSourceMapTree");
    function f(m, T, b, E) {
      let { resolvedSources: w, sourcesContent: K, ignoreList: he } = m, de = E + 1, me = w.map((ve, ye) => {
        let ge = {
          importer: b,
          depth: de,
          source: ve || "",
          content: void 0,
          ignore: void 0
        }, oe = T(ge.source, ge), { source: Ae, content: xt, ignore: kt } = ge;
        if (oe)
          return f(new t.TraceMap(oe, Ae), T, Ae, de);
        let Oe = xt !== void 0 ? xt : K ? K[ye] : null, ke = kt !== void 0 ? kt : he ? he.includes(ye) : !1;
        return l(Ae, Oe, ke);
      });
      return o(m, me);
    }
    n(f, "build");
    class d {
      static {
        n(this, "SourceMap");
      }
      constructor(T, b) {
        let E = b.decodedMappings ? e.toDecodedMap(T) : e.toEncodedMap(T);
        this.version = E.version, this.file = E.file, this.mappings = E.mappings, this.names = E.names, this.ignoreList = E.ignoreList, this.
        sourceRoot = E.sourceRoot, this.sources = E.sources, b.excludeContent || (this.sourcesContent = E.sourcesContent);
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    function y(m, T, b) {
      let E = typeof b == "object" ? b : { excludeContent: !!b, decodedMappings: !1 }, w = h(m, T);
      return new d(u(w), E);
    }
    return n(y, "remapping"), y;
  });
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var Xee = g((JL) => {
  "use strict";
  Object.defineProperty(JL, "__esModule", {
    value: !0
  });
  JL.default = Edt;
  function Yee() {
    let t = Hee();
    return Yee = /* @__PURE__ */ n(function() {
      return t;
    }, "_remapping"), t;
  }
  n(Yee, "_remapping");
  function Edt(t, e, s) {
    let i = s.replace(/\\/g, "/"), r = !1, a = Yee()(Jee(e), (o, l) => o === i && !r ? (r = !0, l.source = "", Jee(t)) : null);
    return typeof t.sourceRoot == "string" && (a.sourceRoot = t.sourceRoot), Object.assign({}, a);
  }
  n(Edt, "mergeSourceMap");
  function Jee(t) {
    return Object.assign({}, t, {
      sourceRoot: null
    });
  }
  n(Jee, "rootless");
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var Gee = g((XL) => {
  "use strict";
  Object.defineProperty(XL, "__esModule", {
    value: !0
  });
  XL.default = vdt;
  function zee() {
    let t = LL();
    return zee = /* @__PURE__ */ n(function() {
      return t;
    }, "_convertSourceMap"), t;
  }
  n(zee, "_convertSourceMap");
  function YL() {
    let t = $x();
    return YL = /* @__PURE__ */ n(function() {
      return t;
    }, "_generator"), t;
  }
  n(YL, "_generator");
  var Adt = Xee();
  function vdt(t, e) {
    let {
      opts: s,
      ast: i,
      code: r,
      inputMap: a
    } = e, {
      generatorOpts: o
    } = s;
    o.inputSourceMap = a?.toObject();
    let l = [];
    for (let h of t)
      for (let f of h) {
        let {
          generatorOverride: d
        } = f;
        if (d) {
          let y = d(i, o, r, YL().default);
          y !== void 0 && l.push(y);
        }
      }
    let u;
    if (l.length === 0)
      u = (0, YL().default)(i, o, r);
    else if (l.length === 1) {
      if (u = l[0], typeof u.then == "function")
        throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're usi\
ng a published plugin, you may need to upgrade your @babel/core version.");
    } else
      throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: c,
      decodedMap: p = u.map
    } = u;
    return u.__mergedMap ? p = Object.assign({}, u.map) : p && (a ? p = (0, Adt.default)(a.toObject(), p, o.sourceFileName) : p = u.map), (s.
    sourceMaps === "inline" || s.sourceMaps === "both") && (c += `
` + zee().fromObject(p).toComment()), s.sourceMaps === "inline" && (p = null), {
      outputCode: c,
      outputMap: p
    };
  }
  n(vdt, "generateCode");
});

// ../node_modules/@babel/core/lib/transformation/index.js
var PE = g((QL) => {
  "use strict";
  Object.defineProperty(QL, "__esModule", {
    value: !0
  });
  QL.run = Odt;
  function GL() {
    let t = zl();
    return GL = /* @__PURE__ */ n(function() {
      return t;
    }, "_traverse"), t;
  }
  n(GL, "_traverse");
  var Cdt = Iee(), wdt = _ee(), Idt = _L(), Ndt = $ee(), kdt = Gee(), Ddt = _P(), zL = Zc();
  function* Odt(t, e, s) {
    let i = yield* (0, Ndt.default)(t.passes, (0, Idt.default)(t), e, s), r = i.opts;
    try {
      yield* _dt(i, t.passes);
    } catch (c) {
      var a;
      throw c.message = `${(a = r.filename) != null ? a : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_TRANSFORM_ERROR"), c;
    }
    let o, l;
    try {
      r.code !== !1 && ({
        outputCode: o,
        outputMap: l
      } = (0, kdt.default)(t.passes, i));
    } catch (c) {
      var u;
      throw c.message = `${(u = r.filename) != null ? u : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_GENERATE_ERROR"), c;
    }
    return {
      metadata: i.metadata,
      options: r,
      ast: r.ast === !0 ? i.ast : null,
      code: o === void 0 ? null : o,
      map: l === void 0 ? null : l,
      sourceType: i.ast.program.sourceType,
      externalDependencies: (0, Ddt.flattenToSet)(t.externalDependencies)
    };
  }
  n(Odt, "run");
  function* _dt(t, e) {
    let s = yield* (0, zL.isAsync)();
    for (let i of e) {
      let r = [], a = [], o = [];
      for (let u of i.concat([(0, wdt.default)()])) {
        let c = new Cdt.default(t, u.key, u.options, s);
        r.push([u, c]), a.push(c), o.push(u.visitor);
      }
      for (let [u, c] of r)
        u.pre && (yield* (0, zL.maybeAsync)(u.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, t));
      let l = GL().default.visitors.merge(o, a, t.opts.wrapPluginVisitorMethod);
      (0, GL().default)(t.ast, l, t.scope);
      for (let [u, c] of r)
        u.post && (yield* (0, zL.maybeAsync)(u.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, t));
    }
  }
  n(_dt, "transformFile");
});

// ../node_modules/@babel/core/lib/transform-file.js
var eB = g((IT) => {
  "use strict";
  Object.defineProperty(IT, "__esModule", {
    value: !0
  });
  IT.transformFile = Fdt;
  IT.transformFileAsync = Rdt;
  IT.transformFileSync = jdt;
  function Qee() {
    let t = ha();
    return Qee = /* @__PURE__ */ n(function() {
      return t;
    }, "_gensync"), t;
  }
  n(Qee, "_gensync");
  var Ldt = dm(), Bdt = PE(), Mdt = EP(), ZL = Qee()(function* (t, e) {
    let s = Object.assign({}, e, {
      filename: t
    }), i = yield* (0, Ldt.default)(s);
    if (i === null) return null;
    let r = yield* Mdt.readFile(t, "utf8");
    return yield* (0, Bdt.run)(i, r);
  });
  function Fdt(...t) {
    ZL.errback(...t);
  }
  n(Fdt, "transformFile");
  function jdt(...t) {
    return ZL.sync(...t);
  }
  n(jdt, "transformFileSync");
  function Rdt(...t) {
    return ZL.async(...t);
  }
  n(Rdt, "transformFileAsync");
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var ete = g((O$s, Zee) => {
  Zee.exports = /* @__PURE__ */ n(function(e) {
    return import(e);
  }, "import_");
});

// ../node_modules/@babel/preset-typescript/package.json
var tte = g((L$s, qdt) => {
  qdt.exports = {
    name: "@babel/preset-typescript",
    version: "7.27.0",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.26.5",
      "@babel/helper-validator-option": "^7.25.9",
      "@babel/plugin-syntax-jsx": "^7.25.9",
      "@babel/plugin-transform-modules-commonjs": "^7.26.3",
      "@babel/plugin-transform-typescript": "^7.27.0"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.26.10",
      "@babel/helper-plugin-test-runner": "^7.25.9"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var mm = g((NT) => {
  "use strict";
  Object.defineProperty(NT, "__esModule", {
    value: !0
  });
  NT.declare = ste;
  NT.declarePreset = void 0;
  var tB = {
    assertVersion: /* @__PURE__ */ n((t) => (e) => {
      Kdt(e, t.version);
    }, "assertVersion")
  };
  Object.assign(tB, {
    targets: /* @__PURE__ */ n(() => () => ({}), "targets"),
    assumption: /* @__PURE__ */ n(() => () => {
    }, "assumption"),
    addExternalDependency: /* @__PURE__ */ n(() => () => {
    }, "addExternalDependency")
  });
  function ste(t) {
    return (e, s, i) => {
      var r;
      let a;
      for (let l of Object.keys(tB)) {
        var o;
        e[l] || ((o = a) != null || (a = Udt(e)), a[l] = tB[l](a));
      }
      return t((r = a) != null ? r : e, s || {}, i);
    };
  }
  n(ste, "declare");
  var B$s = NT.declarePreset = ste;
  function Udt(t) {
    let e = null;
    return typeof t.version == "string" && /^7\./.test(t.version) && (e = Object.getPrototypeOf(t), e && (!hasOwnProperty.call(e, "version") ||
    !hasOwnProperty.call(e, "transform") || !hasOwnProperty.call(e, "template") || !hasOwnProperty.call(e, "types")) && (e = null)), Object.
    assign({}, e, t);
  }
  n(Udt, "copyApiObject");
  function Kdt(t, e) {
    if (typeof t == "number") {
      if (!Number.isInteger(t))
        throw new Error("Expected string or integer value.");
      t = `^${t}.0.0-0`;
    }
    if (typeof t != "string")
      throw new Error("Expected string or integer value.");
    let s = Error.stackTraceLimit;
    typeof s == "number" && s < 25 && (Error.stackTraceLimit = 25);
    let i;
    throw e.slice(0, 2) === "7." ? i = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${e}". You'll need to update your @b\
abel/core version.`) : i = new Error(`Requires Babel "${t}", but was loaded with "${e}". If you are sure you have a compatible version of @b\
abel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for\
 the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof s == "number" && (Error.stackTraceLimit =
    s), Object.assign(i, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: e,
      range: t
    });
  }
  n(Kdt, "throwVersionError");
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var ite = g((EE) => {
  "use strict";
  Object.defineProperty(EE, "__esModule", {
    value: !0
  });
  EE.default = void 0;
  var Vdt = mm();
  sB = /* @__PURE__ */ n(function(t, e) {
    let s = [];
    t.forEach((i, r) => {
      (Array.isArray(i) ? i[0] : i) === e && s.unshift(r);
    });
    for (let i of s)
      t.splice(i, 1);
  }, "removePlugin");
  var sB, j$s = EE.default = (0, Vdt.declare)((t, e) => {
    t.assertVersion(7);
    let {
      disallowAmbiguousJSXLike: s,
      dts: i
    } = e;
    var {
      isTSX: r
    } = e;
    return {
      name: "syntax-typescript",
      manipulateOptions(a, o) {
        {
          let {
            plugins: l
          } = o;
          sB(l, "flow"), sB(l, "jsx"), l.push("objectRestSpread", "classProperties"), r && l.push("jsx");
        }
        o.plugins.push(["typescript", {
          disallowAmbiguousJSXLike: s,
          dts: i
        }]);
      }
    };
  });
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var iB = g((ys) => {
  "use strict";
  Object.defineProperty(ys, "__esModule", {
    value: !0
  });
  ys.Var = ys.User = ys.Statement = ys.SpreadProperty = ys.Scope = ys.RestProperty = ys.ReferencedMemberExpression = ys.ReferencedIdentifier =
  ys.Referenced = ys.Pure = ys.NumericLiteralTypeAnnotation = ys.Generated = ys.ForAwaitStatement = ys.Flow = ys.Expression = ys.ExistentialTypeParam =
  ys.BlockScoped = ys.BindingIdentifier = void 0;
  var U$s = ys.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], K$s = ys.ReferencedMemberExpression = ["MemberExpression"], V$s = ys.
  BindingIdentifier = ["Identifier"], W$s = ys.Statement = ["Statement"], $$s = ys.Expression = ["Expression"], H$s = ys.Scope = ["Scopable",
  "Pattern"], J$s = ys.Referenced = null, Y$s = ys.BlockScoped = null, X$s = ys.Var = ["VariableDeclaration"], z$s = ys.User = null, G$s = ys.
  Generated = null, Q$s = ys.Pure = null, Z$s = ys.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], eHs = ys.RestProperty =
  ["RestElement"], tHs = ys.SpreadProperty = ["RestElement"], sHs = ys.ExistentialTypeParam = ["ExistsTypeAnnotation"], iHs = ys.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], rHs = ys.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var nB = g((Cr) => {
  "use strict";
  Object.defineProperty(Cr, "__esModule", {
    value: !0
  });
  Cr.isBindingIdentifier = hmt;
  Cr.isBlockScoped = gmt;
  Cr.isExpression = dmt;
  Cr.isFlow = Pmt;
  Cr.isForAwaitStatement = vmt;
  Cr.isGenerated = xmt;
  Cr.isPure = Smt;
  Cr.isReferenced = ymt;
  Cr.isReferencedIdentifier = cmt;
  Cr.isReferencedMemberExpression = pmt;
  Cr.isRestProperty = Emt;
  Cr.isScope = mmt;
  Cr.isSpreadProperty = Amt;
  Cr.isStatement = fmt;
  Cr.isUser = bmt;
  Cr.isVar = Tmt;
  var Wdt = fe(), {
    isBinding: $dt,
    isBlockScoped: Hdt,
    isExportDeclaration: Jdt,
    isExpression: Ydt,
    isFlow: Xdt,
    isForStatement: zdt,
    isForXStatement: Gdt,
    isIdentifier: rte,
    isImportDeclaration: Qdt,
    isImportSpecifier: Zdt,
    isJSXIdentifier: emt,
    isJSXMemberExpression: tmt,
    isMemberExpression: smt,
    isRestElement: nte,
    isReferenced: rB,
    isScope: imt,
    isStatement: rmt,
    isVar: nmt,
    isVariableDeclaration: amt,
    react: omt,
    isForOfStatement: lmt
  } = Wdt, {
    isCompatTag: umt
  } = omt;
  function cmt(t) {
    let {
      node: e,
      parent: s
    } = this;
    if (!rte(e, t) && !tmt(s, t))
      if (emt(e, t)) {
        if (umt(e.name)) return !1;
      } else
        return !1;
    return rB(e, s, this.parentPath.parent);
  }
  n(cmt, "isReferencedIdentifier");
  function pmt() {
    let {
      node: t,
      parent: e
    } = this;
    return smt(t) && rB(t, e);
  }
  n(pmt, "isReferencedMemberExpression");
  function hmt() {
    let {
      node: t,
      parent: e
    } = this, s = this.parentPath.parent;
    return rte(t) && $dt(t, e, s);
  }
  n(hmt, "isBindingIdentifier");
  function fmt() {
    let {
      node: t,
      parent: e
    } = this;
    return rmt(t) ? !(amt(t) && (Gdt(e, {
      left: t
    }) || zdt(e, {
      init: t
    }))) : !1;
  }
  n(fmt, "isStatement");
  function dmt() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : Ydt(this.node);
  }
  n(dmt, "isExpression");
  function mmt() {
    return imt(this.node, this.parent);
  }
  n(mmt, "isScope");
  function ymt() {
    return rB(this.node, this.parent);
  }
  n(ymt, "isReferenced");
  function gmt() {
    return Hdt(this.node);
  }
  n(gmt, "isBlockScoped");
  function Tmt() {
    return nmt(this.node);
  }
  n(Tmt, "isVar");
  function bmt() {
    return this.node && !!this.node.loc;
  }
  n(bmt, "isUser");
  function xmt() {
    return !this.isUser();
  }
  n(xmt, "isGenerated");
  function Smt(t) {
    return this.scope.isPure(this.node, t);
  }
  n(Smt, "isPure");
  function Pmt() {
    let {
      node: t
    } = this;
    return Xdt(t) ? !0 : Qdt(t) ? t.importKind === "type" || t.importKind === "typeof" : Jdt(t) ? t.exportKind === "type" : Zdt(t) ? t.importKind ===
    "type" || t.importKind === "typeof" : !1;
  }
  n(Pmt, "isFlow");
  function Emt() {
    var t;
    return nte(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectPattern());
  }
  n(Emt, "isRestProperty");
  function Amt() {
    var t;
    return nte(this.node) && ((t = this.parentPath) == null ? void 0 : t.isObjectExpression());
  }
  n(Amt, "isSpreadProperty");
  function vmt() {
    return lmt(this.node, {
      await: !0
    });
  }
  n(vmt, "isForAwaitStatement");
  Cr.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Cr.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/visitors.js
var AE = g(($h) => {
  "use strict";
  Object.defineProperty($h, "__esModule", {
    value: !0
  });
  $h.environmentVisitor = _mt;
  $h.explode = yte;
  $h.isExplodedVisitor = mte;
  $h.merge = Tte;
  $h.verify = gte;
  var dte = iB(), Cmt = nB(), wmt = fe(), ate = dl(), {
    DEPRECATED_KEYS: ote,
    DEPRECATED_ALIASES: lte,
    FLIPPED_ALIAS_KEYS: ute,
    TYPES: Imt,
    __internal__deprecationWarning: cte
  } = wmt;
  function Nmt(t) {
    return t in dte;
  }
  n(Nmt, "isVirtualType");
  function mte(t) {
    return t?._exploded;
  }
  n(mte, "isExplodedVisitor");
  function yte(t) {
    if (mte(t)) return t;
    t._exploded = !0;
    for (let e of Object.keys(t)) {
      if (Wh(e)) continue;
      let s = e.split("|");
      if (s.length === 1) continue;
      let i = t[e];
      delete t[e];
      for (let r of s)
        t[r] = i;
    }
    gte(t), delete t.__esModule, kmt(t), fte(t);
    for (let e of Object.keys(t)) {
      if (Wh(e) || !Nmt(e)) continue;
      let s = t[e];
      for (let r of Object.keys(s))
        s[r] = Dmt(e, s[r]);
      delete t[e];
      let i = dte[e];
      if (i !== null)
        for (let r of i)
          t[r] ? kT(t[r], s) : t[r] = s;
      else
        kT(t, s);
    }
    for (let e of Object.keys(t)) {
      if (Wh(e)) continue;
      let s = ute[e];
      if (e in ote) {
        let r = ote[e];
        cte(e, r, "Visitor "), s = [r];
      } else if (e in lte) {
        let r = lte[e];
        cte(e, r, "Visitor "), s = ute[r];
      }
      if (!s) continue;
      let i = t[e];
      delete t[e];
      for (let r of s) {
        let a = t[r];
        a ? kT(a, i) : t[r] = Object.assign({}, i);
      }
    }
    for (let e of Object.keys(t))
      Wh(e) || fte(t[e]);
    return t;
  }
  n(yte, "explode$1");
  function gte(t) {
    if (!t._verified) {
      if (typeof t == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let e of Object.keys(t)) {
        if ((e === "enter" || e === "exit") && pte(e, t[e]), Wh(e)) continue;
        if (!Imt.includes(e))
          throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type in @babel/traverse 7.27.0`);
        let s = t[e];
        if (typeof s == "object")
          for (let i of Object.keys(s))
            if (i === "enter" || i === "exit")
              pte(`${e}.${i}`, s[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${i}`);
      }
      t._verified = !0;
    }
  }
  n(gte, "verify$1");
  function pte(t, e) {
    let s = [].concat(e);
    for (let i of s)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${t} with type ${typeof i}`);
  }
  n(pte, "validateVisitorMethods");
  function Tte(t, e = [], s) {
    let i = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(i, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(i, "_verified", {
      enumerable: !1
    });
    for (let r = 0; r < t.length; r++) {
      let a = yte(t[r]), o = e[r], l = a;
      (o || s) && (l = hte(l, o, s)), kT(i, l);
      for (let u of Object.keys(a)) {
        if (Wh(u)) continue;
        let c = a[u];
        (o || s) && (c = hte(c, o, s));
        let p = i[u] || (i[u] = {});
        kT(p, c);
      }
    }
    return i;
  }
  n(Tte, "merge");
  function hte(t, e, s) {
    let i = {};
    for (let r of ["enter", "exit"]) {
      let a = t[r];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return e && (l = /* @__PURE__ */ n(function(u) {
          o.call(e, u, e);
        }, "newFn")), s && (l = s(e?.key, r, l)), l !== o && (l.toString = () => o.toString()), l;
      }), i[r] = a);
    }
    return i;
  }
  n(hte, "wrapWithStateOrWrapper");
  function kmt(t) {
    for (let e of Object.keys(t)) {
      if (Wh(e)) continue;
      let s = t[e];
      typeof s == "function" && (t[e] = {
        enter: s
      });
    }
  }
  n(kmt, "ensureEntranceObjects");
  function fte(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit]);
  }
  n(fte, "ensureCallbackArrays");
  function Dmt(t, e) {
    let s = `is${t}`, i = Cmt[s], r = /* @__PURE__ */ n(function(a) {
      if (i.call(a))
        return e.apply(this, arguments);
    }, "newFn");
    return r.toString = () => e.toString(), r;
  }
  n(Dmt, "wrapCheck");
  function Wh(t) {
    return t[0] === "_" || t === "enter" || t === "exit" || t === "shouldSkip" || t === "denylist" || t === "noScope" || t === "skipKeys" ||
    t === "blacklist";
  }
  n(Wh, "shouldIgnoreKey");
  function kT(t, e) {
    for (let s of ["enter", "exit"])
      e[s] && (t[s] = [].concat(t[s] || [], e[s]));
  }
  n(kT, "mergePair");
  var Omt = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() :
      ate.requeueComputedKeyAndDecorators.call(t)));
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), t.requeueComputedKeyAndDecorators ? t.requeueComputedKeyAndDecorators() : ate.requeueComputedKeyAndDecorators.
      call(t));
    }
  };
  function _mt(t) {
    return Tte([Omt, t]);
  }
  n(_mt, "environmentVisitor");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var bte = g((CE) => {
  "use strict";
  Object.defineProperty(CE, "__esModule", {
    value: !0
  });
  CE.default = void 0;
  var vE = fe(), Lmt = vE, Bmt = wE(), Mmt = AE(), Fmt = dl(), {
    getAssignmentIdentifiers: jmt
  } = Lmt, Rmt = {
    ReferencedIdentifier({
      node: t
    }, e) {
      t.name === e.oldName && (t.name = e.newName);
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) || (t.skip(), t.isMethod() && (t.requeueComputedKeyAndDecorators ? t.
      requeueComputedKeyAndDecorators() : Fmt.requeueComputedKeyAndDecorators.call(t)));
    },
    ObjectProperty({
      node: t,
      scope: e
    }, s) {
      let {
        name: i
      } = t.key;
      if (t.shorthand && (i === s.oldName || i === s.newName) && e.getBindingIdentifier(i) === s.binding.identifier) {
        t.shorthand = !1;
        {
          var r;
          (r = t.extra) != null && r.shorthand && (t.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(t, e) {
      if (t.isVariableDeclaration()) return;
      let s = t.isAssignmentExpression() ? jmt(t.node) : t.getOuterBindingIdentifiers();
      for (let i in s)
        i === e.oldName && (s[i].name = e.newName);
    }
  }, aB = class {
    static {
      n(this, "Renamer");
    }
    constructor(e, s, i) {
      this.newName = i, this.oldName = s, this.binding = e;
    }
    maybeConvertFromExportDeclaration(e) {
      let s = e.parentPath;
      if (s.isExportDeclaration()) {
        if (s.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = s.node;
          if (vE.isDeclaration(i) && !i.id)
            return;
        }
        s.isExportAllDeclaration() || s.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(e) {
      return e;
    }
    maybeConvertFromClassFunctionExpression(e) {
      return e;
    }
    rename() {
      let {
        binding: e,
        oldName: s,
        newName: i
      } = this, {
        scope: r,
        path: a
      } = e, o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression());
      o && o.getOuterBindingIdentifiers()[s] === e.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || r.block, u = {
        discriminant: !0
      };
      vE.isMethod(l) && (l.computed && (u.key = !0), vE.isObjectMethod(l) || (u.decorators = !0)), (0, Bmt.traverseNode)(l, (0, Mmt.explode)(
      Rmt), r, this, r.path, u), arguments[0] || (r.removeOwnBinding(s), r.bindings[i] = e, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  CE.default = aB;
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/scope/binding.js
var xte = g((IE) => {
  "use strict";
  Object.defineProperty(IE, "__esModule", {
    value: !0
  });
  IE.default = void 0;
  var oB = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: e,
      scope: s,
      path: i,
      kind: r
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e, this.scope = s, this.path = i, this.kind = r,
      (r === "var" || r === "hoisted") && qmt(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(e) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = e);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(e) {
      this.constant = !1, !this.constantViolations.includes(e) && this.constantViolations.push(e);
    }
    reference(e) {
      this.referencePaths.includes(e) || (this.referenced = !0, this.references++, this.referencePaths.push(e));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  IE.default = oB;
  function qmt(t) {
    let e = !t.isVariableDeclarator() || t.node.init;
    for (let {
      parentPath: s,
      key: i
    } = t; s; {
      parentPath: s,
      key: i
    } = s) {
      if (s.isFunctionParent()) return !1;
      if (i === "left" && s.isForXStatement() || e && i === "body" && s.isLoop())
        return !0;
    }
    return !1;
  }
  n(qmt, "isInitInLoop");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/cache.js
var Hh = g((da) => {
  "use strict";
  Object.defineProperty(da, "__esModule", {
    value: !0
  });
  da.clear = Kmt;
  da.clearPath = Ste;
  da.clearScope = Pte;
  da.getCachedPaths = Vmt;
  da.getOrCreateCachedPaths = Wmt;
  da.scope = da.path = void 0;
  var NE = da.path = /* @__PURE__ */ new WeakMap(), Umt = da.scope = /* @__PURE__ */ new WeakMap();
  function Kmt() {
    Ste(), Pte();
  }
  n(Kmt, "clear");
  function Ste() {
    da.path = NE = /* @__PURE__ */ new WeakMap();
  }
  n(Ste, "clearPath");
  function Pte() {
    da.scope = Umt = /* @__PURE__ */ new WeakMap();
  }
  n(Pte, "clearScope");
  var lB = Object.freeze({});
  function Vmt(t, e) {
    var s;
    return t = null, (s = NE.get(t ?? lB)) == null ? void 0 : s.get(e);
  }
  n(Vmt, "getCachedPaths");
  function Wmt(t, e) {
    t = null;
    let s = NE.get(t ?? lB);
    s || NE.set(t ?? lB, s = /* @__PURE__ */ new WeakMap());
    let i = s.get(e);
    return i || s.set(e, i = /* @__PURE__ */ new Map()), i;
  }
  n(Wmt, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/scope/index.js
var fB = g((kE) => {
  "use strict";
  Object.defineProperty(kE, "__esModule", {
    value: !0
  });
  kE.default = void 0;
  var $mt = bte(), Dte = Oo(), Hmt = xte(), Jmt = dd(), Ote = fe(), _te = Ote, Ete = Hh(), {
    assignmentExpression: Ymt,
    callExpression: Ate,
    cloneNode: vte,
    getBindingIdentifiers: Lte,
    identifier: Yh,
    isArrayExpression: Bte,
    isBinary: Xmt,
    isCallExpression: Cte,
    isClass: zmt,
    isClassBody: Gmt,
    isClassDeclaration: Qmt,
    isExportAllDeclaration: Mte,
    isExportDefaultDeclaration: Zmt,
    isExportNamedDeclaration: uB,
    isFunctionDeclaration: eyt,
    isIdentifier: Jh,
    isImportDeclaration: cB,
    isLiteral: tyt,
    isMemberExpression: syt,
    isMethod: iyt,
    isModuleSpecifier: ryt,
    isNullLiteral: nyt,
    isObjectExpression: ayt,
    isProperty: oyt,
    isPureish: lyt,
    isRegExpLiteral: uyt,
    isSuper: cyt,
    isTaggedTemplateExpression: pyt,
    isTemplateLiteral: Fte,
    isThisExpression: wte,
    isUnaryExpression: hyt,
    isVariableDeclaration: fyt,
    expressionStatement: dyt,
    matchesPattern: Ite,
    memberExpression: pB,
    numericLiteral: myt,
    toIdentifier: yyt,
    variableDeclaration: gyt,
    variableDeclarator: Tyt,
    isRecordExpression: byt,
    isTupleExpression: xyt,
    isObjectProperty: Syt,
    isTopicReference: Nte,
    isMetaProperty: Pyt,
    isPrivateName: Eyt,
    isExportDeclaration: Ayt,
    buildUndefinedNode: vyt,
    sequenceExpression: Cyt
  } = Ote;
  function wi(t, e) {
    switch (t?.type) {
      default:
        if (cB(t) || Ayt(t)) {
          var s;
          if ((Mte(t) || uB(t) || cB(t)) && t.source)
            wi(t.source, e);
          else if ((uB(t) || cB(t)) && (s = t.specifiers) != null && s.length)
            for (let i of t.specifiers) wi(i, e);
          else (Zmt(t) || uB(t)) && t.declaration && wi(t.declaration, e);
        } else ryt(t) ? wi(t.local, e) : tyt(t) && !nyt(t) && !uyt(t) && !Fte(t) && e.push(t.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        wi(t.object, e), wi(t.property, e);
        break;
      case "Identifier":
      case "JSXIdentifier":
        e.push(t.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        wi(t.callee, e);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of t.properties)
          wi(i, e);
        break;
      case "SpreadElement":
      case "RestElement":
        wi(t.argument, e);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        wi(t.key, e);
        break;
      case "ThisExpression":
        e.push("this");
        break;
      case "Super":
        e.push("super");
        break;
      case "Import":
        e.push("import");
        break;
      case "DoExpression":
        e.push("do");
        break;
      case "YieldExpression":
        e.push("yield"), wi(t.argument, e);
        break;
      case "AwaitExpression":
        e.push("await"), wi(t.argument, e);
        break;
      case "AssignmentExpression":
        wi(t.left, e);
        break;
      case "VariableDeclarator":
        wi(t.id, e);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        wi(t.id, e);
        break;
      case "PrivateName":
        wi(t.id, e);
        break;
      case "ParenthesizedExpression":
        wi(t.expression, e);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        wi(t.argument, e);
        break;
      case "MetaProperty":
        wi(t.meta, e), wi(t.property, e);
        break;
      case "JSXElement":
        wi(t.openingElement, e);
        break;
      case "JSXOpeningElement":
        wi(t.name, e);
        break;
      case "JSXFragment":
        wi(t.openingFragment, e);
        break;
      case "JSXOpeningFragment":
        e.push("Fragment");
        break;
      case "JSXNamespacedName":
        wi(t.namespace, e), wi(t.name, e);
        break;
    }
  }
  n(wi, "gatherNodeParts");
  function kte(t) {
    t.references = /* @__PURE__ */ Object.create(null), t.bindings = /* @__PURE__ */ Object.create(null), t.globals = /* @__PURE__ */ Object.
    create(null), t.uids = /* @__PURE__ */ Object.create(null);
  }
  n(kte, "resetScope");
  hB = Symbol.for("should not be considered a local binding");
  var hB, wyt = {
    ForStatement(t) {
      let e = t.get("init");
      if (e.isVar()) {
        let {
          scope: s
        } = t;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", e);
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return;
      (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t);
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    TSImportEqualsDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    ReferencedIdentifier(t, e) {
      _te.isTSQualifiedName(t.parent) && t.parent.right === t.node || t.parentPath.isTSImportEqualsDeclaration() || e.references.push(t);
    },
    ForXStatement(t, e) {
      let s = t.get("left");
      if (s.isPattern() || s.isIdentifier())
        e.constantViolations.push(t);
      else if (s.isVar()) {
        let {
          scope: i
        } = t;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", s);
      }
    },
    ExportDeclaration: {
      exit(t) {
        let {
          node: e,
          scope: s
        } = t;
        if (Mte(e)) return;
        let i = e.declaration;
        if (Qmt(i) || eyt(i)) {
          let r = i.id;
          if (!r) return;
          let a = s.getBinding(r.name);
          a?.reference(t);
        } else if (fyt(i))
          for (let r of i.declarations)
            for (let a of Object.keys(Lte(r))) {
              let o = s.getBinding(a);
              o?.reference(t);
            }
      }
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t);
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t);
    },
    UnaryExpression(t, e) {
      t.node.operator === "delete" && e.constantViolations.push(t);
    },
    BlockScoped(t) {
      let e = t.scope;
      if (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id) {
        let r = t.node.id.name;
        t.scope.bindings[r] = t.scope.parent.getBinding(r);
      }
    },
    CatchClause(t) {
      t.scope.registerBinding("let", t);
    },
    Function(t) {
      let e = t.get("params");
      for (let s of e)
        t.scope.registerBinding("param", s);
      t.isFunctionExpression() && t.node.id && !t.node.id[hB] && t.scope.registerBinding("local", t.get("id"), t);
    },
    ClassExpression(t) {
      t.node.id && !t.node.id[hB] && t.scope.registerBinding("local", t.get("id"), t);
    },
    TSTypeAnnotation(t) {
      t.skip();
    }
  }, DT, Iyt = 0, Do = class t {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: s
      } = e, i = Ete.scope.get(s);
      if (i?.path === e)
        return i;
      Ete.scope.set(s, this), this.uid = Iyt++, this.block = s, this.path = e, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var e;
      let s, i = this.path;
      do {
        var r;
        let a = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, a && i.isMethod() && (i = i.parentPath), (r = i) != null && r.isScope() && (s = i);
      } while (i && !s);
      return (e = s) == null ? void 0 : e.scope;
    }
    generateDeclaredUidIdentifier(e) {
      let s = this.generateUidIdentifier(e);
      return this.push({
        id: s
      }), vte(s);
    }
    generateUidIdentifier(e) {
      return Yh(this.generateUid(e));
    }
    generateUid(e = "temp") {
      e = yyt(e).replace(/^_+/, "").replace(/\d+$/g, "");
      let s, i = 1;
      do
        s = `_${e}`, i > 1 && (s += i), i++;
      while (this.hasLabel(s) || this.hasBinding(s) || this.hasGlobal(s) || this.hasReference(s));
      let r = this.getProgramParent();
      return r.references[s] = !0, r.uids[s] = !0, s;
    }
    generateUidBasedOnNode(e, s) {
      let i = [];
      wi(e, i);
      let r = i.join("$");
      return r = r.replace(/^_/, "") || s || "ref", this.generateUid(r.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e, s) {
      return Yh(this.generateUidBasedOnNode(e, s));
    }
    isStatic(e) {
      if (wte(e) || cyt(e) || Nte(e))
        return !0;
      if (Jh(e)) {
        let s = this.getBinding(e.name);
        return s ? s.constant : this.hasBinding(e.name);
      }
      return !1;
    }
    maybeGenerateMemoised(e, s) {
      if (this.isStatic(e))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(e);
        return s ? i : (this.push({
          id: i
        }), vte(i));
      }
    }
    checkBlockScopedCollisions(e, s, i, r) {
      if (s === "param" || e.kind === "local") return;
      if (s === "let" || e.kind === "let" || e.kind === "const" || e.kind === "module" || e.kind === "param" && s === "const")
        throw this.path.hub.buildError(r, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(e, s) {
      let i = this.getBinding(e);
      i && (s || (s = this.generateUidIdentifier(e).name), new $mt.default(i, e, s).rename(arguments[2]));
    }
    dump() {
      let e = "-".repeat(60);
      console.log(e);
      let s = this;
      do {
        console.log("#", s.block.type);
        for (let i of Object.keys(s.bindings)) {
          let r = s.bindings[i];
          console.log(" -", i, {
            constant: r.constant,
            references: r.references,
            violations: r.constantViolations.length,
            kind: r.kind
          });
        }
      } while (s = s.parent);
      console.log(e);
    }
    hasLabel(e) {
      return !!this.getLabel(e);
    }
    getLabel(e) {
      return this.labels.get(e);
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e);
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement())
        this.registerLabel(e);
      else if (e.isFunctionDeclaration())
        this.registerBinding("hoisted", e.get("id"), e);
      else if (e.isVariableDeclaration()) {
        let s = e.get("declarations"), {
          kind: i
        } = e.node;
        for (let r of s)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, r);
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return;
        this.registerBinding("let", e);
      } else if (e.isImportDeclaration()) {
        let s = e.node.importKind === "type" || e.node.importKind === "typeof", i = e.get("specifiers");
        for (let r of i) {
          let a = s || r.isImportSpecifier() && (r.node.importKind === "type" || r.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", r);
        }
      } else if (e.isExportDeclaration()) {
        let s = e.get("declaration");
        (s.isClassDeclaration() || s.isFunctionDeclaration() || s.isVariableDeclaration()) && this.registerDeclaration(s);
      } else
        this.registerBinding("unknown", e);
    }
    buildUndefinedNode() {
      return vyt();
    }
    registerConstantViolation(e) {
      let s = e.getAssignmentIdentifiers();
      for (let r of Object.keys(s)) {
        var i;
        (i = this.getBinding(r)) == null || i.reassign(e);
      }
    }
    registerBinding(e, s, i = s) {
      if (!e) throw new ReferenceError("no `kind`");
      if (s.isVariableDeclaration()) {
        let o = s.get("declarations");
        for (let l of o)
          this.registerBinding(e, l);
        return;
      }
      let r = this.getProgramParent(), a = s.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        r.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, e, o, l);
          }
          u ? u.reassign(i) : this.bindings[o] = new Hmt.default({
            identifier: l,
            scope: this,
            path: i,
            kind: e
          });
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e;
    }
    hasUid(e) {
      let s = this;
      do
        if (s.uids[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasGlobal(e) {
      let s = this;
      do
        if (s.globals[e]) return !0;
      while (s = s.parent);
      return !1;
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e];
    }
    isPure(e, s) {
      if (Jh(e)) {
        let o = this.getBinding(e.name);
        return o ? s ? o.constant : !0 : !1;
      } else {
        if (wte(e) || Pyt(e) || Nte(e) || Eyt(e))
          return !0;
        if (zmt(e)) {
          var i;
          return e.superClass && !this.isPure(e.superClass, s) || ((i = e.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(e.
          body, s);
        } else if (Gmt(e)) {
          for (let o of e.body)
            if (!this.isPure(o, s)) return !1;
          return !0;
        } else {
          if (Xmt(e))
            return this.isPure(e.left, s) && this.isPure(e.right, s);
          if (Bte(e) || xyt(e)) {
            for (let o of e.elements)
              if (o !== null && !this.isPure(o, s)) return !1;
            return !0;
          } else if (ayt(e) || byt(e)) {
            for (let o of e.properties)
              if (!this.isPure(o, s)) return !1;
            return !0;
          } else if (iyt(e)) {
            var r;
            return !(e.computed && !this.isPure(e.key, s) || ((r = e.decorators) == null ? void 0 : r.length) > 0);
          } else if (oyt(e)) {
            var a;
            return !(e.computed && !this.isPure(e.key, s) || ((a = e.decorators) == null ? void 0 : a.length) > 0 || (Syt(e) || e.static) &&
            e.value !== null && !this.isPure(e.value, s));
          } else {
            if (hyt(e))
              return this.isPure(e.argument, s);
            if (Fte(e)) {
              for (let o of e.expressions)
                if (!this.isPure(o, s)) return !1;
              return !0;
            } else return pyt(e) ? Ite(e.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(e.quasi, s) : syt(e) ? !e.computed && Jh(e.object) && e.object.name === "Symbol" && Jh(e.property) && e.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : Cte(e) ? Ite(e.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && e.arguments.length === 1 && _te.isStringLiteral(e.arguments[0]) : lyt(e);
          }
        }
      }
    }
    setData(e, s) {
      return this.data[e] = s;
    }
    getData(e) {
      let s = this;
      do {
        let i = s.data[e];
        if (i != null) return i;
      } while (s = s.parent);
    }
    removeData(e) {
      let s = this;
      do
        s.data[e] != null && (s.data[e] = null);
      while (s = s.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let e = this.path;
      kte(this), this.data = /* @__PURE__ */ Object.create(null);
      let s = this;
      do {
        if (s.crawling) return;
        if (s.path.isProgram())
          break;
      } while (s = s.parent);
      let i = s, r = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, DT || (DT = Dte.default.visitors.merge([{
        Scope(a) {
          kte(a.scope);
        }
      }, wyt])), e.type !== "Program") {
        for (let o of DT.enter)
          o.call(r, e, r);
        let a = DT[e.type];
        if (a)
          for (let o of a.enter)
            o.call(r, e, r);
      }
      e.traverse(DT, r), this.crawling = !1;
      for (let a of r.assignments) {
        let o = a.getAssignmentIdentifiers();
        for (let l of Object.keys(o))
          a.scope.getBinding(l) || i.addGlobal(o[l]);
        a.scope.registerConstantViolation(a);
      }
      for (let a of r.references) {
        let o = a.scope.getBinding(a.node.name);
        o ? o.reference(a) : i.addGlobal(a.node);
      }
      for (let a of r.constantViolations)
        a.scope.registerConstantViolation(a);
    }
    push(e) {
      let s = this.path;
      s.isPattern() ? s = this.getPatternParent().path : !s.isBlockStatement() && !s.isProgram() && (s = this.getBlockParent().path), s.isSwitchStatement() &&
      (s = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: r,
        kind: a = "var",
        id: o
      } = e;
      if (!i && !r && (a === "var" || a === "let") && s.isFunction() && !s.node.name && Cte(s.parent, {
        callee: s.node
      }) && s.parent.arguments.length <= s.node.params.length && Jh(o)) {
        s.pushContainer("params", o), s.scope.registerBinding("param", s.get("params")[s.node.params.length - 1]);
        return;
      }
      (s.isLoop() || s.isCatchClause() || s.isFunction()) && (s.ensureBlock(), s = s.get("body"));
      let l = e._blockHoist == null ? 2 : e._blockHoist, u = `declaration:${a}:${l}`, c = !r && s.getData(u);
      if (!c) {
        let f = gyt(a, []);
        f._blockHoist = l, [c] = s.unshiftContainer("body", [f]), r || s.setData(u, c);
      }
      let p = Tyt(o, i), h = c.node.declarations.push(p);
      s.scope.registerBinding(a, c.get("declarations")[h - 1]);
    }
    getProgramParent() {
      let e = this;
      do
        if (e.path.isProgram())
          return e;
      while (e = e.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e = this;
      do
        if (e.path.isFunctionParent())
          return e;
      while (e = e.parent);
      return null;
    }
    getBlockParent() {
      let e = this;
      do
        if (e.path.isBlockParent())
          return e;
      while (e = e.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e = this;
      do
        if (!e.path.isPattern())
          return e.getBlockParent();
      while (e = e.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let e = /* @__PURE__ */ Object.create(null), s = this;
      do {
        for (let i of Object.keys(s.bindings))
          i in e || (e[i] = s.bindings[i]);
        s = s.parent;
      } while (s);
      return e;
    }
    bindingIdentifierEquals(e, s) {
      return this.getBindingIdentifier(e) === s;
    }
    getBinding(e) {
      let s = this, i;
      do {
        let a = s.getOwnBinding(e);
        if (a) {
          var r;
          if (!((r = i) != null && r.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && e === "arguments" && s.path.isFunction() && !s.path.isArrowFunctionExpression())
          break;
        i = s.path;
      } while (s = s.parent);
    }
    getOwnBinding(e) {
      return this.bindings[e];
    }
    getBindingIdentifier(e) {
      var s;
      return (s = this.getBinding(e)) == null ? void 0 : s.identifier;
    }
    getOwnBindingIdentifier(e) {
      let s = this.bindings[e];
      return s?.identifier;
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e);
    }
    hasBinding(e, s) {
      if (!e) return !1;
      let i, r, a;
      typeof s == "object" ? (i = s.noGlobals, r = s.noUids, a = s.upToScope) : typeof s == "boolean" && (i = s);
      let o = this;
      do {
        if (a === o)
          break;
        if (o.hasOwnBinding(e))
          return !0;
      } while (o = o.parent);
      return !!(!r && this.hasUid(e) || !i && t.globals.includes(e) || !i && t.contextVariables.includes(e));
    }
    parentHasBinding(e, s) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(e, s);
    }
    moveBindingTo(e, s) {
      let i = this.getBinding(e);
      i && (i.scope.removeOwnBinding(e), i.scope = s, s.bindings[e] = i);
    }
    removeOwnBinding(e) {
      delete this.bindings[e];
    }
    removeBinding(e) {
      var s;
      (s = this.getBinding(e)) == null || s.scope.removeOwnBinding(e);
      let i = this;
      do
        i.uids[e] && (i.uids[e] = !1);
      while (i = i.parent);
    }
    hoistVariables(e = (s) => this.push({
      id: s
    })) {
      this.crawl();
      let s = /* @__PURE__ */ new Set();
      for (let i of Object.keys(this.bindings)) {
        let r = this.bindings[i];
        if (!r) continue;
        let {
          path: a
        } = r;
        if (!a.isVariableDeclarator()) continue;
        let {
          parent: o,
          parentPath: l
        } = a;
        if (o.kind !== "var" || s.has(o)) continue;
        s.add(a.parent);
        let u, c = [];
        for (let p of o.declarations) {
          u ?? (u = p.id), p.init && c.push(Ymt("=", p.id, p.init));
          let h = Object.keys(Lte(p, !1, !0, !0));
          for (let f of h)
            e(Yh(f), p.init != null);
        }
        if (l.parentPath.isFor({
          left: o
        }))
          l.replaceWith(u);
        else if (c.length === 0)
          l.remove();
        else {
          let p = c.length === 1 ? c[0] : Cyt(c);
          l.parentPath.isForStatement({
            init: o
          }) ? l.replaceWith(p) : l.replaceWith(dyt(p));
        }
      }
    }
  };
  kE.default = Do;
  Do.globals = Object.keys(Jmt.builtin);
  Do.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  Do.prototype._renameFromMap = /* @__PURE__ */ n(function(e, s, i, r) {
    e[s] && (e[i] = r, e[s] = null);
  }, "_renameFromMap"), Do.prototype.traverse = function(t, e, s) {
    (0, Dte.default)(t, e, this, s, this.path);
  }, Do.prototype._generateUid = /* @__PURE__ */ n(function(e, s) {
    let i = e;
    return s > 1 && (i += s), `_${i}`;
  }, "_generateUid"), Do.prototype.toArray = /* @__PURE__ */ n(function(e, s, i) {
    if (Jh(e)) {
      let o = this.getBinding(e.name);
      if (o != null && o.constant && o.path.isGenericType("Array"))
        return e;
    }
    if (Bte(e))
      return e;
    if (Jh(e, {
      name: "arguments"
    }))
      return Ate(pB(pB(pB(Yh("Array"), Yh("prototype")), Yh("slice")), Yh("call")), [e]);
    let r, a = [e];
    return s === !0 ? r = "toConsumableArray" : typeof s == "number" ? (a.push(myt(s)), r = "slicedToArray") : r = "toArray", i && (a.unshift(
    this.path.hub.addHelper(r)), r = "maybeArrayLike"), Ate(this.path.hub.addHelper(r), a);
  }, "toArray"), Do.prototype.getAllBindingsOfKind = /* @__PURE__ */ n(function(...e) {
    let s = /* @__PURE__ */ Object.create(null);
    for (let i of e) {
      let r = this;
      do {
        for (let a of Object.keys(r.bindings)) {
          let o = r.bindings[a];
          o.kind === i && (s[a] = o);
        }
        r = r.parent;
      } while (r);
    }
    return s;
  }, "getAllBindingsOfKind"), Object.defineProperties(Do.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  });
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/source-map.js
var jte = g((DE) => {
  "use strict";
  Object.defineProperty(DE, "__esModule", {
    value: !0
  });
  DE.default = void 0;
  var ap = ch(), dB = Nc(), mB = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, s) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let r = this._map = new ap.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (i = e.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new dB.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, ap.setSourceContent)(r, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof s == "string" && !e.inputSourceMap)
        (0, ap.setSourceContent)(r, this._sourceFileName, s);
      else if (typeof s == "object")
        for (let o of Object.keys(s))
          (0, ap.setSourceContent)(r, o.replace(/\\/g, "/"), s[o]);
    }
    get() {
      return (0, ap.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, ap.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, ap.allMappings)(this._map));
    }
    mark(e, s, i, r, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (s != null)
        if (this._inputMap) {
          if (u = (0, dB.originalPositionFor)(this._inputMap, {
            line: s,
            column: i
          }), !u.name && a) {
            let c = (0, dB.originalPositionFor)(this._inputMap, a);
            c.name && (r = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: s,
            column: i
          };
      (0, ap.maybeAddMapping)(this._map, {
        name: r,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  DE.default = mB;
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/buffer.js
var Rte = g((OE) => {
  "use strict";
  Object.defineProperty(OE, "__esModule", {
    value: !0
  });
  OE.default = void 0;
  var yB = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, s) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = s;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(s.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let s = 0; s < 16; s++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, s, i, r, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = s, l.line = i, l.column = r, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, s = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = e ? e.get() : null;
          return s.map = i, i;
        },
        set map(i) {
          Object.defineProperty(s, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = e?.getRawMappings();
          return s.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(s, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return s;
    }
    append(e, s) {
      this._flush(), this._append(e, this._sourcePosition, s);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let s = this._sourcePosition;
      this._pushQueue(e, 1, s.line, s.column, s.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, s = this._queue;
      for (let i = 0; i < e; i++) {
        let r = s[i];
        this._appendChar(r.char, r.repeat, r);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, s, i) {
      if (this._last = e, e === -1) {
        let r = this._fastIndentations[s];
        r !== void 0 ? this._str += r : this._str += s > 1 ? this._indentChar.repeat(s) : this._indentChar;
      } else
        this._str += s > 1 ? String.fromCharCode(e).repeat(s) : String.fromCharCode(e);
      e !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += s) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(e, s, i) {
      let r = e.length, a = this._position;
      if (this._last = e.charCodeAt(r - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !i && !this._map) {
        a.column += r;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = s, p = s.line;
      (l != null || u != null) && this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
      let h = e.indexOf(`
`), f = 0;
      for (h !== 0 && this._mark(p, o, l, u, c); h !== -1; )
        a.line++, a.column = 0, f = h + 1, f < r && p !== void 0 && this._mark(++p, 0, null, null, c), h = e.indexOf(`
`, f);
      a.column += r - f;
    }
    _mark(e, s, i, r, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, s, i, r, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, s = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let i = e - 1; i >= 0 && this._queue[i].char === 10; i--)
        s++;
      return s === e && this._last === 10 ? s + 1 : s;
    }
    endsWithCharAndNewline() {
      let e = this._queue, s = this._queueCursor;
      if (s !== 0)
        return e[s - 1].char !== 10 ? void 0 : s > 1 ? e[s - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, s) {
      if (!this._map) {
        s();
        return;
      }
      this.source("start", e);
      let i = e.identifierName, r = this._sourcePosition;
      i && (this._canMarkIdName = !1, r.identifierName = i), s(), i && (this._canMarkIdName = !0, r.identifierName = void 0, r.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, s) {
      this._map && this._normalizePosition(e, s, 0);
    }
    sourceWithOffset(e, s, i) {
      this._map && this._normalizePosition(e, s, i);
    }
    _normalizePosition(e, s, i) {
      let r = s[e], a = this._sourcePosition;
      r && (a.line = r.line, a.column = Math.max(r.column + i, 0), a.filename = s.filename);
    }
    getCurrentColumn() {
      let e = this._queue, s = this._queueCursor, i = -1, r = 0;
      for (let a = 0; a < s; a++) {
        let o = e[a];
        o.char === 10 && (i = r), r += o.repeat;
      }
      return i === -1 ? this._position.column + r : r - 1 - i;
    }
    getCurrentLine() {
      let e = 0, s = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        s[i].char === 10 && e++;
      return this._position.line + e;
    }
  };
  OE.default = yB;
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/node/whitespace.js
var Wte = g((LE) => {
  "use strict";
  Object.defineProperty(LE, "__esModule", {
    value: !0
  });
  LE.nodes = void 0;
  var Nyt = fe(), {
    FLIPPED_ALIAS_KEYS: kyt,
    isArrayExpression: Dyt,
    isAssignmentExpression: Ute,
    isBinary: Kte,
    isBlockStatement: Oyt,
    isCallExpression: Vte,
    isFunction: OT,
    isIdentifier: _E,
    isLiteral: _yt,
    isMemberExpression: gB,
    isObjectExpression: Lyt,
    isOptionalCallExpression: Byt,
    isOptionalMemberExpression: Myt,
    isStringLiteral: Fyt
  } = Nyt;
  function ym(t, e) {
    return t && (gB(t) || Myt(t) ? (ym(t.object, e), t.computed && ym(t.property, e)) : Kte(t) || Ute(t) ? (ym(t.left, e), ym(t.right, e)) :
    Vte(t) || Byt(t) ? (e.hasCall = !0, ym(t.callee, e)) : OT(t) ? e.hasFunction = !0 : _E(t) && (e.hasHelper = e.hasHelper || t.callee && ku(
    t.callee))), e;
  }
  n(ym, "crawlInternal");
  function qte(t) {
    return ym(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(qte, "crawl");
  function ku(t) {
    return t ? gB(t) ? ku(t.object) || ku(t.property) : _E(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : Vte(t) ? ku(t.callee) :
    Kte(t) || Ute(t) ? _E(t.left) && ku(t.left) || ku(t.right) : !1 : !1;
  }
  n(ku, "isHelper");
  function jyt(t) {
    return _yt(t) || Lyt(t) || Dyt(t) || _E(t) || gB(t);
  }
  n(jyt, "isType");
  var Xh = LE.nodes = {
    AssignmentExpression(t) {
      let e = qte(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (OT(t.left) || OT(t.right))
        return 2;
    },
    Literal(t) {
      if (Fyt(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (OT(t.callee) || ku(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (OT(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let s = t.declarations[e], i = ku(s.id) && !jyt(s.init);
        if (!i && s.init) {
          let r = qte(s.init);
          i = ku(s.init) && r.hasCall || r.hasFunction;
        }
        if (i)
          return 3;
      }
    },
    IfStatement(t) {
      if (Oyt(t.consequent))
        return 3;
    }
  };
  Xh.ObjectProperty = Xh.ObjectTypeProperty = Xh.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  Xh.ObjectTypeCallProperty = function(t, e) {
    var s;
    if (e.callProperties[0] === t && !((s = e.properties) != null && s.length))
      return 1;
  };
  Xh.ObjectTypeIndexer = function(t, e) {
    var s, i;
    if (e.indexers[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length))
      return 1;
  };
  Xh.ObjectTypeInternalSlot = function(t, e) {
    var s, i, r;
    if (e.internalSlots[0] === t && !((s = e.properties) != null && s.length) && !((i = e.callProperties) != null && i.length) && !((r = e.indexers) !=
    null && r.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(kyt[t] || []).forEach(function(s) {
      let i = e ? 3 : 0;
      Xh[s] = () => i;
    });
  });
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/node/parentheses.js
var Qte = g((As) => {
  "use strict";
  Object.defineProperty(As, "__esModule", {
    value: !0
  });
  As.AssignmentExpression = ygt;
  As.Binary = Xte;
  As.BinaryExpression = cgt;
  As.ClassExpression = fgt;
  As.ArrowFunctionExpression = As.ConditionalExpression = Gte;
  As.DoExpression = Zyt;
  As.FunctionExpression = dgt;
  As.FunctionTypeAnnotation = zyt;
  As.Identifier = Tgt;
  As.LogicalExpression = ggt;
  As.NullableTypeAnnotation = Xyt;
  As.ObjectExpression = Qyt;
  As.OptionalIndexedAccessType = tgt;
  As.OptionalCallExpression = As.OptionalMemberExpression = mgt;
  As.SequenceExpression = pgt;
  As.TSSatisfiesExpression = As.TSAsExpression = sgt;
  As.TSConditionalType = igt;
  As.TSConstructorType = As.TSFunctionType = ugt;
  As.TSInferType = agt;
  As.TSInstantiationExpression = lgt;
  As.TSIntersectionType = ngt;
  As.UnaryLike = As.TSTypeAssertion = zte;
  As.TSTypeOperator = ogt;
  As.TSUnionType = rgt;
  As.IntersectionTypeAnnotation = As.UnionTypeAnnotation = egt;
  As.UpdateExpression = Gyt;
  As.AwaitExpression = As.YieldExpression = hgt;
  var Ryt = fe(), Ka = op(), {
    isArrayTypeAnnotation: qyt,
    isBinaryExpression: Uyt,
    isCallExpression: Kyt,
    isForOfStatement: Vyt,
    isIndexedAccessType: Wyt,
    isMemberExpression: Jte,
    isObjectPattern: $yt,
    isOptionalMemberExpression: Hyt,
    isYieldExpression: Jyt,
    isStatement: Yyt
  } = Ryt, $te = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], [
  "!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], [
  "-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function Hte(t, e) {
    if (e === "BinaryExpression" || e === "LogicalExpression")
      return $te.get(t.operator);
    if (e === "TSAsExpression" || e === "TSSatisfiesExpression")
      return $te.get("in");
  }
  n(Hte, "getBinaryPrecedence");
  function TB(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(TB, "isTSTypeExpression");
  var BE = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "ClassDeclaration" || s === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), ME = /* @__PURE__ */ n((t, e) => {
    let s = e.type;
    return (s === "MemberExpression" || s === "OptionalMemberExpression") && e.object === t || (s === "CallExpression" || s === "OptionalCal\
lExpression" || s === "NewExpression") && e.callee === t || s === "TaggedTemplateExpression" && e.tag === t || s === "TSNonNullExpression";
  }, "hasPostfixPart");
  function Xyt(t, e) {
    return qyt(e);
  }
  n(Xyt, "NullableTypeAnnotation");
  function zyt(t, e, s) {
    let i = e.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(s & Ka.TokenContext.arrowFlowReturnType);
  }
  n(zyt, "FunctionTypeAnnotation");
  function Gyt(t, e) {
    return ME(t, e) || BE(t, e);
  }
  n(Gyt, "UpdateExpression");
  function Yte(t) {
    return !!(t & (Ka.TokenContext.expressionStatement | Ka.TokenContext.arrowBody));
  }
  n(Yte, "needsParenBeforeExpressionBrace");
  function Qyt(t, e, s) {
    return Yte(s);
  }
  n(Qyt, "ObjectExpression");
  function Zyt(t, e, s) {
    return !t.async && !!(s & Ka.TokenContext.expressionStatement);
  }
  n(Zyt, "DoExpression");
  function Xte(t, e) {
    let s = e.type;
    if (t.type === "BinaryExpression" && t.operator === "**" && s === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (BE(t, e) || ME(t, e) || s === "UnaryExpression" || s === "SpreadElement" || s === "AwaitExpression")
      return !0;
    let i = Hte(e, s);
    if (i != null) {
      let r = Hte(t, t.type);
      if (i === r && s === "BinaryExpression" && e.right === t || i > r)
        return !0;
    }
  }
  n(Xte, "Binary");
  function egt(t, e) {
    let s = e.type;
    return s === "ArrayTypeAnnotation" || s === "NullableTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "UnionTypeAnnotation";
  }
  n(egt, "UnionTypeAnnotation");
  function tgt(t, e) {
    return Wyt(e) && e.objectType === t;
  }
  n(tgt, "OptionalIndexedAccessType");
  function sgt(t, e) {
    return (e.type === "AssignmentExpression" || e.type === "AssignmentPattern") && e.left === t || e.type === "BinaryExpression" && (e.operator ===
    "|" || e.operator === "&") && t === e.left ? !0 : Xte(t, e);
  }
  n(sgt, "TSAsExpression");
  function igt(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || s === "TSTypeOperator" || s ===
    "TSTypeParameter" || (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t || s === "TSConditionalType" && (e.checkType ===
    t || e.extendsType === t);
  }
  n(igt, "TSConditionalType");
  function rgt(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t ||
    s === "TSOptionalType";
  }
  n(rgt, "TSUnionType");
  function ngt(t, e) {
    let s = e.type;
    return s === "TSTypeOperator" || s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n(ngt, "TSIntersectionType");
  function agt(t, e) {
    let s = e.type;
    return !!(s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType" || t.typeParameter.constraint &&
    (s === "TSIntersectionType" || s === "TSUnionType") && e.types[0] === t);
  }
  n(agt, "TSInferType");
  function ogt(t, e) {
    let s = e.type;
    return s === "TSArrayType" || s === "TSIndexedAccessType" && e.objectType === t || s === "TSOptionalType";
  }
  n(ogt, "TSTypeOperator");
  function lgt(t, e) {
    let s = e.type;
    return (s === "CallExpression" || s === "OptionalCallExpression" || s === "NewExpression" || s === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(lgt, "TSInstantiationExpression");
  function ugt(t, e) {
    let s = e.type;
    return s === "TSIntersectionType" || s === "TSUnionType" || s === "TSTypeOperator" || s === "TSOptionalType" || s === "TSArrayType" || s ===
    "TSIndexedAccessType" && e.objectType === t || s === "TSConditionalType" && (e.checkType === t || e.extendsType === t);
  }
  n(ugt, "TSFunctionType");
  function cgt(t, e, s, i) {
    return t.operator === "in" && i;
  }
  n(cgt, "BinaryExpression");
  function pgt(t, e) {
    let s = e.type;
    return s === "SequenceExpression" || s === "ParenthesizedExpression" || s === "MemberExpression" && e.property === t || s === "OptionalM\
emberExpression" && e.property === t || s === "TemplateLiteral" ? !1 : s === "ClassDeclaration" ? !0 : s === "ForOfStatement" ? e.right === t :
    s === "ExportDefaultDeclaration" ? !0 : !Yyt(e);
  }
  n(pgt, "SequenceExpression");
  function hgt(t, e) {
    let s = e.type;
    return s === "BinaryExpression" || s === "LogicalExpression" || s === "UnaryExpression" || s === "SpreadElement" || ME(t, e) || s === "A\
waitExpression" && Jyt(t) || s === "ConditionalExpression" && t === e.test || BE(t, e) || TB(s);
  }
  n(hgt, "YieldExpression");
  function fgt(t, e, s) {
    return !!(s & (Ka.TokenContext.expressionStatement | Ka.TokenContext.exportDefault));
  }
  n(fgt, "ClassExpression");
  function zte(t, e) {
    return ME(t, e) || Uyt(e) && e.operator === "**" && e.left === t || BE(t, e);
  }
  n(zte, "UnaryLike");
  function dgt(t, e, s) {
    return !!(s & (Ka.TokenContext.expressionStatement | Ka.TokenContext.exportDefault));
  }
  n(dgt, "FunctionExpression");
  function Gte(t, e) {
    let s = e.type;
    return s === "UnaryExpression" || s === "SpreadElement" || s === "BinaryExpression" || s === "LogicalExpression" || s === "ConditionalEx\
pression" && e.test === t || s === "AwaitExpression" || TB(s) ? !0 : zte(t, e);
  }
  n(Gte, "ConditionalExpression");
  function mgt(t, e) {
    return Kyt(e) && e.callee === t || Jte(e) && e.object === t;
  }
  n(mgt, "OptionalMemberExpression");
  function ygt(t, e, s) {
    return Yte(s) && $yt(t.left) ? !0 : Gte(t, e);
  }
  n(ygt, "AssignmentExpression");
  function ggt(t, e) {
    let s = e.type;
    if (TB(s)) return !0;
    if (s !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(ggt, "LogicalExpression");
  function Tgt(t, e, s, i, r) {
    var a;
    let o = e.type;
    if ((a = t.extra) != null && a.parenthesized && o === "AssignmentExpression" && e.left === t) {
      let l = e.right.type;
      if ((l === "FunctionExpression" || l === "ClassExpression") && e.right.id == null)
        return !0;
    }
    return r && r(t) !== t.name ? !1 : t.name === "let" ? (Jte(e, {
      object: t,
      computed: !0
    }) || Hyt(e, {
      object: t,
      computed: !0,
      optional: !1
    })) && s & (Ka.TokenContext.expressionStatement | Ka.TokenContext.forHead | Ka.TokenContext.forInHead) ? !0 : !!(s & Ka.TokenContext.forOfHead) :
    t.name === "async" && Vyt(e, {
      left: t,
      await: !1
    });
  }
  n(Tgt, "Identifier");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/node/index.js
var op = g((Du) => {
  "use strict";
  Object.defineProperty(Du, "__esModule", {
    value: !0
  });
  Du.TokenContext = void 0;
  Du.isLastChild = Lgt;
  Du.needsParens = _gt;
  Du.needsWhitespace = xB;
  Du.needsWhitespaceAfter = Ogt;
  Du.needsWhitespaceBefore = Dgt;
  var bgt = Wte(), xgt = Qte(), Sgt = fe(), {
    FLIPPED_ALIAS_KEYS: Pgt,
    VISITOR_KEYS: Egt,
    isCallExpression: Zte,
    isDecorator: Agt,
    isExpressionStatement: vgt,
    isMemberExpression: Cgt,
    isNewExpression: wgt,
    isParenthesizedExpression: Igt
  } = Sgt, CHs = Du.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function ese(t) {
    let e = /* @__PURE__ */ new Map();
    function s(i, r) {
      let a = e.get(i);
      e.set(i, a ? function(o, l, u, c, p) {
        var h;
        return (h = a(o, l, u, c, p)) != null ? h : r(o, l, u, c, p);
      } : r);
    }
    n(s, "add");
    for (let i of Object.keys(t)) {
      let r = Pgt[i];
      if (r)
        for (let a of r)
          s(a, t[i]);
      else
        s(i, t[i]);
    }
    return e;
  }
  n(ese, "expandAliases");
  var Ngt = ese(xgt), kgt = ese(bgt.nodes);
  function tse(t) {
    return Zte(t) ? !0 : Cgt(t) && tse(t.object);
  }
  n(tse, "isOrHasCallExpression");
  function xB(t, e, s) {
    var i;
    if (!t) return !1;
    vgt(t) && (t = t.expression);
    let r = (i = kgt.get(t.type)) == null ? void 0 : i(t, e);
    return typeof r == "number" ? (r & s) !== 0 : !1;
  }
  n(xB, "needsWhitespace");
  function Dgt(t, e) {
    return xB(t, e, 1);
  }
  n(Dgt, "needsWhitespaceBefore");
  function Ogt(t, e) {
    return xB(t, e, 2);
  }
  n(Ogt, "needsWhitespaceAfter");
  function _gt(t, e, s, i, r) {
    var a;
    return e ? wgt(e) && e.callee === t && tse(t) ? !0 : Agt(e) ? !bB(t) && !(Zte(t) && bB(t.callee)) && !Igt(t) : (a = Ngt.get(t.type)) == null ?
    void 0 : a(t, e, s, i, r) : !1;
  }
  n(_gt, "needsParens");
  function bB(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && bB(t.object);
      default:
        return !1;
    }
  }
  n(bB, "isDecoratorMemberExpression");
  function Lgt(t, e) {
    let s = Egt[t.type];
    for (let i = s.length - 1; i >= 0; i--) {
      let r = t[s[i]];
      if (r === e)
        return !0;
      if (Array.isArray(r)) {
        let a = r.length - 1;
        for (; a >= 0 && r[a] === null; ) a--;
        return a >= 0 && r[a] === e;
      } else if (r)
        return !1;
    }
    return !1;
  }
  n(Lgt, "isLastChild");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/token-map.js
var sse = g((FE) => {
  "use strict";
  Object.defineProperty(FE, "__esModule", {
    value: !0
  });
  FE.TokenMap = void 0;
  var Bgt = fe(), {
    traverseFast: Mgt,
    VISITOR_KEYS: Fgt
  } = Bgt, SB = class {
    static {
      n(this, "TokenMap");
    }
    constructor(e, s, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = s, this._source = i, Mgt(e, (r) => {
        let a = this._getTokensIndexesOfNode(r);
        a.length > 0 && this._nodesToTokenIndexes.set(r, a);
      }), this._tokensCache = null;
    }
    has(e) {
      return this._nodesToTokenIndexes.has(e);
    }
    getIndexes(e) {
      return this._nodesToTokenIndexes.get(e);
    }
    find(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = 0; r < i.length; r++) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return o;
        }
      return null;
    }
    findLastIndex(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (i)
        for (let r = i.length - 1; r >= 0; r--) {
          let a = i[r], o = this._tokens[a];
          if (s(o, a)) return a;
        }
      return -1;
    }
    findMatching(e, s, i = 0) {
      let r = this._nodesToTokenIndexes.get(e);
      if (r) {
        let a = 0, o = i;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(e);
          l && l.test === s && l.count < o && (a = l.i + 1, i -= l.count + 1);
        }
        for (; a < r.length; a++) {
          let l = this._tokens[r[a]];
          if (this.matchesOriginal(l, s)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(e, {
                test: s,
                count: o,
                i: a
              }), l;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(e, s) {
      return e.end - e.start !== s.length ? !1 : e.value != null ? e.value === s : this._source.startsWith(s, e.start);
    }
    startMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[0]];
      return r.start !== e.start ? !1 : this.matchesOriginal(r, s);
    }
    endMatches(e, s) {
      let i = this._nodesToTokenIndexes.get(e);
      if (!i) return !1;
      let r = this._tokens[i[i.length - 1]];
      return r.end !== e.end ? !1 : this.matchesOriginal(r, s);
    }
    _getTokensIndexesOfNode(e) {
      if (e.start == null || e.end == null) return [];
      let {
        first: s,
        last: i
      } = this._findTokensOfNode(e, 0, this._tokens.length - 1), r = s, a = jgt(e);
      (e.type === "ExportNamedDeclaration" || e.type === "ExportDefaultDeclaration") && e.declaration && e.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, r, i), c = u.first;
        for (let p = r; p < c; p++) o.push(p);
        r = u.last + 1;
      }
      for (let l = r; l <= i; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(e, s, i) {
      let r = this._tokensCache.get(e);
      if (r) return r;
      let a = this._findFirstTokenOfNode(e.start, s, i), o = this._findLastTokenOfNode(e.end, a, i);
      return this._tokensCache.set(e, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].start)
          i = r - 1;
        else if (e > this._tokens[r].start)
          s = r + 1;
        else
          return r;
      }
      return s;
    }
    _findLastTokenOfNode(e, s, i) {
      for (; s <= i; ) {
        let r = i + s >> 1;
        if (e < this._tokens[r].end)
          i = r - 1;
        else if (e > this._tokens[r].end)
          s = r + 1;
        else
          return r;
      }
      return i;
    }
  };
  FE.TokenMap = SB;
  function* jgt(t) {
    if (t.type === "TemplateLiteral") {
      yield t.quasis[0];
      for (let s = 1; s < t.quasis.length; s++)
        yield t.expressions[s - 1], yield t.quasis[s];
      return;
    }
    let e = Fgt[t.type];
    for (let s of e) {
      let i = t[s];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  n(jgt, "childrenIterator");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/template-literals.js
var ise = g((gm) => {
  "use strict";
  Object.defineProperty(gm, "__esModule", {
    value: !0
  });
  gm.TaggedTemplateExpression = Rgt;
  gm.TemplateElement = qgt;
  gm.TemplateLiteral = Kgt;
  gm._printTemplate = Ugt;
  function Rgt(t) {
    this.print(t.tag), this.print(t.typeParameters), this.print(t.quasi);
  }
  n(Rgt, "TaggedTemplateExpression");
  function qgt() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(qgt, "TemplateElement");
  function Ugt(t, e) {
    let s = t.quasis, i = "`";
    for (let r = 0; r < s.length - 1; r++)
      if (i += s[r].value.raw, this.token(i + "${", !0), this.print(e[r]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(t, "}", r);
        a && this._catchUpTo(a.loc.start);
      }
    i += s[s.length - 1].value.raw, this.token(i + "`", !0);
  }
  n(Ugt, "_printTemplate");
  function Kgt(t) {
    this._printTemplate(t, t.expressions);
  }
  n(Kgt, "TemplateLiteral");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/expressions.js
var nse = g((pi) => {
  "use strict";
  Object.defineProperty(pi, "__esModule", {
    value: !0
  });
  pi.LogicalExpression = pi.BinaryExpression = pi.AssignmentExpression = dTt;
  pi.AssignmentPattern = fTt;
  pi.AwaitExpression = uTt;
  pi.BindExpression = mTt;
  pi.CallExpression = oTt;
  pi.ConditionalExpression = Qgt;
  pi.Decorator = rTt;
  pi.DoExpression = Xgt;
  pi.EmptyStatement = pTt;
  pi.ExpressionStatement = hTt;
  pi.Import = lTt;
  pi.MemberExpression = yTt;
  pi.MetaProperty = gTt;
  pi.ModuleExpression = xTt;
  pi.NewExpression = Zgt;
  pi.OptionalCallExpression = aTt;
  pi.OptionalMemberExpression = nTt;
  pi.ParenthesizedExpression = zgt;
  pi.PrivateName = TTt;
  pi.SequenceExpression = eTt;
  pi.Super = sTt;
  pi.ThisExpression = tTt;
  pi.UnaryExpression = Ygt;
  pi.UpdateExpression = Ggt;
  pi.V8IntrinsicIdentifier = bTt;
  pi.YieldExpression = cTt;
  pi._shouldPrintDecoratorsBeforeExport = iTt;
  var Vgt = fe(), Wgt = op(), {
    isCallExpression: $gt,
    isLiteral: rse,
    isMemberExpression: PB,
    isNewExpression: Hgt,
    isPattern: Jgt
  } = Vgt;
  function Ygt(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument);
  }
  n(Ygt, "UnaryExpression");
  function Xgt(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body);
  }
  n(Xgt, "DoExpression");
  function zgt(t) {
    this.tokenChar(40);
    let e = this.enterDelimited();
    this.print(t.expression), e(), this.rightParens(t);
  }
  n(zgt, "ParenthesizedExpression");
  function Ggt(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument)) : (this.print(t.argument, !0), this.token(t.operator));
  }
  n(Ggt, "UpdateExpression");
  function Qgt(t) {
    this.print(t.test), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(t.alternate);
  }
  n(Qgt, "ConditionalExpression");
  function Zgt(t, e) {
    if (this.word("new"), this.space(), this.print(t.callee), this.format.minified && t.arguments.length === 0 && !t.optional && !$gt(e, {
      callee: t
    }) && !PB(e) && !Hgt(e) || (this.print(t.typeArguments), this.print(t.typeParameters), t.optional && this.token("?."), t.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(t, ")")))
      return;
    this.tokenChar(40);
    let s = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), s(), this.rightParens(t);
  }
  n(Zgt, "NewExpression");
  function eTt(t) {
    this.printList(t.expressions);
  }
  n(eTt, "SequenceExpression");
  function tTt() {
    this.word("this");
  }
  n(tTt, "ThisExpression");
  function sTt() {
    this.word("super");
  }
  n(sTt, "Super");
  function iTt(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(iTt, "_shouldPrintDecoratorsBeforeExport");
  function rTt(t) {
    this.tokenChar(64), this.print(t.expression), this.newline();
  }
  n(rTt, "Decorator");
  function nTt(t) {
    let {
      computed: e
    } = t, {
      optional: s,
      property: i
    } = t;
    if (this.print(t.object), !e && PB(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    rse(i) && typeof i.value == "number" && (e = !0), s && this.token("?."), e ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (s ||
    this.tokenChar(46), this.print(i));
  }
  n(nTt, "OptionalMemberExpression");
  function aTt(t) {
    this.print(t.callee), this.print(t.typeParameters), t.optional && this.token("?."), this.print(t.typeArguments), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments), e(), this.rightParens(t);
  }
  n(aTt, "OptionalCallExpression");
  function oTt(t) {
    this.print(t.callee), this.print(t.typeArguments), this.print(t.typeParameters), this.tokenChar(40);
    let e = this.enterDelimited();
    this.printList(t.arguments, this.shouldPrintTrailingComma(")")), e(), this.rightParens(t);
  }
  n(oTt, "CallExpression");
  function lTt() {
    this.word("import");
  }
  n(lTt, "Import");
  function uTt(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument));
  }
  n(uTt, "AwaitExpression");
  function cTt(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument))) : t.argument && (this.space(),
    this.printTerminatorless(t.argument));
  }
  n(cTt, "YieldExpression");
  function pTt() {
    this.semicolon(!0);
  }
  n(pTt, "EmptyStatement");
  function hTt(t) {
    this.tokenContext |= Wgt.TokenContext.expressionStatement, this.print(t.expression), this.semicolon();
  }
  n(hTt, "ExpressionStatement");
  function fTt(t) {
    this.print(t.left), (t.left.type === "Identifier" || Jgt(t.left)) && (t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(t.right);
  }
  n(fTt, "AssignmentPattern");
  function dTt(t) {
    this.print(t.left), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) : (this.token(t.operator), this.
    _endsWithDiv = t.operator === "/"), this.space(), this.print(t.right);
  }
  n(dTt, "AssignmentExpression");
  function mTt(t) {
    this.print(t.object), this.token("::"), this.print(t.callee);
  }
  n(mTt, "BindExpression");
  function yTt(t) {
    if (this.print(t.object), !t.computed && PB(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    if (rse(t.property) && typeof t.property.value == "number" && (e = !0), e) {
      let s = this.enterDelimited();
      this.tokenChar(91), this.print(t.property), this.tokenChar(93), s();
    } else
      this.tokenChar(46), this.print(t.property);
  }
  n(yTt, "MemberExpression");
  function gTt(t) {
    this.print(t.meta), this.tokenChar(46), this.print(t.property);
  }
  n(gTt, "MetaProperty");
  function TTt(t) {
    this.tokenChar(35), this.print(t.id);
  }
  n(TTt, "PrivateName");
  function bTt(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(bTt, "V8IntrinsicIdentifier");
  function xTt(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e), this.dedent(), this.rightBrace(t);
  }
  n(xTt, "ModuleExpression");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/statements.js
var use = g((Qi) => {
  "use strict";
  Object.defineProperty(Qi, "__esModule", {
    value: !0
  });
  Qi.BreakStatement = kTt;
  Qi.CatchClause = MTt;
  Qi.ContinueStatement = DTt;
  Qi.DebuggerStatement = RTt;
  Qi.DoWhileStatement = NTt;
  Qi.ForOfStatement = Qi.ForInStatement = void 0;
  Qi.ForStatement = wTt;
  Qi.IfStatement = CTt;
  Qi.LabeledStatement = LTt;
  Qi.ReturnStatement = OTt;
  Qi.SwitchCase = jTt;
  Qi.SwitchStatement = FTt;
  Qi.ThrowStatement = _Tt;
  Qi.TryStatement = BTt;
  Qi.VariableDeclaration = qTt;
  Qi.VariableDeclarator = UTt;
  Qi.WhileStatement = ITt;
  Qi.WithStatement = vTt;
  var STt = fe(), EB = op(), {
    isFor: ase,
    isForStatement: PTt,
    isIfStatement: ETt,
    isStatement: ATt
  } = STt;
  function vTt(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object), this.tokenChar(41), this.printBlock(t);
  }
  n(vTt, "WithStatement");
  function CTt(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.space();
    let e = t.alternate && ETt(ose(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate));
  }
  n(CTt, "IfStatement");
  function ose(t) {
    let {
      body: e
    } = t;
    return ATt(e) === !1 ? t : ose(e);
  }
  n(ose, "getLastStatement");
  function wTt(t) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let e = this.enterForStatementInit();
      this.tokenContext |= EB.TokenContext.forHead, this.print(t.init), e();
    }
    this.tokenChar(59), t.test && (this.space(), this.print(t.test)), this.token(";", !1, 1), t.update && (this.space(), this.print(t.update)),
    this.tokenChar(41), this.printBlock(t);
  }
  n(wTt, "ForStatement");
  function ITt(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test), this.tokenChar(41), this.printBlock(t);
  }
  n(ITt, "WhileStatement");
  function lse(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let s = e ? null : this.enterForStatementInit();
      this.tokenContext |= e ? EB.TokenContext.forOfHead : EB.TokenContext.forInHead, this.print(t.left), s?.();
    }
    this.space(), this.word(e ? "of" : "in"), this.space(), this.print(t.right), this.tokenChar(41), this.printBlock(t);
  }
  n(lse, "ForXStatement");
  var BHs = Qi.ForInStatement = lse, MHs = Qi.ForOfStatement = lse;
  function NTt(t) {
    this.word("do"), this.space(), this.print(t.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test),
    this.tokenChar(41), this.semicolon();
  }
  n(NTt, "DoWhileStatement");
  function jE(t, e) {
    e && (t.space(), t.printTerminatorless(e)), t.semicolon();
  }
  n(jE, "printStatementAfterKeyword");
  function kTt(t) {
    this.word("break"), jE(this, t.label);
  }
  n(kTt, "BreakStatement");
  function DTt(t) {
    this.word("continue"), jE(this, t.label);
  }
  n(DTt, "ContinueStatement");
  function OTt(t) {
    this.word("return"), jE(this, t.argument);
  }
  n(OTt, "ReturnStatement");
  function _Tt(t) {
    this.word("throw"), jE(this, t.argument);
  }
  n(_Tt, "ThrowStatement");
  function LTt(t) {
    this.print(t.label), this.tokenChar(58), this.space(), this.print(t.body);
  }
  n(LTt, "LabeledStatement");
  function BTt(t) {
    this.word("try"), this.space(), this.print(t.block), this.space(), t.handlers ? this.print(t.handlers[0]) : this.print(t.handler), t.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(t.finalizer));
  }
  n(BTt, "TryStatement");
  function MTt(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param), this.print(t.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(t.body);
  }
  n(MTt, "CatchClause");
  function FTt(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, !0, void 0, /* @__PURE__ */ n(function(s, i) {
      if (!s && t.cases[t.cases.length - 1] === i) return -1;
    }, "addNewlines")), this.rightBrace(t);
  }
  n(FTt, "SwitchStatement");
  function jTt(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, !0));
  }
  n(jTt, "SwitchCase");
  function RTt() {
    this.word("debugger"), this.semicolon();
  }
  n(RTt, "DebuggerStatement");
  function qTt(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: s
    } = t;
    s === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(s, s === "using"), this.space();
    let i = !1;
    if (!ase(e))
      for (let r of t.declarations)
        r.init && (i = !0);
    if (this.printList(t.declarations, void 0, void 0, t.declarations.length > 1, i ? function(r) {
      this.token(",", !1, r), this.newline();
    } : void 0), ase(e)) {
      if (PTt(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(qTt, "VariableDeclaration");
  function UTt(t) {
    this.print(t.id), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation), t.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(t.init));
  }
  n(UTt, "VariableDeclarator");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/classes.js
var cse = g((Va) => {
  "use strict";
  Object.defineProperty(Va, "__esModule", {
    value: !0
  });
  Va.ClassAccessorProperty = XTt;
  Va.ClassBody = HTt;
  Va.ClassExpression = Va.ClassDeclaration = $Tt;
  Va.ClassMethod = GTt;
  Va.ClassPrivateMethod = QTt;
  Va.ClassPrivateProperty = zTt;
  Va.ClassProperty = YTt;
  Va.StaticBlock = e0t;
  Va._classMethodHead = ZTt;
  var KTt = fe(), {
    isExportDefaultDeclaration: VTt,
    isExportNamedDeclaration: WTt
  } = KTt;
  function $Tt(t, e) {
    (!(VTt(e) || WTt(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id)), this.print(
    t.typeParameters), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass), this.print(t.superTypeParameters)),
    t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements)), this.space(), this.print(t.body);
  }
  n($Tt, "ClassDeclaration");
  function HTt(t) {
    if (this.tokenChar(123), t.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let e = JTt(this, t);
      e?.(-1);
      let s = this.enterDelimited();
      this.printJoin(t.body, !0, !0, e, !0), s(), this.endsWith(10) || this.newline(), this.rightBrace(t);
    }
  }
  n(HTt, "ClassBody");
  function JTt(t, e) {
    if (!t.tokenMap || e.start == null || e.end == null)
      return null;
    let s = t.tokenMap.getIndexes(e);
    if (!s) return null;
    let i = 1, r = 0, a = 0, o = /* @__PURE__ */ n(() => {
      for (; a < e.body.length && e.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === e.body.length ? e.end : e.body[a].start, c;
      for (; i < s.length && t.tokenMap.matchesOriginal(c = t._tokens[s[i]], ";") && c.start < u; )
        t.token(";", void 0, r++), i++;
    };
  }
  n(JTt, "classBodyEmptySemicolonsPrinter");
  function YTt(t) {
    if (this.printJoin(t.decorators), !t.static && !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key), this.tokenChar(93)) : (this._variance(t), this.
    print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(YTt, "ClassProperty");
  function XTt(t) {
    var e;
    this.printJoin(t.decorators);
    let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    s && this.catchUp(s), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key), this.tokenChar(93)) : (this._variance(t), this.print(t.key)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(XTt, "ClassAccessorProperty");
  function zTt(t) {
    this.printJoin(t.decorators), this.tsPrintClassMemberModifiers(t), this.print(t.key), t.optional && this.tokenChar(63), t.definite && this.
    tokenChar(33), this.print(t.typeAnnotation), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value)), this.semicolon();
  }
  n(zTt, "ClassPrivateProperty");
  function GTt(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(GTt, "ClassMethod");
  function QTt(t) {
    this._classMethodHead(t), this.space(), this.print(t.body);
  }
  n(QTt, "ClassPrivateMethod");
  function ZTt(t) {
    if (this.printJoin(t.decorators), !this.format.preserveFormat) {
      var e;
      let s = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
      s && this.catchUp(s);
    }
    this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(ZTt, "_classMethodHead");
  function e0t(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, !0), this.rightBrace(t));
  }
  n(e0t, "StaticBlock");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/methods.js
var pse = g((Wa) => {
  "use strict";
  Object.defineProperty(Wa, "__esModule", {
    value: !0
  });
  Wa.ArrowFunctionExpression = p0t;
  Wa.FunctionDeclaration = Wa.FunctionExpression = c0t;
  Wa._functionHead = u0t;
  Wa._methodHead = o0t;
  Wa._param = a0t;
  Wa._parameters = n0t;
  Wa._params = r0t;
  Wa._predicate = l0t;
  Wa._shouldPrintArrowParamsParens = h0t;
  var t0t = fe(), s0t = op(), {
    isIdentifier: i0t
  } = t0t;
  function r0t(t, e, s) {
    this.print(t.typeParameters);
    let i = f0t.call(this, e, s);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(t.params, ")");
    let r = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, r), this._noLineTerminator = r;
  }
  n(r0t, "_params");
  function n0t(t, e) {
    let s = this.enterDelimited(), i = this.shouldPrintTrailingComma(e), r = t.length;
    for (let a = 0; a < r; a++)
      this._param(t[a]), (i || a < r - 1) && (this.token(",", null, a), this.space());
    this.token(e), s();
  }
  n(n0t, "_parameters");
  function a0t(t) {
    this.printJoin(t.decorators), this.print(t), t.optional && this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(a0t, "_param");
  function o0t(t) {
    let e = t.kind, s = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(s), this.tokenChar(93)) : this.print(s), t.optional &&
    this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(o0t, "_methodHead");
  function l0t(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, e));
  }
  n(l0t, "_predicate");
  function u0t(t, e) {
    t.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), t.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), t.id && this.print(t.id), this._params(
    t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(t);
  }
  n(u0t, "_functionHead");
  function c0t(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body);
  }
  n(c0t, "FunctionExpression");
  function p0t(t, e) {
    t.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(t) ? this._params(t, void 0, e) : this.print(t.params[0],
    !0), this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= s0t.TokenContext.
    arrowBody, this.print(t.body);
  }
  n(p0t, "ArrowFunctionExpression");
  function h0t(t) {
    var e, s;
    if (t.params.length !== 1 || t.typeParameters || t.returnType || t.predicate)
      return !0;
    let i = t.params[0];
    if (!i0t(i) || i.typeAnnotation || i.optional || (e = i.leadingComments) != null && e.length || (s = i.trailingComments) != null && s.length)
      return !0;
    if (this.tokenMap) {
      if (t.loc == null || this.tokenMap.findMatching(t, "(") !== null) return !0;
      let r = this.tokenMap.findMatching(t, "=>");
      return r?.loc == null ? !0 : r.loc.start.line !== t.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  n(h0t, "_shouldPrintArrowParamsParens");
  function f0t(t, e) {
    let s = t;
    if (!s && e) {
      let u = e.type;
      u === "VariableDeclarator" ? s = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? s = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (s = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (s = e.key);
    }
    if (!s) return;
    let i;
    if (s.type === "Identifier") {
      var r, a;
      i = {
        pos: (r = s.loc) == null ? void 0 : r.start,
        name: ((a = s.loc) == null ? void 0 : a.identifierName) || s.name
      };
    } else if (s.type === "PrivateName") {
      var o;
      i = {
        pos: (o = s.loc) == null ? void 0 : o.start,
        name: "#" + s.id.name
      };
    } else if (s.type === "StringLiteral") {
      var l;
      i = {
        pos: (l = s.loc) == null ? void 0 : l.start,
        name: s.value
      };
    }
    return i;
  }
  n(f0t, "_getFuncIdName");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/modules.js
var AB = g((Nn) => {
  "use strict";
  Object.defineProperty(Nn, "__esModule", {
    value: !0
  });
  Nn.ExportAllDeclaration = w0t;
  Nn.ExportDefaultDeclaration = N0t;
  Nn.ExportDefaultSpecifier = E0t;
  Nn.ExportNamedDeclaration = I0t;
  Nn.ExportNamespaceSpecifier = v0t;
  Nn.ExportSpecifier = A0t;
  Nn.ImportAttribute = D0t;
  Nn.ImportDeclaration = k0t;
  Nn.ImportDefaultSpecifier = P0t;
  Nn.ImportExpression = _0t;
  Nn.ImportNamespaceSpecifier = O0t;
  Nn.ImportSpecifier = S0t;
  Nn._printAttributes = C0t;
  var d0t = fe(), m0t = op(), {
    isClassDeclaration: y0t,
    isExportDefaultSpecifier: g0t,
    isExportNamespaceSpecifier: T0t,
    isImportDefaultSpecifier: b0t,
    isImportNamespaceSpecifier: x0t,
    isStatement: fse
  } = d0t;
  function S0t(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported), t.local && t.
    local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local));
  }
  n(S0t, "ImportSpecifier");
  function P0t(t) {
    this.print(t.local);
  }
  n(P0t, "ImportDefaultSpecifier");
  function E0t(t) {
    this.print(t.exported);
  }
  n(E0t, "ExportDefaultSpecifier");
  function A0t(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported));
  }
  n(A0t, "ExportSpecifier");
  function v0t(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported);
  }
  n(v0t, "ExportNamespaceSpecifier");
  var hse = !1;
  function C0t(t, e) {
    var s;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: r,
      assertions: a
    } = t;
    r && !i && t.extra && (t.extra.deprecatedAssertSyntax || t.extra.deprecatedWithLegacySyntax) && !hse && (hse = !0, console.warn('You are\
 using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose\
 value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { t\
ype: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (s = t.extra) != null && s.deprecatedWithLegacySyntax)) {
      this.printList(r || a);
      return;
    }
    let l = e ? 1 : 0;
    this.token("{", null, l), this.space(), this.printList(r || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, l);
  }
  n(C0t, "_printAttributes");
  function w0t(t) {
    var e, s;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0),
    this.space(), this._printAttributes(t, !1)) : this.print(t.source), this.semicolon();
  }
  n(w0t, "ExportAllDeclaration");
  function dse(t, e) {
    y0t(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators);
  }
  n(dse, "maybePrintDecoratorsBeforeExport");
  function I0t(t) {
    if (dse(this, t), this.word("export"), this.space(), t.declaration) {
      let i = t.declaration;
      this.print(i), fse(i) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let i = t.specifiers.slice(0), r = !1;
      for (; ; ) {
        let o = i[0];
        if (g0t(o) || T0t(o))
          r = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !r) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), t.source) {
        var e, s;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.
        print(t.source, !0), this.space(), this._printAttributes(t, a)) : this.print(t.source);
      }
      this.semicolon();
    }
  }
  n(I0t, "ExportNamedDeclaration");
  function N0t(t) {
    dse(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    m0t.TokenContext.exportDefault;
    let e = t.declaration;
    this.print(e), fse(e) || this.semicolon();
  }
  n(N0t, "ExportDefaultDeclaration");
  function k0t(t) {
    var e, s;
    this.word("import"), this.space();
    let i = t.importKind === "type" || t.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let r = t.specifiers.slice(0), a = !!r.length;
    for (; a; ) {
      let l = r[0];
      if (b0t(l) || x0t(l))
        this.print(r.shift()), r.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    r.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(r, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (e =
    t.attributes) != null && e.length || (s = t.assertions) != null && s.length ? (this.print(t.source, !0), this.space(), this._printAttributes(
    t, o)) : this.print(t.source), this.semicolon();
  }
  n(k0t, "ImportDeclaration");
  function D0t(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(D0t, "ImportAttribute");
  function O0t(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local);
  }
  n(O0t, "ImportNamespaceSpecifier");
  function _0t(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options)), this.tokenChar(41);
  }
  n(_0t, "ImportExpression");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/types.js
var CB = g((Mi) => {
  "use strict";
  Object.defineProperty(Mi, "__esModule", {
    value: !0
  });
  Mi.ArgumentPlaceholder = j0t;
  Mi.ArrayPattern = Mi.ArrayExpression = V0t;
  Mi.BigIntLiteral = G0t;
  Mi.BooleanLiteral = J0t;
  Mi.Identifier = F0t;
  Mi.NullLiteral = Y0t;
  Mi.NumericLiteral = X0t;
  Mi.ObjectPattern = Mi.ObjectExpression = q0t;
  Mi.ObjectMethod = U0t;
  Mi.ObjectProperty = K0t;
  Mi.PipelineBareFunction = ebt;
  Mi.PipelinePrimaryTopicReference = tbt;
  Mi.PipelineTopicExpression = Z0t;
  Mi.RecordExpression = W0t;
  Mi.RegExpLiteral = H0t;
  Mi.SpreadElement = Mi.RestElement = R0t;
  Mi.StringLiteral = z0t;
  Mi.TopicReference = Q0t;
  Mi.TupleExpression = $0t;
  Mi._getRawIdentifier = M0t;
  var L0t = fe(), gse = gd(), {
    isAssignmentPattern: B0t,
    isIdentifier: vB
  } = L0t, mse = null, RE = "";
  function M0t(t) {
    if (t === mse) return RE;
    mse = t;
    let {
      name: e
    } = t, s = this.tokenMap.find(t, (i) => i.value === e);
    return s ? (RE = this._originalCode.slice(s.start, s.end), RE) : RE = t.name;
  }
  n(M0t, "_getRawIdentifier");
  function F0t(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(this.tokenMap ? this._getRawIdentifier(
    t) : t.name);
  }
  n(F0t, "Identifier");
  function j0t() {
    this.tokenChar(63);
  }
  n(j0t, "ArgumentPlaceholder");
  function R0t(t) {
    this.token("..."), this.print(t.argument);
  }
  n(R0t, "RestElement");
  function q0t(t) {
    let e = t.properties;
    if (this.tokenChar(123), e.length) {
      let s = this.enterDelimited();
      this.space(), this.printList(e, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), s();
    }
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(q0t, "ObjectExpression");
  function U0t(t) {
    this.printJoin(t.decorators), this._methodHead(t), this.space(), this.print(t.body);
  }
  n(U0t, "ObjectMethod");
  function K0t(t) {
    if (this.printJoin(t.decorators), t.computed)
      this.tokenChar(91), this.print(t.key), this.tokenChar(93);
    else {
      if (B0t(t.value) && vB(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value);
        return;
      }
      if (this.print(t.key), t.shorthand && vB(t.key) && vB(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(K0t, "ObjectProperty");
  function V0t(t) {
    let e = t.elements, s = e.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let r = 0; r < e.length; r++) {
      let a = e[r];
      a ? (r > 0 && this.space(), this.print(a), (r < s - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, r)) : this.token("\
,", !1, r);
    }
    i(), this.tokenChar(93);
  }
  n(V0t, "ArrayExpression");
  function W0t(t) {
    let e = t.properties, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      s = "#{", i = "}";
    }
    this.token(s), e.length && (this.space(), this.printList(e, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  n(W0t, "RecordExpression");
  function $0t(t) {
    let e = t.elements, s = e.length, i, r;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", r = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", r = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o), (a < s - 1 || this.shouldPrintTrailingComma(r)) && this.token(",", !1, a));
    }
    this.token(r);
  }
  n($0t, "TupleExpression");
  function H0t(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(H0t, "RegExpLiteral");
  function J0t(t) {
    this.word(t.value ? "true" : "false");
  }
  n(J0t, "BooleanLiteral");
  function Y0t() {
    this.word("null");
  }
  n(Y0t, "NullLiteral");
  function X0t(t) {
    let e = this.getPossibleRaw(t), s = this.format.jsescOption, i = t.value, r = i + "";
    s.numbers ? this.number(gse(i, s), i) : e == null ? this.number(r, i) : this.format.minified ? this.number(e.length < r.length ? e : r, i) :
    this.number(e, i);
  }
  n(X0t, "NumericLiteral");
  function z0t(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let s = gse(t.value, this.format.jsescOption);
    this.token(s);
  }
  n(z0t, "StringLiteral");
  function G0t(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(G0t, "BigIntLiteral");
  var yse = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Q0t() {
    let {
      topicToken: t
    } = this.format;
    if (yse.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), s = Array.from(yse, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${s.join(", ")} (${e} received instead).`);
    }
  }
  n(Q0t, "TopicReference");
  function Z0t(t) {
    this.print(t.expression);
  }
  n(Z0t, "PipelineTopicExpression");
  function ebt(t) {
    this.print(t.callee);
  }
  n(ebt, "PipelineBareFunction");
  function tbt() {
    this.tokenChar(35);
  }
  n(tbt, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/flow.js
var bse = g((rt) => {
  "use strict";
  Object.defineProperty(rt, "__esModule", {
    value: !0
  });
  rt.AnyTypeAnnotation = abt;
  rt.ArrayTypeAnnotation = obt;
  rt.BooleanLiteralTypeAnnotation = ubt;
  rt.BooleanTypeAnnotation = lbt;
  rt.DeclareClass = pbt;
  rt.DeclareExportAllDeclaration = Pbt;
  rt.DeclareExportDeclaration = Sbt;
  rt.DeclareFunction = hbt;
  rt.DeclareInterface = mbt;
  rt.DeclareModule = ybt;
  rt.DeclareModuleExports = gbt;
  rt.DeclareOpaqueType = bbt;
  rt.DeclareTypeAlias = Tbt;
  rt.DeclareVariable = xbt;
  rt.DeclaredPredicate = dbt;
  rt.EmptyTypeAnnotation = Wbt;
  rt.EnumBooleanBody = Abt;
  rt.EnumBooleanMember = Nbt;
  rt.EnumDeclaration = Ebt;
  rt.EnumDefaultedMember = Ibt;
  rt.EnumNumberBody = vbt;
  rt.EnumNumberMember = kbt;
  rt.EnumStringBody = Cbt;
  rt.EnumStringMember = Dbt;
  rt.EnumSymbolBody = wbt;
  rt.ExistsTypeAnnotation = _bt;
  rt.FunctionTypeAnnotation = Lbt;
  rt.FunctionTypeParam = Bbt;
  rt.IndexedAccessType = mxt;
  rt.InferredPredicate = fbt;
  rt.InterfaceDeclaration = Rbt;
  rt.GenericTypeAnnotation = rt.ClassImplements = rt.InterfaceExtends = Mbt;
  rt.InterfaceTypeAnnotation = Ubt;
  rt.IntersectionTypeAnnotation = Kbt;
  rt.MixedTypeAnnotation = Vbt;
  rt.NullLiteralTypeAnnotation = cbt;
  rt.NullableTypeAnnotation = $bt;
  Object.defineProperty(rt, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Tse.NumericLiteral;
    }, "get")
  });
  rt.NumberTypeAnnotation = Hbt;
  rt.ObjectTypeAnnotation = sxt;
  rt.ObjectTypeCallProperty = rxt;
  rt.ObjectTypeIndexer = nxt;
  rt.ObjectTypeInternalSlot = ixt;
  rt.ObjectTypeProperty = axt;
  rt.ObjectTypeSpreadProperty = oxt;
  rt.OpaqueType = txt;
  rt.OptionalIndexedAccessType = yxt;
  rt.QualifiedTypeIdentifier = lxt;
  Object.defineProperty(rt, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Tse.StringLiteral;
    }, "get")
  });
  rt.StringTypeAnnotation = Jbt;
  rt.SymbolTypeAnnotation = uxt;
  rt.ThisTypeAnnotation = Ybt;
  rt.TupleTypeAnnotation = Xbt;
  rt.TypeAlias = Gbt;
  rt.TypeAnnotation = Qbt;
  rt.TypeCastExpression = hxt;
  rt.TypeParameter = ext;
  rt.TypeParameterDeclaration = rt.TypeParameterInstantiation = Zbt;
  rt.TypeofTypeAnnotation = zbt;
  rt.UnionTypeAnnotation = pxt;
  rt.Variance = fxt;
  rt.VoidTypeAnnotation = dxt;
  rt._interfaceish = Fbt;
  rt._variance = jbt;
  var sbt = fe(), ibt = AB(), rbt = op(), Tse = CB(), {
    isDeclareExportDeclaration: qE,
    isStatement: nbt
  } = sbt;
  function abt() {
    this.word("any");
  }
  n(abt, "AnyTypeAnnotation");
  function obt(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(obt, "ArrayTypeAnnotation");
  function lbt() {
    this.word("boolean");
  }
  n(lbt, "BooleanTypeAnnotation");
  function ubt(t) {
    this.word(t.value ? "true" : "false");
  }
  n(ubt, "BooleanLiteralTypeAnnotation");
  function cbt() {
    this.word("null");
  }
  n(cbt, "NullLiteralTypeAnnotation");
  function pbt(t, e) {
    qE(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(pbt, "DeclareClass");
  function hbt(t, e) {
    qE(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation.typeAnnotation),
    t.predicate && (this.space(), this.print(t.predicate)), this.semicolon();
  }
  n(hbt, "DeclareFunction");
  function fbt() {
    this.tokenChar(37), this.word("checks");
  }
  n(fbt, "InferredPredicate");
  function dbt(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value), this.tokenChar(41);
  }
  n(dbt, "DeclaredPredicate");
  function mbt(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(mbt, "DeclareInterface");
  function ybt(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id), this.space(), this.print(t.body);
  }
  n(ybt, "DeclareModule");
  function gbt(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation);
  }
  n(gbt, "DeclareModuleExports");
  function Tbt(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(Tbt, "DeclareTypeAlias");
  function bbt(t, e) {
    qE(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(bbt, "DeclareOpaqueType");
  function xbt(t, e) {
    qE(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id), this.print(t.id.typeAnnotation), this.semicolon();
  }
  n(xbt, "DeclareVariable");
  function Sbt(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), Obt.call(this,
    t);
  }
  n(Sbt, "DeclareExportDeclaration");
  function Pbt(t) {
    this.word("declare"), this.space(), ibt.ExportAllDeclaration.call(this, t);
  }
  n(Pbt, "DeclareExportAllDeclaration");
  function Ebt(t) {
    let {
      id: e,
      body: s
    } = t;
    this.word("enum"), this.space(), this.print(e), this.print(s);
  }
  n(Ebt, "EnumDeclaration");
  function UE(t, e, s) {
    s && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(UE, "enumExplicitType");
  function KE(t, e) {
    let {
      members: s
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let i of s)
      t.print(i), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(KE, "enumBody");
  function Abt(t) {
    let {
      explicitType: e
    } = t;
    UE(this, "boolean", e), KE(this, t);
  }
  n(Abt, "EnumBooleanBody");
  function vbt(t) {
    let {
      explicitType: e
    } = t;
    UE(this, "number", e), KE(this, t);
  }
  n(vbt, "EnumNumberBody");
  function Cbt(t) {
    let {
      explicitType: e
    } = t;
    UE(this, "string", e), KE(this, t);
  }
  n(Cbt, "EnumStringBody");
  function wbt(t) {
    UE(this, "symbol", !0), KE(this, t);
  }
  n(wbt, "EnumSymbolBody");
  function Ibt(t) {
    let {
      id: e
    } = t;
    this.print(e), this.tokenChar(44);
  }
  n(Ibt, "EnumDefaultedMember");
  function wB(t, e) {
    t.print(e.id), t.space(), t.token("="), t.space(), t.print(e.init), t.token(",");
  }
  n(wB, "enumInitializedMember");
  function Nbt(t) {
    wB(this, t);
  }
  n(Nbt, "EnumBooleanMember");
  function kbt(t) {
    wB(this, t);
  }
  n(kbt, "EnumNumberMember");
  function Dbt(t) {
    wB(this, t);
  }
  n(Dbt, "EnumStringMember");
  function Obt(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e), nbt(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source)), this.semicolon();
  }
  n(Obt, "FlowExportDeclaration");
  function _bt() {
    this.tokenChar(42);
  }
  n(_bt, "ExistsTypeAnnotation");
  function Lbt(t, e) {
    this.print(t.typeParameters), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation),
    (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params), t.rest && (t.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(t.rest)), this.tokenChar(41);
    let s = e?.type;
    s != null && (s === "ObjectTypeCallProperty" || s === "ObjectTypeInternalSlot" || s === "DeclareFunction" || s === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType);
  }
  n(Lbt, "FunctionTypeAnnotation");
  function Bbt(t) {
    this.print(t.name), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation);
  }
  n(Bbt, "FunctionTypeParam");
  function Mbt(t) {
    this.print(t.id), this.print(t.typeParameters, !0);
  }
  n(Mbt, "InterfaceExtends");
  function Fbt(t) {
    var e;
    if (this.print(t.id), this.print(t.typeParameters), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(),
    this.printList(t.extends)), t.type === "DeclareClass") {
      var s, i;
      (s = t.mixins) != null && s.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins)), (i = t.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements));
    }
    this.space(), this.print(t.body);
  }
  n(Fbt, "_interfaceish");
  function jbt(t) {
    var e;
    let s = (e = t.variance) == null ? void 0 : e.kind;
    s != null && (s === "plus" ? this.tokenChar(43) : s === "minus" && this.tokenChar(45));
  }
  n(jbt, "_variance");
  function Rbt(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(Rbt, "InterfaceDeclaration");
  function qbt(t) {
    this.space(), this.token("&", !1, t), this.space();
  }
  n(qbt, "andSeparator");
  function Ubt(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends)),
    this.space(), this.print(t.body);
  }
  n(Ubt, "InterfaceTypeAnnotation");
  function Kbt(t) {
    this.printJoin(t.types, void 0, void 0, qbt);
  }
  n(Kbt, "IntersectionTypeAnnotation");
  function Vbt() {
    this.word("mixed");
  }
  n(Vbt, "MixedTypeAnnotation");
  function Wbt() {
    this.word("empty");
  }
  n(Wbt, "EmptyTypeAnnotation");
  function $bt(t) {
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n($bt, "NullableTypeAnnotation");
  function Hbt() {
    this.word("number");
  }
  n(Hbt, "NumberTypeAnnotation");
  function Jbt() {
    this.word("string");
  }
  n(Jbt, "StringTypeAnnotation");
  function Ybt() {
    this.word("this");
  }
  n(Ybt, "ThisTypeAnnotation");
  function Xbt(t) {
    this.tokenChar(91), this.printList(t.types), this.tokenChar(93);
  }
  n(Xbt, "TupleTypeAnnotation");
  function zbt(t) {
    this.word("typeof"), this.space(), this.print(t.argument);
  }
  n(zbt, "TypeofTypeAnnotation");
  function Gbt(t) {
    this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    t.right), this.semicolon();
  }
  n(Gbt, "TypeAlias");
  function Qbt(t, e) {
    this.tokenChar(58), this.space(), e.type === "ArrowFunctionExpression" ? this.tokenContext |= rbt.TokenContext.arrowFlowReturnType : t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(Qbt, "TypeAnnotation");
  function Zbt(t) {
    this.tokenChar(60), this.printList(t.params), this.tokenChar(62);
  }
  n(Zbt, "TypeParameterInstantiation");
  function ext(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default));
  }
  n(ext, "TypeParameter");
  function txt(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id), this.print(t.typeParameters), t.supertype && (this.
    tokenChar(58), this.space(), this.print(t.supertype)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(t.impltype)),
    this.semicolon();
  }
  n(txt, "OpaqueType");
  function sxt(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, !0, !0, void 0, void 0, /* @__PURE__ */ n(function(i) {
      if (i && !e[0]) return 1;
    }, "addNewlines"), () => {
      (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(sxt, "ObjectTypeAnnotation");
  function ixt(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value);
  }
  n(ixt, "ObjectTypeInternalSlot");
  function rxt(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value);
  }
  n(rxt, "ObjectTypeCallProperty");
  function nxt(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id), this.tokenChar(58), this.
    space()), this.print(t.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(nxt, "ObjectTypeIndexer");
  function axt(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58),
    this.space()), this.print(t.value);
  }
  n(axt, "ObjectTypeProperty");
  function oxt(t) {
    this.token("..."), this.print(t.argument);
  }
  n(oxt, "ObjectTypeSpreadProperty");
  function lxt(t) {
    this.print(t.qualification), this.tokenChar(46), this.print(t.id);
  }
  n(lxt, "QualifiedTypeIdentifier");
  function uxt() {
    this.word("symbol");
  }
  n(uxt, "SymbolTypeAnnotation");
  function cxt(t) {
    this.space(), this.token("|", !1, t), this.space();
  }
  n(cxt, "orSeparator");
  function pxt(t) {
    this.printJoin(t.types, void 0, void 0, cxt);
  }
  n(pxt, "UnionTypeAnnotation");
  function hxt(t) {
    this.tokenChar(40), this.print(t.expression), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(hxt, "TypeCastExpression");
  function fxt(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(fxt, "Variance");
  function dxt() {
    this.word("void");
  }
  n(dxt, "VoidTypeAnnotation");
  function mxt(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(mxt, "IndexedAccessType");
  function yxt(t) {
    this.print(t.objectType), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(yxt, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/base.js
var xse = g((Ou) => {
  "use strict";
  Object.defineProperty(Ou, "__esModule", {
    value: !0
  });
  Ou.BlockStatement = bxt;
  Ou.Directive = xxt;
  Ou.DirectiveLiteral = Ext;
  Ou.File = gxt;
  Ou.InterpreterDirective = Axt;
  Ou.Placeholder = vxt;
  Ou.Program = Txt;
  function gxt(t) {
    t.program && this.print(t.program.interpreter), this.print(t.program);
  }
  n(gxt, "File");
  function Txt(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let s = (e = t.directives) == null ? void 0 : e.length;
    if (s) {
      var i;
      let r = t.body.length ? 2 : 1;
      this.printSequence(t.directives, void 0, r), (i = t.directives[s - 1].trailingComments) != null && i.length || this.newline(r);
    }
    this.printSequence(t.body);
  }
  n(Txt, "Program");
  function bxt(t) {
    var e;
    this.tokenChar(123);
    let s = this.enterDelimited(), i = (e = t.directives) == null ? void 0 : e.length;
    if (i) {
      var r;
      let a = t.body.length ? 2 : 1;
      this.printSequence(t.directives, !0, a), (r = t.directives[i - 1].trailingComments) != null && r.length || this.newline(a);
    }
    this.printSequence(t.body, !0), s(), this.rightBrace(t);
  }
  n(bxt, "BlockStatement");
  function xxt(t) {
    this.print(t.value), this.semicolon();
  }
  n(xxt, "Directive");
  var Sxt = /(?:^|[^\\])(?:\\\\)*'/, Pxt = /(?:^|[^\\])(?:\\\\)*"/;
  function Ext(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: s
    } = t;
    if (!Pxt.test(s))
      this.token(`"${s}"`);
    else if (!Sxt.test(s))
      this.token(`'${s}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(Ext, "DirectiveLiteral");
  function Axt(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(Axt, "InterpreterDirective");
  function vxt(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(vxt, "Placeholder");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/jsx.js
var Sse = g((Hr) => {
  "use strict";
  Object.defineProperty(Hr, "__esModule", {
    value: !0
  });
  Hr.JSXAttribute = Cxt;
  Hr.JSXClosingElement = Fxt;
  Hr.JSXClosingFragment = Uxt;
  Hr.JSXElement = Lxt;
  Hr.JSXEmptyExpression = jxt;
  Hr.JSXExpressionContainer = Dxt;
  Hr.JSXFragment = Rxt;
  Hr.JSXIdentifier = wxt;
  Hr.JSXMemberExpression = Nxt;
  Hr.JSXNamespacedName = Ixt;
  Hr.JSXOpeningElement = Mxt;
  Hr.JSXOpeningFragment = qxt;
  Hr.JSXSpreadAttribute = kxt;
  Hr.JSXSpreadChild = Oxt;
  Hr.JSXText = _xt;
  function Cxt(t) {
    this.print(t.name), t.value && (this.tokenChar(61), this.print(t.value));
  }
  n(Cxt, "JSXAttribute");
  function wxt(t) {
    this.word(t.name);
  }
  n(wxt, "JSXIdentifier");
  function Ixt(t) {
    this.print(t.namespace), this.tokenChar(58), this.print(t.name);
  }
  n(Ixt, "JSXNamespacedName");
  function Nxt(t) {
    this.print(t.object), this.tokenChar(46), this.print(t.property);
  }
  n(Nxt, "JSXMemberExpression");
  function kxt(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument), this.rightBrace(t);
  }
  n(kxt, "JSXSpreadAttribute");
  function Dxt(t) {
    this.tokenChar(123), this.print(t.expression), this.rightBrace(t);
  }
  n(Dxt, "JSXExpressionContainer");
  function Oxt(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression), this.rightBrace(t);
  }
  n(Oxt, "JSXSpreadChild");
  function _xt(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(_xt, "JSXText");
  function Lxt(t) {
    let e = t.openingElement;
    if (this.print(e), !e.selfClosing) {
      this.indent();
      for (let s of t.children)
        this.print(s);
      this.dedent(), this.print(t.closingElement);
    }
  }
  n(Lxt, "JSXElement");
  function Bxt() {
    this.space();
  }
  n(Bxt, "spaceSeparator");
  function Mxt(t) {
    this.tokenChar(60), this.print(t.name), t.typeArguments && this.print(t.typeArguments), this.print(t.typeParameters), t.attributes.length >
    0 && (this.space(), this.printJoin(t.attributes, void 0, void 0, Bxt)), t.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  n(Mxt, "JSXOpeningElement");
  function Fxt(t) {
    this.tokenChar(60), this.tokenChar(47), this.print(t.name), this.tokenChar(62);
  }
  n(Fxt, "JSXClosingElement");
  function jxt() {
    this.printInnerComments();
  }
  n(jxt, "JSXEmptyExpression");
  function Rxt(t) {
    this.print(t.openingFragment), this.indent();
    for (let e of t.children)
      this.print(e);
    this.dedent(), this.print(t.closingFragment);
  }
  n(Rxt, "JSXFragment");
  function qxt() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(qxt, "JSXOpeningFragment");
  function Uxt() {
    this.token("</"), this.tokenChar(62);
  }
  n(Uxt, "JSXClosingFragment");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/typescript.js
var Cse = g((ze) => {
  "use strict";
  Object.defineProperty(ze, "__esModule", {
    value: !0
  });
  ze.TSAnyKeyword = tSt;
  ze.TSArrayType = PSt;
  ze.TSSatisfiesExpression = ze.TSAsExpression = USt;
  ze.TSBigIntKeyword = sSt;
  ze.TSBooleanKeyword = aSt;
  ze.TSCallSignatureDeclaration = Xxt;
  ze.TSInterfaceHeritage = ze.TSClassImplements = FSt;
  ze.TSConditionalType = NSt;
  ze.TSConstructSignatureDeclaration = zxt;
  ze.TSConstructorType = ySt;
  ze.TSDeclareFunction = Hxt;
  ze.TSDeclareMethod = Jxt;
  ze.TSEnumBody = vse;
  ze.TSEnumDeclaration = WSt;
  ze.TSEnumMember = $St;
  ze.TSExportAssignment = QSt;
  ze.TSExternalModuleReference = zSt;
  ze.TSFunctionType = mSt;
  ze.TSImportEqualsDeclaration = XSt;
  ze.TSImportType = YSt;
  ze.TSIndexSignature = eSt;
  ze.TSIndexedAccessType = _St;
  ze.TSInferType = kSt;
  ze.TSInstantiationExpression = VSt;
  ze.TSInterfaceBody = RSt;
  ze.TSInterfaceDeclaration = jSt;
  ze.TSIntersectionType = ISt;
  ze.TSIntrinsicKeyword = fSt;
  ze.TSLiteralType = MSt;
  ze.TSMappedType = LSt;
  ze.TSMethodSignature = Zxt;
  ze.TSModuleBlock = JSt;
  ze.TSModuleDeclaration = HSt;
  ze.TSNamedTupleMember = CSt;
  ze.TSNamespaceExportDeclaration = ZSt;
  ze.TSNeverKeyword = hSt;
  ze.TSNonNullExpression = GSt;
  ze.TSNullKeyword = pSt;
  ze.TSNumberKeyword = rSt;
  ze.TSObjectKeyword = nSt;
  ze.TSOptionalType = ASt;
  ze.TSParameterProperty = $xt;
  ze.TSParenthesizedType = DSt;
  ze.TSPropertySignature = Gxt;
  ze.TSQualifiedName = Yxt;
  ze.TSRestType = vSt;
  ze.TSStringKeyword = oSt;
  ze.TSSymbolKeyword = lSt;
  ze.TSTemplateLiteralType = BSt;
  ze.TSThisType = dSt;
  ze.TSTupleType = ESt;
  ze.TSTypeAliasDeclaration = qSt;
  ze.TSTypeAnnotation = Kxt;
  ze.TSTypeAssertion = KSt;
  ze.TSTypeLiteral = SSt;
  ze.TSTypeOperator = OSt;
  ze.TSTypeParameter = Wxt;
  ze.TSTypeParameterDeclaration = ze.TSTypeParameterInstantiation = Vxt;
  ze.TSTypePredicate = bSt;
  ze.TSTypeQuery = xSt;
  ze.TSTypeReference = TSt;
  ze.TSUndefinedKeyword = cSt;
  ze.TSUnionType = wSt;
  ze.TSUnknownKeyword = iSt;
  ze.TSVoidKeyword = uSt;
  ze.tsPrintClassMemberModifiers = tPt;
  ze.tsPrintFunctionOrConstructorType = gSt;
  ze.tsPrintPropertyOrMethodName = Qxt;
  ze.tsPrintSignatureDeclarationBase = ePt;
  function Kxt(t, e) {
    this.token((e.type === "TSFunctionType" || e.type === "TSConstructorType") && e.typeAnnotation === t ? "=>" : ":"), this.space(), t.optional &&
    this.tokenChar(63), this.print(t.typeAnnotation);
  }
  n(Kxt, "TSTypeAnnotation");
  function Vxt(t, e) {
    this.tokenChar(60);
    let s = e.type === "ArrowFunctionExpression" && t.params.length === 1;
    this.tokenMap && t.start != null && t.end != null && (s && (s = !!this.tokenMap.find(t, (i) => this.tokenMap.matchesOriginal(i, ","))), s ||
    (s = this.shouldPrintTrailingComma(">"))), this.printList(t.params, s), this.tokenChar(62);
  }
  n(Vxt, "TSTypeParameterInstantiation");
  function Wxt(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.default));
  }
  n(Wxt, "TSTypeParameter");
  function $xt(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n($xt, "TSParameterProperty");
  function Hxt(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.semicolon();
  }
  n(Hxt, "TSDeclareFunction");
  function Jxt(t) {
    this._classMethodHead(t), this.semicolon();
  }
  n(Jxt, "TSDeclareMethod");
  function Yxt(t) {
    this.print(t.left), this.tokenChar(46), this.print(t.right);
  }
  n(Yxt, "TSQualifiedName");
  function Xxt(t) {
    this.tsPrintSignatureDeclarationBase(t), _T(this, t);
  }
  n(Xxt, "TSCallSignatureDeclaration");
  function _T(t, e) {
    if (!t.tokenMap || !e.start || !e.end) {
      t.semicolon();
      return;
    }
    t.tokenMap.endMatches(e, ",") ? t.token(",") : t.tokenMap.endMatches(e, ";") && t.semicolon();
  }
  n(_T, "maybePrintTrailingCommaOrSemicolon");
  function zxt(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), _T(this, t);
  }
  n(zxt, "TSConstructSignatureDeclaration");
  function Gxt(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation), _T(this, t);
  }
  n(Gxt, "TSPropertySignature");
  function Qxt(t) {
    t.computed && this.tokenChar(91), this.print(t.key), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(Qxt, "tsPrintPropertyOrMethodName");
  function Zxt(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), _T(this, t);
  }
  n(Zxt, "TSMethodSignature");
  function eSt(t) {
    let {
      readonly: e,
      static: s
    } = t;
    s && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    "]"), this.print(t.typeAnnotation), _T(this, t);
  }
  n(eSt, "TSIndexSignature");
  function tSt() {
    this.word("any");
  }
  n(tSt, "TSAnyKeyword");
  function sSt() {
    this.word("bigint");
  }
  n(sSt, "TSBigIntKeyword");
  function iSt() {
    this.word("unknown");
  }
  n(iSt, "TSUnknownKeyword");
  function rSt() {
    this.word("number");
  }
  n(rSt, "TSNumberKeyword");
  function nSt() {
    this.word("object");
  }
  n(nSt, "TSObjectKeyword");
  function aSt() {
    this.word("boolean");
  }
  n(aSt, "TSBooleanKeyword");
  function oSt() {
    this.word("string");
  }
  n(oSt, "TSStringKeyword");
  function lSt() {
    this.word("symbol");
  }
  n(lSt, "TSSymbolKeyword");
  function uSt() {
    this.word("void");
  }
  n(uSt, "TSVoidKeyword");
  function cSt() {
    this.word("undefined");
  }
  n(cSt, "TSUndefinedKeyword");
  function pSt() {
    this.word("null");
  }
  n(pSt, "TSNullKeyword");
  function hSt() {
    this.word("never");
  }
  n(hSt, "TSNeverKeyword");
  function fSt() {
    this.word("intrinsic");
  }
  n(fSt, "TSIntrinsicKeyword");
  function dSt() {
    this.word("this");
  }
  n(dSt, "TSThisType");
  function mSt(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(mSt, "TSFunctionType");
  function ySt(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(ySt, "TSConstructorType");
  function gSt(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")"), this.space();
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(gSt, "tsPrintFunctionOrConstructorType");
  function TSt(t) {
    let e = t.typeParameters;
    this.print(t.typeName, !!e), this.print(e);
  }
  n(TSt, "TSTypeReference");
  function bSt(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(bSt, "TSTypePredicate");
  function xSt(t) {
    this.word("typeof"), this.space(), this.print(t.exprName);
    let e = t.typeParameters;
    e && this.print(e);
  }
  n(xSt, "TSTypeQuery");
  function SSt(t) {
    VE(this, t, () => this.printJoin(t.members, !0, !0));
  }
  n(SSt, "TSTypeLiteral");
  function PSt(t) {
    this.print(t.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(PSt, "TSArrayType");
  function ESt(t) {
    this.tokenChar(91), this.printList(t.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  n(ESt, "TSTupleType");
  function ASt(t) {
    this.print(t.typeAnnotation), this.tokenChar(63);
  }
  n(ASt, "TSOptionalType");
  function vSt(t) {
    this.token("..."), this.print(t.typeAnnotation);
  }
  n(vSt, "TSRestType");
  function CSt(t) {
    this.print(t.label), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType);
  }
  n(CSt, "TSNamedTupleMember");
  function wSt(t) {
    Ase(this, t, "|");
  }
  n(wSt, "TSUnionType");
  function ISt(t) {
    Ase(this, t, "&");
  }
  n(ISt, "TSIntersectionType");
  function Ase(t, e, s) {
    var i;
    let r = 0;
    (i = t.tokenMap) != null && i.startMatches(e, s) && (r = 1, t.token(s)), t.printJoin(e.types, void 0, void 0, function(a) {
      this.space(), this.token(s, null, a + r), this.space();
    });
  }
  n(Ase, "tsPrintUnionOrIntersectionType");
  function NSt(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(NSt, "TSConditionalType");
  function kSt(t) {
    this.word("infer"), this.print(t.typeParameter);
  }
  n(kSt, "TSInferType");
  function DSt(t) {
    this.tokenChar(40), this.print(t.typeAnnotation), this.tokenChar(41);
  }
  n(DSt, "TSParenthesizedType");
  function OSt(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation);
  }
  n(OSt, "TSTypeOperator");
  function _St(t) {
    this.print(t.objectType, !0), this.tokenChar(91), this.print(t.indexType), this.tokenChar(93);
  }
  n(_St, "TSIndexedAccessType");
  function LSt(t) {
    let {
      nameType: e,
      optional: s,
      readonly: i,
      typeAnnotation: r
    } = t;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (Pse(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(t.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(t.typeParameter.constraint), e && (this.space(), this.word("as"), this.space(), this.print(e)),
    this.tokenChar(93), s && (Pse(this, s), this.tokenChar(63)), r && (this.tokenChar(58), this.space(), this.print(r)), this.space(), a(), this.
    tokenChar(125);
  }
  n(LSt, "TSMappedType");
  function Pse(t, e) {
    e !== !0 && t.token(e);
  }
  n(Pse, "tokenIfPlusMinus");
  function BSt(t) {
    this._printTemplate(t, t.types);
  }
  n(BSt, "TSTemplateLiteralType");
  function MSt(t) {
    this.print(t.literal);
  }
  n(MSt, "TSLiteralType");
  function FSt(t) {
    this.print(t.expression), this.print(t.typeArguments);
  }
  n(FSt, "TSClassImplements");
  function jSt(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      extends: r,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(s), this.print(i), r != null && r.length && (this.
    space(), this.word("extends"), this.space(), this.printList(r)), this.space(), this.print(a);
  }
  n(jSt, "TSInterfaceDeclaration");
  function RSt(t) {
    VE(this, t, () => this.printJoin(t.body, !0, !0));
  }
  n(RSt, "TSInterfaceBody");
  function qSt(t) {
    let {
      declare: e,
      id: s,
      typeParameters: i,
      typeAnnotation: r
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(s), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(r), this.semicolon();
  }
  n(qSt, "TSTypeAliasDeclaration");
  function USt(t) {
    let {
      type: e,
      expression: s,
      typeAnnotation: i
    } = t;
    this.print(s, !0), this.space(), this.word(e === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  n(USt, "TSTypeExpression");
  function KSt(t) {
    let {
      typeAnnotation: e,
      expression: s
    } = t;
    this.tokenChar(60), this.print(e), this.tokenChar(62), this.space(), this.print(s);
  }
  n(KSt, "TSTypeAssertion");
  function VSt(t) {
    this.print(t.expression), this.print(t.typeParameters);
  }
  n(VSt, "TSInstantiationExpression");
  function WSt(t) {
    let {
      declare: e,
      const: s,
      id: i
    } = t;
    e && (this.word("declare"), this.space()), s && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), vse.call(this, t);
  }
  n(WSt, "TSEnumDeclaration");
  function vse(t) {
    VE(this, t, () => {
      var e;
      return this.printList(t.members, (e = this.shouldPrintTrailingComma("}")) != null ? e : !0, !0, !0);
    });
  }
  n(vse, "TSEnumBody");
  function $St(t) {
    let {
      id: e,
      initializer: s
    } = t;
    this.print(e), s && (this.space(), this.tokenChar(61), this.space(), this.print(s));
  }
  n($St, "TSEnumMember");
  function HSt(t) {
    let {
      declare: e,
      id: s,
      kind: i
    } = t;
    e && (this.word("declare"), this.space());
    {
      if (t.global || (this.word(i ?? (s.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(s), !t.body) {
        this.semicolon();
        return;
      }
      let r = t.body;
      for (; r.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(r.id), r = r.body;
      this.space(), this.print(r);
    }
  }
  n(HSt, "TSModuleDeclaration");
  function JSt(t) {
    VE(this, t, () => this.printSequence(t.body, !0));
  }
  n(JSt, "TSModuleBlock");
  function YSt(t) {
    let {
      argument: e,
      qualifier: s,
      options: i
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), s && (this.tokenChar(
    46), this.print(s));
    let r = t.typeParameters;
    r && this.print(r);
  }
  n(YSt, "TSImportType");
  function XSt(t) {
    let {
      id: e,
      moduleReference: s
    } = t;
    t.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(e), this.space(), this.tokenChar(61), this.
    space(), this.print(s), this.semicolon();
  }
  n(XSt, "TSImportEqualsDeclaration");
  function zSt(t) {
    this.token("require("), this.print(t.expression), this.tokenChar(41);
  }
  n(zSt, "TSExternalModuleReference");
  function GSt(t) {
    this.print(t.expression), this.tokenChar(33);
  }
  n(GSt, "TSNonNullExpression");
  function QSt(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression), this.semicolon();
  }
  n(QSt, "TSExportAssignment");
  function ZSt(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id), this.semicolon();
  }
  n(ZSt, "TSNamespaceExportDeclaration");
  function ePt(t) {
    let {
      typeParameters: e
    } = t, s = t.parameters;
    this.print(e), this.tokenChar(40), this._parameters(s, ")");
    let i = t.typeAnnotation;
    this.print(i);
  }
  n(ePt, "tsPrintSignatureDeclarationBase");
  function tPt(t) {
    let e = t.type === "ClassPrivateProperty", s = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    Ese(this, t, [s && t.declare && "declare", !e && t.accessibility]), t.static && (this.word("static"), this.space()), Ese(this, t, [!e &&
    t.abstract && "abstract", !e && t.override && "override", (s || e) && t.readonly && "readonly"]);
  }
  n(tPt, "tsPrintClassMemberModifiers");
  function VE(t, e, s) {
    t.token("{");
    let i = t.enterDelimited();
    s(), i(), t.rightBrace(e);
  }
  n(VE, "printBraced");
  function Ese(t, e, s) {
    var i;
    let r = /* @__PURE__ */ new Set();
    for (let a of s)
      a && r.add(a);
    (i = t.tokenMap) == null || i.find(e, (a) => {
      if (r.has(a.value))
        return t.token(a.value), t.space(), r.delete(a.value), r.size === 0;
    });
    for (let a of r)
      t.word(a), t.space();
  }
  n(Ese, "printModifiersList");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/index.js
var wse = g((Os) => {
  "use strict";
  Object.defineProperty(Os, "__esModule", {
    value: !0
  });
  var IB = ise();
  Object.keys(IB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === IB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return IB[t];
      }, "get")
    });
  });
  var NB = nse();
  Object.keys(NB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === NB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return NB[t];
      }, "get")
    });
  });
  var kB = use();
  Object.keys(kB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === kB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return kB[t];
      }, "get")
    });
  });
  var DB = cse();
  Object.keys(DB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === DB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return DB[t];
      }, "get")
    });
  });
  var OB = pse();
  Object.keys(OB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === OB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return OB[t];
      }, "get")
    });
  });
  var _B = AB();
  Object.keys(_B).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === _B[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return _B[t];
      }, "get")
    });
  });
  var LB = CB();
  Object.keys(LB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === LB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return LB[t];
      }, "get")
    });
  });
  var BB = bse();
  Object.keys(BB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === BB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return BB[t];
      }, "get")
    });
  });
  var MB = xse();
  Object.keys(MB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === MB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return MB[t];
      }, "get")
    });
  });
  var FB = Sse();
  Object.keys(FB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === FB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return FB[t];
      }, "get")
    });
  });
  var jB = Cse();
  Object.keys(jB).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Os && Os[t] === jB[t] || Object.defineProperty(Os, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return jB[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/generators/deprecated.js
var Ise = g((RB) => {
  "use strict";
  Object.defineProperty(RB, "__esModule", {
    value: !0
  });
  RB.addDeprecatedGenerators = sPt;
  function sPt(t) {
    {
      let e = {
        Noop() {
        },
        TSExpressionWithTypeArguments(s) {
          this.print(s.expression), this.print(s.typeParameters);
        },
        DecimalLiteral(s) {
          let i = this.getPossibleRaw(s);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(s.value + "m");
        }
      };
      Object.assign(t.prototype, e);
    }
  }
  n(sPt, "addDeprecatedGenerators");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/printer.js
var Ose = g((WE) => {
  "use strict";
  Object.defineProperty(WE, "__esModule", {
    value: !0
  });
  WE.default = void 0;
  var iPt = Rte(), kse = op(), rPt = fe(), nPt = sse(), aPt = wse(), oPt = Ise(), {
    isExpression: lPt,
    isFunction: uPt,
    isStatement: cPt,
    isClassBody: pPt,
    isTSInterfaceBody: hPt,
    isTSEnumMember: fPt
  } = rPt, dPt = /e/i, mPt = /\.0+$/, Dse = /[\n\r\u2028\u2029]/, yPt = /[\n\r\u2028\u2029]|\*\//;
  function Nse(t) {
    return t.type === "CommentLine" || Dse.test(t.value);
  }
  n(Nse, "commentIsNewline");
  var {
    needsParens: gPt
  } = kse, LT = class {
    static {
      n(this, "Printer");
    }
    constructor(e, s, i, r) {
      this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent =
      0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e,
      this._tokens = i, this._originalCode = r, this._indentRepeat = e.indent.style.length, this._inputMap = s?._inputMap, this._buf = new iPt.
      default(s, e.indent.style[0]);
    }
    enterForStatementInit() {
      return this.inForStatementInit ? () => {
      } : (this.inForStatementInit = !0, () => {
        this.inForStatementInit = !1;
      });
    }
    enterDelimited() {
      let e = this.inForStatementInit, s = this._noLineTerminatorAfterNode;
      return e === !1 && s === null ? () => {
      } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
        this.inForStatementInit = e, this._noLineTerminatorAfterNode = s;
      });
    }
    generate(e) {
      return this.format.preserveFormat && (this.tokenMap = new nPt.TokenMap(e, this._tokens, this._originalCode)), this.print(e), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent++;
    }
    dedent() {
      let {
        format: e
      } = this;
      e.preserveFormat || e.compact || e.concise || this._indent--;
    }
    semicolon(e = !1) {
      if (this._maybeAddAuxComment(), e) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let s = this._currentNode;
        if (s.start != null && s.end != null) {
          if (!this.tokenMap.endMatches(s, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      let {
        format: s
      } = this;
      if (!(s.compact || s.preserveFormat)) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(e, s = !1) {
      this.tokenContext = 0, this._maybePrintInnerComments(e), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e), (this.
      _endsWithWord || this._endsWithDiv && e.charCodeAt(0) === 47) && this._space(), this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator =
      s;
    }
    number(e, s) {
      function i(r) {
        if (r.length > 2 && r.charCodeAt(0) === 48) {
          let a = r.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(i, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(s) && !i(e) && !dPt.test(e) && !mPt.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, s = !1, i = 0) {
      this.tokenContext = 0, this._maybePrintInnerComments(e, i), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e,
      i);
      let r = this.getLastChar(), a = e.charCodeAt(0);
      (r === 33 && (e === "--" || a === 61) || a === 43 && r === 43 || a === 45 && r === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(e, s), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this.tokenContext = 0;
      let s = String.fromCharCode(e);
      this._maybePrintInnerComments(s), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(s);
      let i = this.getLastChar();
      (e === 43 && i === 43 || e === 45 && i === 45 || e === 46 && this._endsWithInteger) && this._space(), this._appendChar(e), this._noLineTerminator =
      !1;
    }
    newline(e = 1, s) {
      if (!(e <= 0)) {
        if (!s) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let i = 0; i < e; i++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, s) {
      if (!e) {
        s();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, s);
    }
    source(e, s) {
      s && (this._catchUp(e, s), this._buf.source(e, s));
    }
    sourceWithOffset(e, s, i) {
      !s || this.format.preserveFormat || (this._catchUp(e, s), this._buf.sourceWithOffset(e, s, i));
    }
    sourceIdentifierName(e, s) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = s, i.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(e, s = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, e, s);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(e, s) {
      this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, s), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(e) {
      this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(e) {
      this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let s = e - this._buf.getCurrentLine();
      for (let i = 0; i < s; i++)
        this._newline();
    }
    _catchUp(e, s) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && s != null && s[e] && this.catchUp(s[e].line);
        return;
      }
      let r = s?.[e];
      r != null && this._catchUpTo(r);
    }
    _catchUpTo({
      line: e,
      column: s,
      index: i
    }) {
      let r = e - this._buf.getCurrentLine();
      if (r > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < r; o++)
        this._newline();
      let a = r > 0 ? s : s - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e) {
      this._noLineTerminator = !0, this.print(e);
    }
    print(e, s, i) {
      var r, a, o;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let l = e.type, u = this.format, c = u.concise;
      e._compact && (u.concise = !0);
      let p = this[l];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(e.constructor.name)}`);
      let h = this._currentNode;
      this._currentNode = e, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let f = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !f);
      let d = (r = e.extra) == null ? void 0 : r.parenthesized, y = d && u.preserveFormat || d && u.retainFunctionParens && l === "FunctionE\
xpression" || gPt(e, h, this.tokenContext, this.inForStatementInit, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!y && d && (a = e.leadingComments) != null && a.length && e.leadingComments[0].type === "CommentBlock")
        switch (h?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (h.callee !== e) break;
          default:
            y = !0;
        }
      let m = !1;
      !y && this._noLineTerminator && ((o = e.leadingComments) != null && o.some(Nse) || this.format.retainLines && e.loc && e.loc.start.line >
      this._buf.getCurrentLine()) && (y = !0, m = !0);
      let T, b;
      if (!y && (s || (s = h && this._noLineTerminatorAfterNode === h && kse.isLastChild(h, e)), s)) {
        var E;
        (E = e.trailingComments) != null && E.some(Nse) ? lPt(e) && (y = !0) : (T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        e);
      }
      y && (this.tokenChar(40), m && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (b = !0, this.inForStatementInit =
      !1), T = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(
      e, h);
      let w = l === "Program" || l === "File" ? null : e.loc;
      this.exactSource(w, p.bind(this, e, h)), y ? (this._printTrailingComments(e, h), m && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = s, b && (this.inForStatementInit = !0)) : s && !this._noLineTerminator ? (this._noLineTerminator = !0, this.
      _printTrailingComments(e, h)) : this._printTrailingComments(e, h, i), this._currentNode = h, u.concise = c, this._insideAux = f, T !==
      void 0 && (this._noLineTerminatorAfterNode = T), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let s = e.extra;
      if (s?.raw != null && s.rawValue != null && e.value === s.rawValue)
        return s.raw;
    }
    printJoin(e, s, i, r, a, o, l, u) {
      if (!(e != null && e.length)) return;
      if (i == null && this.format.retainLines) {
        var c;
        let m = (c = e[0].loc) == null ? void 0 : c.start.line;
        m != null && m !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let p = {
        addNewlines: o,
        nextNodeStartLine: 0
      }, h = r?.bind(this), f = e.length;
      for (let m = 0; m < f; m++) {
        let T = e[m];
        if (T && (s && this._printNewline(m === 0, p), this.print(T, void 0, u || 0), l?.(T, m), h != null && (m < f - 1 ? h(m, !1) : a && h(
        m, !0)), s)) {
          var d;
          if ((d = T.trailingComments) != null && d.length || (this._lastCommentLine = 0), m + 1 === f)
            this.newline(1);
          else {
            var y;
            let b = e[m + 1];
            p.nextNodeStartLine = ((y = b.loc) == null ? void 0 : y.start.line) || 0, this._printNewline(!0, p);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e), s && this.dedent();
    }
    printBlock(e) {
      let s = e.body;
      s.type !== "EmptyStatement" && this.space(), this.print(s);
    }
    _printTrailingComments(e, s, i) {
      let {
        innerComments: r,
        trailingComments: a
      } = e;
      r != null && r.length && this._printComments(2, r, e, s, i), a != null && a.length && this._printComments(2, a, e, s, i);
    }
    _printLeadingComments(e, s) {
      let i = e.leadingComments;
      i != null && i.length && this._printComments(0, i, e, s);
    }
    _maybePrintInnerComments(e, s) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, e, s));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(e) {
      let s = this._currentNode, i = s.innerComments;
      if (!(i != null && i.length)) return;
      let r = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, s, void 0, void 0, e), r && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, s, i, r) {
      this.printJoin(e, !0, s ?? !1, void 0, void 0, r, void 0, i);
    }
    printList(e, s, i, r, a, o) {
      this.printJoin(e, i, r, a ?? TPt, s, void 0, o);
    }
    shouldPrintTrailingComma(e) {
      if (!this.tokenMap) return null;
      let s = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, e));
      return s <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[s - 1], ",");
    }
    _printNewline(e, s) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let r = s.nextNodeStartLine, a = this._lastCommentLine;
      if (r > 0 && a > 0) {
        let o = r - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e, s) {
      if (e.ignore || this._printedComments.has(e)) return 0;
      if (this._noLineTerminator && yPt.test(e.value))
        return 2;
      if (s && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (r) => r.value === e.value);
        if (i && i.start > s.start)
          return 2;
      }
      return this._printedComments.add(e), this.format.shouldPrintComment(e.value) ? 1 : 0;
    }
    _printComment(e, s) {
      let i = this._noLineTerminator, r = e.type === "CommentBlock", a = r && s !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && s !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (r) {
        if (l = `/*${e.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let c = (u = e.loc) == null ? void 0 : u.start.column;
          if (c) {
            let p = new RegExp("\\n\\s{1," + c + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else i ? l = `/*${e.value}*/` : l = `//${e.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: p
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e.loc), this._append(l, r), this.
        _printSemicolonBeforeNextNode = p, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", e.loc), this._append(l, r);
      !r && !i && this.newline(1, !0), a && s !== 3 && this.newline(1);
    }
    _printComments(e, s, i, r, a = 0, o) {
      let l = i.loc, u = s.length, c = !!l, p = c ? l.start.line : 0, h = c ? l.end.line : 0, f = 0, d = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let m = 0; m < u; m++) {
        let T = s[m], b = this._shouldPrintComment(T, o);
        if (b === 2) {
          c = !1;
          break;
        }
        if (c && T.loc && b === 1) {
          let E = T.loc.start.line, w = T.loc.end.line;
          if (e === 0) {
            let K = 0;
            m === 0 ? this._buf.hasContent() && (T.type === "CommentLine" || E !== w) && (K = d = 1) : K = E - f, f = w, y(K), this._printComment(
            T, 1), m + 1 === u && (y(Math.max(p - f, d)), f = p);
          } else if (e === 1) {
            let K = E - (m === 0 ? p : f);
            f = w, y(K), this._printComment(T, 1), m + 1 === u && (y(Math.min(1, h - f)), f = h);
          } else {
            let K = E - (m === 0 ? h - a : f);
            f = w, y(K), this._printComment(T, 1);
          }
        } else {
          if (c = !1, b !== 1)
            continue;
          if (u === 1) {
            let E = T.loc ? T.loc.start.line === T.loc.end.line : !Dse.test(T.value), w = E && !cPt(i) && !pPt(r) && !hPt(r) && !fPt(i);
            e === 0 ? this._printComment(T, w && i.type !== "ObjectExpression" || E && uPt(r, {
              body: i
            }) ? 1 : 0) : w && e === 2 ? this._printComment(T, 1) : this._printComment(T, 0);
          } else e === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(T, m === 0 ? 2 : m === u - 1 ? 3 : 0) : this._printComment(T, 0);
        }
      }
      e === 2 && c && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(LT.prototype, aPt);
  (0, oPt.addDeprecatedGenerators)(LT);
  var nJs = WE.default = LT;
  function TPt(t, e) {
    this.token(",", !1, t), e || this.space();
  }
  n(TPt, "commaSeparator");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/generator/lib/index.js
var Fse = g((Tm) => {
  "use strict";
  Object.defineProperty(Tm, "__esModule", {
    value: !0
  });
  Tm.default = void 0;
  Tm.generate = Mse;
  var _se = jte(), Lse = Ose();
  function Bse(t, e, s) {
    if (e.experimental_preserveFormat) {
      if (typeof t != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!e.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (e.compact && e.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (e.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (e.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(s.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable t\
he `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      preserveFormat: e.experimental_preserveFormat,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var r;
      i.decoratorsBeforeExport = e.decoratorsBeforeExport, i.jsescOption.json = e.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (r = e.
      recordAndTupleSyntaxType) != null ? r : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((u) => i.comments || u.includes("@license") || u.includes("@preserve")), i.compact === "auto" && (i.compact = typeof t == "string" && t.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = i;
    return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  n(Bse, "normalizeOptions");
  Tm.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, s = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = Bse(i, s, e), this._map = s.sourceMaps ? new _se.
      default(s, i) : null;
    }
    generate() {
      return new Lse.default(this._format, this._map).generate(this._ast);
    }
  };
  function Mse(t, e = {}, s) {
    let i = Bse(s, e, t), r = e.sourceMaps ? new _se.default(e, s) : null;
    return new Lse.default(i, r, t.tokens, typeof s == "string" ? s : null).generate(t);
  }
  n(Mse, "generate");
  var uJs = Tm.default = Mse;
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/ancestry.js
var jse = g(($a) => {
  "use strict";
  Object.defineProperty($a, "__esModule", {
    value: !0
  });
  $a.find = PPt;
  $a.findParent = SPt;
  $a.getAncestry = wPt;
  $a.getDeepestCommonAncestorFrom = CPt;
  $a.getEarliestCommonAncestorFrom = vPt;
  $a.getFunctionParent = EPt;
  $a.getStatementParent = APt;
  $a.inType = kPt;
  $a.isAncestor = IPt;
  $a.isDescendant = NPt;
  var bPt = fe(), {
    VISITOR_KEYS: xPt
  } = bPt;
  function SPt(t) {
    let e = this;
    for (; e = e.parentPath; )
      if (t(e)) return e;
    return null;
  }
  n(SPt, "findParent");
  function PPt(t) {
    let e = this;
    do
      if (t(e)) return e;
    while (e = e.parentPath);
    return null;
  }
  n(PPt, "find");
  function EPt() {
    return this.findParent((t) => t.isFunction());
  }
  n(EPt, "getFunctionParent");
  function APt() {
    let t = this;
    do {
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        break;
      t = t.parentPath;
    } while (t);
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return t;
  }
  n(APt, "getStatementParent");
  function vPt(t) {
    return this.getDeepestCommonAncestorFrom(t, function(e, s, i) {
      let r, a = xPt[e.type];
      for (let o of i) {
        let l = o[s + 1];
        if (!r) {
          r = l;
          continue;
        }
        if (l.listKey && r.listKey === l.listKey && l.key < r.key) {
          r = l;
          continue;
        }
        let u = a.indexOf(r.parentKey), c = a.indexOf(l.parentKey);
        u > c && (r = l);
      }
      return r;
    });
  }
  n(vPt, "getEarliestCommonAncestorFrom");
  function CPt(t, e) {
    if (!t.length)
      return this;
    if (t.length === 1)
      return t[0];
    let s = 1 / 0, i, r, a = t.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < s && (s = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < s; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      i = l, r = u;
    }
    if (r)
      return e ? e(r, i, a) : r;
    throw new Error("Couldn't find intersection");
  }
  n(CPt, "getDeepestCommonAncestorFrom");
  function wPt() {
    let t = this, e = [];
    do
      e.push(t);
    while (t = t.parentPath);
    return e;
  }
  n(wPt, "getAncestry");
  function IPt(t) {
    return t.isDescendant(this);
  }
  n(IPt, "isAncestor");
  function NPt(t) {
    return !!this.findParent((e) => e === t);
  }
  n(NPt, "isDescendant");
  function kPt(...t) {
    let e = this;
    for (; e; ) {
      if (t.includes(e.node.type)) return !0;
      e = e.parentPath;
    }
    return !1;
  }
  n(kPt, "inType");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/inference/util.js
var UB = g((qB) => {
  "use strict";
  Object.defineProperty(qB, "__esModule", {
    value: !0
  });
  qB.createUnionType = BPt;
  var DPt = fe(), {
    createFlowUnionType: Rse,
    createTSUnionType: qse,
    createUnionTypeAnnotation: OPt,
    isFlowType: _Pt,
    isTSType: LPt
  } = DPt;
  function BPt(t) {
    {
      if (t.every((e) => _Pt(e)))
        return Rse ? Rse(t) : OPt(t);
      if (t.every((e) => LPt(e)) && qse)
        return qse(t);
    }
  }
  n(BPt, "createUnionType");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var $se = g((KB) => {
  "use strict";
  Object.defineProperty(KB, "__esModule", {
    value: !0
  });
  KB.default = qPt;
  var MPt = fe(), Kse = UB(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: FPt,
    createTypeAnnotationBasedOnTypeof: jPt,
    numberTypeAnnotation: Vse,
    voidTypeAnnotation: RPt
  } = MPt;
  function qPt(t) {
    if (!this.isReferenced()) return;
    let e = this.scope.getBinding(t.name);
    if (e)
      return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : UPt(e, this, t.name);
    if (t.name === "undefined")
      return RPt();
    if (t.name === "NaN" || t.name === "Infinity")
      return Vse();
    t.name;
  }
  n(qPt, "_default");
  function UPt(t, e, s) {
    let i = [], r = [], a = Use(t, e, r), o = Wse(t, e, s);
    if (o) {
      let l = Use(t, o.ifStatement);
      a = a.filter((u) => !l.includes(u)), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...r);
      for (let l of a)
        i.push(l.getTypeAnnotation());
    }
    if (i.length)
      return (0, Kse.createUnionType)(i);
  }
  n(UPt, "getTypeAnnotationBindingConstantViolations");
  function Use(t, e, s) {
    let i = t.constantViolations.slice();
    return i.unshift(t.path), i.filter((r) => {
      r = r.resolve();
      let a = r._guessExecutionStatusRelativeTo(e);
      return s && a === "unknown" && s.push(r), a === "before";
    });
  }
  n(Use, "getConstantViolationsBefore");
  function KPt(t, e) {
    let s = e.node.operator, i = e.get("right").resolve(), r = e.get("left").resolve(), a;
    if (r.isIdentifier({
      name: t
    }) ? a = i : i.isIdentifier({
      name: t
    }) && (a = r), a)
      return s === "===" ? a.getTypeAnnotation() : FPt.includes(s) ? Vse() : void 0;
    if (s !== "===" && s !== "==") return;
    let o, l;
    if (r.isUnaryExpression({
      operator: "typeof"
    }) ? (o = r, l = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, l = r), !o || !o.get("argument").isIdentifier({
      name: t
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return jPt(u);
  }
  n(KPt, "inferAnnotationFromBinaryExpression");
  function VPt(t, e, s) {
    let i;
    for (; i = e.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return e.key === "test" ? void 0 : i;
      if (i.isFunction() && i.parentPath.scope.getBinding(s) !== t)
        return;
      e = i;
    }
  }
  n(VPt, "getParentConditionalPath");
  function Wse(t, e, s) {
    let i = VPt(t, e, s);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = KPt(s, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, Kse.createUnionType)(o),
      ifStatement: i
    } : Wse(t, i, s);
  }
  n(Wse, "getConditionalAnnotation");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/inference/inferers.js
var Zse = g((Qs) => {
  "use strict";
  Object.defineProperty(Qs, "__esModule", {
    value: !0
  });
  Qs.ArrayExpression = zse;
  Qs.AssignmentExpression = hEt;
  Qs.BinaryExpression = oEt;
  Qs.BooleanLiteral = yEt;
  Qs.CallExpression = vEt;
  Qs.ConditionalExpression = uEt;
  Qs.ClassDeclaration = Qs.ClassExpression = Qs.FunctionDeclaration = Qs.ArrowFunctionExpression = Qs.FunctionExpression = xEt;
  Object.defineProperty(Qs, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $Pt.default;
    }, "get")
  });
  Qs.LogicalExpression = lEt;
  Qs.NewExpression = rEt;
  Qs.NullLiteral = gEt;
  Qs.NumericLiteral = mEt;
  Qs.ObjectExpression = bEt;
  Qs.ParenthesizedExpression = pEt;
  Qs.RegExpLiteral = TEt;
  Qs.RestElement = Gse;
  Qs.SequenceExpression = cEt;
  Qs.StringLiteral = dEt;
  Qs.TSAsExpression = Xse;
  Qs.TSNonNullExpression = iEt;
  Qs.TaggedTemplateExpression = CEt;
  Qs.TemplateLiteral = nEt;
  Qs.TypeCastExpression = Yse;
  Qs.UnaryExpression = aEt;
  Qs.UpdateExpression = fEt;
  Qs.VariableDeclarator = sEt;
  var WPt = fe(), $Pt = $se(), Jse = UB(), {
    BOOLEAN_BINARY_OPERATORS: HPt,
    BOOLEAN_UNARY_OPERATORS: JPt,
    NUMBER_BINARY_OPERATORS: YPt,
    NUMBER_UNARY_OPERATORS: XPt,
    STRING_UNARY_OPERATORS: zPt,
    anyTypeAnnotation: Hse,
    arrayTypeAnnotation: VB,
    booleanTypeAnnotation: WB,
    buildMatchMemberExpression: $E,
    genericTypeAnnotation: lp,
    identifier: zh,
    nullLiteralTypeAnnotation: GPt,
    numberTypeAnnotation: bm,
    stringTypeAnnotation: Gh,
    tupleTypeAnnotation: QPt,
    unionTypeAnnotation: ZPt,
    voidTypeAnnotation: eEt,
    isIdentifier: tEt
  } = WPt;
  function sEt() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(sEt, "VariableDeclarator");
  function Yse(t) {
    return t.typeAnnotation;
  }
  n(Yse, "TypeCastExpression");
  Yse.validParent = !0;
  function Xse(t) {
    return t.typeAnnotation;
  }
  n(Xse, "TSAsExpression");
  Xse.validParent = !0;
  function iEt() {
    return this.get("expression").getTypeAnnotation();
  }
  n(iEt, "TSNonNullExpression");
  function rEt(t) {
    if (t.callee.type === "Identifier")
      return lp(t.callee);
  }
  n(rEt, "NewExpression");
  function nEt() {
    return Gh();
  }
  n(nEt, "TemplateLiteral");
  function aEt(t) {
    let e = t.operator;
    if (e === "void")
      return eEt();
    if (XPt.includes(e))
      return bm();
    if (zPt.includes(e))
      return Gh();
    if (JPt.includes(e))
      return WB();
  }
  n(aEt, "UnaryExpression");
  function oEt(t) {
    let e = t.operator;
    if (YPt.includes(e))
      return bm();
    if (HPt.includes(e))
      return WB();
    if (e === "+") {
      let s = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && s.isBaseType("number") ? bm() : i.isBaseType("string") || s.isBaseType("string") ? Gh() : ZPt([Gh(), bm()]);
    }
  }
  n(oEt, "BinaryExpression");
  function lEt() {
    let t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, Jse.createUnionType)(t);
  }
  n(lEt, "LogicalExpression");
  function uEt() {
    let t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, Jse.createUnionType)(t);
  }
  n(uEt, "ConditionalExpression");
  function cEt() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(cEt, "SequenceExpression");
  function pEt() {
    return this.get("expression").getTypeAnnotation();
  }
  n(pEt, "ParenthesizedExpression");
  function hEt() {
    return this.get("right").getTypeAnnotation();
  }
  n(hEt, "AssignmentExpression");
  function fEt(t) {
    let e = t.operator;
    if (e === "++" || e === "--")
      return bm();
  }
  n(fEt, "UpdateExpression");
  function dEt() {
    return Gh();
  }
  n(dEt, "StringLiteral");
  function mEt() {
    return bm();
  }
  n(mEt, "NumericLiteral");
  function yEt() {
    return WB();
  }
  n(yEt, "BooleanLiteral");
  function gEt() {
    return GPt();
  }
  n(gEt, "NullLiteral");
  function TEt() {
    return lp(zh("RegExp"));
  }
  n(TEt, "RegExpLiteral");
  function bEt() {
    return lp(zh("Object"));
  }
  n(bEt, "ObjectExpression");
  function zse() {
    return lp(zh("Array"));
  }
  n(zse, "ArrayExpression");
  function Gse() {
    return zse();
  }
  n(Gse, "RestElement");
  Gse.validParent = !0;
  function xEt() {
    return lp(zh("Function"));
  }
  n(xEt, "Func");
  var SEt = $E("Array.from"), PEt = $E("Object.keys"), EEt = $E("Object.values"), AEt = $E("Object.entries");
  function vEt() {
    let {
      callee: t
    } = this.node;
    return PEt(t) ? VB(Gh()) : SEt(t) || EEt(t) || tEt(t, {
      name: "Array"
    }) ? VB(Hse()) : AEt(t) ? VB(QPt([Gh(), Hse()])) : Qse(this.get("callee"));
  }
  n(vEt, "CallExpression");
  function CEt() {
    return Qse(this.get("tag"));
  }
  n(CEt, "TaggedTemplateExpression");
  function Qse(t) {
    if (t = t.resolve(), t.isFunction()) {
      let {
        node: e
      } = t;
      if (e.async)
        return e.generator ? lp(zh("AsyncIterator")) : lp(zh("Promise"));
      if (e.generator)
        return lp(zh("Iterator"));
      if (t.node.returnType)
        return t.node.returnType;
    }
  }
  n(Qse, "resolveCall");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/inference/index.js
var rie = g((up) => {
  "use strict";
  Object.defineProperty(up, "__esModule", {
    value: !0
  });
  up._getTypeAnnotation = iie;
  up.baseTypeStrictlyMatches = YEt;
  up.couldBeBaseType = JEt;
  up.getTypeAnnotation = $Et;
  up.isBaseType = HEt;
  up.isGenericType = XEt;
  var eie = Zse(), wEt = fe(), {
    anyTypeAnnotation: sie,
    isAnyTypeAnnotation: HE,
    isArrayTypeAnnotation: IEt,
    isBooleanTypeAnnotation: NEt,
    isEmptyTypeAnnotation: kEt,
    isFlowBaseAnnotation: DEt,
    isGenericTypeAnnotation: OEt,
    isIdentifier: tie,
    isMixedTypeAnnotation: _Et,
    isNumberTypeAnnotation: LEt,
    isStringTypeAnnotation: BEt,
    isTSArrayType: MEt,
    isTSTypeAnnotation: FEt,
    isTSTypeReference: jEt,
    isTupleTypeAnnotation: REt,
    isTypeAnnotation: qEt,
    isUnionTypeAnnotation: UEt,
    isVoidTypeAnnotation: KEt,
    stringTypeAnnotation: VEt,
    voidTypeAnnotation: WEt
  } = wEt;
  function $Et() {
    let t = this.getData("typeAnnotation");
    return t != null || (t = iie.call(this) || sie(), (qEt(t) || FEt(t)) && (t = t.typeAnnotation), this.setData("typeAnnotation", t)), t;
  }
  n($Et, "getTypeAnnotation");
  var $B = /* @__PURE__ */ new WeakSet();
  function iie() {
    let t = this.node;
    if (!t)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let s = this.parentPath.parentPath, i = s.parentPath;
        return s.key === "left" && i.isForInStatement() ? VEt() : s.key === "left" && i.isForOfStatement() ? sie() : WEt();
      } else
        return;
    if (t.typeAnnotation)
      return t.typeAnnotation;
    if (!$B.has(t)) {
      $B.add(t);
      try {
        var e;
        let s = eie[t.type];
        if (s)
          return s.call(this, t);
        if (s = eie[this.parentPath.type], (e = s) != null && e.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        $B.delete(t);
      }
    }
  }
  n(iie, "_getTypeAnnotation");
  function HEt(t, e) {
    return HB(t, this.getTypeAnnotation(), e);
  }
  n(HEt, "isBaseType");
  function HB(t, e, s) {
    if (t === "string")
      return BEt(e);
    if (t === "number")
      return LEt(e);
    if (t === "boolean")
      return NEt(e);
    if (t === "any")
      return HE(e);
    if (t === "mixed")
      return _Et(e);
    if (t === "empty")
      return kEt(e);
    if (t === "void")
      return KEt(e);
    if (s)
      return !1;
    throw new Error(`Unknown base type ${t}`);
  }
  n(HB, "_isBaseType");
  function JEt(t) {
    let e = this.getTypeAnnotation();
    if (HE(e)) return !0;
    if (UEt(e)) {
      for (let s of e.types)
        if (HE(s) || HB(t, s, !0))
          return !0;
      return !1;
    } else
      return HB(t, e, !0);
  }
  n(JEt, "couldBeBaseType");
  function YEt(t) {
    let e = this.getTypeAnnotation(), s = t.getTypeAnnotation();
    return !HE(e) && DEt(e) ? s.type === e.type : !1;
  }
  n(YEt, "baseTypeStrictlyMatches");
  function XEt(t) {
    let e = this.getTypeAnnotation();
    return t === "Array" && (MEt(e) || IEt(e) || REt(e)) ? !0 : OEt(e) && tie(e.id, {
      name: t
    }) || jEt(e) && tie(e.typeName, {
      name: t
    });
  }
  n(XEt, "isGenericType");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var nie = g((JE) => {
  "use strict";
  Object.defineProperty(JE, "__esModule", {
    value: !0
  });
  JE.hooks = void 0;
  var PJs = JE.hooks = [function(t, e) {
    if (t.key === "test" && (e.isWhile() || e.isSwitchCase()) || t.key === "declaration" && e.isExportDeclaration() || t.key === "body" && e.
    isLabeledStatement() || t.listKey === "declarations" && e.isVariableDeclaration() && e.node.declarations.length === 1 || t.key === "expr\
ession" && e.isExpressionStatement())
      return e.remove(), !0;
  }, function(t, e) {
    if (e.isSequenceExpression() && e.node.expressions.length === 1)
      return e.replaceWith(e.node.expressions[0]), !0;
  }, function(t, e) {
    if (e.isBinary())
      return t.key === "left" ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0;
  }, function(t, e) {
    if (e.isIfStatement() && t.key === "consequent" || t.key === "body" && (e.isLoop() || e.isArrowFunctionExpression()))
      return t.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/removal.js
var YE = g((cp) => {
  "use strict";
  Object.defineProperty(cp, "__esModule", {
    value: !0
  });
  cp._assertUnremoved = cie;
  cp._callRemovalHooks = lie;
  cp._markRemoved = JB;
  cp._remove = uie;
  cp._removeFromScope = oie;
  cp.remove = i1t;
  var zEt = nie(), GEt = Hh(), QEt = YB(), aie = pp(), ZEt = fe(), e1t = XE(), t1t = dl(), {
    getBindingIdentifiers: s1t
  } = ZEt;
  function i1t() {
    var t;
    if (cie.call(this), t1t.resync.call(this), lie.call(this)) {
      JB.call(this);
      return;
    }
    (t = this.opts) != null && t.noScope || oie.call(this), this.shareCommentsWithSiblings(), uie.call(this), JB.call(this);
  }
  n(i1t, "remove");
  function oie() {
    let t = s1t(this.node, !1, !1, !0);
    Object.keys(t).forEach((e) => this.scope.removeBinding(e));
  }
  n(oie, "_removeFromScope");
  function lie() {
    if (this.parentPath) {
      for (let t of zEt.hooks)
        if (t(this, this.parentPath)) return !0;
    }
  }
  n(lie, "_callRemovalHooks");
  function uie() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), e1t.updateSiblingKeys.call(this, this.key, -1)) : QEt._replaceWith.
    call(this, null);
  }
  n(uie, "_remove");
  function JB() {
    this._traverseFlags |= aie.SHOULD_SKIP | aie.REMOVED, this.parent && (0, GEt.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  n(JB, "_markRemoved");
  function cie() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(cie, "_assertUnremoved");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/lib/hoister.js
var hie = g((zE) => {
  "use strict";
  Object.defineProperty(zE, "__esModule", {
    value: !0
  });
  zE.default = void 0;
  var pie = fe(), r1t = pie, {
    react: n1t
  } = pie, {
    cloneNode: a1t,
    jsxExpressionContainer: o1t,
    variableDeclaration: l1t,
    variableDeclarator: u1t
  } = r1t, c1t = {
    ReferencedIdentifier(t, e) {
      if (t.isJSXIdentifier() && n1t.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression())
        return;
      if (t.node.name === "this") {
        let i = t.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && e.breakOnScopePaths.push(i.path);
      }
      let s = t.scope.getBinding(t.node.name);
      if (s) {
        for (let i of s.constantViolations)
          if (i.scope !== s.path.scope) {
            e.mutableBinding = !0, t.stop();
            return;
          }
        s === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = s);
      }
    }
  }, XB = class {
    static {
      n(this, "PathHoister");
    }
    constructor(e, s) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = s, this.path = e, this.attachAfter = !1;
    }
    isCompatibleScope(e) {
      for (let s of Object.keys(this.bindings)) {
        let i = this.bindings[s];
        if (!e.bindingIdentifierEquals(s, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let e = this.path.scope;
      do {
        if (this.isCompatibleScope(e))
          this.scopes.push(e);
        else
          break;
        if (this.breakOnScopePaths.includes(e.path))
          break;
      } while (e = e.parent);
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath();
      if (!e) return;
      let s = e.scope;
      if (s.path === e && (s = e.scope.parent), s.path.isProgram() || s.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!s.hasOwnBinding(i)) continue;
          let r = this.bindings[i];
          if (r.kind === "param" || r.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(r.path).key >= e.key) {
            this.attachAfter = !0, e = r.path;
            for (let o of r.constantViolations)
              this.getAttachmentParentForPath(o).key > e.key && (e = o);
          }
        }
      return e;
    }
    _getAttachmentPath() {
      let s = this.scopes.pop();
      if (s) {
        if (s.path.isFunction())
          if (this.hasOwnParamBindings(s)) {
            if (this.scope === s) return;
            let i = s.path.get("body").get("body");
            for (let r = 0; r < i.length; r++)
              if (!i[r].node._blockHoist)
                return i[r];
          } else
            return this.getNextScopeAttachmentParent();
        else if (s.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let e = this.scopes.pop();
      if (e) return this.getAttachmentParentForPath(e.path);
    }
    getAttachmentParentForPath(e) {
      do
        if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
          return e;
      while (e = e.parentPath);
    }
    hasOwnParamBindings(e) {
      for (let s of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(s)) continue;
        let i = this.bindings[s];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(c1t, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let e = this.getAttachmentPath();
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return;
      let s = e.scope.generateUidIdentifier("ref"), i = u1t(s, this.path.node), r = this.attachAfter ? "insertAfter" : "insertBefore", [a] = e[r](
      [e.isVariableDeclarator() ? i : l1t("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (s = o1t(s)), this.path.replaceWith(a1t(s)), e.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  zE.default = XB;
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/traverse/lib/path/modification.js
var XE = g((Ha) => {
  "use strict";
  Object.defineProperty(Ha, "__esModule", {
    value: !0
  });
  Ha._containerInsert = eM;
  Ha._containerInsertAfter = mie;
  Ha._containerInsertBefore = tM;
  Ha._verifyNodeList = BT;
  Ha.insertAfter = w1t;
  Ha.insertBefore = v1t;
  Ha.pushContainer = N1t;
  Ha.unshiftContainer = I1t;
  Ha.updateSiblingKeys = Tie;
  var p1t = Hh(), ZB = pp(), zB = dl(), GE = YE(), h1t = fe(), f1t = hie(), {
    arrowFunctionExpression: d1t,
    assertExpression: m1t,
    assignmentExpression: y1t,
    blockStatement: fie,
    callExpression: g1t,
    cloneNode: GB,
    expressionStatement: QB,
    isAssignmentExpression: T1t,
    isCallExpression: b1t,
    isExportNamedDeclaration: die,
    isExpression: x1t,
    isIdentifier: S1t,
    isSequenceExpression: P1t,
    isSuper: E1t,
    thisExpression: A1t
  } = h1t;
  function v1t(t) {
    GE._assertUnremoved.call(this);
    let e = BT.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || die(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertBefore(e);
    if (this.isNodeType("Expression") && !this.isJSXElement() || s.isForStatement() && this.key === "init")
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e);
    if (Array.isArray(this.container))
      return tM.call(this, e);
    if (this.isStatementOrBlock()) {
      let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
      return this.replaceWith(fie(a ? [r] : [])), this.unshiftContainer("body", e);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(v1t, "insertBefore");
  function eM(t, e) {
    Tie.call(this, t, e.length);
    let s = [];
    this.container.splice(t, 0, ...e);
    for (let a = 0; a < e.length; a++) {
      var i;
      let o = t + a, l = this.getSibling(o);
      s.push(l), (i = this.context) != null && i.queue && zB.pushContext.call(l, this.context);
    }
    let r = zB._getQueueContexts.call(this);
    for (let a of s) {
      zB.setScope.call(a), a.debug("Inserted.");
      for (let o of r)
        o.maybeQueue(a, !0);
    }
    return s;
  }
  n(eM, "_containerInsert");
  function tM(t) {
    return eM.call(this, this.key, t);
  }
  n(tM, "_containerInsertBefore");
  function mie(t) {
    return eM.call(this, this.key + 1, t);
  }
  n(mie, "_containerInsertAfter");
  var yie = /* @__PURE__ */ n((t) => t[t.length - 1], "last");
  function gie(t) {
    return P1t(t.parent) && (yie(t.parent.expressions) !== t.node || gie(t.parentPath));
  }
  n(gie, "isHiddenInSequenceExpression");
  function C1t(t, e) {
    if (!T1t(t) || !S1t(t.left))
      return !1;
    let s = e.getBlockParent();
    return s.hasOwnBinding(t.left.name) && s.getOwnBinding(t.left.name).constantViolations.length <= 1;
  }
  n(C1t, "isAlmostConstantAssignment");
  function w1t(t) {
    if (GE._assertUnremoved.call(this), this.isSequenceExpression())
      return yie(this.get("expressions")).insertAfter(t);
    let e = BT.call(this, t), {
      parentPath: s,
      parent: i
    } = this;
    if (s.isExpressionStatement() || s.isLabeledStatement() || die(i) || s.isExportDefaultDeclaration() && this.isDeclaration())
      return s.insertAfter(e.map((r) => x1t(r) ? QB(r) : r));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !s.isJSXElement() || s.isForStatement() && this.key === "init") {
      let r = this;
      if (r.node) {
        let a = r.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return m1t(a), r.replaceWith(g1t(d1t([], a), [])), r.get("callee.body").insertAfter(e), [r];
        if (gie(r))
          e.unshift(a);
        else if (b1t(a) && E1t(a.callee))
          e.unshift(a), e.push(A1t());
        else if (C1t(a, o))
          e.unshift(a), e.push(GB(a.left));
        else if (o.isPure(a, !0))
          e.push(a);
        else {
          s.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let l = o.generateDeclaredUidIdentifier();
          e.unshift(QB(y1t("=", GB(l), a))), e.push(QB(GB(l)));
        }
      }
      return this.replaceExpressionWithStatements(e);
    } else {
      if (Array.isArray(this.container))
        return mie.call(this, e);
      if (this.isStatementOrBlock()) {
        let r = this.node, a = r && (!this.isExpressionStatement() || r.expression != null);
        return this.replaceWith(fie(a ? [r] : [])), this.pushContainer("body", e);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(w1t, "insertAfter");
  function Tie(t, e) {
    if (!this.parent) return;
    let s = (0, p1t.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, i] of s)
      typeof i.key == "number" && i.container === this.container && i.key >= t && (i.key += e);
  }
  n(Tie, "updateSiblingKeys");
  function BT(t) {
    if (!t)
      return [];
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++) {
      let s = t[e], i;
      if (s ? typeof s != "object" ? i = "contains a non-object node" : s.type ? s instanceof ZB.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let r = Array.isArray(s) ? "array" : typeof s;
        throw new Error(`Node list ${i} with the index of ${e} and type of ${r}`);
      }
    }
    return t;
  }
  n(BT, "_verifyNodeList");
  function I1t(t, e) {
    GE._assertUnremoved.call(this), e = BT.call(this, e);
    let s = ZB.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[t],
      listKey: t,
      key: 0
    }).setContext(this.context);
    return tM.call(s, e);
  }
  n(I1t, "unshiftContainer");
  function N1t(t, e) {
    GE._assertUnremoved.call(this);
    let s = BT.call(this, e), i = this.node[t];
    return ZB.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: t,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(s);
  }
  n(N1t, "pushContainer");
  Ha.hoist = /* @__PURE__ */ n(function(e = this.scope) {
    return new f1t.default(this, e).run();
  }, "hoist");
});

// ../node_modules/@babel/helper-create-class-features-plugin/node_modules/@babel/parser/lib/index.js
var Xie = g(($T) => {
  "use strict";
  Object.defineProperty($T, "__esModule", {
    value: !0
  });
  function k1t(t, e) {
    if (t == null) return {};
    var s = {};
    for (var i in t) if ({}.hasOwnProperty.call(t, i)) {
      if (e.indexOf(i) !== -1) continue;
      s[i] = t[i];
    }
    return s;
  }
  n(k1t, "_objectWithoutPropertiesLoose");
  var yl = class {
    static {
      n(this, "Position");
    }
    constructor(e, s, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = s, this.index = i;
    }
  }, Am = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, s) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = s;
    }
  };
  function Dn(t, e) {
    let {
      line: s,
      column: i,
      index: r
    } = t;
    return new yl(s, i + e, r + e);
  }
  n(Dn, "createPositionWithColumnOffset");
  var bie = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", D1t = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: bie
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: bie
    }
  }, xie = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, e1 = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? xie.UpdateExpression[`${t.prefix}`] : xie[t.type], "toNodeDescription"), O1t = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${e1(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${e1(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${e1(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, _1t = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, L1t = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), B1t = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${e1({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), M1t = ["message"];
  function Sie(t, e, s) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: s
    });
  }
  n(Sie, "defineHidden");
  function F1t({
    toMessage: t,
    code: e,
    reasonCode: s,
    syntaxPlugin: i
  }) {
    let r = s === "MissingPlugin" || s === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[s] && (s = a[s]);
    }
    return /* @__PURE__ */ n(function a(o, l) {
      let u = new SyntaxError();
      return u.code = e, u.reasonCode = s, u.loc = o, u.pos = o.index, u.syntaxPlugin = i, r && (u.missingPlugin = l.missingPlugin), Sie(u, "\
clone", /* @__PURE__ */ n(function(p = {}) {
        var h;
        let {
          line: f,
          column: d,
          index: y
        } = (h = p.loc) != null ? h : o;
        return a(new yl(f, d, y), Object.assign({}, l, p.details));
      }, "clone")), Sie(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${t(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  n(F1t, "toParseErrorConstructor");
  function Mu(t, e) {
    if (Array.isArray(t))
      return (i) => Mu(i, t[0]);
    let s = {};
    for (let i of Object.keys(t)) {
      let r = t[i], a = typeof r == "string" ? {
        message: /* @__PURE__ */ n(() => r, "message")
      } : typeof r == "function" ? {
        message: r
      } : r, {
        message: o
      } = a, l = k1t(a, M1t), u = typeof o == "string" ? () => o : o;
      s[i] = F1t(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return s;
  }
  n(Mu, "ParseErrorEnum");
  var ee = Object.assign({}, Mu(D1t), Mu(O1t), Mu(_1t), Mu`pipelineOperator`(B1t));
  function j1t() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: null,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  n(j1t, "createDefaultOptions");
  function R1t(t) {
    let e = j1t();
    if (t == null)
      return e;
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let s of Object.keys(e))
      t[s] != null && (e[s] = t[s]);
    if (e.startLine === 1)
      t.startIndex == null && e.startColumn > 0 ? e.startIndex = e.startColumn : t.startColumn == null && e.startIndex > 0 && (e.startColumn =
      e.startIndex);
    else if ((t.startColumn == null || t.startIndex == null) && t.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return e;
  }
  n(R1t, "getOptions");
  var {
    defineProperty: q1t
  } = Object, Pie = /* @__PURE__ */ n((t, e) => {
    t && q1t(t, e, {
      enumerable: !1,
      value: t[e]
    });
  }, "toUnenumerable");
  function MT(t) {
    return Pie(t.loc.start, "index"), Pie(t.loc.end, "index"), t;
  }
  n(MT, "toESTreeLocation");
  var U1t = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let s = MT(super.parse());
      return this.optionFlags & 256 && (s.tokens = s.tokens.map(MT)), s;
    }
    parseRegExpLiteral({
      pattern: s,
      flags: i
    }) {
      let r = null;
      try {
        r = new RegExp(s, i);
      } catch {
      }
      let a = this.estreeParseLiteral(r);
      return a.regex = {
        pattern: s,
        flags: i
      }, a;
    }
    parseBigIntLiteral(s) {
      let i;
      try {
        i = BigInt(s);
      } catch {
        i = null;
      }
      let r = this.estreeParseLiteral(i);
      return r.bigint = String(r.value || s), r;
    }
    parseDecimalLiteral(s) {
      let r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || s), r;
    }
    estreeParseLiteral(s) {
      return this.parseLiteral(s, "Literal");
    }
    parseStringLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNumericLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(s) {
      return this.estreeParseLiteral(s);
    }
    directiveToStmt(s) {
      let i = s.value;
      delete s.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let r = s;
      return r.type = "ExpressionStatement", r.expression = i, r.directive = i.extra.rawValue, delete i.extra, r;
    }
    initFunction(s, i) {
      super.initFunction(s, i), s.expression = !1;
    }
    checkDeclaration(s) {
      s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
    }
    getObjectOrClassMethodParams(s) {
      return s.value.params;
    }
    isValidDirective(s) {
      var i;
      return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((i = s.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(s, i, r, a, o) {
      super.parseBlockBody(s, i, r, a, o);
      let l = s.directives.map((u) => this.directiveToStmt(u));
      s.body = l.concat(s.body), delete s.directives;
    }
    parsePrivateName() {
      let s = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
    }
    convertPrivateNameToPrivateIdentifier(s) {
      let i = super.getPrivateNameSV(s);
      return s = s, delete s.id, s.name = i, s.type = "PrivateIdentifier", s;
    }
    isPrivateName(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
    }
    getPrivateNameSV(s) {
      return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
    }
    parseLiteral(s, i) {
      let r = super.parseLiteral(s, i);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(s, i, r = !1) {
      super.parseFunctionBody(s, i, r), s.expression = s.body.type !== "BlockStatement";
    }
    parseMethod(s, i, r, a, o, l, u = !1) {
      let c = this.startNode();
      c.kind = s.kind, c = super.parseMethod(c, i, r, a, o, l, u), c.type = "FunctionExpression", delete c.kind, s.value = c;
      let {
        typeParameters: p
      } = s;
      return p && (delete s.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p)), l === "ClassPrivateMethod" && (s.computed =
      !1), this.finishNode(s, "MethodDefinition");
    }
    nameIsConstructor(s) {
      return s.type === "Literal" ? s.value === "constructor" : super.nameIsConstructor(s);
    }
    parseClassProperty(...s) {
      let i = super.parseClassProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...s) {
      let i = super.parseClassPrivateProperty(...s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
    }
    parseClassAccessorProperty(s) {
      let i = super.parseClassAccessorProperty(s);
      return this.getPluginOption("estree", "classFeatures") && (i.type = "AccessorProperty"), i;
    }
    parseObjectMethod(s, i, r, a, o) {
      let l = super.parseObjectMethod(s, i, r, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(s, i, r, a) {
      let o = super.parseObjectProperty(s, i, r, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(s, i, r) {
      return s === "Property" ? "value" : super.isValidLVal(s, i, r);
    }
    isAssignable(s, i) {
      return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, i) : super.isAssignable(s, i);
    }
    toAssignable(s, i = !1) {
      if (s != null && this.isObjectProperty(s)) {
        let {
          key: r,
          value: a
        } = s;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(s, i);
    }
    toAssignableObjectExpressionProp(s, i, r) {
      s.type === "Property" && (s.kind === "get" || s.kind === "set") ? this.raise(ee.PatternHasAccessor, s.key) : s.type === "Property" && s.
      method ? this.raise(ee.PatternHasMethod, s.key) : super.toAssignableObjectExpressionProp(s, i, r);
    }
    finishCallExpression(s, i) {
      let r = super.finishCallExpression(s, i);
      if (r.callee.type === "Import") {
        var a, o;
        r.type = "ImportExpression", r.source = r.arguments[0], r.options = (a = r.arguments[1]) != null ? a : null, r.attributes = (o = r.arguments[1]) !=
        null ? o : null, delete r.arguments, delete r.callee;
      }
      return r;
    }
    toReferencedArguments(s) {
      s.type !== "ImportExpression" && super.toReferencedArguments(s);
    }
    parseExport(s, i) {
      let r = this.state.lastTokStartLoc, a = super.parseExport(s, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, r);
          }
          break;
      }
      return a;
    }
    parseSubscript(s, i, r, a) {
      let o = super.parseSubscript(s, i, r, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(s) {
      return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
    }
    hasPropertyAsPrivateName(s) {
      return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
    }
    isObjectProperty(s) {
      return s.type === "Property" && s.kind === "init" && !s.method;
    }
    isObjectMethod(s) {
      return s.type === "Property" && (s.method || s.kind === "get" || s.kind === "set");
    }
    finishNodeAt(s, i, r) {
      return MT(super.finishNodeAt(s, i, r));
    }
    resetStartLocation(s, i) {
      super.resetStartLocation(s, i), MT(s);
    }
    resetEndLocation(s, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(s, i), MT(s);
    }
  }, "estree"), ef = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, s) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!s;
    }
  }, Zs = {
    brace: new ef("{"),
    j_oTag: new ef("<tag"),
    j_cTag: new ef("</tag"),
    j_expr: new ef("<tag>...</tag>", !0)
  };
  Zs.template = new ef("`", !0);
  var us = !0, We = !0, sM = !0, FT = !0, hp = !0, K1t = !0, i1 = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, s = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = s.keyword,
      this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop,
      this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.
      updateContext = null;
    }
  }, CM = /* @__PURE__ */ new Map();
  function _s(t, e = {}) {
    e.keyword = t;
    let s = Ct(t, e);
    return CM.set(t, s), s;
  }
  n(_s, "createKeyword");
  function kn(t, e) {
    return Ct(t, {
      beforeExpr: us,
      binop: e
    });
  }
  n(kn, "createBinop");
  var UT = -1, Lu = [], wM = [], IM = [], NM = [], kM = [], DM = [];
  function Ct(t, e = {}) {
    var s, i, r, a;
    return ++UT, wM.push(t), IM.push((s = e.binop) != null ? s : -1), NM.push((i = e.beforeExpr) != null ? i : !1), kM.push((r = e.startsExpr) !=
    null ? r : !1), DM.push((a = e.prefix) != null ? a : !1), Lu.push(new i1(t, e)), UT;
  }
  n(Ct, "createToken");
  function ls(t, e = {}) {
    var s, i, r, a;
    return ++UT, CM.set(t, UT), wM.push(t), IM.push((s = e.binop) != null ? s : -1), NM.push((i = e.beforeExpr) != null ? i : !1), kM.push((r =
    e.startsExpr) != null ? r : !1), DM.push((a = e.prefix) != null ? a : !1), Lu.push(new i1("name", e)), UT;
  }
  n(ls, "createKeywordLike");
  var V1t = {
    bracketL: Ct("[", {
      beforeExpr: us,
      startsExpr: We
    }),
    bracketHashL: Ct("#[", {
      beforeExpr: us,
      startsExpr: We
    }),
    bracketBarL: Ct("[|", {
      beforeExpr: us,
      startsExpr: We
    }),
    bracketR: Ct("]"),
    bracketBarR: Ct("|]"),
    braceL: Ct("{", {
      beforeExpr: us,
      startsExpr: We
    }),
    braceBarL: Ct("{|", {
      beforeExpr: us,
      startsExpr: We
    }),
    braceHashL: Ct("#{", {
      beforeExpr: us,
      startsExpr: We
    }),
    braceR: Ct("}"),
    braceBarR: Ct("|}"),
    parenL: Ct("(", {
      beforeExpr: us,
      startsExpr: We
    }),
    parenR: Ct(")"),
    comma: Ct(",", {
      beforeExpr: us
    }),
    semi: Ct(";", {
      beforeExpr: us
    }),
    colon: Ct(":", {
      beforeExpr: us
    }),
    doubleColon: Ct("::", {
      beforeExpr: us
    }),
    dot: Ct("."),
    question: Ct("?", {
      beforeExpr: us
    }),
    questionDot: Ct("?."),
    arrow: Ct("=>", {
      beforeExpr: us
    }),
    template: Ct("template"),
    ellipsis: Ct("...", {
      beforeExpr: us
    }),
    backQuote: Ct("`", {
      startsExpr: We
    }),
    dollarBraceL: Ct("${", {
      beforeExpr: us,
      startsExpr: We
    }),
    templateTail: Ct("...`", {
      startsExpr: We
    }),
    templateNonTail: Ct("...${", {
      beforeExpr: us,
      startsExpr: We
    }),
    at: Ct("@"),
    hash: Ct("#", {
      startsExpr: We
    }),
    interpreterDirective: Ct("#!..."),
    eq: Ct("=", {
      beforeExpr: us,
      isAssign: FT
    }),
    assign: Ct("_=", {
      beforeExpr: us,
      isAssign: FT
    }),
    slashAssign: Ct("_=", {
      beforeExpr: us,
      isAssign: FT
    }),
    xorAssign: Ct("_=", {
      beforeExpr: us,
      isAssign: FT
    }),
    moduloAssign: Ct("_=", {
      beforeExpr: us,
      isAssign: FT
    }),
    incDec: Ct("++/--", {
      prefix: hp,
      postfix: K1t,
      startsExpr: We
    }),
    bang: Ct("!", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    tilde: Ct("~", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    doubleCaret: Ct("^^", {
      startsExpr: We
    }),
    doubleAt: Ct("@@", {
      startsExpr: We
    }),
    pipeline: kn("|>", 0),
    nullishCoalescing: kn("??", 1),
    logicalOR: kn("||", 1),
    logicalAND: kn("&&", 2),
    bitwiseOR: kn("|", 3),
    bitwiseXOR: kn("^", 4),
    bitwiseAND: kn("&", 5),
    equality: kn("==/!=/===/!==", 6),
    lt: kn("</>/<=/>=", 7),
    gt: kn("</>/<=/>=", 7),
    relational: kn("</>/<=/>=", 7),
    bitShift: kn("<</>>/>>>", 8),
    bitShiftL: kn("<</>>/>>>", 8),
    bitShiftR: kn("<</>>/>>>", 8),
    plusMin: Ct("+/-", {
      beforeExpr: us,
      binop: 9,
      prefix: hp,
      startsExpr: We
    }),
    modulo: Ct("%", {
      binop: 10,
      startsExpr: We
    }),
    star: Ct("*", {
      binop: 10
    }),
    slash: kn("/", 10),
    exponent: Ct("**", {
      beforeExpr: us,
      binop: 11,
      rightAssociative: !0
    }),
    _in: _s("in", {
      beforeExpr: us,
      binop: 7
    }),
    _instanceof: _s("instanceof", {
      beforeExpr: us,
      binop: 7
    }),
    _break: _s("break"),
    _case: _s("case", {
      beforeExpr: us
    }),
    _catch: _s("catch"),
    _continue: _s("continue"),
    _debugger: _s("debugger"),
    _default: _s("default", {
      beforeExpr: us
    }),
    _else: _s("else", {
      beforeExpr: us
    }),
    _finally: _s("finally"),
    _function: _s("function", {
      startsExpr: We
    }),
    _if: _s("if"),
    _return: _s("return", {
      beforeExpr: us
    }),
    _switch: _s("switch"),
    _throw: _s("throw", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    _try: _s("try"),
    _var: _s("var"),
    _const: _s("const"),
    _with: _s("with"),
    _new: _s("new", {
      beforeExpr: us,
      startsExpr: We
    }),
    _this: _s("this", {
      startsExpr: We
    }),
    _super: _s("super", {
      startsExpr: We
    }),
    _class: _s("class", {
      startsExpr: We
    }),
    _extends: _s("extends", {
      beforeExpr: us
    }),
    _export: _s("export"),
    _import: _s("import", {
      startsExpr: We
    }),
    _null: _s("null", {
      startsExpr: We
    }),
    _true: _s("true", {
      startsExpr: We
    }),
    _false: _s("false", {
      startsExpr: We
    }),
    _typeof: _s("typeof", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    _void: _s("void", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    _delete: _s("delete", {
      beforeExpr: us,
      prefix: hp,
      startsExpr: We
    }),
    _do: _s("do", {
      isLoop: sM,
      beforeExpr: us
    }),
    _for: _s("for", {
      isLoop: sM
    }),
    _while: _s("while", {
      isLoop: sM
    }),
    _as: ls("as", {
      startsExpr: We
    }),
    _assert: ls("assert", {
      startsExpr: We
    }),
    _async: ls("async", {
      startsExpr: We
    }),
    _await: ls("await", {
      startsExpr: We
    }),
    _defer: ls("defer", {
      startsExpr: We
    }),
    _from: ls("from", {
      startsExpr: We
    }),
    _get: ls("get", {
      startsExpr: We
    }),
    _let: ls("let", {
      startsExpr: We
    }),
    _meta: ls("meta", {
      startsExpr: We
    }),
    _of: ls("of", {
      startsExpr: We
    }),
    _sent: ls("sent", {
      startsExpr: We
    }),
    _set: ls("set", {
      startsExpr: We
    }),
    _source: ls("source", {
      startsExpr: We
    }),
    _static: ls("static", {
      startsExpr: We
    }),
    _using: ls("using", {
      startsExpr: We
    }),
    _yield: ls("yield", {
      startsExpr: We
    }),
    _asserts: ls("asserts", {
      startsExpr: We
    }),
    _checks: ls("checks", {
      startsExpr: We
    }),
    _exports: ls("exports", {
      startsExpr: We
    }),
    _global: ls("global", {
      startsExpr: We
    }),
    _implements: ls("implements", {
      startsExpr: We
    }),
    _intrinsic: ls("intrinsic", {
      startsExpr: We
    }),
    _infer: ls("infer", {
      startsExpr: We
    }),
    _is: ls("is", {
      startsExpr: We
    }),
    _mixins: ls("mixins", {
      startsExpr: We
    }),
    _proto: ls("proto", {
      startsExpr: We
    }),
    _require: ls("require", {
      startsExpr: We
    }),
    _satisfies: ls("satisfies", {
      startsExpr: We
    }),
    _keyof: ls("keyof", {
      startsExpr: We
    }),
    _readonly: ls("readonly", {
      startsExpr: We
    }),
    _unique: ls("unique", {
      startsExpr: We
    }),
    _abstract: ls("abstract", {
      startsExpr: We
    }),
    _declare: ls("declare", {
      startsExpr: We
    }),
    _enum: ls("enum", {
      startsExpr: We
    }),
    _module: ls("module", {
      startsExpr: We
    }),
    _namespace: ls("namespace", {
      startsExpr: We
    }),
    _interface: ls("interface", {
      startsExpr: We
    }),
    _type: ls("type", {
      startsExpr: We
    }),
    _opaque: ls("opaque", {
      startsExpr: We
    }),
    name: Ct("name", {
      startsExpr: We
    }),
    placeholder: Ct("%%", {
      startsExpr: !0
    }),
    string: Ct("string", {
      startsExpr: We
    }),
    num: Ct("num", {
      startsExpr: We
    }),
    bigint: Ct("bigint", {
      startsExpr: We
    }),
    decimal: Ct("decimal", {
      startsExpr: We
    }),
    regexp: Ct("regexp", {
      startsExpr: We
    }),
    privateName: Ct("#name", {
      startsExpr: We
    }),
    eof: Ct("eof"),
    jsxName: Ct("jsxName"),
    jsxText: Ct("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Ct("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Ct("jsxTagEnd")
  };
  function ei(t) {
    return t >= 93 && t <= 133;
  }
  n(ei, "tokenIsIdentifier");
  function W1t(t) {
    return t <= 92;
  }
  n(W1t, "tokenKeywordOrIdentifierIsKeyword");
  function _o(t) {
    return t >= 58 && t <= 133;
  }
  n(_o, "tokenIsKeywordOrIdentifier");
  function Lie(t) {
    return t >= 58 && t <= 137;
  }
  n(Lie, "tokenIsLiteralPropertyName");
  function $1t(t) {
    return NM[t];
  }
  n($1t, "tokenComesBeforeExpression");
  function RT(t) {
    return kM[t];
  }
  n(RT, "tokenCanStartExpression");
  function H1t(t) {
    return t >= 29 && t <= 33;
  }
  n(H1t, "tokenIsAssignment");
  function Eie(t) {
    return t >= 129 && t <= 131;
  }
  n(Eie, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function J1t(t) {
    return t >= 90 && t <= 92;
  }
  n(J1t, "tokenIsLoop");
  function OM(t) {
    return t >= 58 && t <= 92;
  }
  n(OM, "tokenIsKeyword");
  function Y1t(t) {
    return t >= 39 && t <= 59;
  }
  n(Y1t, "tokenIsOperator");
  function X1t(t) {
    return t === 34;
  }
  n(X1t, "tokenIsPostfix");
  function z1t(t) {
    return DM[t];
  }
  n(z1t, "tokenIsPrefix");
  function G1t(t) {
    return t >= 121 && t <= 123;
  }
  n(G1t, "tokenIsTSTypeOperator");
  function Q1t(t) {
    return t >= 124 && t <= 130;
  }
  n(Q1t, "tokenIsTSDeclarationStart");
  function dp(t) {
    return wM[t];
  }
  n(dp, "tokenLabelName");
  function t1(t) {
    return IM[t];
  }
  n(t1, "tokenOperatorPrecedence");
  function Z1t(t) {
    return t === 57;
  }
  n(Z1t, "tokenIsRightAssociative");
  function r1(t) {
    return t >= 24 && t <= 25;
  }
  n(r1, "tokenIsTemplate");
  function _u(t) {
    return Lu[t];
  }
  n(_u, "getExportedToken");
  Lu[8].updateContext = (t) => {
    t.pop();
  }, Lu[5].updateContext = Lu[7].updateContext = Lu[23].updateContext = (t) => {
    t.push(Zs.brace);
  }, Lu[22].updateContext = (t) => {
    t[t.length - 1] === Zs.template ? t.pop() : t.push(Zs.template);
  }, Lu[143].updateContext = (t) => {
    t.push(Zs.j_expr, Zs.j_oTag);
  };
  var _M = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  Bie = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE\
-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\
\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\
\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\
\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", eAt = new RegExp("[" + _M + "]"), tAt = new RegExp("[" + _M + Bie + "]");
  _M = Bie = null;
  var Mie = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43,
  157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70,
  5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36,
  7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43,
  17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1,
  64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2,
  0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3,
  7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50,
  29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16,
  1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67,
  12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991,
  84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3,
  0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2,
  2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153,
  7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], sAt = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
  0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13,
  2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4,
  68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58,
  14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54,
  7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350,
  0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543,
  4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6,
  10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function oM(t, e) {
    let s = 65536;
    for (let i = 0, r = e.length; i < r; i += 2) {
      if (s += e[i], s > t) return !1;
      if (s += e[i + 1], s >= t) return !0;
    }
    return !1;
  }
  n(oM, "isInAstralSet");
  function Bu(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && eAt.test(String.fromCharCode(t)) :
    oM(t, Mie);
  }
  n(Bu, "isIdentifierStart");
  function Sm(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && tAt.test(
    String.fromCharCode(t)) : oM(t, Mie) || oM(t, sAt);
  }
  n(Sm, "isIdentifierChar");
  var LM = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, iAt = new Set(LM.keyword), rAt = new Set(LM.strict), nAt = new Set(LM.strictBind);
  function Fie(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(Fie, "isReservedWord");
  function jie(t, e) {
    return Fie(t, e) || rAt.has(t);
  }
  n(jie, "isStrictReservedWord");
  function Rie(t) {
    return nAt.has(t);
  }
  n(Rie, "isStrictBindOnlyReservedWord");
  function qie(t, e) {
    return jie(t, e) || Rie(t);
  }
  n(qie, "isStrictBindReservedWord");
  function aAt(t) {
    return iAt.has(t);
  }
  n(aAt, "isKeyword");
  function oAt(t, e, s) {
    return t === 64 && e === 64 && Bu(s);
  }
  n(oAt, "isIteratorStart");
  var lAt = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function uAt(t) {
    return lAt.has(t);
  }
  n(uAt, "canBeReservedWord");
  var KT = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, VT = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, s) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = s;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 128)
          return !0;
        if (s & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new KT(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 8 || s & 16) {
        this.checkRedeclarationInScope(r, e, s, i);
        let a = r.names.get(e) || 0;
        s & 16 ? a = a | 4 : (r.firstLexicalName || (r.firstLexicalName = e), a = a | 2), r.names.set(e, a), s & 8 && this.maybeExportDefined(
        r, e);
      } else if (s & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (r = this.scopeStack[a], this.checkRedeclarationInScope(r, e, s, i), r.names.set(
        e, (r.names.get(e) || 0) | 1), this.maybeExportDefined(r, e), !(r.flags & 387)); --a)
          ;
      this.parser.inModule && r.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, s) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(s);
    }
    checkRedeclarationInScope(e, s, i, r) {
      this.isRedeclaredInScope(e, s, i) && this.parser.raise(ee.VarRedeclaration, r, {
        identifierName: s
      });
    }
    isRedeclaredInScope(e, s, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return e.names.has(s);
      let r = e.names.get(s);
      return i & 16 ? (r & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (r & 1) > 0 : (r & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      s) || !this.treatFunctionsAsVarInScope(e) && (r & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: s
      } = e;
      this.scopeStack[0].names.has(s) || this.undefinedExports.set(s, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 387)
          return s;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: s
        } = this.scopeStack[e];
        if (s & 451 && !(s & 4))
          return s;
      }
    }
  }, lM = class extends KT {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, uM = class extends VT {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new lM(e);
    }
    declareName(e, s, i) {
      let r = this.currentScope();
      if (s & 2048) {
        this.checkRedeclarationInScope(r, e, s, i), this.maybeExportDefined(r, e), r.declareFunctions.add(e);
        return;
      }
      super.declareName(e, s, i);
    }
    isRedeclaredInScope(e, s, i) {
      if (super.isRedeclaredInScope(e, s, i)) return !0;
      if (i & 2048 && !e.declareFunctions.has(s)) {
        let r = e.names.get(s);
        return (r & 4) > 0 || (r & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, cM = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(e) {
      return e + this.startIndex;
    }
    offsetToSourcePos(e) {
      return e - this.startIndex;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [s, i] = e;
        if (!this.hasPlugin(s))
          return !1;
        let r = this.plugins.get(s);
        for (let a of Object.keys(i))
          if (r?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, s) {
      var i;
      return (i = this.plugins.get(e)) == null ? void 0 : i[s];
    }
  };
  function Uie(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(Uie, "setTrailingComments");
  function cAt(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(cAt, "setLeadingComments");
  function WT(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(WT, "setInnerComments");
  function Qh(t, e, s) {
    let i = null, r = e.length;
    for (; i === null && r > 0; )
      i = e[--r];
    i === null || i.start > s.start ? WT(t, s.comments) : Uie(i, s.comments);
  }
  n(Qh, "adjustInnerComments");
  var pM = class extends cM {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: s
      } = this.state;
      this.comments.length !== s && (this.comments.length = s), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: s
      } = this.state, i = s.length;
      if (i === 0) return;
      let r = i - 1, a = s[r];
      a.start === e.end && (a.leadingNode = e, r--);
      let {
        start: o
      } = e;
      for (; r >= 0; r--) {
        let l = s[r], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), s.splice(r, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: s
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && Uie(e.leadingNode, s), e.trailingNode !== null && cAt(e.trailingNode, s);
      else {
        let {
          containingNode: i,
          start: r
        } = e;
        if (this.input.charCodeAt(this.offsetToSourcePos(r) - 1) === 44)
          switch (i.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Qh(i, i.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Qh(i, i.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Qh(i, i.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Qh(i, i.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Qh(i, i.specifiers, e);
              break;
            case "TSEnumDeclaration":
              Qh(i, i.members, e);
              break;
            case "TSEnumBody":
              Qh(i, i.members, e);
              break;
            default:
              WT(i, s);
          }
        else
          WT(i, s);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let s = e.length - 1; s >= 0; s--)
        this.finalizeComment(e[s]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      if (i === 0) return;
      let r = s[i - 1];
      r.leadingNode === e && (r.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: s
      } = this.state, {
        length: i
      } = s;
      i !== 0 && (s[i - 1].trailingNode === e ? s[i - 1].trailingNode = null : i >= 2 && s[i - 2].trailingNode === e && (s[i - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, s, i) {
      let {
        commentStack: r
      } = this.state, a = r.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = r[o], u = l.end;
        if (l.start === i)
          l.leadingNode = e;
        else if (u === s)
          l.trailingNode = e;
        else if (u < s)
          break;
      }
    }
  }, pAt = /\r\n|[\r\n\u2028\u2029]/, QE = new RegExp(pAt.source, "g");
  function Pm(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(Pm, "isNewLine");
  function Aie(t, e, s) {
    for (let i = e; i < s; i++)
      if (Pm(t.charCodeAt(i)))
        return !0;
    return !1;
  }
  n(Aie, "hasNewLine");
  var iM = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, rM = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function hAt(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(hAt, "isWhitespace");
  var hM = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Zs.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: s,
      startIndex: i,
      startLine: r,
      startColumn: a
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : s === "module", this.startIndex = i, this.curLine = r, this.lineStart = -a, this.startLoc =
      this.endLoc = new yl(r, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(e) {
      e ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new yl(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.startIndex = this.startIndex, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.
      startLoc, e.endLoc = this.endLoc, e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.
      slice(), e.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.
      slice(), e.commentsLen = this.commentsLen, e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value =
      this.value, e.start = this.start, e.end = this.end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.
      context = this.context.slice(), e.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors,
      e.tokensLength = this.tokensLength, e;
    }
  }, fAt = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), vie = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, ZE = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function Cie(t, e, s, i, r, a) {
    let o = s, l = i, u = r, c = "", p = null, h = s, {
      length: f
    } = e;
    for (; ; ) {
      if (s >= f) {
        a.unterminated(o, l, u), c += e.slice(h, s);
        break;
      }
      let d = e.charCodeAt(s);
      if (dAt(t, d, e, s)) {
        c += e.slice(h, s);
        break;
      }
      if (d === 92) {
        c += e.slice(h, s);
        let y = mAt(e, s, i, r, t === "template", a);
        y.ch === null && !p ? p = {
          pos: s,
          lineStart: i,
          curLine: r
        } : c += y.ch, {
          pos: s,
          lineStart: i,
          curLine: r
        } = y, h = s;
      } else d === 8232 || d === 8233 ? (++s, ++r, i = s) : d === 10 || d === 13 ? t === "template" ? (c += e.slice(h, s) + `
`, ++s, d === 13 && e.charCodeAt(s) === 10 && ++s, ++r, h = i = s) : a.unterminated(o, l, u) : ++s;
    }
    return {
      pos: s,
      str: c,
      firstInvalidLoc: p,
      lineStart: i,
      curLine: r,
      containsInvalid: !!p
    };
  }
  n(Cie, "readStringContents");
  function dAt(t, e, s, i) {
    return t === "template" ? e === 96 || e === 36 && s.charCodeAt(i + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(dAt, "isStringEnd");
  function mAt(t, e, s, i, r, a) {
    let o = !r;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: s,
      curLine: i
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = fM(t, e, s, i, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = Vie(t, e, s, i, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        s = e, ++i;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (r)
          return l(null);
        a.strictNumericEscape(e - 1, s, i);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, h = /^[0-7]+/.exec(t.slice(c, e + 2))[0], f = parseInt(h, 8);
          f > 255 && (h = h.slice(0, -1), f = parseInt(h, 8)), e += h.length - 1;
          let d = t.charCodeAt(e);
          if (h !== "0" || d === 56 || d === 57) {
            if (r)
              return l(null);
            a.strictNumericEscape(c, s, i);
          }
          return l(String.fromCharCode(f));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(mAt, "readEscapedChar");
  function fM(t, e, s, i, r, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = Kie(t, e, s, i, 16, r, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, s, i) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(fM, "readHexChar");
  function Kie(t, e, s, i, r, a, o, l, u, c) {
    let p = e, h = r === 16 ? vie.hex : vie.decBinOct, f = r === 16 ? ZE.hex : r === 10 ? ZE.dec : r === 8 ? ZE.oct : ZE.bin, d = !1, y = 0;
    for (let m = 0, T = a ?? 1 / 0; m < T; ++m) {
      let b = t.charCodeAt(e), E;
      if (b === 95 && l !== "bail") {
        let w = t.charCodeAt(e - 1), K = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(K) || !f(K) || h.has(w) || h.has(K)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, s, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, s, i);
        }
        ++e;
        continue;
      }
      if (b >= 97 ? E = b - 97 + 10 : b >= 65 ? E = b - 65 + 10 : fAt(b) ? E = b - 48 : E = 1 / 0, E >= r) {
        if (E <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (E <= 9 && u.invalidDigit(e, s, i, r))
          E = 0;
        else if (o)
          E = 0, d = !0;
        else
          break;
      }
      ++e, y = y * r + E;
    }
    return e === p || a != null && e - p !== a || d ? {
      n: null,
      pos: e
    } : {
      n: y,
      pos: e
    };
  }
  n(Kie, "readInt");
  function Vie(t, e, s, i, r, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = fM(t, e, s, i, t.indexOf("}", e) - e, !0, r, a), ++e, l !== null && l > 1114111)
        if (r)
          a.invalidCodePoint(e, s, i);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = fM(t, e, s, i, 4, !1, r, a));
    return {
      code: l,
      pos: e
    };
  }
  n(Vie, "readCodePoint");
  function jT(t, e, s) {
    return new yl(s, t - e, t);
  }
  n(jT, "buildPosition");
  var yAt = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ml = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      let s = e.startIndex || 0;
      this.type = e.type, this.value = e.value, this.start = s + e.start, this.end = s + e.end, this.loc = new Am(e.startLoc, e.endLoc);
    }
  }, dM = class extends pM {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, s) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((i, r, a, o) => this.optionFlags & 2048 ? (this.raise(ee.InvalidDigit, jT(i, r, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(ee.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(ee.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(ee.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(ee.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((i, r, a) => {
          this.recordStrictModeErrors(ee.StrictNumericEscape, jT(i, r, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(ee.UnterminatedString, jT(i - 1, r, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(ee.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((i, r, a) => {
          throw this.raise(ee.UnterminatedTemplate, jT(i, r, a));
        }, "unterminated")
      }), this.state = new hM(), this.state.init(e), this.input = s, this.length = s.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new ml(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let s = this.state;
      return this.state = e, s;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return iM.lastIndex = e, iM.test(this.input) ? iM.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return rM.lastIndex = e, rM.test(this.input) ? rM.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let s = this.input.charCodeAt(e);
      if ((s & 64512) === 55296 && ++e < this.input.length) {
        let i = this.input.charCodeAt(e);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      return s;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([s, i]) => this.raise(s, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.state.pos, r = this.input.indexOf(e, i + 2);
      if (r === -1)
        throw this.raise(ee.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = r + e.length, QE.lastIndex = i + 2; QE.test(this.input) && QE.lastIndex <= r; )
        ++this.state.curLine, this.state.lineStart = QE.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, r),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(r + e.length),
        loc: new Am(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let s = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let r = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !Pm(r) && ++this.state.pos < this.length; )
          r = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(s + e, a),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(a),
        loc: new Am(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, s = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let r = this.skipBlockComment("*/");
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              case 47: {
                let r = this.skipLineComment(2);
                r !== void 0 && (this.addComment(r), s?.push(r));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (hAt(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let r = this.state.pos;
              if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), s?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (s?.length > 0) {
        let i = this.state.pos, r = {
          start: this.sourceToOffsetPos(e),
          end: this.sourceToOffsetPos(i),
          comments: s,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(r);
      }
    }
    finishToken(e, s) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = e, this.state.value = s, this.isLookahead || this.updateContext(i);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, s = this.codePointAtPos(e);
      if (s >= 48 && s <= 57)
        throw this.raise(ee.UnexpectedDigitAfterHash, this.state.curPosition());
      if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(s === 123 ? ee.RecordExpressionHashIncorrectStartSyntaxType : ee.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Bu(s) ? (++this.state.pos, this.finishToken(139, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let s = this.state.pos;
      for (this.state.pos += 1; !Pm(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(s + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(e) {
      let s = e === 42 ? 55 : 54, i = 1, r = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && r === 42 && (i++, r = this.input.charCodeAt(this.state.pos + 2), s = 57), r === 61 && !this.state.inType && (i++, s = e ===
      37 ? 33 : 30), this.finishOp(s, i);
    }
    readToken_pipe_amp(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (s === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(ee.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && s === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(ee.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (s === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === e) {
        this.finishOp(34, 2);
        return;
      }
      s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, s = this.input.charCodeAt(e + 1);
      if (s === 62) {
        let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (s === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (s === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && s === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(ee.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(ee.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let s = this.input.charCodeAt(this.state.pos + 1);
          if (s === 120 || s === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (s === 111 || s === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (s === 98 || s === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Bu(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(ee.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, s) {
      let i = this.input.slice(this.state.pos, this.state.pos + s);
      this.state.pos += s, this.finishToken(e, i);
    }
    readRegexp() {
      let e = this.state.startLoc, s = this.state.start + 1, i, r, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(ee.UnterminatedRegExp, Dn(e, 1));
        let c = this.input.charCodeAt(a);
        if (Pm(c))
          throw this.raise(ee.UnterminatedRegExp, Dn(e, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            r = !0;
          else if (c === 93 && r)
            r = !1;
          else if (c === 47 && !r)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(s, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => Dn(e, a + 2 - s), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (yAt.has(c))
          c === 118 ? l.includes("u") && this.raise(ee.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(ee.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(ee.DuplicateRegExpFlags, u());
        else if (Sm(c) || c === 92)
          this.raise(ee.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, s, i = !1, r = !0) {
      let {
        n: a,
        pos: o
      } = Kie(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, s, i, r, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1;
      this.state.pos += 2;
      let a = this.readInt(e);
      a == null && this.raise(ee.InvalidDigit, Dn(i, 2), {
        radix: e
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, r = !0;
      else if (o === 109)
        throw this.raise(ee.InvalidDecimal, i);
      if (Bu(this.codePointAtPos(this.state.pos)))
        throw this.raise(ee.NumberIdentifier, this.state.curPosition());
      if (r) {
        let l = this.input.slice(s, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(e) {
      let s = this.state.pos, i = this.state.curPosition(), r = !1, a = !1, o = !1, l = !1;
      !e && this.readInt(10) === null && this.raise(ee.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
      if (u) {
        let d = this.input.slice(s, this.state.pos);
        if (this.recordStrictModeErrors(ee.StrictOctalLiteral, i), !this.state.strict) {
          let y = d.indexOf("_");
          y > 0 && this.raise(ee.ZeroDigitNumericSeparator, Dn(i, y));
        }
        l = u && !/[89]/.test(d);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !l && (++this.state.pos, this.readInt(10), r = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      ee.InvalidOrMissingExponent, i), r = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((r || u) && this.raise(ee.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(ee.InvalidDecimal, i), ++this.state.pos;
        var p = !0;
      }
      if (Bu(this.codePointAtPos(this.state.pos)))
        throw this.raise(ee.NumberIdentifier, this.state.curPosition());
      let h = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, h);
        return;
      }
      if (p) {
        this.finishToken(137, h);
        return;
      }
      let f = l ? parseInt(h, 8) : parseFloat(h);
      this.finishToken(135, f);
    }
    readCodePoint(e) {
      let {
        code: s,
        pos: i
      } = Vie(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = i, s;
    }
    readString(e) {
      let {
        str: s,
        pos: i,
        curLine: r,
        lineStart: a
      } = Cie(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = r, this.finishToken(134, s);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: s,
        firstInvalidLoc: i,
        pos: r,
        curLine: a,
        lineStart: o
      } = Cie("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = r + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new yl(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(r) === 96 ? this.finishToken(24, i ? null : e + s + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : e + s + "${"));
    }
    recordStrictModeErrors(e, s) {
      let i = s.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(e, s) : this.state.strictErrors.set(i, [e, s]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let s = "", i = this.state.pos, r = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Sm(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, s += this.input.slice(r, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === i ? Bu : Sm;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(ee.MissingUnicodeEscape, this.state.curPosition()), r = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(ee.EscapedCharNotAnIdentifier, o), s += String.fromCodePoint(u)), r = this.state.pos;
        } else
          break;
      }
      return s + this.input.slice(r, this.state.pos);
    }
    readWord(e) {
      let s = this.readWord1(e), i = CM.get(s);
      i !== void 0 ? this.finishToken(i, dp(i)) : this.finishToken(132, s);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      OM(e) && this.state.containsEsc && this.raise(ee.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: dp(e)
      });
    }
    raise(e, s, i = {}) {
      let r = s instanceof yl ? s : s.loc.start, a = e(r, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, s, i = {}) {
      let r = s instanceof yl ? s : s.loc.start, a = r.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(r, i);
        if (u.loc.index < a) break;
      }
      return this.raise(e, s, i);
    }
    updateContext(e) {
    }
    unexpected(e, s) {
      throw this.raise(ee.UnexpectedToken, e ?? this.state.startLoc, {
        expected: s ? dp(s) : null
      });
    }
    expectPlugin(e, s) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(ee.MissingPlugin, s ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((s) => this.hasPlugin(s)))
        throw this.raise(ee.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (s, i, r) => {
        this.raise(e, jT(s, i, r));
      };
    }
  }, mM = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, yM = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new mM());
    }
    exit() {
      let e = this.stack.pop(), s = this.current();
      for (let [i, r] of Array.from(e.undefinedPrivateNames))
        s ? s.undefinedPrivateNames.has(i) || s.undefinedPrivateNames.set(i, r) : this.parser.raise(ee.InvalidPrivateFieldResolution, r, {
          identifierName: i
        });
    }
    declarePrivateName(e, s, i) {
      let {
        privateNames: r,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = r.has(e);
      if (s & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = s & 4, h = u & 3, f = s & 3;
          l = h === f || c !== p, l || a.delete(e);
        } else l || a.set(e, s);
      }
      l && this.parser.raise(ee.PrivateNameRedeclaration, i, {
        identifierName: e
      }), r.add(e), o.delete(e);
    }
    usePrivateName(e, s) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(e)) return;
      i ? i.undefinedPrivateNames.set(e, s) : this.parser.raise(ee.InvalidPrivateFieldResolution, s, {
        identifierName: e
      });
    }
  }, vm = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, n1 = class extends vm {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, s) {
      let i = s.index;
      this.declarationErrors.set(i, [e, s]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, gM = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new vm()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, s) {
      let i = s.loc.start, {
        stack: r
      } = this, a = r.length - 1, o = r[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, i);
        else
          return;
        o = r[--a];
      }
      this.parser.raise(e, i);
    }
    recordArrowParameterBindingError(e, s) {
      let {
        stack: i
      } = this, r = i[i.length - 1], a = s.loc.start;
      if (r.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (r.canBeArrowParameterDeclaration())
        r.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: s
      } = this, i = s.length - 1, r = s[i];
      for (; r.canBeArrowParameterDeclaration(); )
        r.type === 2 && r.recordDeclarationError(ee.AwaitBindingIdentifier, e), r = s[--i];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, s = e[e.length - 1];
      s.canBeArrowParameterDeclaration() && s.iterateErrors(([i, r]) => {
        this.parser.raise(i, r);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(r.index), o = e[--a];
      });
    }
  };
  function gAt() {
    return new vm(3);
  }
  n(gAt, "newParameterDeclarationScope");
  function TAt() {
    return new n1(1);
  }
  n(TAt, "newArrowHeadScope");
  function bAt() {
    return new n1(2);
  }
  n(bAt, "newAsyncArrowScope");
  function Wie() {
    return new vm();
  }
  n(Wie, "newExpressionScope");
  var TM = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function s1(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(s1, "functionFlags");
  var bM = class extends dM {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, s, i, r = !0) {
      if (!e) return;
      let {
        extra: a
      } = e;
      a == null && (a = {}, e.extra = a), r ? a[s] = i : Object.defineProperty(a, s, {
        enumerable: r,
        value: i
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, s) {
      let i = e + s.length;
      if (this.input.slice(e, i) === s) {
        let r = this.input.charCodeAt(i);
        return !(Sm(r) || (r & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let s = this.nextTokenStart();
      return this.isUnparsedContextual(s, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, s) {
      if (!this.eatContextual(e)) {
        if (s != null)
          throw this.raise(s, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Aie(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return Aie(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(ee.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, s) {
      this.eat(e) || this.unexpected(s, e);
    }
    tryParse(e, s = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let r = e((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > s.errors.length) {
          let a = this.state;
          return this.state = s, this.state.tokensLength = a.tokensLength, {
            node: r,
            error: a.errors[s.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: r,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (r) {
        let a = this.state;
        if (this.state = s, r instanceof SyntaxError)
          return {
            node: null,
            error: r,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (r === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw r;
      }
    }
    checkExpressionErrors(e, s) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: r,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!i || !!r || !!o || !!a;
      if (!s)
        return l;
      i != null && this.raise(ee.InvalidCoverInitializedName, i), r != null && this.raise(ee.DuplicateProto, r), a != null && this.raise(ee.
      UnexpectedPrivateField, a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return Lie(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let s = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let r = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new TM();
      let u = this.classScope;
      this.classScope = new yM(this);
      let c = this.expressionScope;
      return this.expressionScope = new gM(this), () => {
        this.state.labels = s, this.exportedIdentifiers = i, this.inModule = r, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.optionFlags & 32 && (e |= 1), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: s
      } = e;
      s !== null && this.expectPlugin("destructuringPrivate", s);
    }
  }, Em = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Cm = class {
    static {
      n(this, "Node");
    }
    constructor(e, s, i) {
      this.type = "", this.start = s, this.end = 0, this.loc = new Am(i), e?.optionFlags & 128 && (this.range = [s, 0]), e != null && e.filename &&
      (this.loc.filename = e.filename);
    }
  }, BM = Cm.prototype;
  BM.__clone = function() {
    let t = new Cm(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let s = 0, i = e.length; s < i; s++) {
      let r = e[s];
      r !== "leadingComments" && r !== "trailingComments" && r !== "innerComments" && (t[r] = this[r]);
    }
    return t;
  };
  function xAt(t) {
    return Fu(t);
  }
  n(xAt, "clonePlaceholder");
  function Fu(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(BM);
    return u.type = e, u.start = s, u.end = i, u.loc = r, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Fu, "cloneIdentifier");
  function SAt(t) {
    let {
      type: e,
      start: s,
      end: i,
      loc: r,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return xAt(t);
    let l = Object.create(BM);
    return l.type = e, l.start = s, l.end = i, l.loc = r, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(SAt, "cloneStringLiteral");
  var xM = class extends bM {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Cm(this, e.index, e);
    }
    startNodeAt(e) {
      return new Cm(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, s) {
      return this.finishNodeAt(e, s, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, s, i) {
      return e.type = s, e.end = i.index, e.loc.end = i, this.optionFlags & 128 && (e.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      e), e;
    }
    resetStartLocation(e, s) {
      e.start = s.index, e.loc.start = s, this.optionFlags & 128 && (e.range[0] = s.index);
    }
    resetEndLocation(e, s = this.state.lastTokEndLoc) {
      e.end = s.index, e.loc.end = s, this.optionFlags & 128 && (e.range[1] = s.index);
    }
    resetStartLocationFromNode(e, s) {
      this.resetStartLocation(e, s.loc.start);
    }
  }, PAt = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Bt = Mu`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: s
    }) => `Enum \`${t}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: s
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionO